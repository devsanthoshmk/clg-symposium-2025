import { _ as Tf } from "../chunks/preload-helper.6d58dae5.js";
import {
  ah as K1,
  a0 as J1,
  ab as Pl,
  a7 as Q1,
  s as gs,
  e as he,
  a as Ie,
  c as ue,
  f as Oe,
  b as Ue,
  d as fe,
  w as ht,
  i as Q,
  k as Mt,
  j as $,
  m as Af,
  y as Ia,
  n as Ei,
  v as tl,
  a2 as eb,
  Y as tb,
  t as Ii,
  g as Ui,
  A as Pa,
  D as yy,
  E as ph,
  ai as Qp,
  r as em,
  x as ib,
  h as nb,
  P as rb,
  C as qh,
} from "../chunks/scheduler.b44937bc.js";
import {
  g as ki,
  b as Xe,
  e as Vi,
  t as Be,
  S as vs,
  i as ys,
  c as At,
  a as Ct,
  m as Pt,
  d as Lt,
  h as mh,
  j as gh,
  f as Xh,
} from "../chunks/index.08749574.js";
import { I as ni } from "../chunks/Icon.bcad08c4.js";
import { w as sb } from "../chunks/index.6e4317f1.js";
import { L as ab } from "../chunks/LogoWithText.07dfda91.js";
import { n as Cc } from "../chunks/notify.112187cd.js";
import { t as xy } from "../chunks/langUtils.50e57082.js";
import { C as il } from "../chunks/CDNImage.3b610445.js";
import { c as hs, s as us } from "../chunks/index.e14db2ec.js";
import { g as ob } from "../chunks/navigation.348d0091.js";
import { p as lb } from "../chunks/stores.8bffc7f8.js";
import { t as cb } from "../chunks/toastStore.b0ed32a8.js";
import { e as tm } from "../chunks/each.3cf95a54.js";
import { a as hb } from "../chunks/sheet.d59c388b.js";
(function () {
  try {
    var t =
        typeof window < "u"
          ? window
          : typeof global < "u"
          ? global
          : typeof self < "u"
          ? self
          : {},
      e = new Error().stack;
    e &&
      ((t._sentryDebugIds = t._sentryDebugIds || {}),
      (t._sentryDebugIds[e] = "e5e29ac0-addd-4b3e-afb6-9dfb5e4722f6"),
      (t._sentryDebugIdIdentifier =
        "sentry-dbid-e5e29ac0-addd-4b3e-afb6-9dfb5e4722f6"));
  } catch {}
})();
const ub =
  typeof window < "u" ? window : typeof globalThis < "u" ? globalThis : global;
function db(t, e) {
  const i = (e.token = {});
  function n(r, s, a, o) {
    if (e.token !== i) return;
    e.resolved = o;
    let l = e.ctx;
    a !== void 0 && ((l = l.slice()), (l[a] = o));
    const c = r && (e.current = r)(l);
    let d = !1;
    e.block &&
      (e.blocks
        ? e.blocks.forEach((h, u) => {
            u !== s &&
              h &&
              (ki(),
              Xe(h, 1, 1, () => {
                e.blocks[u] === h && (e.blocks[u] = null);
              }),
              Vi());
          })
        : e.block.d(1),
      c.c(),
      Be(c, 1),
      c.m(e.mount(), e.anchor),
      (d = !0)),
      (e.block = c),
      e.blocks && (e.blocks[s] = c),
      d && Q1();
  }
  if (K1(t)) {
    const r = J1();
    if (
      (t.then(
        (s) => {
          Pl(r), n(e.then, 1, e.value, s), Pl(null);
        },
        (s) => {
          if ((Pl(r), n(e.catch, 2, e.error, s), Pl(null), !e.hasCatch))
            throw s;
        }
      ),
      e.current !== e.pending)
    )
      return n(e.pending, 0), !0;
  } else {
    if (e.current !== e.then) return n(e.then, 1, e.value, t), !0;
    e.resolved = t;
  }
}
function fb(t, e, i) {
  const n = e.slice(),
    { resolved: r } = t;
  t.current === t.then && (n[t.value] = r),
    t.current === t.catch && (n[t.error] = r),
    t.block.p(n, i);
}
var _y = {
    update: null,
    begin: null,
    loopBegin: null,
    changeBegin: null,
    change: null,
    changeComplete: null,
    loopComplete: null,
    complete: null,
    loop: 1,
    direction: "normal",
    autoplay: !0,
    timelineOffset: 0,
  },
  Cf = {
    duration: 1e3,
    delay: 0,
    endDelay: 0,
    easing: "easeOutElastic(1, .5)",
    round: 0,
  },
  pb = [
    "translateX",
    "translateY",
    "translateZ",
    "rotate",
    "rotateX",
    "rotateY",
    "rotateZ",
    "scale",
    "scaleX",
    "scaleY",
    "scaleZ",
    "skew",
    "skewX",
    "skewY",
    "perspective",
    "matrix",
    "matrix3d",
  ],
  Nc = { CSS: {}, springs: {} };
function ar(t, e, i) {
  return Math.min(Math.max(t, e), i);
}
function jo(t, e) {
  return t.indexOf(e) > -1;
}
function $h(t, e) {
  return t.apply(null, e);
}
var Qe = {
  arr: function (t) {
    return Array.isArray(t);
  },
  obj: function (t) {
    return jo(Object.prototype.toString.call(t), "Object");
  },
  pth: function (t) {
    return Qe.obj(t) && t.hasOwnProperty("totalLength");
  },
  svg: function (t) {
    return t instanceof SVGElement;
  },
  inp: function (t) {
    return t instanceof HTMLInputElement;
  },
  dom: function (t) {
    return t.nodeType || Qe.svg(t);
  },
  str: function (t) {
    return typeof t == "string";
  },
  fnc: function (t) {
    return typeof t == "function";
  },
  und: function (t) {
    return typeof t > "u";
  },
  nil: function (t) {
    return Qe.und(t) || t === null;
  },
  hex: function (t) {
    return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(t);
  },
  rgb: function (t) {
    return /^rgb/.test(t);
  },
  hsl: function (t) {
    return /^hsl/.test(t);
  },
  col: function (t) {
    return Qe.hex(t) || Qe.rgb(t) || Qe.hsl(t);
  },
  key: function (t) {
    return (
      !_y.hasOwnProperty(t) &&
      !Cf.hasOwnProperty(t) &&
      t !== "targets" &&
      t !== "keyframes"
    );
  },
};
function by(t) {
  var e = /\(([^)]+)\)/.exec(t);
  return e
    ? e[1].split(",").map(function (i) {
        return parseFloat(i);
      })
    : [];
}
function wy(t, e) {
  var i = by(t),
    n = ar(Qe.und(i[0]) ? 1 : i[0], 0.1, 100),
    r = ar(Qe.und(i[1]) ? 100 : i[1], 0.1, 100),
    s = ar(Qe.und(i[2]) ? 10 : i[2], 0.1, 100),
    a = ar(Qe.und(i[3]) ? 0 : i[3], 0.1, 100),
    o = Math.sqrt(r / n),
    l = s / (2 * Math.sqrt(r * n)),
    c = l < 1 ? o * Math.sqrt(1 - l * l) : 0,
    d = 1,
    h = l < 1 ? (l * o + -a) / c : -a + o;
  function u(p) {
    var v = e ? (e * p) / 1e3 : p;
    return (
      l < 1
        ? (v =
            Math.exp(-v * l * o) * (d * Math.cos(c * v) + h * Math.sin(c * v)))
        : (v = (d + h * v) * Math.exp(-v * o)),
      p === 0 || p === 1 ? p : 1 - v
    );
  }
  function f() {
    var p = Nc.springs[t];
    if (p) return p;
    for (var v = 1 / 6, g = 0, m = 0; ; )
      if (((g += v), u(g) === 1)) {
        if ((m++, m >= 16)) break;
      } else m = 0;
    var x = g * v * 1e3;
    return (Nc.springs[t] = x), x;
  }
  return e ? u : f;
}
function mb(t) {
  return (
    t === void 0 && (t = 10),
    function (e) {
      return Math.ceil(ar(e, 1e-6, 1) * t) * (1 / t);
    }
  );
}
var gb = (function () {
    var t = 11,
      e = 1 / (t - 1);
    function i(d, h) {
      return 1 - 3 * h + 3 * d;
    }
    function n(d, h) {
      return 3 * h - 6 * d;
    }
    function r(d) {
      return 3 * d;
    }
    function s(d, h, u) {
      return ((i(h, u) * d + n(h, u)) * d + r(h)) * d;
    }
    function a(d, h, u) {
      return 3 * i(h, u) * d * d + 2 * n(h, u) * d + r(h);
    }
    function o(d, h, u, f, p) {
      var v,
        g,
        m = 0;
      do (g = h + (u - h) / 2), (v = s(g, f, p) - d), v > 0 ? (u = g) : (h = g);
      while (Math.abs(v) > 1e-7 && ++m < 10);
      return g;
    }
    function l(d, h, u, f) {
      for (var p = 0; p < 4; ++p) {
        var v = a(h, u, f);
        if (v === 0) return h;
        var g = s(h, u, f) - d;
        h -= g / v;
      }
      return h;
    }
    function c(d, h, u, f) {
      if (!(0 <= d && d <= 1 && 0 <= u && u <= 1)) return;
      var p = new Float32Array(t);
      if (d !== h || u !== f) for (var v = 0; v < t; ++v) p[v] = s(v * e, d, u);
      function g(m) {
        for (var x = 0, y = 1, _ = t - 1; y !== _ && p[y] <= m; ++y) x += e;
        --y;
        var M = (m - p[y]) / (p[y + 1] - p[y]),
          b = x + M * e,
          E = a(b, d, u);
        return E >= 0.001 ? l(m, b, d, u) : E === 0 ? b : o(m, x, x + e, d, u);
      }
      return function (m) {
        return (d === h && u === f) || m === 0 || m === 1 ? m : s(g(m), h, f);
      };
    }
    return c;
  })(),
  Sy = (function () {
    var t = {
        linear: function () {
          return function (n) {
            return n;
          };
        },
      },
      e = {
        Sine: function () {
          return function (n) {
            return 1 - Math.cos((n * Math.PI) / 2);
          };
        },
        Circ: function () {
          return function (n) {
            return 1 - Math.sqrt(1 - n * n);
          };
        },
        Back: function () {
          return function (n) {
            return n * n * (3 * n - 2);
          };
        },
        Bounce: function () {
          return function (n) {
            for (var r, s = 4; n < ((r = Math.pow(2, --s)) - 1) / 11; );
            return (
              1 / Math.pow(4, 3 - s) -
              7.5625 * Math.pow((r * 3 - 2) / 22 - n, 2)
            );
          };
        },
        Elastic: function (n, r) {
          n === void 0 && (n = 1), r === void 0 && (r = 0.5);
          var s = ar(n, 1, 10),
            a = ar(r, 0.1, 2);
          return function (o) {
            return o === 0 || o === 1
              ? o
              : -s *
                  Math.pow(2, 10 * (o - 1)) *
                  Math.sin(
                    ((o - 1 - (a / (Math.PI * 2)) * Math.asin(1 / s)) *
                      (Math.PI * 2)) /
                      a
                  );
          };
        },
      },
      i = ["Quad", "Cubic", "Quart", "Quint", "Expo"];
    return (
      i.forEach(function (n, r) {
        e[n] = function () {
          return function (s) {
            return Math.pow(s, r + 2);
          };
        };
      }),
      Object.keys(e).forEach(function (n) {
        var r = e[n];
        (t["easeIn" + n] = r),
          (t["easeOut" + n] = function (s, a) {
            return function (o) {
              return 1 - r(s, a)(1 - o);
            };
          }),
          (t["easeInOut" + n] = function (s, a) {
            return function (o) {
              return o < 0.5 ? r(s, a)(o * 2) / 2 : 1 - r(s, a)(o * -2 + 2) / 2;
            };
          }),
          (t["easeOutIn" + n] = function (s, a) {
            return function (o) {
              return o < 0.5
                ? (1 - r(s, a)(1 - o * 2)) / 2
                : (r(s, a)(o * 2 - 1) + 1) / 2;
            };
          });
      }),
      t
    );
  })();
function Pf(t, e) {
  if (Qe.fnc(t)) return t;
  var i = t.split("(")[0],
    n = Sy[i],
    r = by(t);
  switch (i) {
    case "spring":
      return wy(t, e);
    case "cubicBezier":
      return $h(gb, r);
    case "steps":
      return $h(mb, r);
    default:
      return $h(n, r);
  }
}
function My(t) {
  try {
    var e = document.querySelectorAll(t);
    return e;
  } catch {
    return;
  }
}
function vh(t, e) {
  for (
    var i = t.length,
      n = arguments.length >= 2 ? arguments[1] : void 0,
      r = [],
      s = 0;
    s < i;
    s++
  )
    if (s in t) {
      var a = t[s];
      e.call(n, a, s, t) && r.push(a);
    }
  return r;
}
function yh(t) {
  return t.reduce(function (e, i) {
    return e.concat(Qe.arr(i) ? yh(i) : i);
  }, []);
}
function im(t) {
  return Qe.arr(t)
    ? t
    : (Qe.str(t) && (t = My(t) || t),
      t instanceof NodeList || t instanceof HTMLCollection
        ? [].slice.call(t)
        : [t]);
}
function Lf(t, e) {
  return t.some(function (i) {
    return i === e;
  });
}
function Df(t) {
  var e = {};
  for (var i in t) e[i] = t[i];
  return e;
}
function cd(t, e) {
  var i = Df(t);
  for (var n in t) i[n] = e.hasOwnProperty(n) ? e[n] : t[n];
  return i;
}
function xh(t, e) {
  var i = Df(t);
  for (var n in e) i[n] = Qe.und(t[n]) ? e[n] : t[n];
  return i;
}
function vb(t) {
  var e = /rgb\((\d+,\s*[\d]+,\s*[\d]+)\)/g.exec(t);
  return e ? "rgba(" + e[1] + ",1)" : t;
}
function yb(t) {
  var e = /^#?([a-f\d])([a-f\d])([a-f\d])$/i,
    i = t.replace(e, function (o, l, c, d) {
      return l + l + c + c + d + d;
    }),
    n = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(i),
    r = parseInt(n[1], 16),
    s = parseInt(n[2], 16),
    a = parseInt(n[3], 16);
  return "rgba(" + r + "," + s + "," + a + ",1)";
}
function xb(t) {
  var e =
      /hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.exec(t) ||
      /hsla\((\d+),\s*([\d.]+)%,\s*([\d.]+)%,\s*([\d.]+)\)/g.exec(t),
    i = parseInt(e[1], 10) / 360,
    n = parseInt(e[2], 10) / 100,
    r = parseInt(e[3], 10) / 100,
    s = e[4] || 1;
  function a(u, f, p) {
    return (
      p < 0 && (p += 1),
      p > 1 && (p -= 1),
      p < 1 / 6
        ? u + (f - u) * 6 * p
        : p < 1 / 2
        ? f
        : p < 2 / 3
        ? u + (f - u) * (2 / 3 - p) * 6
        : u
    );
  }
  var o, l, c;
  if (n == 0) o = l = c = r;
  else {
    var d = r < 0.5 ? r * (1 + n) : r + n - r * n,
      h = 2 * r - d;
    (o = a(h, d, i + 1 / 3)), (l = a(h, d, i)), (c = a(h, d, i - 1 / 3));
  }
  return "rgba(" + o * 255 + "," + l * 255 + "," + c * 255 + "," + s + ")";
}
function _b(t) {
  if (Qe.rgb(t)) return vb(t);
  if (Qe.hex(t)) return yb(t);
  if (Qe.hsl(t)) return xb(t);
}
function Ur(t) {
  var e =
    /[+-]?\d*\.?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?(%|px|pt|em|rem|in|cm|mm|ex|ch|pc|vw|vh|vmin|vmax|deg|rad|turn)?$/.exec(
      t
    );
  if (e) return e[1];
}
function bb(t) {
  if (jo(t, "translate") || t === "perspective") return "px";
  if (jo(t, "rotate") || jo(t, "skew")) return "deg";
}
function hd(t, e) {
  return Qe.fnc(t) ? t(e.target, e.id, e.total) : t;
}
function or(t, e) {
  return t.getAttribute(e);
}
function Rf(t, e, i) {
  var n = Ur(e);
  if (Lf([i, "deg", "rad", "turn"], n)) return e;
  var r = Nc.CSS[e + i];
  if (!Qe.und(r)) return r;
  var s = 100,
    a = document.createElement(t.tagName),
    o =
      t.parentNode && t.parentNode !== document ? t.parentNode : document.body;
  o.appendChild(a), (a.style.position = "absolute"), (a.style.width = s + i);
  var l = s / a.offsetWidth;
  o.removeChild(a);
  var c = l * parseFloat(e);
  return (Nc.CSS[e + i] = c), c;
}
function Ey(t, e, i) {
  if (e in t.style) {
    var n = e.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase(),
      r = t.style[e] || getComputedStyle(t).getPropertyValue(n) || "0";
    return i ? Rf(t, r, i) : r;
  }
}
function Of(t, e) {
  if (Qe.dom(t) && !Qe.inp(t) && (!Qe.nil(or(t, e)) || (Qe.svg(t) && t[e])))
    return "attribute";
  if (Qe.dom(t) && Lf(pb, e)) return "transform";
  if (Qe.dom(t) && e !== "transform" && Ey(t, e)) return "css";
  if (t[e] != null) return "object";
}
function Ty(t) {
  if (Qe.dom(t)) {
    for (
      var e = t.style.transform || "",
        i = /(\w+)\(([^)]*)\)/g,
        n = new Map(),
        r;
      (r = i.exec(e));

    )
      n.set(r[1], r[2]);
    return n;
  }
}
function wb(t, e, i, n) {
  var r = jo(e, "scale") ? 1 : 0 + bb(e),
    s = Ty(t).get(e) || r;
  return (
    i && (i.transforms.list.set(e, s), (i.transforms.last = e)),
    n ? Rf(t, s, n) : s
  );
}
function If(t, e, i, n) {
  switch (Of(t, e)) {
    case "transform":
      return wb(t, e, n, i);
    case "css":
      return Ey(t, e, i);
    case "attribute":
      return or(t, e);
    default:
      return t[e] || 0;
  }
}
function Uf(t, e) {
  var i = /^(\*=|\+=|-=)/.exec(t);
  if (!i) return t;
  var n = Ur(t) || 0,
    r = parseFloat(e),
    s = parseFloat(t.replace(i[0], ""));
  switch (i[0][0]) {
    case "+":
      return r + s + n;
    case "-":
      return r - s + n;
    case "*":
      return r * s + n;
  }
}
function Ay(t, e) {
  if (Qe.col(t)) return _b(t);
  if (/\s/g.test(t)) return t;
  var i = Ur(t),
    n = i ? t.substr(0, t.length - i.length) : t;
  return e ? n + e : n;
}
function Nf(t, e) {
  return Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2));
}
function Sb(t) {
  return Math.PI * 2 * or(t, "r");
}
function Mb(t) {
  return or(t, "width") * 2 + or(t, "height") * 2;
}
function Eb(t) {
  return Nf(
    { x: or(t, "x1"), y: or(t, "y1") },
    { x: or(t, "x2"), y: or(t, "y2") }
  );
}
function Cy(t) {
  for (var e = t.points, i = 0, n, r = 0; r < e.numberOfItems; r++) {
    var s = e.getItem(r);
    r > 0 && (i += Nf(n, s)), (n = s);
  }
  return i;
}
function Tb(t) {
  var e = t.points;
  return Cy(t) + Nf(e.getItem(e.numberOfItems - 1), e.getItem(0));
}
function Py(t) {
  if (t.getTotalLength) return t.getTotalLength();
  switch (t.tagName.toLowerCase()) {
    case "circle":
      return Sb(t);
    case "rect":
      return Mb(t);
    case "line":
      return Eb(t);
    case "polyline":
      return Cy(t);
    case "polygon":
      return Tb(t);
  }
}
function Ab(t) {
  var e = Py(t);
  return t.setAttribute("stroke-dasharray", e), e;
}
function Cb(t) {
  for (var e = t.parentNode; Qe.svg(e) && Qe.svg(e.parentNode); )
    e = e.parentNode;
  return e;
}
function Ly(t, e) {
  var i = e || {},
    n = i.el || Cb(t),
    r = n.getBoundingClientRect(),
    s = or(n, "viewBox"),
    a = r.width,
    o = r.height,
    l = i.viewBox || (s ? s.split(" ") : [0, 0, a, o]);
  return {
    el: n,
    viewBox: l,
    x: l[0] / 1,
    y: l[1] / 1,
    w: a,
    h: o,
    vW: l[2],
    vH: l[3],
  };
}
function Pb(t, e) {
  var i = Qe.str(t) ? My(t)[0] : t,
    n = e || 100;
  return function (r) {
    return { property: r, el: i, svg: Ly(i), totalLength: Py(i) * (n / 100) };
  };
}
function Lb(t, e, i) {
  function n(d) {
    d === void 0 && (d = 0);
    var h = e + d >= 1 ? e + d : 0;
    return t.el.getPointAtLength(h);
  }
  var r = Ly(t.el, t.svg),
    s = n(),
    a = n(-1),
    o = n(1),
    l = i ? 1 : r.w / r.vW,
    c = i ? 1 : r.h / r.vH;
  switch (t.property) {
    case "x":
      return (s.x - r.x) * l;
    case "y":
      return (s.y - r.y) * c;
    case "angle":
      return (Math.atan2(o.y - a.y, o.x - a.x) * 180) / Math.PI;
  }
}
function nm(t, e) {
  var i = /[+-]?\d*\.?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?/g,
    n = Ay(Qe.pth(t) ? t.totalLength : t, e) + "";
  return {
    original: n,
    numbers: n.match(i) ? n.match(i).map(Number) : [0],
    strings: Qe.str(t) || e ? n.split(i) : [],
  };
}
function zf(t) {
  var e = t ? yh(Qe.arr(t) ? t.map(im) : im(t)) : [];
  return vh(e, function (i, n, r) {
    return r.indexOf(i) === n;
  });
}
function Dy(t) {
  var e = zf(t);
  return e.map(function (i, n) {
    return { target: i, id: n, total: e.length, transforms: { list: Ty(i) } };
  });
}
function Db(t, e) {
  var i = Df(e);
  if ((/^spring/.test(i.easing) && (i.duration = wy(i.easing)), Qe.arr(t))) {
    var n = t.length,
      r = n === 2 && !Qe.obj(t[0]);
    r
      ? (t = { value: t })
      : Qe.fnc(e.duration) || (i.duration = e.duration / n);
  }
  var s = Qe.arr(t) ? t : [t];
  return s
    .map(function (a, o) {
      var l = Qe.obj(a) && !Qe.pth(a) ? a : { value: a };
      return (
        Qe.und(l.delay) && (l.delay = o ? 0 : e.delay),
        Qe.und(l.endDelay) &&
          (l.endDelay = o === s.length - 1 ? e.endDelay : 0),
        l
      );
    })
    .map(function (a) {
      return xh(a, i);
    });
}
function Rb(t) {
  for (
    var e = vh(
        yh(
          t.map(function (s) {
            return Object.keys(s);
          })
        ),
        function (s) {
          return Qe.key(s);
        }
      ).reduce(function (s, a) {
        return s.indexOf(a) < 0 && s.push(a), s;
      }, []),
      i = {},
      n = function (s) {
        var a = e[s];
        i[a] = t.map(function (o) {
          var l = {};
          for (var c in o)
            Qe.key(c) ? c == a && (l.value = o[c]) : (l[c] = o[c]);
          return l;
        });
      },
      r = 0;
    r < e.length;
    r++
  )
    n(r);
  return i;
}
function Ob(t, e) {
  var i = [],
    n = e.keyframes;
  n && (e = xh(Rb(n), e));
  for (var r in e) Qe.key(r) && i.push({ name: r, tweens: Db(e[r], t) });
  return i;
}
function Ib(t, e) {
  var i = {};
  for (var n in t) {
    var r = hd(t[n], e);
    Qe.arr(r) &&
      ((r = r.map(function (s) {
        return hd(s, e);
      })),
      r.length === 1 && (r = r[0])),
      (i[n] = r);
  }
  return (
    (i.duration = parseFloat(i.duration)), (i.delay = parseFloat(i.delay)), i
  );
}
function Ub(t, e) {
  var i;
  return t.tweens.map(function (n) {
    var r = Ib(n, e),
      s = r.value,
      a = Qe.arr(s) ? s[1] : s,
      o = Ur(a),
      l = If(e.target, t.name, o, e),
      c = i ? i.to.original : l,
      d = Qe.arr(s) ? s[0] : c,
      h = Ur(d) || Ur(l),
      u = o || h;
    return (
      Qe.und(a) && (a = c),
      (r.from = nm(d, u)),
      (r.to = nm(Uf(a, d), u)),
      (r.start = i ? i.end : 0),
      (r.end = r.start + r.delay + r.duration + r.endDelay),
      (r.easing = Pf(r.easing, r.duration)),
      (r.isPath = Qe.pth(s)),
      (r.isPathTargetInsideSVG = r.isPath && Qe.svg(e.target)),
      (r.isColor = Qe.col(r.from.original)),
      r.isColor && (r.round = 1),
      (i = r),
      r
    );
  });
}
var Ry = {
  css: function (t, e, i) {
    return (t.style[e] = i);
  },
  attribute: function (t, e, i) {
    return t.setAttribute(e, i);
  },
  object: function (t, e, i) {
    return (t[e] = i);
  },
  transform: function (t, e, i, n, r) {
    if ((n.list.set(e, i), e === n.last || r)) {
      var s = "";
      n.list.forEach(function (a, o) {
        s += o + "(" + a + ") ";
      }),
        (t.style.transform = s);
    }
  },
};
function Oy(t, e) {
  var i = Dy(t);
  i.forEach(function (n) {
    for (var r in e) {
      var s = hd(e[r], n),
        a = n.target,
        o = Ur(s),
        l = If(a, r, o, n),
        c = o || Ur(l),
        d = Uf(Ay(s, c), l),
        h = Of(a, r);
      Ry[h](a, r, d, n.transforms, !0);
    }
  });
}
function Nb(t, e) {
  var i = Of(t.target, e.name);
  if (i) {
    var n = Ub(e, t),
      r = n[n.length - 1];
    return {
      type: i,
      property: e.name,
      animatable: t,
      tweens: n,
      duration: r.end,
      delay: n[0].delay,
      endDelay: r.endDelay,
    };
  }
}
function zb(t, e) {
  return vh(
    yh(
      t.map(function (i) {
        return e.map(function (n) {
          return Nb(i, n);
        });
      })
    ),
    function (i) {
      return !Qe.und(i);
    }
  );
}
function Iy(t, e) {
  var i = t.length,
    n = function (s) {
      return s.timelineOffset ? s.timelineOffset : 0;
    },
    r = {};
  return (
    (r.duration = i
      ? Math.max.apply(
          Math,
          t.map(function (s) {
            return n(s) + s.duration;
          })
        )
      : e.duration),
    (r.delay = i
      ? Math.min.apply(
          Math,
          t.map(function (s) {
            return n(s) + s.delay;
          })
        )
      : e.delay),
    (r.endDelay = i
      ? r.duration -
        Math.max.apply(
          Math,
          t.map(function (s) {
            return n(s) + s.duration - s.endDelay;
          })
        )
      : e.endDelay),
    r
  );
}
var rm = 0;
function Bb(t) {
  var e = cd(_y, t),
    i = cd(Cf, t),
    n = Ob(i, t),
    r = Dy(t.targets),
    s = zb(r, n),
    a = Iy(s, i),
    o = rm;
  return (
    rm++,
    xh(e, {
      id: o,
      children: [],
      animatables: r,
      animations: s,
      duration: a.duration,
      delay: a.delay,
      endDelay: a.endDelay,
    })
  );
}
var zn = [],
  Uy = (function () {
    var t;
    function e() {
      !t &&
        (!sm() || !Yt.suspendWhenDocumentHidden) &&
        zn.length > 0 &&
        (t = requestAnimationFrame(i));
    }
    function i(r) {
      for (var s = zn.length, a = 0; a < s; ) {
        var o = zn[a];
        o.paused ? (zn.splice(a, 1), s--) : (o.tick(r), a++);
      }
      t = a > 0 ? requestAnimationFrame(i) : void 0;
    }
    function n() {
      Yt.suspendWhenDocumentHidden &&
        (sm()
          ? (t = cancelAnimationFrame(t))
          : (zn.forEach(function (r) {
              return r._onDocumentVisibility();
            }),
            Uy()));
    }
    return (
      typeof document < "u" && document.addEventListener("visibilitychange", n),
      e
    );
  })();
function sm() {
  return !!document && document.hidden;
}
function Yt(t) {
  t === void 0 && (t = {});
  var e = 0,
    i = 0,
    n = 0,
    r,
    s = 0,
    a = null;
  function o(x) {
    var y =
      window.Promise &&
      new Promise(function (_) {
        return (a = _);
      });
    return (x.finished = y), y;
  }
  var l = Bb(t);
  o(l);
  function c() {
    var x = l.direction;
    x !== "alternate" && (l.direction = x !== "normal" ? "normal" : "reverse"),
      (l.reversed = !l.reversed),
      r.forEach(function (y) {
        return (y.reversed = l.reversed);
      });
  }
  function d(x) {
    return l.reversed ? l.duration - x : x;
  }
  function h() {
    (e = 0), (i = d(l.currentTime) * (1 / Yt.speed));
  }
  function u(x, y) {
    y && y.seek(x - y.timelineOffset);
  }
  function f(x) {
    if (l.reversePlayback) for (var _ = s; _--; ) u(x, r[_]);
    else for (var y = 0; y < s; y++) u(x, r[y]);
  }
  function p(x) {
    for (var y = 0, _ = l.animations, M = _.length; y < M; ) {
      var b = _[y],
        E = b.animatable,
        T = b.tweens,
        S = T.length - 1,
        w = T[S];
      S &&
        (w =
          vh(T, function (Y) {
            return x < Y.end;
          })[0] || w);
      for (
        var C = ar(x - w.start - w.delay, 0, w.duration) / w.duration,
          L = isNaN(C) ? 1 : w.easing(C),
          P = w.to.strings,
          R = w.round,
          I = [],
          W = w.to.numbers.length,
          N = void 0,
          U = 0;
        U < W;
        U++
      ) {
        var G = void 0,
          k = w.to.numbers[U],
          B = w.from.numbers[U] || 0;
        w.isPath
          ? (G = Lb(w.value, L * k, w.isPathTargetInsideSVG))
          : (G = B + L * (k - B)),
          R && ((w.isColor && U > 2) || (G = Math.round(G * R) / R)),
          I.push(G);
      }
      var V = P.length;
      if (!V) N = I[0];
      else {
        N = P[0];
        for (var X = 0; X < V; X++) {
          P[X];
          var H = P[X + 1],
            j = I[X];
          isNaN(j) || (H ? (N += j + H) : (N += j + " "));
        }
      }
      Ry[b.type](E.target, b.property, N, E.transforms),
        (b.currentValue = N),
        y++;
    }
  }
  function v(x) {
    l[x] && !l.passThrough && l[x](l);
  }
  function g() {
    l.remaining && l.remaining !== !0 && l.remaining--;
  }
  function m(x) {
    var y = l.duration,
      _ = l.delay,
      M = y - l.endDelay,
      b = d(x);
    (l.progress = ar((b / y) * 100, 0, 100)),
      (l.reversePlayback = b < l.currentTime),
      r && f(b),
      !l.began && l.currentTime > 0 && ((l.began = !0), v("begin")),
      !l.loopBegan && l.currentTime > 0 && ((l.loopBegan = !0), v("loopBegin")),
      b <= _ && l.currentTime !== 0 && p(0),
      ((b >= M && l.currentTime !== y) || !y) && p(y),
      b > _ && b < M
        ? (l.changeBegan ||
            ((l.changeBegan = !0), (l.changeCompleted = !1), v("changeBegin")),
          v("change"),
          p(b))
        : l.changeBegan &&
          ((l.changeCompleted = !0), (l.changeBegan = !1), v("changeComplete")),
      (l.currentTime = ar(b, 0, y)),
      l.began && v("update"),
      x >= y &&
        ((i = 0),
        g(),
        l.remaining
          ? ((e = n),
            v("loopComplete"),
            (l.loopBegan = !1),
            l.direction === "alternate" && c())
          : ((l.paused = !0),
            l.completed ||
              ((l.completed = !0),
              v("loopComplete"),
              v("complete"),
              !l.passThrough && "Promise" in window && (a(), o(l)))));
  }
  return (
    (l.reset = function () {
      var x = l.direction;
      (l.passThrough = !1),
        (l.currentTime = 0),
        (l.progress = 0),
        (l.paused = !0),
        (l.began = !1),
        (l.loopBegan = !1),
        (l.changeBegan = !1),
        (l.completed = !1),
        (l.changeCompleted = !1),
        (l.reversePlayback = !1),
        (l.reversed = x === "reverse"),
        (l.remaining = l.loop),
        (r = l.children),
        (s = r.length);
      for (var y = s; y--; ) l.children[y].reset();
      ((l.reversed && l.loop !== !0) || (x === "alternate" && l.loop === 1)) &&
        l.remaining++,
        p(l.reversed ? l.duration : 0);
    }),
    (l._onDocumentVisibility = h),
    (l.set = function (x, y) {
      return Oy(x, y), l;
    }),
    (l.tick = function (x) {
      (n = x), e || (e = n), m((n + (i - e)) * Yt.speed);
    }),
    (l.seek = function (x) {
      m(d(x));
    }),
    (l.pause = function () {
      (l.paused = !0), h();
    }),
    (l.play = function () {
      l.paused &&
        (l.completed && l.reset(), (l.paused = !1), zn.push(l), h(), Uy());
    }),
    (l.reverse = function () {
      c(), (l.completed = !l.reversed), h();
    }),
    (l.restart = function () {
      l.reset(), l.play();
    }),
    (l.remove = function (x) {
      var y = zf(x);
      Ny(y, l);
    }),
    l.reset(),
    l.autoplay && l.play(),
    l
  );
}
function am(t, e) {
  for (var i = e.length; i--; ) Lf(t, e[i].animatable.target) && e.splice(i, 1);
}
function Ny(t, e) {
  var i = e.animations,
    n = e.children;
  am(t, i);
  for (var r = n.length; r--; ) {
    var s = n[r],
      a = s.animations;
    am(t, a), !a.length && !s.children.length && n.splice(r, 1);
  }
  !i.length && !n.length && e.pause();
}
function Fb(t) {
  for (var e = zf(t), i = zn.length; i--; ) {
    var n = zn[i];
    Ny(e, n);
  }
}
function kb(t, e) {
  e === void 0 && (e = {});
  var i = e.direction || "normal",
    n = e.easing ? Pf(e.easing) : null,
    r = e.grid,
    s = e.axis,
    a = e.from || 0,
    o = a === "first",
    l = a === "center",
    c = a === "last",
    d = Qe.arr(t),
    h = parseFloat(d ? t[0] : t),
    u = d ? parseFloat(t[1]) : 0,
    f = Ur(d ? t[1] : t) || 0,
    p = e.start || 0 + (d ? h : 0),
    v = [],
    g = 0;
  return function (m, x, y) {
    if ((o && (a = 0), l && (a = (y - 1) / 2), c && (a = y - 1), !v.length)) {
      for (var _ = 0; _ < y; _++) {
        if (!r) v.push(Math.abs(a - _));
        else {
          var M = l ? (r[0] - 1) / 2 : a % r[0],
            b = l ? (r[1] - 1) / 2 : Math.floor(a / r[0]),
            E = _ % r[0],
            T = Math.floor(_ / r[0]),
            S = M - E,
            w = b - T,
            C = Math.sqrt(S * S + w * w);
          s === "x" && (C = -S), s === "y" && (C = -w), v.push(C);
        }
        g = Math.max.apply(Math, v);
      }
      n &&
        (v = v.map(function (P) {
          return n(P / g) * g;
        })),
        i === "reverse" &&
          (v = v.map(function (P) {
            return s ? (P < 0 ? P * -1 : -P) : Math.abs(g - P);
          }));
    }
    var L = d ? (u - h) / g : h;
    return p + L * (Math.round(v[x] * 100) / 100) + f;
  };
}
function Vb(t) {
  t === void 0 && (t = {});
  var e = Yt(t);
  return (
    (e.duration = 0),
    (e.add = function (i, n) {
      var r = zn.indexOf(e),
        s = e.children;
      r > -1 && zn.splice(r, 1);
      function a(u) {
        u.passThrough = !0;
      }
      for (var o = 0; o < s.length; o++) a(s[o]);
      var l = xh(i, cd(Cf, t));
      l.targets = l.targets || t.targets;
      var c = e.duration;
      (l.autoplay = !1),
        (l.direction = e.direction),
        (l.timelineOffset = Qe.und(n) ? c : Uf(n, c)),
        a(e),
        e.seek(l.timelineOffset);
      var d = Yt(l);
      a(d), s.push(d);
      var h = Iy(s, t);
      return (
        (e.delay = h.delay),
        (e.endDelay = h.endDelay),
        (e.duration = h.duration),
        e.seek(0),
        e.reset(),
        e.autoplay && e.play(),
        e
      );
    }),
    e
  );
}
Yt.version = "3.2.1";
Yt.speed = 1;
Yt.suspendWhenDocumentHidden = !0;
Yt.running = zn;
Yt.remove = Fb;
Yt.get = If;
Yt.set = Oy;
Yt.convertPx = Rf;
Yt.path = Pb;
Yt.setDashoffset = Ab;
Yt.stagger = kb;
Yt.timeline = Vb;
Yt.easing = Pf;
Yt.penner = Sy;
Yt.random = function (t, e) {
  return Math.floor(Math.random() * (e - t + 1)) + t;
};
const Pc = sb(0);
function Hb(t) {
  let e,
    i,
    n,
    r,
    s,
    a,
    o,
    l =
      "<span><i>Improving a Sustainable World Through Innovation and Projects</i></span> <span><i>พัฒนาโลกสู่ความยั่งยืนด้วยนวัตกรรมและโครงงาน</i></span>",
    c;
  return (
    (n = new ab({ props: { class: "w-full" } })),
    {
      c() {
        (e = he("div")),
          (i = he("div")),
          At(n.$$.fragment),
          (r = Ie()),
          (s = he("progress")),
          (a = Ie()),
          (o = he("div")),
          (o.innerHTML = l),
          this.h();
      },
      l(d) {
        e = ue(d, "DIV", { class: !0 });
        var h = Oe(e);
        i = ue(h, "DIV", { class: !0 });
        var u = Oe(i);
        Ct(n.$$.fragment, u),
          (r = Ue(u)),
          (s = ue(u, "PROGRESS", { class: !0, max: !0 })),
          Oe(s).forEach(fe),
          (a = Ue(u)),
          (o = ue(u, "DIV", { class: !0, ["data-svelte-h"]: !0 })),
          ht(o) !== "svelte-37lars" && (o.innerHTML = l),
          u.forEach(fe),
          h.forEach(fe),
          this.h();
      },
      h() {
        Q(s, "class", "progress-primary progress w-full"),
          (s.value = t[0]),
          Q(s, "max", "100"),
          Q(o, "class", "mt-10 flex flex-col text-center text-xs"),
          Q(
            i,
            "class",
            "max-w- m-auto flex h-full w-[calc(100%-32px)] max-w-sm flex-col items-center justify-center align-middle"
          ),
          Q(
            e,
            "class",
            "main-container absolute z-[2002] h-full w-full bg-base-100 transition-all duration-700 ease-in-out"
          );
      },
      m(d, h) {
        Mt(d, e, h),
          $(e, i),
          Pt(n, i, null),
          $(i, r),
          $(i, s),
          $(i, a),
          $(i, o),
          t[2](e),
          (c = !0);
      },
      p(d, [h]) {
        (!c || h & 1) && (s.value = d[0]);
      },
      i(d) {
        c || (Be(n.$$.fragment, d), (c = !0));
      },
      o(d) {
        Xe(n.$$.fragment, d), (c = !1);
      },
      d(d) {
        d && fe(e), Lt(n), t[2](null);
      },
    }
  );
}
function Gb(t, e, i) {
  let n;
  Af(t, Pc, (a) => i(0, (n = a)));
  let r;
  function s(a) {
    Ia[a ? "unshift" : "push"](() => {
      (r = a), i(1, r), i(0, n);
    });
  }
  return (
    (t.$$.update = () => {
      t.$$.dirty & 1 &&
        (n < 100
          ? (document.body.style.overflow = "hidden")
          : setTimeout(() => {
              i(1, (r.style.opacity = "0"), r),
                i(1, (r.style.transform = "translateY(-100%)"), r),
                (document.body.style.overflow = "auto"),
                setTimeout(() => {
                  i(1, (r.style.display = "none"), r);
                }, 700);
            }, 1e3));
    }),
    [n, r, s]
  );
}
class jb extends vs {
  constructor(e) {
    super(), ys(this, e, Gb, Hb, gs, {});
  }
}
const Wb = [
  {
    "start-date": "2023-07-17",
    "end-date": "2023-07-25",
    "start-time": "00:00",
    "end-time": "23:59",
    name: "Register for Event",
    description: `
      # Register for Event
    `,
  },
  {
    "start-date": "2023-07-25",
    "end-date": "2023-08-30",
    "start-time": "00:00",
    "end-time": "23:59",
    name: "Send abstract",
    description: `
      # Send abstract
    `,
  },
];
/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */ const Bf = "154",
  qb = 0,
  om = 1,
  Xb = 2,
  zy = 1,
  By = 2,
  Mr = 3,
  ds = 0,
  nn = 1,
  Dr = 2,
  Pi = 0,
  Ua = 1,
  ud = 2,
  lm = 3,
  cm = 4,
  Fy = 5,
  Xr = 100,
  $b = 101,
  Yb = 102,
  hm = 103,
  um = 104,
  dd = 200,
  Zb = 201,
  Kb = 202,
  Jb = 203,
  ky = 204,
  Vy = 205,
  Hy = 206,
  Qb = 207,
  Gy = 208,
  ew = 209,
  tw = 210,
  iw = 0,
  nw = 1,
  rw = 2,
  fd = 3,
  sw = 4,
  aw = 5,
  ow = 6,
  lw = 7,
  jy = 0,
  cw = 1,
  hw = 2,
  Nr = 0,
  uw = 1,
  dw = 2,
  fw = 3,
  pw = 4,
  mw = 5,
  Wy = 300,
  Hs = 301,
  Gs = 302,
  pd = 303,
  md = 304,
  gl = 306,
  nl = 1e3,
  Bn = 1001,
  gd = 1002,
  vi = 1003,
  dm = 1004,
  Yh = 1005,
  Zi = 1006,
  gw = 1007,
  rl = 1008,
  rs = 1009,
  vw = 1010,
  yw = 1011,
  Ff = 1012,
  qy = 1013,
  Zr = 1014,
  lr = 1015,
  Mn = 1016,
  Xy = 1017,
  $y = 1018,
  ss = 1020,
  xw = 1021,
  wn = 1023,
  Yy = 1024,
  _w = 1025,
  zs = 1026,
  js = 1027,
  Zy = 1028,
  Ky = 1029,
  bw = 1030,
  Jy = 1031,
  Qy = 1033,
  Zh = 33776,
  Kh = 33777,
  Jh = 33778,
  Qh = 33779,
  fm = 35840,
  pm = 35841,
  mm = 35842,
  gm = 35843,
  ww = 36196,
  vm = 37492,
  ym = 37496,
  xm = 37808,
  _m = 37809,
  bm = 37810,
  wm = 37811,
  Sm = 37812,
  Mm = 37813,
  Em = 37814,
  Tm = 37815,
  Am = 37816,
  Cm = 37817,
  Pm = 37818,
  Lm = 37819,
  Dm = 37820,
  Rm = 37821,
  eu = 36492,
  Sw = 36283,
  Om = 36284,
  Im = 36285,
  Um = 36286,
  sl = 3e3,
  zr = 3001,
  Mw = 3200,
  Ew = 3201,
  ex = 0,
  Tw = 1,
  Bs = "",
  gt = "srgb",
  qn = "srgb-linear",
  tx = "display-p3",
  tu = 7680,
  Aw = 519,
  Cw = 512,
  Pw = 513,
  Lw = 514,
  Dw = 515,
  Rw = 516,
  Ow = 517,
  Iw = 518,
  Uw = 519,
  vd = 35044,
  Nm = "300 es",
  yd = 1035,
  Or = 2e3,
  zc = 2001;
class Ys {
  addEventListener(e, i) {
    this._listeners === void 0 && (this._listeners = {});
    const n = this._listeners;
    n[e] === void 0 && (n[e] = []), n[e].indexOf(i) === -1 && n[e].push(i);
  }
  hasEventListener(e, i) {
    if (this._listeners === void 0) return !1;
    const n = this._listeners;
    return n[e] !== void 0 && n[e].indexOf(i) !== -1;
  }
  removeEventListener(e, i) {
    if (this._listeners === void 0) return;
    const r = this._listeners[e];
    if (r !== void 0) {
      const s = r.indexOf(i);
      s !== -1 && r.splice(s, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0) return;
    const n = this._listeners[e.type];
    if (n !== void 0) {
      e.target = this;
      const r = n.slice(0);
      for (let s = 0, a = r.length; s < a; s++) r[s].call(this, e);
      e.target = null;
    }
  }
}
const Di = [
  "00",
  "01",
  "02",
  "03",
  "04",
  "05",
  "06",
  "07",
  "08",
  "09",
  "0a",
  "0b",
  "0c",
  "0d",
  "0e",
  "0f",
  "10",
  "11",
  "12",
  "13",
  "14",
  "15",
  "16",
  "17",
  "18",
  "19",
  "1a",
  "1b",
  "1c",
  "1d",
  "1e",
  "1f",
  "20",
  "21",
  "22",
  "23",
  "24",
  "25",
  "26",
  "27",
  "28",
  "29",
  "2a",
  "2b",
  "2c",
  "2d",
  "2e",
  "2f",
  "30",
  "31",
  "32",
  "33",
  "34",
  "35",
  "36",
  "37",
  "38",
  "39",
  "3a",
  "3b",
  "3c",
  "3d",
  "3e",
  "3f",
  "40",
  "41",
  "42",
  "43",
  "44",
  "45",
  "46",
  "47",
  "48",
  "49",
  "4a",
  "4b",
  "4c",
  "4d",
  "4e",
  "4f",
  "50",
  "51",
  "52",
  "53",
  "54",
  "55",
  "56",
  "57",
  "58",
  "59",
  "5a",
  "5b",
  "5c",
  "5d",
  "5e",
  "5f",
  "60",
  "61",
  "62",
  "63",
  "64",
  "65",
  "66",
  "67",
  "68",
  "69",
  "6a",
  "6b",
  "6c",
  "6d",
  "6e",
  "6f",
  "70",
  "71",
  "72",
  "73",
  "74",
  "75",
  "76",
  "77",
  "78",
  "79",
  "7a",
  "7b",
  "7c",
  "7d",
  "7e",
  "7f",
  "80",
  "81",
  "82",
  "83",
  "84",
  "85",
  "86",
  "87",
  "88",
  "89",
  "8a",
  "8b",
  "8c",
  "8d",
  "8e",
  "8f",
  "90",
  "91",
  "92",
  "93",
  "94",
  "95",
  "96",
  "97",
  "98",
  "99",
  "9a",
  "9b",
  "9c",
  "9d",
  "9e",
  "9f",
  "a0",
  "a1",
  "a2",
  "a3",
  "a4",
  "a5",
  "a6",
  "a7",
  "a8",
  "a9",
  "aa",
  "ab",
  "ac",
  "ad",
  "ae",
  "af",
  "b0",
  "b1",
  "b2",
  "b3",
  "b4",
  "b5",
  "b6",
  "b7",
  "b8",
  "b9",
  "ba",
  "bb",
  "bc",
  "bd",
  "be",
  "bf",
  "c0",
  "c1",
  "c2",
  "c3",
  "c4",
  "c5",
  "c6",
  "c7",
  "c8",
  "c9",
  "ca",
  "cb",
  "cc",
  "cd",
  "ce",
  "cf",
  "d0",
  "d1",
  "d2",
  "d3",
  "d4",
  "d5",
  "d6",
  "d7",
  "d8",
  "d9",
  "da",
  "db",
  "dc",
  "dd",
  "de",
  "df",
  "e0",
  "e1",
  "e2",
  "e3",
  "e4",
  "e5",
  "e6",
  "e7",
  "e8",
  "e9",
  "ea",
  "eb",
  "ec",
  "ed",
  "ee",
  "ef",
  "f0",
  "f1",
  "f2",
  "f3",
  "f4",
  "f5",
  "f6",
  "f7",
  "f8",
  "f9",
  "fa",
  "fb",
  "fc",
  "fd",
  "fe",
  "ff",
];
let zm = 1234567;
const Wo = Math.PI / 180,
  $a = 180 / Math.PI;
function Gn() {
  const t = (Math.random() * 4294967295) | 0,
    e = (Math.random() * 4294967295) | 0,
    i = (Math.random() * 4294967295) | 0,
    n = (Math.random() * 4294967295) | 0;
  return (
    Di[t & 255] +
    Di[(t >> 8) & 255] +
    Di[(t >> 16) & 255] +
    Di[(t >> 24) & 255] +
    "-" +
    Di[e & 255] +
    Di[(e >> 8) & 255] +
    "-" +
    Di[((e >> 16) & 15) | 64] +
    Di[(e >> 24) & 255] +
    "-" +
    Di[(i & 63) | 128] +
    Di[(i >> 8) & 255] +
    "-" +
    Di[(i >> 16) & 255] +
    Di[(i >> 24) & 255] +
    Di[n & 255] +
    Di[(n >> 8) & 255] +
    Di[(n >> 16) & 255] +
    Di[(n >> 24) & 255]
  ).toLowerCase();
}
function yi(t, e, i) {
  return Math.max(e, Math.min(i, t));
}
function kf(t, e) {
  return ((t % e) + e) % e;
}
function Nw(t, e, i, n, r) {
  return n + ((t - e) * (r - n)) / (i - e);
}
function zw(t, e, i) {
  return t !== e ? (i - t) / (e - t) : 0;
}
function qo(t, e, i) {
  return (1 - i) * t + i * e;
}
function Bw(t, e, i, n) {
  return qo(t, e, 1 - Math.exp(-i * n));
}
function Fw(t, e = 1) {
  return e - Math.abs(kf(t, e * 2) - e);
}
function kw(t, e, i) {
  return t <= e
    ? 0
    : t >= i
    ? 1
    : ((t = (t - e) / (i - e)), t * t * (3 - 2 * t));
}
function Vw(t, e, i) {
  return t <= e
    ? 0
    : t >= i
    ? 1
    : ((t = (t - e) / (i - e)), t * t * t * (t * (t * 6 - 15) + 10));
}
function Hw(t, e) {
  return t + Math.floor(Math.random() * (e - t + 1));
}
function Gw(t, e) {
  return t + Math.random() * (e - t);
}
function jw(t) {
  return t * (0.5 - Math.random());
}
function Ww(t) {
  t !== void 0 && (zm = t);
  let e = (zm += 1831565813);
  return (
    (e = Math.imul(e ^ (e >>> 15), e | 1)),
    (e ^= e + Math.imul(e ^ (e >>> 7), e | 61)),
    ((e ^ (e >>> 14)) >>> 0) / 4294967296
  );
}
function qw(t) {
  return t * Wo;
}
function Xw(t) {
  return t * $a;
}
function xd(t) {
  return (t & (t - 1)) === 0 && t !== 0;
}
function ix(t) {
  return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2));
}
function Bc(t) {
  return Math.pow(2, Math.floor(Math.log(t) / Math.LN2));
}
function $w(t, e, i, n, r) {
  const s = Math.cos,
    a = Math.sin,
    o = s(i / 2),
    l = a(i / 2),
    c = s((e + n) / 2),
    d = a((e + n) / 2),
    h = s((e - n) / 2),
    u = a((e - n) / 2),
    f = s((n - e) / 2),
    p = a((n - e) / 2);
  switch (r) {
    case "XYX":
      t.set(o * d, l * h, l * u, o * c);
      break;
    case "YZY":
      t.set(l * u, o * d, l * h, o * c);
      break;
    case "ZXZ":
      t.set(l * h, l * u, o * d, o * c);
      break;
    case "XZX":
      t.set(o * d, l * p, l * f, o * c);
      break;
    case "YXY":
      t.set(l * f, o * d, l * p, o * c);
      break;
    case "ZYZ":
      t.set(l * p, l * f, o * d, o * c);
      break;
    default:
      console.warn(
        "THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
          r
      );
  }
}
function Ir(t, e) {
  switch (e.constructor) {
    case Float32Array:
      return t;
    case Uint32Array:
      return t / 4294967295;
    case Uint16Array:
      return t / 65535;
    case Uint8Array:
      return t / 255;
    case Int32Array:
      return Math.max(t / 2147483647, -1);
    case Int16Array:
      return Math.max(t / 32767, -1);
    case Int8Array:
      return Math.max(t / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function Wt(t, e) {
  switch (e.constructor) {
    case Float32Array:
      return t;
    case Uint32Array:
      return Math.round(t * 4294967295);
    case Uint16Array:
      return Math.round(t * 65535);
    case Uint8Array:
      return Math.round(t * 255);
    case Int32Array:
      return Math.round(t * 2147483647);
    case Int16Array:
      return Math.round(t * 32767);
    case Int8Array:
      return Math.round(t * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const Jt = {
  DEG2RAD: Wo,
  RAD2DEG: $a,
  generateUUID: Gn,
  clamp: yi,
  euclideanModulo: kf,
  mapLinear: Nw,
  inverseLerp: zw,
  lerp: qo,
  damp: Bw,
  pingpong: Fw,
  smoothstep: kw,
  smootherstep: Vw,
  randInt: Hw,
  randFloat: Gw,
  randFloatSpread: jw,
  seededRandom: Ww,
  degToRad: qw,
  radToDeg: Xw,
  isPowerOfTwo: xd,
  ceilPowerOfTwo: ix,
  floorPowerOfTwo: Bc,
  setQuaternionFromProperEuler: $w,
  normalize: Wt,
  denormalize: Ir,
};
class J {
  constructor(e = 0, i = 0) {
    (J.prototype.isVector2 = !0), (this.x = e), (this.y = i);
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, i) {
    return (this.x = e), (this.y = i), this;
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setComponent(e, i) {
    switch (e) {
      case 0:
        this.x = i;
        break;
      case 1:
        this.y = i;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return (this.x = e.x), (this.y = e.y), this;
  }
  add(e) {
    return (this.x += e.x), (this.y += e.y), this;
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), this;
  }
  addVectors(e, i) {
    return (this.x = e.x + i.x), (this.y = e.y + i.y), this;
  }
  addScaledVector(e, i) {
    return (this.x += e.x * i), (this.y += e.y * i), this;
  }
  sub(e) {
    return (this.x -= e.x), (this.y -= e.y), this;
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), this;
  }
  subVectors(e, i) {
    return (this.x = e.x - i.x), (this.y = e.y - i.y), this;
  }
  multiply(e) {
    return (this.x *= e.x), (this.y *= e.y), this;
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), this;
  }
  divide(e) {
    return (this.x /= e.x), (this.y /= e.y), this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const i = this.x,
      n = this.y,
      r = e.elements;
    return (
      (this.x = r[0] * i + r[3] * n + r[6]),
      (this.y = r[1] * i + r[4] * n + r[7]),
      this
    );
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)), (this.y = Math.min(this.y, e.y)), this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)), (this.y = Math.max(this.y, e.y)), this
    );
  }
  clamp(e, i) {
    return (
      (this.x = Math.max(e.x, Math.min(i.x, this.x))),
      (this.y = Math.max(e.y, Math.min(i.y, this.y))),
      this
    );
  }
  clampScalar(e, i) {
    return (
      (this.x = Math.max(e, Math.min(i, this.x))),
      (this.y = Math.max(e, Math.min(i, this.y))),
      this
    );
  }
  clampLength(e, i) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(
      Math.max(e, Math.min(i, n))
    );
  }
  floor() {
    return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this;
  }
  ceil() {
    return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;
  }
  round() {
    return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this;
  }
  roundToZero() {
    return (
      (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
      (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
      this
    );
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(e) {
    const i = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (i === 0) return Math.PI / 2;
    const n = this.dot(e) / i;
    return Math.acos(yi(n, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const i = this.x - e.x,
      n = this.y - e.y;
    return i * i + n * n;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, i) {
    return (this.x += (e.x - this.x) * i), (this.y += (e.y - this.y) * i), this;
  }
  lerpVectors(e, i, n) {
    return (
      (this.x = e.x + (i.x - e.x) * n), (this.y = e.y + (i.y - e.y) * n), this
    );
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, i = 0) {
    return (this.x = e[i]), (this.y = e[i + 1]), this;
  }
  toArray(e = [], i = 0) {
    return (e[i] = this.x), (e[i + 1] = this.y), e;
  }
  fromBufferAttribute(e, i) {
    return (this.x = e.getX(i)), (this.y = e.getY(i)), this;
  }
  rotateAround(e, i) {
    const n = Math.cos(i),
      r = Math.sin(i),
      s = this.x - e.x,
      a = this.y - e.y;
    return (this.x = s * n - a * r + e.x), (this.y = s * r + a * n + e.y), this;
  }
  random() {
    return (this.x = Math.random()), (this.y = Math.random()), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class ft {
  constructor(e, i, n, r, s, a, o, l, c) {
    (ft.prototype.isMatrix3 = !0),
      (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
      e !== void 0 && this.set(e, i, n, r, s, a, o, l, c);
  }
  set(e, i, n, r, s, a, o, l, c) {
    const d = this.elements;
    return (
      (d[0] = e),
      (d[1] = r),
      (d[2] = o),
      (d[3] = i),
      (d[4] = s),
      (d[5] = l),
      (d[6] = n),
      (d[7] = a),
      (d[8] = c),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
  }
  copy(e) {
    const i = this.elements,
      n = e.elements;
    return (
      (i[0] = n[0]),
      (i[1] = n[1]),
      (i[2] = n[2]),
      (i[3] = n[3]),
      (i[4] = n[4]),
      (i[5] = n[5]),
      (i[6] = n[6]),
      (i[7] = n[7]),
      (i[8] = n[8]),
      this
    );
  }
  extractBasis(e, i, n) {
    return (
      e.setFromMatrix3Column(this, 0),
      i.setFromMatrix3Column(this, 1),
      n.setFromMatrix3Column(this, 2),
      this
    );
  }
  setFromMatrix4(e) {
    const i = e.elements;
    return (
      this.set(i[0], i[4], i[8], i[1], i[5], i[9], i[2], i[6], i[10]), this
    );
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, i) {
    const n = e.elements,
      r = i.elements,
      s = this.elements,
      a = n[0],
      o = n[3],
      l = n[6],
      c = n[1],
      d = n[4],
      h = n[7],
      u = n[2],
      f = n[5],
      p = n[8],
      v = r[0],
      g = r[3],
      m = r[6],
      x = r[1],
      y = r[4],
      _ = r[7],
      M = r[2],
      b = r[5],
      E = r[8];
    return (
      (s[0] = a * v + o * x + l * M),
      (s[3] = a * g + o * y + l * b),
      (s[6] = a * m + o * _ + l * E),
      (s[1] = c * v + d * x + h * M),
      (s[4] = c * g + d * y + h * b),
      (s[7] = c * m + d * _ + h * E),
      (s[2] = u * v + f * x + p * M),
      (s[5] = u * g + f * y + p * b),
      (s[8] = u * m + f * _ + p * E),
      this
    );
  }
  multiplyScalar(e) {
    const i = this.elements;
    return (
      (i[0] *= e),
      (i[3] *= e),
      (i[6] *= e),
      (i[1] *= e),
      (i[4] *= e),
      (i[7] *= e),
      (i[2] *= e),
      (i[5] *= e),
      (i[8] *= e),
      this
    );
  }
  determinant() {
    const e = this.elements,
      i = e[0],
      n = e[1],
      r = e[2],
      s = e[3],
      a = e[4],
      o = e[5],
      l = e[6],
      c = e[7],
      d = e[8];
    return (
      i * a * d - i * o * c - n * s * d + n * o * l + r * s * c - r * a * l
    );
  }
  invert() {
    const e = this.elements,
      i = e[0],
      n = e[1],
      r = e[2],
      s = e[3],
      a = e[4],
      o = e[5],
      l = e[6],
      c = e[7],
      d = e[8],
      h = d * a - o * c,
      u = o * l - d * s,
      f = c * s - a * l,
      p = i * h + n * u + r * f;
    if (p === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const v = 1 / p;
    return (
      (e[0] = h * v),
      (e[1] = (r * c - d * n) * v),
      (e[2] = (o * n - r * a) * v),
      (e[3] = u * v),
      (e[4] = (d * i - r * l) * v),
      (e[5] = (r * s - o * i) * v),
      (e[6] = f * v),
      (e[7] = (n * l - c * i) * v),
      (e[8] = (a * i - n * s) * v),
      this
    );
  }
  transpose() {
    let e;
    const i = this.elements;
    return (
      (e = i[1]),
      (i[1] = i[3]),
      (i[3] = e),
      (e = i[2]),
      (i[2] = i[6]),
      (i[6] = e),
      (e = i[5]),
      (i[5] = i[7]),
      (i[7] = e),
      this
    );
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const i = this.elements;
    return (
      (e[0] = i[0]),
      (e[1] = i[3]),
      (e[2] = i[6]),
      (e[3] = i[1]),
      (e[4] = i[4]),
      (e[5] = i[7]),
      (e[6] = i[2]),
      (e[7] = i[5]),
      (e[8] = i[8]),
      this
    );
  }
  setUvTransform(e, i, n, r, s, a, o) {
    const l = Math.cos(s),
      c = Math.sin(s);
    return (
      this.set(
        n * l,
        n * c,
        -n * (l * a + c * o) + a + e,
        -r * c,
        r * l,
        -r * (-c * a + l * o) + o + i,
        0,
        0,
        1
      ),
      this
    );
  }
  scale(e, i) {
    return this.premultiply(iu.makeScale(e, i)), this;
  }
  rotate(e) {
    return this.premultiply(iu.makeRotation(-e)), this;
  }
  translate(e, i) {
    return this.premultiply(iu.makeTranslation(e, i)), this;
  }
  makeTranslation(e, i) {
    return (
      e.isVector2
        ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1)
        : this.set(1, 0, e, 0, 1, i, 0, 0, 1),
      this
    );
  }
  makeRotation(e) {
    const i = Math.cos(e),
      n = Math.sin(e);
    return this.set(i, -n, 0, n, i, 0, 0, 0, 1), this;
  }
  makeScale(e, i) {
    return this.set(e, 0, 0, 0, i, 0, 0, 0, 1), this;
  }
  equals(e) {
    const i = this.elements,
      n = e.elements;
    for (let r = 0; r < 9; r++) if (i[r] !== n[r]) return !1;
    return !0;
  }
  fromArray(e, i = 0) {
    for (let n = 0; n < 9; n++) this.elements[n] = e[n + i];
    return this;
  }
  toArray(e = [], i = 0) {
    const n = this.elements;
    return (
      (e[i] = n[0]),
      (e[i + 1] = n[1]),
      (e[i + 2] = n[2]),
      (e[i + 3] = n[3]),
      (e[i + 4] = n[4]),
      (e[i + 5] = n[5]),
      (e[i + 6] = n[6]),
      (e[i + 7] = n[7]),
      (e[i + 8] = n[8]),
      e
    );
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const iu = new ft();
function nx(t) {
  for (let e = t.length - 1; e >= 0; --e) if (t[e] >= 65535) return !0;
  return !1;
}
const Yw = {
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array,
};
function Ll(t, e) {
  return new Yw[t](e);
}
function Fc(t) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", t);
}
const Bm = {};
function Xo(t) {
  t in Bm || ((Bm[t] = !0), console.warn(t));
}
function Na(t) {
  return t < 0.04045
    ? t * 0.0773993808
    : Math.pow(t * 0.9478672986 + 0.0521327014, 2.4);
}
function nu(t) {
  return t < 0.0031308 ? t * 12.92 : 1.055 * Math.pow(t, 0.41666) - 0.055;
}
const Zw = new ft().fromArray([
    0.8224621, 0.0331941, 0.0170827, 0.177538, 0.9668058, 0.0723974, -1e-7,
    1e-7, 0.9105199,
  ]),
  Kw = new ft().fromArray([
    1.2249401, -0.0420569, -0.0196376, -0.2249404, 1.0420571, -0.0786361, 1e-7,
    0, 1.0982735,
  ]);
function Jw(t) {
  return t.convertSRGBToLinear().applyMatrix3(Kw);
}
function Qw(t) {
  return t.applyMatrix3(Zw).convertLinearToSRGB();
}
const eS = { [qn]: (t) => t, [gt]: (t) => t.convertSRGBToLinear(), [tx]: Jw },
  tS = { [qn]: (t) => t, [gt]: (t) => t.convertLinearToSRGB(), [tx]: Qw },
  Ln = {
    enabled: !0,
    get legacyMode() {
      return (
        console.warn(
          "THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."
        ),
        !this.enabled
      );
    },
    set legacyMode(t) {
      console.warn(
        "THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."
      ),
        (this.enabled = !t);
    },
    get workingColorSpace() {
      return qn;
    },
    set workingColorSpace(t) {
      console.warn("THREE.ColorManagement: .workingColorSpace is readonly.");
    },
    convert: function (t, e, i) {
      if (this.enabled === !1 || e === i || !e || !i) return t;
      const n = eS[e],
        r = tS[i];
      if (n === void 0 || r === void 0)
        throw new Error(
          `Unsupported color space conversion, "${e}" to "${i}".`
        );
      return r(n(t));
    },
    fromWorkingColorSpace: function (t, e) {
      return this.convert(t, this.workingColorSpace, e);
    },
    toWorkingColorSpace: function (t, e) {
      return this.convert(t, e, this.workingColorSpace);
    },
  };
let ra;
class rx {
  static getDataURL(e) {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u") return e.src;
    let i;
    if (e instanceof HTMLCanvasElement) i = e;
    else {
      ra === void 0 && (ra = Fc("canvas")),
        (ra.width = e.width),
        (ra.height = e.height);
      const n = ra.getContext("2d");
      e instanceof ImageData
        ? n.putImageData(e, 0, 0)
        : n.drawImage(e, 0, 0, e.width, e.height),
        (i = ra);
    }
    return i.width > 2048 || i.height > 2048
      ? (console.warn(
          "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
          e
        ),
        i.toDataURL("image/jpeg", 0.6))
      : i.toDataURL("image/png");
  }
  static sRGBToLinear(e) {
    if (
      (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement) ||
      (typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement) ||
      (typeof ImageBitmap < "u" && e instanceof ImageBitmap)
    ) {
      const i = Fc("canvas");
      (i.width = e.width), (i.height = e.height);
      const n = i.getContext("2d");
      n.drawImage(e, 0, 0, e.width, e.height);
      const r = n.getImageData(0, 0, e.width, e.height),
        s = r.data;
      for (let a = 0; a < s.length; a++) s[a] = Na(s[a] / 255) * 255;
      return n.putImageData(r, 0, 0), i;
    } else if (e.data) {
      const i = e.data.slice(0);
      for (let n = 0; n < i.length; n++)
        i instanceof Uint8Array || i instanceof Uint8ClampedArray
          ? (i[n] = Math.floor(Na(i[n] / 255) * 255))
          : (i[n] = Na(i[n]));
      return { data: i, width: e.width, height: e.height };
    } else
      return (
        console.warn(
          "THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."
        ),
        e
      );
  }
}
let iS = 0;
class sx {
  constructor(e = null) {
    (this.isSource = !0),
      Object.defineProperty(this, "id", { value: iS++ }),
      (this.uuid = Gn()),
      (this.data = e),
      (this.version = 0);
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  toJSON(e) {
    const i = e === void 0 || typeof e == "string";
    if (!i && e.images[this.uuid] !== void 0) return e.images[this.uuid];
    const n = { uuid: this.uuid, url: "" },
      r = this.data;
    if (r !== null) {
      let s;
      if (Array.isArray(r)) {
        s = [];
        for (let a = 0, o = r.length; a < o; a++)
          r[a].isDataTexture ? s.push(ru(r[a].image)) : s.push(ru(r[a]));
      } else s = ru(r);
      n.url = s;
    }
    return i || (e.images[this.uuid] = n), n;
  }
}
function ru(t) {
  return (typeof HTMLImageElement < "u" && t instanceof HTMLImageElement) ||
    (typeof HTMLCanvasElement < "u" && t instanceof HTMLCanvasElement) ||
    (typeof ImageBitmap < "u" && t instanceof ImageBitmap)
    ? rx.getDataURL(t)
    : t.data
    ? {
        data: Array.from(t.data),
        width: t.width,
        height: t.height,
        type: t.data.constructor.name,
      }
    : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let nS = 0;
class Li extends Ys {
  constructor(
    e = Li.DEFAULT_IMAGE,
    i = Li.DEFAULT_MAPPING,
    n = Bn,
    r = Bn,
    s = Zi,
    a = rl,
    o = wn,
    l = rs,
    c = Li.DEFAULT_ANISOTROPY,
    d = Bs
  ) {
    super(),
      (this.isTexture = !0),
      Object.defineProperty(this, "id", { value: nS++ }),
      (this.uuid = Gn()),
      (this.name = ""),
      (this.source = new sx(e)),
      (this.mipmaps = []),
      (this.mapping = i),
      (this.channel = 0),
      (this.wrapS = n),
      (this.wrapT = r),
      (this.magFilter = s),
      (this.minFilter = a),
      (this.anisotropy = c),
      (this.format = o),
      (this.internalFormat = null),
      (this.type = l),
      (this.offset = new J(0, 0)),
      (this.repeat = new J(1, 1)),
      (this.center = new J(0, 0)),
      (this.rotation = 0),
      (this.matrixAutoUpdate = !0),
      (this.matrix = new ft()),
      (this.generateMipmaps = !0),
      (this.premultiplyAlpha = !1),
      (this.flipY = !0),
      (this.unpackAlignment = 4),
      typeof d == "string"
        ? (this.colorSpace = d)
        : (Xo(
            "THREE.Texture: Property .encoding has been replaced by .colorSpace."
          ),
          (this.colorSpace = d === zr ? gt : Bs)),
      (this.userData = {}),
      (this.version = 0),
      (this.onUpdate = null),
      (this.isRenderTargetTexture = !1),
      (this.needsPMREMUpdate = !1);
  }
  get image() {
    return this.source.data;
  }
  set image(e = null) {
    this.source.data = e;
  }
  updateMatrix() {
    this.matrix.setUvTransform(
      this.offset.x,
      this.offset.y,
      this.repeat.x,
      this.repeat.y,
      this.rotation,
      this.center.x,
      this.center.y
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.source = e.source),
      (this.mipmaps = e.mipmaps.slice(0)),
      (this.mapping = e.mapping),
      (this.channel = e.channel),
      (this.wrapS = e.wrapS),
      (this.wrapT = e.wrapT),
      (this.magFilter = e.magFilter),
      (this.minFilter = e.minFilter),
      (this.anisotropy = e.anisotropy),
      (this.format = e.format),
      (this.internalFormat = e.internalFormat),
      (this.type = e.type),
      this.offset.copy(e.offset),
      this.repeat.copy(e.repeat),
      this.center.copy(e.center),
      (this.rotation = e.rotation),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this.matrix.copy(e.matrix),
      (this.generateMipmaps = e.generateMipmaps),
      (this.premultiplyAlpha = e.premultiplyAlpha),
      (this.flipY = e.flipY),
      (this.unpackAlignment = e.unpackAlignment),
      (this.colorSpace = e.colorSpace),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      (this.needsUpdate = !0),
      this
    );
  }
  toJSON(e) {
    const i = e === void 0 || typeof e == "string";
    if (!i && e.textures[this.uuid] !== void 0) return e.textures[this.uuid];
    const n = {
      metadata: { version: 4.6, type: "Texture", generator: "Texture.toJSON" },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(e).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment,
    };
    return (
      Object.keys(this.userData).length > 0 && (n.userData = this.userData),
      i || (e.textures[this.uuid] = n),
      n
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(e) {
    if (this.mapping !== Wy) return e;
    if ((e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1))
      switch (this.wrapS) {
        case nl:
          e.x = e.x - Math.floor(e.x);
          break;
        case Bn:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case gd:
          Math.abs(Math.floor(e.x) % 2) === 1
            ? (e.x = Math.ceil(e.x) - e.x)
            : (e.x = e.x - Math.floor(e.x));
          break;
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case nl:
          e.y = e.y - Math.floor(e.y);
          break;
        case Bn:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case gd:
          Math.abs(Math.floor(e.y) % 2) === 1
            ? (e.y = Math.ceil(e.y) - e.y)
            : (e.y = e.y - Math.floor(e.y));
          break;
      }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  set needsUpdate(e) {
    e === !0 && (this.version++, (this.source.needsUpdate = !0));
  }
  get encoding() {
    return (
      Xo("THREE.Texture: Property .encoding has been replaced by .colorSpace."),
      this.colorSpace === gt ? zr : sl
    );
  }
  set encoding(e) {
    Xo("THREE.Texture: Property .encoding has been replaced by .colorSpace."),
      (this.colorSpace = e === zr ? gt : Bs);
  }
}
Li.DEFAULT_IMAGE = null;
Li.DEFAULT_MAPPING = Wy;
Li.DEFAULT_ANISOTROPY = 1;
class yt {
  constructor(e = 0, i = 0, n = 0, r = 1) {
    (yt.prototype.isVector4 = !0),
      (this.x = e),
      (this.y = i),
      (this.z = n),
      (this.w = r);
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, i, n, r) {
    return (this.x = e), (this.y = i), (this.z = n), (this.w = r), this;
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), (this.z = e), (this.w = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setZ(e) {
    return (this.z = e), this;
  }
  setW(e) {
    return (this.w = e), this;
  }
  setComponent(e, i) {
    switch (e) {
      case 0:
        this.x = i;
        break;
      case 1:
        this.y = i;
        break;
      case 2:
        this.z = i;
        break;
      case 3:
        this.w = i;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return (
      (this.x = e.x),
      (this.y = e.y),
      (this.z = e.z),
      (this.w = e.w !== void 0 ? e.w : 1),
      this
    );
  }
  add(e) {
    return (
      (this.x += e.x), (this.y += e.y), (this.z += e.z), (this.w += e.w), this
    );
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), (this.z += e), (this.w += e), this;
  }
  addVectors(e, i) {
    return (
      (this.x = e.x + i.x),
      (this.y = e.y + i.y),
      (this.z = e.z + i.z),
      (this.w = e.w + i.w),
      this
    );
  }
  addScaledVector(e, i) {
    return (
      (this.x += e.x * i),
      (this.y += e.y * i),
      (this.z += e.z * i),
      (this.w += e.w * i),
      this
    );
  }
  sub(e) {
    return (
      (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), (this.w -= e.w), this
    );
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), (this.z -= e), (this.w -= e), this;
  }
  subVectors(e, i) {
    return (
      (this.x = e.x - i.x),
      (this.y = e.y - i.y),
      (this.z = e.z - i.z),
      (this.w = e.w - i.w),
      this
    );
  }
  multiply(e) {
    return (
      (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), (this.w *= e.w), this
    );
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), (this.z *= e), (this.w *= e), this;
  }
  applyMatrix4(e) {
    const i = this.x,
      n = this.y,
      r = this.z,
      s = this.w,
      a = e.elements;
    return (
      (this.x = a[0] * i + a[4] * n + a[8] * r + a[12] * s),
      (this.y = a[1] * i + a[5] * n + a[9] * r + a[13] * s),
      (this.z = a[2] * i + a[6] * n + a[10] * r + a[14] * s),
      (this.w = a[3] * i + a[7] * n + a[11] * r + a[15] * s),
      this
    );
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const i = Math.sqrt(1 - e.w * e.w);
    return (
      i < 1e-4
        ? ((this.x = 1), (this.y = 0), (this.z = 0))
        : ((this.x = e.x / i), (this.y = e.y / i), (this.z = e.z / i)),
      this
    );
  }
  setAxisAngleFromRotationMatrix(e) {
    let i, n, r, s;
    const l = e.elements,
      c = l[0],
      d = l[4],
      h = l[8],
      u = l[1],
      f = l[5],
      p = l[9],
      v = l[2],
      g = l[6],
      m = l[10];
    if (
      Math.abs(d - u) < 0.01 &&
      Math.abs(h - v) < 0.01 &&
      Math.abs(p - g) < 0.01
    ) {
      if (
        Math.abs(d + u) < 0.1 &&
        Math.abs(h + v) < 0.1 &&
        Math.abs(p + g) < 0.1 &&
        Math.abs(c + f + m - 3) < 0.1
      )
        return this.set(1, 0, 0, 0), this;
      i = Math.PI;
      const y = (c + 1) / 2,
        _ = (f + 1) / 2,
        M = (m + 1) / 2,
        b = (d + u) / 4,
        E = (h + v) / 4,
        T = (p + g) / 4;
      return (
        y > _ && y > M
          ? y < 0.01
            ? ((n = 0), (r = 0.707106781), (s = 0.707106781))
            : ((n = Math.sqrt(y)), (r = b / n), (s = E / n))
          : _ > M
          ? _ < 0.01
            ? ((n = 0.707106781), (r = 0), (s = 0.707106781))
            : ((r = Math.sqrt(_)), (n = b / r), (s = T / r))
          : M < 0.01
          ? ((n = 0.707106781), (r = 0.707106781), (s = 0))
          : ((s = Math.sqrt(M)), (n = E / s), (r = T / s)),
        this.set(n, r, s, i),
        this
      );
    }
    let x = Math.sqrt(
      (g - p) * (g - p) + (h - v) * (h - v) + (u - d) * (u - d)
    );
    return (
      Math.abs(x) < 0.001 && (x = 1),
      (this.x = (g - p) / x),
      (this.y = (h - v) / x),
      (this.z = (u - d) / x),
      (this.w = Math.acos((c + f + m - 1) / 2)),
      this
    );
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      (this.w = Math.min(this.w, e.w)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      (this.w = Math.max(this.w, e.w)),
      this
    );
  }
  clamp(e, i) {
    return (
      (this.x = Math.max(e.x, Math.min(i.x, this.x))),
      (this.y = Math.max(e.y, Math.min(i.y, this.y))),
      (this.z = Math.max(e.z, Math.min(i.z, this.z))),
      (this.w = Math.max(e.w, Math.min(i.w, this.w))),
      this
    );
  }
  clampScalar(e, i) {
    return (
      (this.x = Math.max(e, Math.min(i, this.x))),
      (this.y = Math.max(e, Math.min(i, this.y))),
      (this.z = Math.max(e, Math.min(i, this.z))),
      (this.w = Math.max(e, Math.min(i, this.w))),
      this
    );
  }
  clampLength(e, i) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(
      Math.max(e, Math.min(i, n))
    );
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      (this.w = Math.floor(this.w)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      (this.w = Math.ceil(this.w)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      (this.w = Math.round(this.w)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
      (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
      (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
      (this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w)),
      this
    );
  }
  negate() {
    return (
      (this.x = -this.x),
      (this.y = -this.y),
      (this.z = -this.z),
      (this.w = -this.w),
      this
    );
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return (
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  length() {
    return Math.sqrt(
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  manhattanLength() {
    return (
      Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    );
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, i) {
    return (
      (this.x += (e.x - this.x) * i),
      (this.y += (e.y - this.y) * i),
      (this.z += (e.z - this.z) * i),
      (this.w += (e.w - this.w) * i),
      this
    );
  }
  lerpVectors(e, i, n) {
    return (
      (this.x = e.x + (i.x - e.x) * n),
      (this.y = e.y + (i.y - e.y) * n),
      (this.z = e.z + (i.z - e.z) * n),
      (this.w = e.w + (i.w - e.w) * n),
      this
    );
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, i = 0) {
    return (
      (this.x = e[i]),
      (this.y = e[i + 1]),
      (this.z = e[i + 2]),
      (this.w = e[i + 3]),
      this
    );
  }
  toArray(e = [], i = 0) {
    return (
      (e[i] = this.x),
      (e[i + 1] = this.y),
      (e[i + 2] = this.z),
      (e[i + 3] = this.w),
      e
    );
  }
  fromBufferAttribute(e, i) {
    return (
      (this.x = e.getX(i)),
      (this.y = e.getY(i)),
      (this.z = e.getZ(i)),
      (this.w = e.getW(i)),
      this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      (this.w = Math.random()),
      this
    );
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class rn extends Ys {
  constructor(e = 1, i = 1, n = {}) {
    super(),
      (this.isWebGLRenderTarget = !0),
      (this.width = e),
      (this.height = i),
      (this.depth = 1),
      (this.scissor = new yt(0, 0, e, i)),
      (this.scissorTest = !1),
      (this.viewport = new yt(0, 0, e, i));
    const r = { width: e, height: i, depth: 1 };
    n.encoding !== void 0 &&
      (Xo(
        "THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace."
      ),
      (n.colorSpace = n.encoding === zr ? gt : Bs)),
      (this.texture = new Li(
        r,
        n.mapping,
        n.wrapS,
        n.wrapT,
        n.magFilter,
        n.minFilter,
        n.format,
        n.type,
        n.anisotropy,
        n.colorSpace
      )),
      (this.texture.isRenderTargetTexture = !0),
      (this.texture.flipY = !1),
      (this.texture.generateMipmaps =
        n.generateMipmaps !== void 0 ? n.generateMipmaps : !1),
      (this.texture.internalFormat =
        n.internalFormat !== void 0 ? n.internalFormat : null),
      (this.texture.minFilter = n.minFilter !== void 0 ? n.minFilter : Zi),
      (this.depthBuffer = n.depthBuffer !== void 0 ? n.depthBuffer : !0),
      (this.stencilBuffer = n.stencilBuffer !== void 0 ? n.stencilBuffer : !1),
      (this.depthTexture = n.depthTexture !== void 0 ? n.depthTexture : null),
      (this.samples = n.samples !== void 0 ? n.samples : 0);
  }
  setSize(e, i, n = 1) {
    (this.width !== e || this.height !== i || this.depth !== n) &&
      ((this.width = e),
      (this.height = i),
      (this.depth = n),
      (this.texture.image.width = e),
      (this.texture.image.height = i),
      (this.texture.image.depth = n),
      this.dispose()),
      this.viewport.set(0, 0, e, i),
      this.scissor.set(0, 0, e, i);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.width = e.width),
      (this.height = e.height),
      (this.depth = e.depth),
      this.scissor.copy(e.scissor),
      (this.scissorTest = e.scissorTest),
      this.viewport.copy(e.viewport),
      (this.texture = e.texture.clone()),
      (this.texture.isRenderTargetTexture = !0);
    const i = Object.assign({}, e.texture.image);
    return (
      (this.texture.source = new sx(i)),
      (this.depthBuffer = e.depthBuffer),
      (this.stencilBuffer = e.stencilBuffer),
      e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
      (this.samples = e.samples),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class ax extends Li {
  constructor(e = null, i = 1, n = 1, r = 1) {
    super(null),
      (this.isDataArrayTexture = !0),
      (this.image = { data: e, width: i, height: n, depth: r }),
      (this.magFilter = vi),
      (this.minFilter = vi),
      (this.wrapR = Bn),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
class rS extends Li {
  constructor(e = null, i = 1, n = 1, r = 1) {
    super(null),
      (this.isData3DTexture = !0),
      (this.image = { data: e, width: i, height: n, depth: r }),
      (this.magFilter = vi),
      (this.minFilter = vi),
      (this.wrapR = Bn),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
class Zs {
  constructor(e = 0, i = 0, n = 0, r = 1) {
    (this.isQuaternion = !0),
      (this._x = e),
      (this._y = i),
      (this._z = n),
      (this._w = r);
  }
  static slerpFlat(e, i, n, r, s, a, o) {
    let l = n[r + 0],
      c = n[r + 1],
      d = n[r + 2],
      h = n[r + 3];
    const u = s[a + 0],
      f = s[a + 1],
      p = s[a + 2],
      v = s[a + 3];
    if (o === 0) {
      (e[i + 0] = l), (e[i + 1] = c), (e[i + 2] = d), (e[i + 3] = h);
      return;
    }
    if (o === 1) {
      (e[i + 0] = u), (e[i + 1] = f), (e[i + 2] = p), (e[i + 3] = v);
      return;
    }
    if (h !== v || l !== u || c !== f || d !== p) {
      let g = 1 - o;
      const m = l * u + c * f + d * p + h * v,
        x = m >= 0 ? 1 : -1,
        y = 1 - m * m;
      if (y > Number.EPSILON) {
        const M = Math.sqrt(y),
          b = Math.atan2(M, m * x);
        (g = Math.sin(g * b) / M), (o = Math.sin(o * b) / M);
      }
      const _ = o * x;
      if (
        ((l = l * g + u * _),
        (c = c * g + f * _),
        (d = d * g + p * _),
        (h = h * g + v * _),
        g === 1 - o)
      ) {
        const M = 1 / Math.sqrt(l * l + c * c + d * d + h * h);
        (l *= M), (c *= M), (d *= M), (h *= M);
      }
    }
    (e[i] = l), (e[i + 1] = c), (e[i + 2] = d), (e[i + 3] = h);
  }
  static multiplyQuaternionsFlat(e, i, n, r, s, a) {
    const o = n[r],
      l = n[r + 1],
      c = n[r + 2],
      d = n[r + 3],
      h = s[a],
      u = s[a + 1],
      f = s[a + 2],
      p = s[a + 3];
    return (
      (e[i] = o * p + d * h + l * f - c * u),
      (e[i + 1] = l * p + d * u + c * h - o * f),
      (e[i + 2] = c * p + d * f + o * u - l * h),
      (e[i + 3] = d * p - o * h - l * u - c * f),
      e
    );
  }
  get x() {
    return this._x;
  }
  set x(e) {
    (this._x = e), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    (this._y = e), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    (this._z = e), this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    (this._w = e), this._onChangeCallback();
  }
  set(e, i, n, r) {
    return (
      (this._x = e),
      (this._y = i),
      (this._z = n),
      (this._w = r),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return (
      (this._x = e.x),
      (this._y = e.y),
      (this._z = e.z),
      (this._w = e.w),
      this._onChangeCallback(),
      this
    );
  }
  setFromEuler(e, i) {
    const n = e._x,
      r = e._y,
      s = e._z,
      a = e._order,
      o = Math.cos,
      l = Math.sin,
      c = o(n / 2),
      d = o(r / 2),
      h = o(s / 2),
      u = l(n / 2),
      f = l(r / 2),
      p = l(s / 2);
    switch (a) {
      case "XYZ":
        (this._x = u * d * h + c * f * p),
          (this._y = c * f * h - u * d * p),
          (this._z = c * d * p + u * f * h),
          (this._w = c * d * h - u * f * p);
        break;
      case "YXZ":
        (this._x = u * d * h + c * f * p),
          (this._y = c * f * h - u * d * p),
          (this._z = c * d * p - u * f * h),
          (this._w = c * d * h + u * f * p);
        break;
      case "ZXY":
        (this._x = u * d * h - c * f * p),
          (this._y = c * f * h + u * d * p),
          (this._z = c * d * p + u * f * h),
          (this._w = c * d * h - u * f * p);
        break;
      case "ZYX":
        (this._x = u * d * h - c * f * p),
          (this._y = c * f * h + u * d * p),
          (this._z = c * d * p - u * f * h),
          (this._w = c * d * h + u * f * p);
        break;
      case "YZX":
        (this._x = u * d * h + c * f * p),
          (this._y = c * f * h + u * d * p),
          (this._z = c * d * p - u * f * h),
          (this._w = c * d * h - u * f * p);
        break;
      case "XZY":
        (this._x = u * d * h - c * f * p),
          (this._y = c * f * h - u * d * p),
          (this._z = c * d * p + u * f * h),
          (this._w = c * d * h + u * f * p);
        break;
      default:
        console.warn(
          "THREE.Quaternion: .setFromEuler() encountered an unknown order: " + a
        );
    }
    return i !== !1 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e, i) {
    const n = i / 2,
      r = Math.sin(n);
    return (
      (this._x = e.x * r),
      (this._y = e.y * r),
      (this._z = e.z * r),
      (this._w = Math.cos(n)),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(e) {
    const i = e.elements,
      n = i[0],
      r = i[4],
      s = i[8],
      a = i[1],
      o = i[5],
      l = i[9],
      c = i[2],
      d = i[6],
      h = i[10],
      u = n + o + h;
    if (u > 0) {
      const f = 0.5 / Math.sqrt(u + 1);
      (this._w = 0.25 / f),
        (this._x = (d - l) * f),
        (this._y = (s - c) * f),
        (this._z = (a - r) * f);
    } else if (n > o && n > h) {
      const f = 2 * Math.sqrt(1 + n - o - h);
      (this._w = (d - l) / f),
        (this._x = 0.25 * f),
        (this._y = (r + a) / f),
        (this._z = (s + c) / f);
    } else if (o > h) {
      const f = 2 * Math.sqrt(1 + o - n - h);
      (this._w = (s - c) / f),
        (this._x = (r + a) / f),
        (this._y = 0.25 * f),
        (this._z = (l + d) / f);
    } else {
      const f = 2 * Math.sqrt(1 + h - n - o);
      (this._w = (a - r) / f),
        (this._x = (s + c) / f),
        (this._y = (l + d) / f),
        (this._z = 0.25 * f);
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e, i) {
    let n = e.dot(i) + 1;
    return (
      n < Number.EPSILON
        ? ((n = 0),
          Math.abs(e.x) > Math.abs(e.z)
            ? ((this._x = -e.y), (this._y = e.x), (this._z = 0), (this._w = n))
            : ((this._x = 0), (this._y = -e.z), (this._z = e.y), (this._w = n)))
        : ((this._x = e.y * i.z - e.z * i.y),
          (this._y = e.z * i.x - e.x * i.z),
          (this._z = e.x * i.y - e.y * i.x),
          (this._w = n)),
      this.normalize()
    );
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(yi(this.dot(e), -1, 1)));
  }
  rotateTowards(e, i) {
    const n = this.angleTo(e);
    if (n === 0) return this;
    const r = Math.min(1, i / n);
    return this.slerp(e, r), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return (
      (this._x *= -1),
      (this._y *= -1),
      (this._z *= -1),
      this._onChangeCallback(),
      this
    );
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return (
      this._x * this._x +
      this._y * this._y +
      this._z * this._z +
      this._w * this._w
    );
  }
  length() {
    return Math.sqrt(
      this._x * this._x +
        this._y * this._y +
        this._z * this._z +
        this._w * this._w
    );
  }
  normalize() {
    let e = this.length();
    return (
      e === 0
        ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
        : ((e = 1 / e),
          (this._x = this._x * e),
          (this._y = this._y * e),
          (this._z = this._z * e),
          (this._w = this._w * e)),
      this._onChangeCallback(),
      this
    );
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, i) {
    const n = e._x,
      r = e._y,
      s = e._z,
      a = e._w,
      o = i._x,
      l = i._y,
      c = i._z,
      d = i._w;
    return (
      (this._x = n * d + a * o + r * c - s * l),
      (this._y = r * d + a * l + s * o - n * c),
      (this._z = s * d + a * c + n * l - r * o),
      (this._w = a * d - n * o - r * l - s * c),
      this._onChangeCallback(),
      this
    );
  }
  slerp(e, i) {
    if (i === 0) return this;
    if (i === 1) return this.copy(e);
    const n = this._x,
      r = this._y,
      s = this._z,
      a = this._w;
    let o = a * e._w + n * e._x + r * e._y + s * e._z;
    if (
      (o < 0
        ? ((this._w = -e._w),
          (this._x = -e._x),
          (this._y = -e._y),
          (this._z = -e._z),
          (o = -o))
        : this.copy(e),
      o >= 1)
    )
      return (this._w = a), (this._x = n), (this._y = r), (this._z = s), this;
    const l = 1 - o * o;
    if (l <= Number.EPSILON) {
      const f = 1 - i;
      return (
        (this._w = f * a + i * this._w),
        (this._x = f * n + i * this._x),
        (this._y = f * r + i * this._y),
        (this._z = f * s + i * this._z),
        this.normalize(),
        this._onChangeCallback(),
        this
      );
    }
    const c = Math.sqrt(l),
      d = Math.atan2(c, o),
      h = Math.sin((1 - i) * d) / c,
      u = Math.sin(i * d) / c;
    return (
      (this._w = a * h + this._w * u),
      (this._x = n * h + this._x * u),
      (this._y = r * h + this._y * u),
      (this._z = s * h + this._z * u),
      this._onChangeCallback(),
      this
    );
  }
  slerpQuaternions(e, i, n) {
    return this.copy(e).slerp(i, n);
  }
  random() {
    const e = Math.random(),
      i = Math.sqrt(1 - e),
      n = Math.sqrt(e),
      r = 2 * Math.PI * Math.random(),
      s = 2 * Math.PI * Math.random();
    return this.set(
      i * Math.cos(r),
      n * Math.sin(s),
      n * Math.cos(s),
      i * Math.sin(r)
    );
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._w === this._w
    );
  }
  fromArray(e, i = 0) {
    return (
      (this._x = e[i]),
      (this._y = e[i + 1]),
      (this._z = e[i + 2]),
      (this._w = e[i + 3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(e = [], i = 0) {
    return (
      (e[i] = this._x),
      (e[i + 1] = this._y),
      (e[i + 2] = this._z),
      (e[i + 3] = this._w),
      e
    );
  }
  fromBufferAttribute(e, i) {
    return (
      (this._x = e.getX(i)),
      (this._y = e.getY(i)),
      (this._z = e.getZ(i)),
      (this._w = e.getW(i)),
      this
    );
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(e) {
    return (this._onChangeCallback = e), this;
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class A {
  constructor(e = 0, i = 0, n = 0) {
    (A.prototype.isVector3 = !0), (this.x = e), (this.y = i), (this.z = n);
  }
  set(e, i, n) {
    return (
      n === void 0 && (n = this.z),
      (this.x = e),
      (this.y = i),
      (this.z = n),
      this
    );
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), (this.z = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setZ(e) {
    return (this.z = e), this;
  }
  setComponent(e, i) {
    switch (e) {
      case 0:
        this.x = i;
        break;
      case 1:
        this.y = i;
        break;
      case 2:
        this.z = i;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return (this.x = e.x), (this.y = e.y), (this.z = e.z), this;
  }
  add(e) {
    return (this.x += e.x), (this.y += e.y), (this.z += e.z), this;
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), (this.z += e), this;
  }
  addVectors(e, i) {
    return (
      (this.x = e.x + i.x), (this.y = e.y + i.y), (this.z = e.z + i.z), this
    );
  }
  addScaledVector(e, i) {
    return (this.x += e.x * i), (this.y += e.y * i), (this.z += e.z * i), this;
  }
  sub(e) {
    return (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), this;
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), (this.z -= e), this;
  }
  subVectors(e, i) {
    return (
      (this.x = e.x - i.x), (this.y = e.y - i.y), (this.z = e.z - i.z), this
    );
  }
  multiply(e) {
    return (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), this;
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), (this.z *= e), this;
  }
  multiplyVectors(e, i) {
    return (
      (this.x = e.x * i.x), (this.y = e.y * i.y), (this.z = e.z * i.z), this
    );
  }
  applyEuler(e) {
    return this.applyQuaternion(Fm.setFromEuler(e));
  }
  applyAxisAngle(e, i) {
    return this.applyQuaternion(Fm.setFromAxisAngle(e, i));
  }
  applyMatrix3(e) {
    const i = this.x,
      n = this.y,
      r = this.z,
      s = e.elements;
    return (
      (this.x = s[0] * i + s[3] * n + s[6] * r),
      (this.y = s[1] * i + s[4] * n + s[7] * r),
      (this.z = s[2] * i + s[5] * n + s[8] * r),
      this
    );
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const i = this.x,
      n = this.y,
      r = this.z,
      s = e.elements,
      a = 1 / (s[3] * i + s[7] * n + s[11] * r + s[15]);
    return (
      (this.x = (s[0] * i + s[4] * n + s[8] * r + s[12]) * a),
      (this.y = (s[1] * i + s[5] * n + s[9] * r + s[13]) * a),
      (this.z = (s[2] * i + s[6] * n + s[10] * r + s[14]) * a),
      this
    );
  }
  applyQuaternion(e) {
    const i = this.x,
      n = this.y,
      r = this.z,
      s = e.x,
      a = e.y,
      o = e.z,
      l = e.w,
      c = l * i + a * r - o * n,
      d = l * n + o * i - s * r,
      h = l * r + s * n - a * i,
      u = -s * i - a * n - o * r;
    return (
      (this.x = c * l + u * -s + d * -o - h * -a),
      (this.y = d * l + u * -a + h * -s - c * -o),
      (this.z = h * l + u * -o + c * -a - d * -s),
      this
    );
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(
      e.projectionMatrix
    );
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(
      e.matrixWorld
    );
  }
  transformDirection(e) {
    const i = this.x,
      n = this.y,
      r = this.z,
      s = e.elements;
    return (
      (this.x = s[0] * i + s[4] * n + s[8] * r),
      (this.y = s[1] * i + s[5] * n + s[9] * r),
      (this.z = s[2] * i + s[6] * n + s[10] * r),
      this.normalize()
    );
  }
  divide(e) {
    return (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      this
    );
  }
  clamp(e, i) {
    return (
      (this.x = Math.max(e.x, Math.min(i.x, this.x))),
      (this.y = Math.max(e.y, Math.min(i.y, this.y))),
      (this.z = Math.max(e.z, Math.min(i.z, this.z))),
      this
    );
  }
  clampScalar(e, i) {
    return (
      (this.x = Math.max(e, Math.min(i, this.x))),
      (this.y = Math.max(e, Math.min(i, this.y))),
      (this.z = Math.max(e, Math.min(i, this.z))),
      this
    );
  }
  clampLength(e, i) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(
      Math.max(e, Math.min(i, n))
    );
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
      (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
      (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
      this
    );
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, i) {
    return (
      (this.x += (e.x - this.x) * i),
      (this.y += (e.y - this.y) * i),
      (this.z += (e.z - this.z) * i),
      this
    );
  }
  lerpVectors(e, i, n) {
    return (
      (this.x = e.x + (i.x - e.x) * n),
      (this.y = e.y + (i.y - e.y) * n),
      (this.z = e.z + (i.z - e.z) * n),
      this
    );
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, i) {
    const n = e.x,
      r = e.y,
      s = e.z,
      a = i.x,
      o = i.y,
      l = i.z;
    return (
      (this.x = r * l - s * o),
      (this.y = s * a - n * l),
      (this.z = n * o - r * a),
      this
    );
  }
  projectOnVector(e) {
    const i = e.lengthSq();
    if (i === 0) return this.set(0, 0, 0);
    const n = e.dot(this) / i;
    return this.copy(e).multiplyScalar(n);
  }
  projectOnPlane(e) {
    return su.copy(this).projectOnVector(e), this.sub(su);
  }
  reflect(e) {
    return this.sub(su.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const i = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (i === 0) return Math.PI / 2;
    const n = this.dot(e) / i;
    return Math.acos(yi(n, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const i = this.x - e.x,
      n = this.y - e.y,
      r = this.z - e.z;
    return i * i + n * n + r * r;
  }
  manhattanDistanceTo(e) {
    return (
      Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
    );
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, i, n) {
    const r = Math.sin(i) * e;
    return (
      (this.x = r * Math.sin(n)),
      (this.y = Math.cos(i) * e),
      (this.z = r * Math.cos(n)),
      this
    );
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, i, n) {
    return (
      (this.x = e * Math.sin(i)), (this.y = n), (this.z = e * Math.cos(i)), this
    );
  }
  setFromMatrixPosition(e) {
    const i = e.elements;
    return (this.x = i[12]), (this.y = i[13]), (this.z = i[14]), this;
  }
  setFromMatrixScale(e) {
    const i = this.setFromMatrixColumn(e, 0).length(),
      n = this.setFromMatrixColumn(e, 1).length(),
      r = this.setFromMatrixColumn(e, 2).length();
    return (this.x = i), (this.y = n), (this.z = r), this;
  }
  setFromMatrixColumn(e, i) {
    return this.fromArray(e.elements, i * 4);
  }
  setFromMatrix3Column(e, i) {
    return this.fromArray(e.elements, i * 3);
  }
  setFromEuler(e) {
    return (this.x = e._x), (this.y = e._y), (this.z = e._z), this;
  }
  setFromColor(e) {
    return (this.x = e.r), (this.y = e.g), (this.z = e.b), this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, i = 0) {
    return (this.x = e[i]), (this.y = e[i + 1]), (this.z = e[i + 2]), this;
  }
  toArray(e = [], i = 0) {
    return (e[i] = this.x), (e[i + 1] = this.y), (e[i + 2] = this.z), e;
  }
  fromBufferAttribute(e, i) {
    return (
      (this.x = e.getX(i)), (this.y = e.getY(i)), (this.z = e.getZ(i)), this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      this
    );
  }
  randomDirection() {
    const e = (Math.random() - 0.5) * 2,
      i = Math.random() * Math.PI * 2,
      n = Math.sqrt(1 - e ** 2);
    return (
      (this.x = n * Math.cos(i)), (this.y = n * Math.sin(i)), (this.z = e), this
    );
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const su = new A(),
  Fm = new Zs();
class An {
  constructor(
    e = new A(1 / 0, 1 / 0, 1 / 0),
    i = new A(-1 / 0, -1 / 0, -1 / 0)
  ) {
    (this.isBox3 = !0), (this.min = e), (this.max = i);
  }
  set(e, i) {
    return this.min.copy(e), this.max.copy(i), this;
  }
  setFromArray(e) {
    this.makeEmpty();
    for (let i = 0, n = e.length; i < n; i += 3)
      this.expandByPoint(vr.fromArray(e, i));
    return this;
  }
  setFromBufferAttribute(e) {
    this.makeEmpty();
    for (let i = 0, n = e.count; i < n; i++)
      this.expandByPoint(vr.fromBufferAttribute(e, i));
    return this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let i = 0, n = e.length; i < n; i++) this.expandByPoint(e[i]);
    return this;
  }
  setFromCenterAndSize(e, i) {
    const n = vr.copy(i).multiplyScalar(0.5);
    return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
  }
  setFromObject(e, i = !1) {
    return this.makeEmpty(), this.expandByObject(e, i);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = this.min.z = 1 / 0),
      (this.max.x = this.max.y = this.max.z = -1 / 0),
      this
    );
  }
  isEmpty() {
    return (
      this.max.x < this.min.x ||
      this.max.y < this.min.y ||
      this.max.z < this.min.z
    );
  }
  getCenter(e) {
    return this.isEmpty()
      ? e.set(0, 0, 0)
      : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  expandByObject(e, i = !1) {
    if ((e.updateWorldMatrix(!1, !1), e.boundingBox !== void 0))
      e.boundingBox === null && e.computeBoundingBox(),
        sa.copy(e.boundingBox),
        sa.applyMatrix4(e.matrixWorld),
        this.union(sa);
    else {
      const r = e.geometry;
      if (r !== void 0)
        if (i && r.attributes !== void 0 && r.attributes.position !== void 0) {
          const s = r.attributes.position;
          for (let a = 0, o = s.count; a < o; a++)
            vr.fromBufferAttribute(s, a).applyMatrix4(e.matrixWorld),
              this.expandByPoint(vr);
        } else
          r.boundingBox === null && r.computeBoundingBox(),
            sa.copy(r.boundingBox),
            sa.applyMatrix4(e.matrixWorld),
            this.union(sa);
    }
    const n = e.children;
    for (let r = 0, s = n.length; r < s; r++) this.expandByObject(n[r], i);
    return this;
  }
  containsPoint(e) {
    return !(
      e.x < this.min.x ||
      e.x > this.max.x ||
      e.y < this.min.y ||
      e.y > this.max.y ||
      e.z < this.min.z ||
      e.z > this.max.z
    );
  }
  containsBox(e) {
    return (
      this.min.x <= e.min.x &&
      e.max.x <= this.max.x &&
      this.min.y <= e.min.y &&
      e.max.y <= this.max.y &&
      this.min.z <= e.min.z &&
      e.max.z <= this.max.z
    );
  }
  getParameter(e, i) {
    return i.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(e) {
    return !(
      e.max.x < this.min.x ||
      e.min.x > this.max.x ||
      e.max.y < this.min.y ||
      e.min.y > this.max.y ||
      e.max.z < this.min.z ||
      e.min.z > this.max.z
    );
  }
  intersectsSphere(e) {
    return (
      this.clampPoint(e.center, vr),
      vr.distanceToSquared(e.center) <= e.radius * e.radius
    );
  }
  intersectsPlane(e) {
    let i, n;
    return (
      e.normal.x > 0
        ? ((i = e.normal.x * this.min.x), (n = e.normal.x * this.max.x))
        : ((i = e.normal.x * this.max.x), (n = e.normal.x * this.min.x)),
      e.normal.y > 0
        ? ((i += e.normal.y * this.min.y), (n += e.normal.y * this.max.y))
        : ((i += e.normal.y * this.max.y), (n += e.normal.y * this.min.y)),
      e.normal.z > 0
        ? ((i += e.normal.z * this.min.z), (n += e.normal.z * this.max.z))
        : ((i += e.normal.z * this.max.z), (n += e.normal.z * this.min.z)),
      i <= -e.constant && n >= -e.constant
    );
  }
  intersectsTriangle(e) {
    if (this.isEmpty()) return !1;
    this.getCenter(wo),
      Dl.subVectors(this.max, wo),
      aa.subVectors(e.a, wo),
      oa.subVectors(e.b, wo),
      la.subVectors(e.c, wo),
      kr.subVectors(oa, aa),
      Vr.subVectors(la, oa),
      ws.subVectors(aa, la);
    let i = [
      0,
      -kr.z,
      kr.y,
      0,
      -Vr.z,
      Vr.y,
      0,
      -ws.z,
      ws.y,
      kr.z,
      0,
      -kr.x,
      Vr.z,
      0,
      -Vr.x,
      ws.z,
      0,
      -ws.x,
      -kr.y,
      kr.x,
      0,
      -Vr.y,
      Vr.x,
      0,
      -ws.y,
      ws.x,
      0,
    ];
    return !au(i, aa, oa, la, Dl) ||
      ((i = [1, 0, 0, 0, 1, 0, 0, 0, 1]), !au(i, aa, oa, la, Dl))
      ? !1
      : (Rl.crossVectors(kr, Vr),
        (i = [Rl.x, Rl.y, Rl.z]),
        au(i, aa, oa, la, Dl));
  }
  clampPoint(e, i) {
    return i.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, vr).distanceTo(e);
  }
  getBoundingSphere(e) {
    return (
      this.isEmpty()
        ? e.makeEmpty()
        : (this.getCenter(e.center),
          (e.radius = this.getSize(vr).length() * 0.5)),
      e
    );
  }
  intersect(e) {
    return (
      this.min.max(e.min),
      this.max.min(e.max),
      this.isEmpty() && this.makeEmpty(),
      this
    );
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  applyMatrix4(e) {
    return this.isEmpty()
      ? this
      : (gr[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
        gr[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
        gr[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
        gr[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
        gr[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
        gr[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
        gr[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
        gr[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
        this.setFromPoints(gr),
        this);
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const gr = [
    new A(),
    new A(),
    new A(),
    new A(),
    new A(),
    new A(),
    new A(),
    new A(),
  ],
  vr = new A(),
  sa = new An(),
  aa = new A(),
  oa = new A(),
  la = new A(),
  kr = new A(),
  Vr = new A(),
  ws = new A(),
  wo = new A(),
  Dl = new A(),
  Rl = new A(),
  Ss = new A();
function au(t, e, i, n, r) {
  for (let s = 0, a = t.length - 3; s <= a; s += 3) {
    Ss.fromArray(t, s);
    const o =
        r.x * Math.abs(Ss.x) + r.y * Math.abs(Ss.y) + r.z * Math.abs(Ss.z),
      l = e.dot(Ss),
      c = i.dot(Ss),
      d = n.dot(Ss);
    if (Math.max(-Math.max(l, c, d), Math.min(l, c, d)) > o) return !1;
  }
  return !0;
}
const sS = new An(),
  So = new A(),
  ou = new A();
class Xn {
  constructor(e = new A(), i = -1) {
    (this.center = e), (this.radius = i);
  }
  set(e, i) {
    return this.center.copy(e), (this.radius = i), this;
  }
  setFromPoints(e, i) {
    const n = this.center;
    i !== void 0 ? n.copy(i) : sS.setFromPoints(e).getCenter(n);
    let r = 0;
    for (let s = 0, a = e.length; s < a; s++)
      r = Math.max(r, n.distanceToSquared(e[s]));
    return (this.radius = Math.sqrt(r)), this;
  }
  copy(e) {
    return this.center.copy(e.center), (this.radius = e.radius), this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), (this.radius = -1), this;
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const i = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= i * i;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, i) {
    const n = this.center.distanceToSquared(e);
    return (
      i.copy(e),
      n > this.radius * this.radius &&
        (i.sub(this.center).normalize(),
        i.multiplyScalar(this.radius).add(this.center)),
      i
    );
  }
  getBoundingBox(e) {
    return this.isEmpty()
      ? (e.makeEmpty(), e)
      : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return (
      this.center.applyMatrix4(e),
      (this.radius = this.radius * e.getMaxScaleOnAxis()),
      this
    );
  }
  translate(e) {
    return this.center.add(e), this;
  }
  expandByPoint(e) {
    if (this.isEmpty()) return this.center.copy(e), (this.radius = 0), this;
    So.subVectors(e, this.center);
    const i = So.lengthSq();
    if (i > this.radius * this.radius) {
      const n = Math.sqrt(i),
        r = (n - this.radius) * 0.5;
      this.center.addScaledVector(So, r / n), (this.radius += r);
    }
    return this;
  }
  union(e) {
    return e.isEmpty()
      ? this
      : this.isEmpty()
      ? (this.copy(e), this)
      : (this.center.equals(e.center) === !0
          ? (this.radius = Math.max(this.radius, e.radius))
          : (ou.subVectors(e.center, this.center).setLength(e.radius),
            this.expandByPoint(So.copy(e.center).add(ou)),
            this.expandByPoint(So.copy(e.center).sub(ou))),
        this);
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const yr = new A(),
  lu = new A(),
  Ol = new A(),
  Hr = new A(),
  cu = new A(),
  Il = new A(),
  hu = new A();
class oo {
  constructor(e = new A(), i = new A(0, 0, -1)) {
    (this.origin = e), (this.direction = i);
  }
  set(e, i) {
    return this.origin.copy(e), this.direction.copy(i), this;
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  at(e, i) {
    return i.copy(this.origin).addScaledVector(this.direction, e);
  }
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  recast(e) {
    return this.origin.copy(this.at(e, yr)), this;
  }
  closestPointToPoint(e, i) {
    i.subVectors(e, this.origin);
    const n = i.dot(this.direction);
    return n < 0
      ? i.copy(this.origin)
      : i.copy(this.origin).addScaledVector(this.direction, n);
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  distanceSqToPoint(e) {
    const i = yr.subVectors(e, this.origin).dot(this.direction);
    return i < 0
      ? this.origin.distanceToSquared(e)
      : (yr.copy(this.origin).addScaledVector(this.direction, i),
        yr.distanceToSquared(e));
  }
  distanceSqToSegment(e, i, n, r) {
    lu.copy(e).add(i).multiplyScalar(0.5),
      Ol.copy(i).sub(e).normalize(),
      Hr.copy(this.origin).sub(lu);
    const s = e.distanceTo(i) * 0.5,
      a = -this.direction.dot(Ol),
      o = Hr.dot(this.direction),
      l = -Hr.dot(Ol),
      c = Hr.lengthSq(),
      d = Math.abs(1 - a * a);
    let h, u, f, p;
    if (d > 0)
      if (((h = a * l - o), (u = a * o - l), (p = s * d), h >= 0))
        if (u >= -p)
          if (u <= p) {
            const v = 1 / d;
            (h *= v),
              (u *= v),
              (f = h * (h + a * u + 2 * o) + u * (a * h + u + 2 * l) + c);
          } else
            (u = s),
              (h = Math.max(0, -(a * u + o))),
              (f = -h * h + u * (u + 2 * l) + c);
        else
          (u = -s),
            (h = Math.max(0, -(a * u + o))),
            (f = -h * h + u * (u + 2 * l) + c);
      else
        u <= -p
          ? ((h = Math.max(0, -(-a * s + o))),
            (u = h > 0 ? -s : Math.min(Math.max(-s, -l), s)),
            (f = -h * h + u * (u + 2 * l) + c))
          : u <= p
          ? ((h = 0),
            (u = Math.min(Math.max(-s, -l), s)),
            (f = u * (u + 2 * l) + c))
          : ((h = Math.max(0, -(a * s + o))),
            (u = h > 0 ? s : Math.min(Math.max(-s, -l), s)),
            (f = -h * h + u * (u + 2 * l) + c));
    else
      (u = a > 0 ? -s : s),
        (h = Math.max(0, -(a * u + o))),
        (f = -h * h + u * (u + 2 * l) + c);
    return (
      n && n.copy(this.origin).addScaledVector(this.direction, h),
      r && r.copy(lu).addScaledVector(Ol, u),
      f
    );
  }
  intersectSphere(e, i) {
    yr.subVectors(e.center, this.origin);
    const n = yr.dot(this.direction),
      r = yr.dot(yr) - n * n,
      s = e.radius * e.radius;
    if (r > s) return null;
    const a = Math.sqrt(s - r),
      o = n - a,
      l = n + a;
    return l < 0 ? null : o < 0 ? this.at(l, i) : this.at(o, i);
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  distanceToPlane(e) {
    const i = e.normal.dot(this.direction);
    if (i === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const n = -(this.origin.dot(e.normal) + e.constant) / i;
    return n >= 0 ? n : null;
  }
  intersectPlane(e, i) {
    const n = this.distanceToPlane(e);
    return n === null ? null : this.at(n, i);
  }
  intersectsPlane(e) {
    const i = e.distanceToPoint(this.origin);
    return i === 0 || e.normal.dot(this.direction) * i < 0;
  }
  intersectBox(e, i) {
    let n, r, s, a, o, l;
    const c = 1 / this.direction.x,
      d = 1 / this.direction.y,
      h = 1 / this.direction.z,
      u = this.origin;
    return (
      c >= 0
        ? ((n = (e.min.x - u.x) * c), (r = (e.max.x - u.x) * c))
        : ((n = (e.max.x - u.x) * c), (r = (e.min.x - u.x) * c)),
      d >= 0
        ? ((s = (e.min.y - u.y) * d), (a = (e.max.y - u.y) * d))
        : ((s = (e.max.y - u.y) * d), (a = (e.min.y - u.y) * d)),
      n > a ||
      s > r ||
      ((s > n || isNaN(n)) && (n = s),
      (a < r || isNaN(r)) && (r = a),
      h >= 0
        ? ((o = (e.min.z - u.z) * h), (l = (e.max.z - u.z) * h))
        : ((o = (e.max.z - u.z) * h), (l = (e.min.z - u.z) * h)),
      n > l || o > r) ||
      ((o > n || n !== n) && (n = o), (l < r || r !== r) && (r = l), r < 0)
        ? null
        : this.at(n >= 0 ? n : r, i)
    );
  }
  intersectsBox(e) {
    return this.intersectBox(e, yr) !== null;
  }
  intersectTriangle(e, i, n, r, s) {
    cu.subVectors(i, e), Il.subVectors(n, e), hu.crossVectors(cu, Il);
    let a = this.direction.dot(hu),
      o;
    if (a > 0) {
      if (r) return null;
      o = 1;
    } else if (a < 0) (o = -1), (a = -a);
    else return null;
    Hr.subVectors(this.origin, e);
    const l = o * this.direction.dot(Il.crossVectors(Hr, Il));
    if (l < 0) return null;
    const c = o * this.direction.dot(cu.cross(Hr));
    if (c < 0 || l + c > a) return null;
    const d = -o * Hr.dot(hu);
    return d < 0 ? null : this.at(d / a, s);
  }
  applyMatrix4(e) {
    return (
      this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
    );
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class ze {
  constructor(e, i, n, r, s, a, o, l, c, d, h, u, f, p, v, g) {
    (ze.prototype.isMatrix4 = !0),
      (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
      e !== void 0 && this.set(e, i, n, r, s, a, o, l, c, d, h, u, f, p, v, g);
  }
  set(e, i, n, r, s, a, o, l, c, d, h, u, f, p, v, g) {
    const m = this.elements;
    return (
      (m[0] = e),
      (m[4] = i),
      (m[8] = n),
      (m[12] = r),
      (m[1] = s),
      (m[5] = a),
      (m[9] = o),
      (m[13] = l),
      (m[2] = c),
      (m[6] = d),
      (m[10] = h),
      (m[14] = u),
      (m[3] = f),
      (m[7] = p),
      (m[11] = v),
      (m[15] = g),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  clone() {
    return new ze().fromArray(this.elements);
  }
  copy(e) {
    const i = this.elements,
      n = e.elements;
    return (
      (i[0] = n[0]),
      (i[1] = n[1]),
      (i[2] = n[2]),
      (i[3] = n[3]),
      (i[4] = n[4]),
      (i[5] = n[5]),
      (i[6] = n[6]),
      (i[7] = n[7]),
      (i[8] = n[8]),
      (i[9] = n[9]),
      (i[10] = n[10]),
      (i[11] = n[11]),
      (i[12] = n[12]),
      (i[13] = n[13]),
      (i[14] = n[14]),
      (i[15] = n[15]),
      this
    );
  }
  copyPosition(e) {
    const i = this.elements,
      n = e.elements;
    return (i[12] = n[12]), (i[13] = n[13]), (i[14] = n[14]), this;
  }
  setFromMatrix3(e) {
    const i = e.elements;
    return (
      this.set(
        i[0],
        i[3],
        i[6],
        0,
        i[1],
        i[4],
        i[7],
        0,
        i[2],
        i[5],
        i[8],
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  extractBasis(e, i, n) {
    return (
      e.setFromMatrixColumn(this, 0),
      i.setFromMatrixColumn(this, 1),
      n.setFromMatrixColumn(this, 2),
      this
    );
  }
  makeBasis(e, i, n) {
    return (
      this.set(
        e.x,
        i.x,
        n.x,
        0,
        e.y,
        i.y,
        n.y,
        0,
        e.z,
        i.z,
        n.z,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  extractRotation(e) {
    const i = this.elements,
      n = e.elements,
      r = 1 / ca.setFromMatrixColumn(e, 0).length(),
      s = 1 / ca.setFromMatrixColumn(e, 1).length(),
      a = 1 / ca.setFromMatrixColumn(e, 2).length();
    return (
      (i[0] = n[0] * r),
      (i[1] = n[1] * r),
      (i[2] = n[2] * r),
      (i[3] = 0),
      (i[4] = n[4] * s),
      (i[5] = n[5] * s),
      (i[6] = n[6] * s),
      (i[7] = 0),
      (i[8] = n[8] * a),
      (i[9] = n[9] * a),
      (i[10] = n[10] * a),
      (i[11] = 0),
      (i[12] = 0),
      (i[13] = 0),
      (i[14] = 0),
      (i[15] = 1),
      this
    );
  }
  makeRotationFromEuler(e) {
    const i = this.elements,
      n = e.x,
      r = e.y,
      s = e.z,
      a = Math.cos(n),
      o = Math.sin(n),
      l = Math.cos(r),
      c = Math.sin(r),
      d = Math.cos(s),
      h = Math.sin(s);
    if (e.order === "XYZ") {
      const u = a * d,
        f = a * h,
        p = o * d,
        v = o * h;
      (i[0] = l * d),
        (i[4] = -l * h),
        (i[8] = c),
        (i[1] = f + p * c),
        (i[5] = u - v * c),
        (i[9] = -o * l),
        (i[2] = v - u * c),
        (i[6] = p + f * c),
        (i[10] = a * l);
    } else if (e.order === "YXZ") {
      const u = l * d,
        f = l * h,
        p = c * d,
        v = c * h;
      (i[0] = u + v * o),
        (i[4] = p * o - f),
        (i[8] = a * c),
        (i[1] = a * h),
        (i[5] = a * d),
        (i[9] = -o),
        (i[2] = f * o - p),
        (i[6] = v + u * o),
        (i[10] = a * l);
    } else if (e.order === "ZXY") {
      const u = l * d,
        f = l * h,
        p = c * d,
        v = c * h;
      (i[0] = u - v * o),
        (i[4] = -a * h),
        (i[8] = p + f * o),
        (i[1] = f + p * o),
        (i[5] = a * d),
        (i[9] = v - u * o),
        (i[2] = -a * c),
        (i[6] = o),
        (i[10] = a * l);
    } else if (e.order === "ZYX") {
      const u = a * d,
        f = a * h,
        p = o * d,
        v = o * h;
      (i[0] = l * d),
        (i[4] = p * c - f),
        (i[8] = u * c + v),
        (i[1] = l * h),
        (i[5] = v * c + u),
        (i[9] = f * c - p),
        (i[2] = -c),
        (i[6] = o * l),
        (i[10] = a * l);
    } else if (e.order === "YZX") {
      const u = a * l,
        f = a * c,
        p = o * l,
        v = o * c;
      (i[0] = l * d),
        (i[4] = v - u * h),
        (i[8] = p * h + f),
        (i[1] = h),
        (i[5] = a * d),
        (i[9] = -o * d),
        (i[2] = -c * d),
        (i[6] = f * h + p),
        (i[10] = u - v * h);
    } else if (e.order === "XZY") {
      const u = a * l,
        f = a * c,
        p = o * l,
        v = o * c;
      (i[0] = l * d),
        (i[4] = -h),
        (i[8] = c * d),
        (i[1] = u * h + v),
        (i[5] = a * d),
        (i[9] = f * h - p),
        (i[2] = p * h - f),
        (i[6] = o * d),
        (i[10] = v * h + u);
    }
    return (
      (i[3] = 0),
      (i[7] = 0),
      (i[11] = 0),
      (i[12] = 0),
      (i[13] = 0),
      (i[14] = 0),
      (i[15] = 1),
      this
    );
  }
  makeRotationFromQuaternion(e) {
    return this.compose(aS, e, oS);
  }
  lookAt(e, i, n) {
    const r = this.elements;
    return (
      ln.subVectors(e, i),
      ln.lengthSq() === 0 && (ln.z = 1),
      ln.normalize(),
      Gr.crossVectors(n, ln),
      Gr.lengthSq() === 0 &&
        (Math.abs(n.z) === 1 ? (ln.x += 1e-4) : (ln.z += 1e-4),
        ln.normalize(),
        Gr.crossVectors(n, ln)),
      Gr.normalize(),
      Ul.crossVectors(ln, Gr),
      (r[0] = Gr.x),
      (r[4] = Ul.x),
      (r[8] = ln.x),
      (r[1] = Gr.y),
      (r[5] = Ul.y),
      (r[9] = ln.y),
      (r[2] = Gr.z),
      (r[6] = Ul.z),
      (r[10] = ln.z),
      this
    );
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, i) {
    const n = e.elements,
      r = i.elements,
      s = this.elements,
      a = n[0],
      o = n[4],
      l = n[8],
      c = n[12],
      d = n[1],
      h = n[5],
      u = n[9],
      f = n[13],
      p = n[2],
      v = n[6],
      g = n[10],
      m = n[14],
      x = n[3],
      y = n[7],
      _ = n[11],
      M = n[15],
      b = r[0],
      E = r[4],
      T = r[8],
      S = r[12],
      w = r[1],
      C = r[5],
      L = r[9],
      P = r[13],
      R = r[2],
      I = r[6],
      W = r[10],
      N = r[14],
      U = r[3],
      G = r[7],
      k = r[11],
      B = r[15];
    return (
      (s[0] = a * b + o * w + l * R + c * U),
      (s[4] = a * E + o * C + l * I + c * G),
      (s[8] = a * T + o * L + l * W + c * k),
      (s[12] = a * S + o * P + l * N + c * B),
      (s[1] = d * b + h * w + u * R + f * U),
      (s[5] = d * E + h * C + u * I + f * G),
      (s[9] = d * T + h * L + u * W + f * k),
      (s[13] = d * S + h * P + u * N + f * B),
      (s[2] = p * b + v * w + g * R + m * U),
      (s[6] = p * E + v * C + g * I + m * G),
      (s[10] = p * T + v * L + g * W + m * k),
      (s[14] = p * S + v * P + g * N + m * B),
      (s[3] = x * b + y * w + _ * R + M * U),
      (s[7] = x * E + y * C + _ * I + M * G),
      (s[11] = x * T + y * L + _ * W + M * k),
      (s[15] = x * S + y * P + _ * N + M * B),
      this
    );
  }
  multiplyScalar(e) {
    const i = this.elements;
    return (
      (i[0] *= e),
      (i[4] *= e),
      (i[8] *= e),
      (i[12] *= e),
      (i[1] *= e),
      (i[5] *= e),
      (i[9] *= e),
      (i[13] *= e),
      (i[2] *= e),
      (i[6] *= e),
      (i[10] *= e),
      (i[14] *= e),
      (i[3] *= e),
      (i[7] *= e),
      (i[11] *= e),
      (i[15] *= e),
      this
    );
  }
  determinant() {
    const e = this.elements,
      i = e[0],
      n = e[4],
      r = e[8],
      s = e[12],
      a = e[1],
      o = e[5],
      l = e[9],
      c = e[13],
      d = e[2],
      h = e[6],
      u = e[10],
      f = e[14],
      p = e[3],
      v = e[7],
      g = e[11],
      m = e[15];
    return (
      p *
        (+s * l * h -
          r * c * h -
          s * o * u +
          n * c * u +
          r * o * f -
          n * l * f) +
      v *
        (+i * l * f -
          i * c * u +
          s * a * u -
          r * a * f +
          r * c * d -
          s * l * d) +
      g *
        (+i * c * h -
          i * o * f -
          s * a * h +
          n * a * f +
          s * o * d -
          n * c * d) +
      m *
        (-r * o * d - i * l * h + i * o * u + r * a * h - n * a * u + n * l * d)
    );
  }
  transpose() {
    const e = this.elements;
    let i;
    return (
      (i = e[1]),
      (e[1] = e[4]),
      (e[4] = i),
      (i = e[2]),
      (e[2] = e[8]),
      (e[8] = i),
      (i = e[6]),
      (e[6] = e[9]),
      (e[9] = i),
      (i = e[3]),
      (e[3] = e[12]),
      (e[12] = i),
      (i = e[7]),
      (e[7] = e[13]),
      (e[13] = i),
      (i = e[11]),
      (e[11] = e[14]),
      (e[14] = i),
      this
    );
  }
  setPosition(e, i, n) {
    const r = this.elements;
    return (
      e.isVector3
        ? ((r[12] = e.x), (r[13] = e.y), (r[14] = e.z))
        : ((r[12] = e), (r[13] = i), (r[14] = n)),
      this
    );
  }
  invert() {
    const e = this.elements,
      i = e[0],
      n = e[1],
      r = e[2],
      s = e[3],
      a = e[4],
      o = e[5],
      l = e[6],
      c = e[7],
      d = e[8],
      h = e[9],
      u = e[10],
      f = e[11],
      p = e[12],
      v = e[13],
      g = e[14],
      m = e[15],
      x = h * g * c - v * u * c + v * l * f - o * g * f - h * l * m + o * u * m,
      y = p * u * c - d * g * c - p * l * f + a * g * f + d * l * m - a * u * m,
      _ = d * v * c - p * h * c + p * o * f - a * v * f - d * o * m + a * h * m,
      M = p * h * l - d * v * l - p * o * u + a * v * u + d * o * g - a * h * g,
      b = i * x + n * y + r * _ + s * M;
    if (b === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const E = 1 / b;
    return (
      (e[0] = x * E),
      (e[1] =
        (v * u * s -
          h * g * s -
          v * r * f +
          n * g * f +
          h * r * m -
          n * u * m) *
        E),
      (e[2] =
        (o * g * s -
          v * l * s +
          v * r * c -
          n * g * c -
          o * r * m +
          n * l * m) *
        E),
      (e[3] =
        (h * l * s -
          o * u * s -
          h * r * c +
          n * u * c +
          o * r * f -
          n * l * f) *
        E),
      (e[4] = y * E),
      (e[5] =
        (d * g * s -
          p * u * s +
          p * r * f -
          i * g * f -
          d * r * m +
          i * u * m) *
        E),
      (e[6] =
        (p * l * s -
          a * g * s -
          p * r * c +
          i * g * c +
          a * r * m -
          i * l * m) *
        E),
      (e[7] =
        (a * u * s -
          d * l * s +
          d * r * c -
          i * u * c -
          a * r * f +
          i * l * f) *
        E),
      (e[8] = _ * E),
      (e[9] =
        (p * h * s -
          d * v * s -
          p * n * f +
          i * v * f +
          d * n * m -
          i * h * m) *
        E),
      (e[10] =
        (a * v * s -
          p * o * s +
          p * n * c -
          i * v * c -
          a * n * m +
          i * o * m) *
        E),
      (e[11] =
        (d * o * s -
          a * h * s -
          d * n * c +
          i * h * c +
          a * n * f -
          i * o * f) *
        E),
      (e[12] = M * E),
      (e[13] =
        (d * v * r -
          p * h * r +
          p * n * u -
          i * v * u -
          d * n * g +
          i * h * g) *
        E),
      (e[14] =
        (p * o * r -
          a * v * r -
          p * n * l +
          i * v * l +
          a * n * g -
          i * o * g) *
        E),
      (e[15] =
        (a * h * r -
          d * o * r +
          d * n * l -
          i * h * l -
          a * n * u +
          i * o * u) *
        E),
      this
    );
  }
  scale(e) {
    const i = this.elements,
      n = e.x,
      r = e.y,
      s = e.z;
    return (
      (i[0] *= n),
      (i[4] *= r),
      (i[8] *= s),
      (i[1] *= n),
      (i[5] *= r),
      (i[9] *= s),
      (i[2] *= n),
      (i[6] *= r),
      (i[10] *= s),
      (i[3] *= n),
      (i[7] *= r),
      (i[11] *= s),
      this
    );
  }
  getMaxScaleOnAxis() {
    const e = this.elements,
      i = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
      n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
      r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(i, n, r));
  }
  makeTranslation(e, i, n) {
    return (
      e.isVector3
        ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1)
        : this.set(1, 0, 0, e, 0, 1, 0, i, 0, 0, 1, n, 0, 0, 0, 1),
      this
    );
  }
  makeRotationX(e) {
    const i = Math.cos(e),
      n = Math.sin(e);
    return this.set(1, 0, 0, 0, 0, i, -n, 0, 0, n, i, 0, 0, 0, 0, 1), this;
  }
  makeRotationY(e) {
    const i = Math.cos(e),
      n = Math.sin(e);
    return this.set(i, 0, n, 0, 0, 1, 0, 0, -n, 0, i, 0, 0, 0, 0, 1), this;
  }
  makeRotationZ(e) {
    const i = Math.cos(e),
      n = Math.sin(e);
    return this.set(i, -n, 0, 0, n, i, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  makeRotationAxis(e, i) {
    const n = Math.cos(i),
      r = Math.sin(i),
      s = 1 - n,
      a = e.x,
      o = e.y,
      l = e.z,
      c = s * a,
      d = s * o;
    return (
      this.set(
        c * a + n,
        c * o - r * l,
        c * l + r * o,
        0,
        c * o + r * l,
        d * o + n,
        d * l - r * a,
        0,
        c * l - r * o,
        d * l + r * a,
        s * l * l + n,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  makeScale(e, i, n) {
    return this.set(e, 0, 0, 0, 0, i, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this;
  }
  makeShear(e, i, n, r, s, a) {
    return this.set(1, n, s, 0, e, 1, a, 0, i, r, 1, 0, 0, 0, 0, 1), this;
  }
  compose(e, i, n) {
    const r = this.elements,
      s = i._x,
      a = i._y,
      o = i._z,
      l = i._w,
      c = s + s,
      d = a + a,
      h = o + o,
      u = s * c,
      f = s * d,
      p = s * h,
      v = a * d,
      g = a * h,
      m = o * h,
      x = l * c,
      y = l * d,
      _ = l * h,
      M = n.x,
      b = n.y,
      E = n.z;
    return (
      (r[0] = (1 - (v + m)) * M),
      (r[1] = (f + _) * M),
      (r[2] = (p - y) * M),
      (r[3] = 0),
      (r[4] = (f - _) * b),
      (r[5] = (1 - (u + m)) * b),
      (r[6] = (g + x) * b),
      (r[7] = 0),
      (r[8] = (p + y) * E),
      (r[9] = (g - x) * E),
      (r[10] = (1 - (u + v)) * E),
      (r[11] = 0),
      (r[12] = e.x),
      (r[13] = e.y),
      (r[14] = e.z),
      (r[15] = 1),
      this
    );
  }
  decompose(e, i, n) {
    const r = this.elements;
    let s = ca.set(r[0], r[1], r[2]).length();
    const a = ca.set(r[4], r[5], r[6]).length(),
      o = ca.set(r[8], r[9], r[10]).length();
    this.determinant() < 0 && (s = -s),
      (e.x = r[12]),
      (e.y = r[13]),
      (e.z = r[14]),
      Dn.copy(this);
    const c = 1 / s,
      d = 1 / a,
      h = 1 / o;
    return (
      (Dn.elements[0] *= c),
      (Dn.elements[1] *= c),
      (Dn.elements[2] *= c),
      (Dn.elements[4] *= d),
      (Dn.elements[5] *= d),
      (Dn.elements[6] *= d),
      (Dn.elements[8] *= h),
      (Dn.elements[9] *= h),
      (Dn.elements[10] *= h),
      i.setFromRotationMatrix(Dn),
      (n.x = s),
      (n.y = a),
      (n.z = o),
      this
    );
  }
  makePerspective(e, i, n, r, s, a, o = Or) {
    const l = this.elements,
      c = (2 * s) / (i - e),
      d = (2 * s) / (n - r),
      h = (i + e) / (i - e),
      u = (n + r) / (n - r);
    let f, p;
    if (o === Or) (f = -(a + s) / (a - s)), (p = (-2 * a * s) / (a - s));
    else if (o === zc) (f = -a / (a - s)), (p = (-a * s) / (a - s));
    else
      throw new Error(
        "THREE.Matrix4.makePerspective(): Invalid coordinate system: " + o
      );
    return (
      (l[0] = c),
      (l[4] = 0),
      (l[8] = h),
      (l[12] = 0),
      (l[1] = 0),
      (l[5] = d),
      (l[9] = u),
      (l[13] = 0),
      (l[2] = 0),
      (l[6] = 0),
      (l[10] = f),
      (l[14] = p),
      (l[3] = 0),
      (l[7] = 0),
      (l[11] = -1),
      (l[15] = 0),
      this
    );
  }
  makeOrthographic(e, i, n, r, s, a, o = Or) {
    const l = this.elements,
      c = 1 / (i - e),
      d = 1 / (n - r),
      h = 1 / (a - s),
      u = (i + e) * c,
      f = (n + r) * d;
    let p, v;
    if (o === Or) (p = (a + s) * h), (v = -2 * h);
    else if (o === zc) (p = s * h), (v = -1 * h);
    else
      throw new Error(
        "THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + o
      );
    return (
      (l[0] = 2 * c),
      (l[4] = 0),
      (l[8] = 0),
      (l[12] = -u),
      (l[1] = 0),
      (l[5] = 2 * d),
      (l[9] = 0),
      (l[13] = -f),
      (l[2] = 0),
      (l[6] = 0),
      (l[10] = v),
      (l[14] = -p),
      (l[3] = 0),
      (l[7] = 0),
      (l[11] = 0),
      (l[15] = 1),
      this
    );
  }
  equals(e) {
    const i = this.elements,
      n = e.elements;
    for (let r = 0; r < 16; r++) if (i[r] !== n[r]) return !1;
    return !0;
  }
  fromArray(e, i = 0) {
    for (let n = 0; n < 16; n++) this.elements[n] = e[n + i];
    return this;
  }
  toArray(e = [], i = 0) {
    const n = this.elements;
    return (
      (e[i] = n[0]),
      (e[i + 1] = n[1]),
      (e[i + 2] = n[2]),
      (e[i + 3] = n[3]),
      (e[i + 4] = n[4]),
      (e[i + 5] = n[5]),
      (e[i + 6] = n[6]),
      (e[i + 7] = n[7]),
      (e[i + 8] = n[8]),
      (e[i + 9] = n[9]),
      (e[i + 10] = n[10]),
      (e[i + 11] = n[11]),
      (e[i + 12] = n[12]),
      (e[i + 13] = n[13]),
      (e[i + 14] = n[14]),
      (e[i + 15] = n[15]),
      e
    );
  }
}
const ca = new A(),
  Dn = new ze(),
  aS = new A(0, 0, 0),
  oS = new A(1, 1, 1),
  Gr = new A(),
  Ul = new A(),
  ln = new A(),
  km = new ze(),
  Vm = new Zs();
class as {
  constructor(e = 0, i = 0, n = 0, r = as.DEFAULT_ORDER) {
    (this.isEuler = !0),
      (this._x = e),
      (this._y = i),
      (this._z = n),
      (this._order = r);
  }
  get x() {
    return this._x;
  }
  set x(e) {
    (this._x = e), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    (this._y = e), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    (this._z = e), this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    (this._order = e), this._onChangeCallback();
  }
  set(e, i, n, r = this._order) {
    return (
      (this._x = e),
      (this._y = i),
      (this._z = n),
      (this._order = r),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return (
      (this._x = e._x),
      (this._y = e._y),
      (this._z = e._z),
      (this._order = e._order),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(e, i = this._order, n = !0) {
    const r = e.elements,
      s = r[0],
      a = r[4],
      o = r[8],
      l = r[1],
      c = r[5],
      d = r[9],
      h = r[2],
      u = r[6],
      f = r[10];
    switch (i) {
      case "XYZ":
        (this._y = Math.asin(yi(o, -1, 1))),
          Math.abs(o) < 0.9999999
            ? ((this._x = Math.atan2(-d, f)), (this._z = Math.atan2(-a, s)))
            : ((this._x = Math.atan2(u, c)), (this._z = 0));
        break;
      case "YXZ":
        (this._x = Math.asin(-yi(d, -1, 1))),
          Math.abs(d) < 0.9999999
            ? ((this._y = Math.atan2(o, f)), (this._z = Math.atan2(l, c)))
            : ((this._y = Math.atan2(-h, s)), (this._z = 0));
        break;
      case "ZXY":
        (this._x = Math.asin(yi(u, -1, 1))),
          Math.abs(u) < 0.9999999
            ? ((this._y = Math.atan2(-h, f)), (this._z = Math.atan2(-a, c)))
            : ((this._y = 0), (this._z = Math.atan2(l, s)));
        break;
      case "ZYX":
        (this._y = Math.asin(-yi(h, -1, 1))),
          Math.abs(h) < 0.9999999
            ? ((this._x = Math.atan2(u, f)), (this._z = Math.atan2(l, s)))
            : ((this._x = 0), (this._z = Math.atan2(-a, c)));
        break;
      case "YZX":
        (this._z = Math.asin(yi(l, -1, 1))),
          Math.abs(l) < 0.9999999
            ? ((this._x = Math.atan2(-d, c)), (this._y = Math.atan2(-h, s)))
            : ((this._x = 0), (this._y = Math.atan2(o, f)));
        break;
      case "XZY":
        (this._z = Math.asin(-yi(a, -1, 1))),
          Math.abs(a) < 0.9999999
            ? ((this._x = Math.atan2(u, c)), (this._y = Math.atan2(o, s)))
            : ((this._x = Math.atan2(-d, f)), (this._y = 0));
        break;
      default:
        console.warn(
          "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
            i
        );
    }
    return (this._order = i), n === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, i, n) {
    return (
      km.makeRotationFromQuaternion(e), this.setFromRotationMatrix(km, i, n)
    );
  }
  setFromVector3(e, i = this._order) {
    return this.set(e.x, e.y, e.z, i);
  }
  reorder(e) {
    return Vm.setFromEuler(this), this.setFromQuaternion(Vm, e);
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._order === this._order
    );
  }
  fromArray(e) {
    return (
      (this._x = e[0]),
      (this._y = e[1]),
      (this._z = e[2]),
      e[3] !== void 0 && (this._order = e[3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(e = [], i = 0) {
    return (
      (e[i] = this._x),
      (e[i + 1] = this._y),
      (e[i + 2] = this._z),
      (e[i + 3] = this._order),
      e
    );
  }
  _onChange(e) {
    return (this._onChangeCallback = e), this;
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
as.DEFAULT_ORDER = "XYZ";
class Vf {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = ((1 << e) | 0) >>> 0;
  }
  enable(e) {
    this.mask |= (1 << e) | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= (1 << e) | 0;
  }
  disable(e) {
    this.mask &= ~((1 << e) | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  isEnabled(e) {
    return (this.mask & ((1 << e) | 0)) !== 0;
  }
}
let lS = 0;
const Hm = new A(),
  ha = new Zs(),
  xr = new ze(),
  Nl = new A(),
  Mo = new A(),
  cS = new A(),
  hS = new Zs(),
  Gm = new A(1, 0, 0),
  jm = new A(0, 1, 0),
  Wm = new A(0, 0, 1),
  uS = { type: "added" },
  qm = { type: "removed" };
class Ht extends Ys {
  constructor() {
    super(),
      (this.isObject3D = !0),
      Object.defineProperty(this, "id", { value: lS++ }),
      (this.uuid = Gn()),
      (this.name = ""),
      (this.type = "Object3D"),
      (this.parent = null),
      (this.children = []),
      (this.up = Ht.DEFAULT_UP.clone());
    const e = new A(),
      i = new as(),
      n = new Zs(),
      r = new A(1, 1, 1);
    function s() {
      n.setFromEuler(i, !1);
    }
    function a() {
      i.setFromQuaternion(n, void 0, !1);
    }
    i._onChange(s),
      n._onChange(a),
      Object.defineProperties(this, {
        position: { configurable: !0, enumerable: !0, value: e },
        rotation: { configurable: !0, enumerable: !0, value: i },
        quaternion: { configurable: !0, enumerable: !0, value: n },
        scale: { configurable: !0, enumerable: !0, value: r },
        modelViewMatrix: { value: new ze() },
        normalMatrix: { value: new ft() },
      }),
      (this.matrix = new ze()),
      (this.matrixWorld = new ze()),
      (this.matrixAutoUpdate = Ht.DEFAULT_MATRIX_AUTO_UPDATE),
      (this.matrixWorldNeedsUpdate = !1),
      (this.matrixWorldAutoUpdate = Ht.DEFAULT_MATRIX_WORLD_AUTO_UPDATE),
      (this.layers = new Vf()),
      (this.visible = !0),
      (this.castShadow = !1),
      (this.receiveShadow = !1),
      (this.frustumCulled = !0),
      (this.renderOrder = 0),
      (this.animations = []),
      (this.userData = {});
  }
  onBeforeRender() {}
  onAfterRender() {}
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(),
      this.matrix.premultiply(e),
      this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, i) {
    this.quaternion.setFromAxisAngle(e, i);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, i) {
    return ha.setFromAxisAngle(e, i), this.quaternion.multiply(ha), this;
  }
  rotateOnWorldAxis(e, i) {
    return ha.setFromAxisAngle(e, i), this.quaternion.premultiply(ha), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(Gm, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(jm, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(Wm, e);
  }
  translateOnAxis(e, i) {
    return (
      Hm.copy(e).applyQuaternion(this.quaternion),
      this.position.add(Hm.multiplyScalar(i)),
      this
    );
  }
  translateX(e) {
    return this.translateOnAxis(Gm, e);
  }
  translateY(e) {
    return this.translateOnAxis(jm, e);
  }
  translateZ(e) {
    return this.translateOnAxis(Wm, e);
  }
  localToWorld(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      e.applyMatrix4(xr.copy(this.matrixWorld).invert())
    );
  }
  lookAt(e, i, n) {
    e.isVector3 ? Nl.copy(e) : Nl.set(e, i, n);
    const r = this.parent;
    this.updateWorldMatrix(!0, !1),
      Mo.setFromMatrixPosition(this.matrixWorld),
      this.isCamera || this.isLight
        ? xr.lookAt(Mo, Nl, this.up)
        : xr.lookAt(Nl, Mo, this.up),
      this.quaternion.setFromRotationMatrix(xr),
      r &&
        (xr.extractRotation(r.matrixWorld),
        ha.setFromRotationMatrix(xr),
        this.quaternion.premultiply(ha.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++) this.add(arguments[i]);
      return this;
    }
    return e === this
      ? (console.error(
          "THREE.Object3D.add: object can't be added as a child of itself.",
          e
        ),
        this)
      : (e && e.isObject3D
          ? (e.parent !== null && e.parent.remove(e),
            (e.parent = this),
            this.children.push(e),
            e.dispatchEvent(uS))
          : console.error(
              "THREE.Object3D.add: object not an instance of THREE.Object3D.",
              e
            ),
        this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let n = 0; n < arguments.length; n++) this.remove(arguments[n]);
      return this;
    }
    const i = this.children.indexOf(e);
    return (
      i !== -1 &&
        ((e.parent = null), this.children.splice(i, 1), e.dispatchEvent(qm)),
      this
    );
  }
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  clear() {
    for (let e = 0; e < this.children.length; e++) {
      const i = this.children[e];
      (i.parent = null), i.dispatchEvent(qm);
    }
    return (this.children.length = 0), this;
  }
  attach(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      xr.copy(this.matrixWorld).invert(),
      e.parent !== null &&
        (e.parent.updateWorldMatrix(!0, !1), xr.multiply(e.parent.matrixWorld)),
      e.applyMatrix4(xr),
      this.add(e),
      e.updateWorldMatrix(!1, !0),
      this
    );
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, i) {
    if (this[e] === i) return this;
    for (let n = 0, r = this.children.length; n < r; n++) {
      const a = this.children[n].getObjectByProperty(e, i);
      if (a !== void 0) return a;
    }
  }
  getObjectsByProperty(e, i) {
    let n = [];
    this[e] === i && n.push(this);
    for (let r = 0, s = this.children.length; r < s; r++) {
      const a = this.children[r].getObjectsByProperty(e, i);
      a.length > 0 && (n = n.concat(a));
    }
    return n;
  }
  getWorldPosition(e) {
    return (
      this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld)
    );
  }
  getWorldQuaternion(e) {
    return (
      this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Mo, e, cS), e
    );
  }
  getWorldScale(e) {
    return (
      this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Mo, hS, e), e
    );
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const i = this.matrixWorld.elements;
    return e.set(i[8], i[9], i[10]).normalize();
  }
  raycast() {}
  traverse(e) {
    e(this);
    const i = this.children;
    for (let n = 0, r = i.length; n < r; n++) i[n].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === !1) return;
    e(this);
    const i = this.children;
    for (let n = 0, r = i.length; n < r; n++) i[n].traverseVisible(e);
  }
  traverseAncestors(e) {
    const i = this.parent;
    i !== null && (e(i), i.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale),
      (this.matrixWorldNeedsUpdate = !0);
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(),
      (this.matrixWorldNeedsUpdate || e) &&
        (this.parent === null
          ? this.matrixWorld.copy(this.matrix)
          : this.matrixWorld.multiplyMatrices(
              this.parent.matrixWorld,
              this.matrix
            ),
        (this.matrixWorldNeedsUpdate = !1),
        (e = !0));
    const i = this.children;
    for (let n = 0, r = i.length; n < r; n++) {
      const s = i[n];
      (s.matrixWorldAutoUpdate === !0 || e === !0) && s.updateMatrixWorld(e);
    }
  }
  updateWorldMatrix(e, i) {
    const n = this.parent;
    if (
      (e === !0 &&
        n !== null &&
        n.matrixWorldAutoUpdate === !0 &&
        n.updateWorldMatrix(!0, !1),
      this.matrixAutoUpdate && this.updateMatrix(),
      this.parent === null
        ? this.matrixWorld.copy(this.matrix)
        : this.matrixWorld.multiplyMatrices(
            this.parent.matrixWorld,
            this.matrix
          ),
      i === !0)
    ) {
      const r = this.children;
      for (let s = 0, a = r.length; s < a; s++) {
        const o = r[s];
        o.matrixWorldAutoUpdate === !0 && o.updateWorldMatrix(!1, !0);
      }
    }
  }
  toJSON(e) {
    const i = e === void 0 || typeof e == "string",
      n = {};
    i &&
      ((e = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
        nodes: {},
      }),
      (n.metadata = {
        version: 4.6,
        type: "Object",
        generator: "Object3D.toJSON",
      }));
    const r = {};
    (r.uuid = this.uuid),
      (r.type = this.type),
      this.name !== "" && (r.name = this.name),
      this.castShadow === !0 && (r.castShadow = !0),
      this.receiveShadow === !0 && (r.receiveShadow = !0),
      this.visible === !1 && (r.visible = !1),
      this.frustumCulled === !1 && (r.frustumCulled = !1),
      this.renderOrder !== 0 && (r.renderOrder = this.renderOrder),
      Object.keys(this.userData).length > 0 && (r.userData = this.userData),
      (r.layers = this.layers.mask),
      (r.matrix = this.matrix.toArray()),
      (r.up = this.up.toArray()),
      this.matrixAutoUpdate === !1 && (r.matrixAutoUpdate = !1),
      this.isInstancedMesh &&
        ((r.type = "InstancedMesh"),
        (r.count = this.count),
        (r.instanceMatrix = this.instanceMatrix.toJSON()),
        this.instanceColor !== null &&
          (r.instanceColor = this.instanceColor.toJSON()));
    function s(o, l) {
      return o[l.uuid] === void 0 && (o[l.uuid] = l.toJSON(e)), l.uuid;
    }
    if (this.isScene)
      this.background &&
        (this.background.isColor
          ? (r.background = this.background.toJSON())
          : this.background.isTexture &&
            (r.background = this.background.toJSON(e).uuid)),
        this.environment &&
          this.environment.isTexture &&
          this.environment.isRenderTargetTexture !== !0 &&
          (r.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      r.geometry = s(e.geometries, this.geometry);
      const o = this.geometry.parameters;
      if (o !== void 0 && o.shapes !== void 0) {
        const l = o.shapes;
        if (Array.isArray(l))
          for (let c = 0, d = l.length; c < d; c++) {
            const h = l[c];
            s(e.shapes, h);
          }
        else s(e.shapes, l);
      }
    }
    if (
      (this.isSkinnedMesh &&
        ((r.bindMode = this.bindMode),
        (r.bindMatrix = this.bindMatrix.toArray()),
        this.skeleton !== void 0 &&
          (s(e.skeletons, this.skeleton), (r.skeleton = this.skeleton.uuid))),
      this.material !== void 0)
    )
      if (Array.isArray(this.material)) {
        const o = [];
        for (let l = 0, c = this.material.length; l < c; l++)
          o.push(s(e.materials, this.material[l]));
        r.material = o;
      } else r.material = s(e.materials, this.material);
    if (this.children.length > 0) {
      r.children = [];
      for (let o = 0; o < this.children.length; o++)
        r.children.push(this.children[o].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      r.animations = [];
      for (let o = 0; o < this.animations.length; o++) {
        const l = this.animations[o];
        r.animations.push(s(e.animations, l));
      }
    }
    if (i) {
      const o = a(e.geometries),
        l = a(e.materials),
        c = a(e.textures),
        d = a(e.images),
        h = a(e.shapes),
        u = a(e.skeletons),
        f = a(e.animations),
        p = a(e.nodes);
      o.length > 0 && (n.geometries = o),
        l.length > 0 && (n.materials = l),
        c.length > 0 && (n.textures = c),
        d.length > 0 && (n.images = d),
        h.length > 0 && (n.shapes = h),
        u.length > 0 && (n.skeletons = u),
        f.length > 0 && (n.animations = f),
        p.length > 0 && (n.nodes = p);
    }
    return (n.object = r), n;
    function a(o) {
      const l = [];
      for (const c in o) {
        const d = o[c];
        delete d.metadata, l.push(d);
      }
      return l;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, i = !0) {
    if (
      ((this.name = e.name),
      this.up.copy(e.up),
      this.position.copy(e.position),
      (this.rotation.order = e.rotation.order),
      this.quaternion.copy(e.quaternion),
      this.scale.copy(e.scale),
      this.matrix.copy(e.matrix),
      this.matrixWorld.copy(e.matrixWorld),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      (this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate),
      (this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate),
      (this.layers.mask = e.layers.mask),
      (this.visible = e.visible),
      (this.castShadow = e.castShadow),
      (this.receiveShadow = e.receiveShadow),
      (this.frustumCulled = e.frustumCulled),
      (this.renderOrder = e.renderOrder),
      (this.animations = e.animations),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      i === !0)
    )
      for (let n = 0; n < e.children.length; n++) {
        const r = e.children[n];
        this.add(r.clone());
      }
    return this;
  }
}
Ht.DEFAULT_UP = new A(0, 1, 0);
Ht.DEFAULT_MATRIX_AUTO_UPDATE = !0;
Ht.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const Rn = new A(),
  _r = new A(),
  uu = new A(),
  br = new A(),
  ua = new A(),
  da = new A(),
  Xm = new A(),
  du = new A(),
  fu = new A(),
  pu = new A();
let zl = !1;
class Ki {
  constructor(e = new A(), i = new A(), n = new A()) {
    (this.a = e), (this.b = i), (this.c = n);
  }
  static getNormal(e, i, n, r) {
    r.subVectors(n, i), Rn.subVectors(e, i), r.cross(Rn);
    const s = r.lengthSq();
    return s > 0 ? r.multiplyScalar(1 / Math.sqrt(s)) : r.set(0, 0, 0);
  }
  static getBarycoord(e, i, n, r, s) {
    Rn.subVectors(r, i), _r.subVectors(n, i), uu.subVectors(e, i);
    const a = Rn.dot(Rn),
      o = Rn.dot(_r),
      l = Rn.dot(uu),
      c = _r.dot(_r),
      d = _r.dot(uu),
      h = a * c - o * o;
    if (h === 0) return s.set(-2, -1, -1);
    const u = 1 / h,
      f = (c * l - o * d) * u,
      p = (a * d - o * l) * u;
    return s.set(1 - f - p, p, f);
  }
  static containsPoint(e, i, n, r) {
    return (
      this.getBarycoord(e, i, n, r, br),
      br.x >= 0 && br.y >= 0 && br.x + br.y <= 1
    );
  }
  static getUV(e, i, n, r, s, a, o, l) {
    return (
      zl === !1 &&
        (console.warn(
          "THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."
        ),
        (zl = !0)),
      this.getInterpolation(e, i, n, r, s, a, o, l)
    );
  }
  static getInterpolation(e, i, n, r, s, a, o, l) {
    return (
      this.getBarycoord(e, i, n, r, br),
      l.setScalar(0),
      l.addScaledVector(s, br.x),
      l.addScaledVector(a, br.y),
      l.addScaledVector(o, br.z),
      l
    );
  }
  static isFrontFacing(e, i, n, r) {
    return Rn.subVectors(n, i), _r.subVectors(e, i), Rn.cross(_r).dot(r) < 0;
  }
  set(e, i, n) {
    return this.a.copy(e), this.b.copy(i), this.c.copy(n), this;
  }
  setFromPointsAndIndices(e, i, n, r) {
    return this.a.copy(e[i]), this.b.copy(e[n]), this.c.copy(e[r]), this;
  }
  setFromAttributeAndIndices(e, i, n, r) {
    return (
      this.a.fromBufferAttribute(e, i),
      this.b.fromBufferAttribute(e, n),
      this.c.fromBufferAttribute(e, r),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return (
      Rn.subVectors(this.c, this.b),
      _r.subVectors(this.a, this.b),
      Rn.cross(_r).length() * 0.5
    );
  }
  getMidpoint(e) {
    return e
      .addVectors(this.a, this.b)
      .add(this.c)
      .multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return Ki.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, i) {
    return Ki.getBarycoord(e, this.a, this.b, this.c, i);
  }
  getUV(e, i, n, r, s) {
    return (
      zl === !1 &&
        (console.warn(
          "THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."
        ),
        (zl = !0)),
      Ki.getInterpolation(e, this.a, this.b, this.c, i, n, r, s)
    );
  }
  getInterpolation(e, i, n, r, s) {
    return Ki.getInterpolation(e, this.a, this.b, this.c, i, n, r, s);
  }
  containsPoint(e) {
    return Ki.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return Ki.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, i) {
    const n = this.a,
      r = this.b,
      s = this.c;
    let a, o;
    ua.subVectors(r, n), da.subVectors(s, n), du.subVectors(e, n);
    const l = ua.dot(du),
      c = da.dot(du);
    if (l <= 0 && c <= 0) return i.copy(n);
    fu.subVectors(e, r);
    const d = ua.dot(fu),
      h = da.dot(fu);
    if (d >= 0 && h <= d) return i.copy(r);
    const u = l * h - d * c;
    if (u <= 0 && l >= 0 && d <= 0)
      return (a = l / (l - d)), i.copy(n).addScaledVector(ua, a);
    pu.subVectors(e, s);
    const f = ua.dot(pu),
      p = da.dot(pu);
    if (p >= 0 && f <= p) return i.copy(s);
    const v = f * c - l * p;
    if (v <= 0 && c >= 0 && p <= 0)
      return (o = c / (c - p)), i.copy(n).addScaledVector(da, o);
    const g = d * p - f * h;
    if (g <= 0 && h - d >= 0 && f - p >= 0)
      return (
        Xm.subVectors(s, r),
        (o = (h - d) / (h - d + (f - p))),
        i.copy(r).addScaledVector(Xm, o)
      );
    const m = 1 / (g + v + u);
    return (
      (a = v * m),
      (o = u * m),
      i.copy(n).addScaledVector(ua, a).addScaledVector(da, o)
    );
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
let dS = 0;
class lo extends Ys {
  constructor() {
    super(),
      (this.isMaterial = !0),
      Object.defineProperty(this, "id", { value: dS++ }),
      (this.uuid = Gn()),
      (this.name = ""),
      (this.type = "Material"),
      (this.blending = Ua),
      (this.side = ds),
      (this.vertexColors = !1),
      (this.opacity = 1),
      (this.transparent = !1),
      (this.alphaHash = !1),
      (this.blendSrc = ky),
      (this.blendDst = Vy),
      (this.blendEquation = Xr),
      (this.blendSrcAlpha = null),
      (this.blendDstAlpha = null),
      (this.blendEquationAlpha = null),
      (this.depthFunc = fd),
      (this.depthTest = !0),
      (this.depthWrite = !0),
      (this.stencilWriteMask = 255),
      (this.stencilFunc = Aw),
      (this.stencilRef = 0),
      (this.stencilFuncMask = 255),
      (this.stencilFail = tu),
      (this.stencilZFail = tu),
      (this.stencilZPass = tu),
      (this.stencilWrite = !1),
      (this.clippingPlanes = null),
      (this.clipIntersection = !1),
      (this.clipShadows = !1),
      (this.shadowSide = null),
      (this.colorWrite = !0),
      (this.precision = null),
      (this.polygonOffset = !1),
      (this.polygonOffsetFactor = 0),
      (this.polygonOffsetUnits = 0),
      (this.dithering = !1),
      (this.alphaToCoverage = !1),
      (this.premultipliedAlpha = !1),
      (this.forceSinglePass = !1),
      (this.visible = !0),
      (this.toneMapped = !0),
      (this.userData = {}),
      (this.version = 0),
      (this._alphaTest = 0);
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(e) {
    this._alphaTest > 0 != e > 0 && this.version++, (this._alphaTest = e);
  }
  onBuild() {}
  onBeforeRender() {}
  onBeforeCompile() {}
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(e) {
    if (e !== void 0)
      for (const i in e) {
        const n = e[i];
        if (n === void 0) {
          console.warn(
            `THREE.Material: parameter '${i}' has value of undefined.`
          );
          continue;
        }
        const r = this[i];
        if (r === void 0) {
          console.warn(
            `THREE.Material: '${i}' is not a property of THREE.${this.type}.`
          );
          continue;
        }
        r && r.isColor
          ? r.set(n)
          : r && r.isVector3 && n && n.isVector3
          ? r.copy(n)
          : (this[i] = n);
      }
  }
  toJSON(e) {
    const i = e === void 0 || typeof e == "string";
    i && (e = { textures: {}, images: {} });
    const n = {
      metadata: {
        version: 4.6,
        type: "Material",
        generator: "Material.toJSON",
      },
    };
    (n.uuid = this.uuid),
      (n.type = this.type),
      this.name !== "" && (n.name = this.name),
      this.color && this.color.isColor && (n.color = this.color.getHex()),
      this.roughness !== void 0 && (n.roughness = this.roughness),
      this.metalness !== void 0 && (n.metalness = this.metalness),
      this.sheen !== void 0 && (n.sheen = this.sheen),
      this.sheenColor &&
        this.sheenColor.isColor &&
        (n.sheenColor = this.sheenColor.getHex()),
      this.sheenRoughness !== void 0 &&
        (n.sheenRoughness = this.sheenRoughness),
      this.emissive &&
        this.emissive.isColor &&
        (n.emissive = this.emissive.getHex()),
      this.emissiveIntensity &&
        this.emissiveIntensity !== 1 &&
        (n.emissiveIntensity = this.emissiveIntensity),
      this.specular &&
        this.specular.isColor &&
        (n.specular = this.specular.getHex()),
      this.specularIntensity !== void 0 &&
        (n.specularIntensity = this.specularIntensity),
      this.specularColor &&
        this.specularColor.isColor &&
        (n.specularColor = this.specularColor.getHex()),
      this.shininess !== void 0 && (n.shininess = this.shininess),
      this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat),
      this.clearcoatRoughness !== void 0 &&
        (n.clearcoatRoughness = this.clearcoatRoughness),
      this.clearcoatMap &&
        this.clearcoatMap.isTexture &&
        (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
      this.clearcoatRoughnessMap &&
        this.clearcoatRoughnessMap.isTexture &&
        (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
      this.clearcoatNormalMap &&
        this.clearcoatNormalMap.isTexture &&
        ((n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid),
        (n.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
      this.iridescence !== void 0 && (n.iridescence = this.iridescence),
      this.iridescenceIOR !== void 0 &&
        (n.iridescenceIOR = this.iridescenceIOR),
      this.iridescenceThicknessRange !== void 0 &&
        (n.iridescenceThicknessRange = this.iridescenceThicknessRange),
      this.iridescenceMap &&
        this.iridescenceMap.isTexture &&
        (n.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
      this.iridescenceThicknessMap &&
        this.iridescenceThicknessMap.isTexture &&
        (n.iridescenceThicknessMap =
          this.iridescenceThicknessMap.toJSON(e).uuid),
      this.anisotropy !== void 0 && (n.anisotropy = this.anisotropy),
      this.anisotropyRotation !== void 0 &&
        (n.anisotropyRotation = this.anisotropyRotation),
      this.anisotropyMap &&
        this.anisotropyMap.isTexture &&
        (n.anisotropyMap = this.anisotropyMap.toJSON(e).uuid),
      this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid),
      this.matcap &&
        this.matcap.isTexture &&
        (n.matcap = this.matcap.toJSON(e).uuid),
      this.alphaMap &&
        this.alphaMap.isTexture &&
        (n.alphaMap = this.alphaMap.toJSON(e).uuid),
      this.lightMap &&
        this.lightMap.isTexture &&
        ((n.lightMap = this.lightMap.toJSON(e).uuid),
        (n.lightMapIntensity = this.lightMapIntensity)),
      this.aoMap &&
        this.aoMap.isTexture &&
        ((n.aoMap = this.aoMap.toJSON(e).uuid),
        (n.aoMapIntensity = this.aoMapIntensity)),
      this.bumpMap &&
        this.bumpMap.isTexture &&
        ((n.bumpMap = this.bumpMap.toJSON(e).uuid),
        (n.bumpScale = this.bumpScale)),
      this.normalMap &&
        this.normalMap.isTexture &&
        ((n.normalMap = this.normalMap.toJSON(e).uuid),
        (n.normalMapType = this.normalMapType),
        (n.normalScale = this.normalScale.toArray())),
      this.displacementMap &&
        this.displacementMap.isTexture &&
        ((n.displacementMap = this.displacementMap.toJSON(e).uuid),
        (n.displacementScale = this.displacementScale),
        (n.displacementBias = this.displacementBias)),
      this.roughnessMap &&
        this.roughnessMap.isTexture &&
        (n.roughnessMap = this.roughnessMap.toJSON(e).uuid),
      this.metalnessMap &&
        this.metalnessMap.isTexture &&
        (n.metalnessMap = this.metalnessMap.toJSON(e).uuid),
      this.emissiveMap &&
        this.emissiveMap.isTexture &&
        (n.emissiveMap = this.emissiveMap.toJSON(e).uuid),
      this.specularMap &&
        this.specularMap.isTexture &&
        (n.specularMap = this.specularMap.toJSON(e).uuid),
      this.specularIntensityMap &&
        this.specularIntensityMap.isTexture &&
        (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
      this.specularColorMap &&
        this.specularColorMap.isTexture &&
        (n.specularColorMap = this.specularColorMap.toJSON(e).uuid),
      this.envMap &&
        this.envMap.isTexture &&
        ((n.envMap = this.envMap.toJSON(e).uuid),
        this.combine !== void 0 && (n.combine = this.combine)),
      this.envMapIntensity !== void 0 &&
        (n.envMapIntensity = this.envMapIntensity),
      this.reflectivity !== void 0 && (n.reflectivity = this.reflectivity),
      this.refractionRatio !== void 0 &&
        (n.refractionRatio = this.refractionRatio),
      this.gradientMap &&
        this.gradientMap.isTexture &&
        (n.gradientMap = this.gradientMap.toJSON(e).uuid),
      this.transmission !== void 0 && (n.transmission = this.transmission),
      this.transmissionMap &&
        this.transmissionMap.isTexture &&
        (n.transmissionMap = this.transmissionMap.toJSON(e).uuid),
      this.thickness !== void 0 && (n.thickness = this.thickness),
      this.thicknessMap &&
        this.thicknessMap.isTexture &&
        (n.thicknessMap = this.thicknessMap.toJSON(e).uuid),
      this.attenuationDistance !== void 0 &&
        this.attenuationDistance !== 1 / 0 &&
        (n.attenuationDistance = this.attenuationDistance),
      this.attenuationColor !== void 0 &&
        (n.attenuationColor = this.attenuationColor.getHex()),
      this.size !== void 0 && (n.size = this.size),
      this.shadowSide !== null && (n.shadowSide = this.shadowSide),
      this.sizeAttenuation !== void 0 &&
        (n.sizeAttenuation = this.sizeAttenuation),
      this.blending !== Ua && (n.blending = this.blending),
      this.side !== ds && (n.side = this.side),
      this.vertexColors && (n.vertexColors = !0),
      this.opacity < 1 && (n.opacity = this.opacity),
      this.transparent === !0 && (n.transparent = this.transparent),
      (n.depthFunc = this.depthFunc),
      (n.depthTest = this.depthTest),
      (n.depthWrite = this.depthWrite),
      (n.colorWrite = this.colorWrite),
      (n.stencilWrite = this.stencilWrite),
      (n.stencilWriteMask = this.stencilWriteMask),
      (n.stencilFunc = this.stencilFunc),
      (n.stencilRef = this.stencilRef),
      (n.stencilFuncMask = this.stencilFuncMask),
      (n.stencilFail = this.stencilFail),
      (n.stencilZFail = this.stencilZFail),
      (n.stencilZPass = this.stencilZPass),
      this.rotation !== void 0 &&
        this.rotation !== 0 &&
        (n.rotation = this.rotation),
      this.polygonOffset === !0 && (n.polygonOffset = !0),
      this.polygonOffsetFactor !== 0 &&
        (n.polygonOffsetFactor = this.polygonOffsetFactor),
      this.polygonOffsetUnits !== 0 &&
        (n.polygonOffsetUnits = this.polygonOffsetUnits),
      this.linewidth !== void 0 &&
        this.linewidth !== 1 &&
        (n.linewidth = this.linewidth),
      this.dashSize !== void 0 && (n.dashSize = this.dashSize),
      this.gapSize !== void 0 && (n.gapSize = this.gapSize),
      this.scale !== void 0 && (n.scale = this.scale),
      this.dithering === !0 && (n.dithering = !0),
      this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
      this.alphaHash === !0 && (n.alphaHash = this.alphaHash),
      this.alphaToCoverage === !0 && (n.alphaToCoverage = this.alphaToCoverage),
      this.premultipliedAlpha === !0 &&
        (n.premultipliedAlpha = this.premultipliedAlpha),
      this.forceSinglePass === !0 && (n.forceSinglePass = this.forceSinglePass),
      this.wireframe === !0 && (n.wireframe = this.wireframe),
      this.wireframeLinewidth > 1 &&
        (n.wireframeLinewidth = this.wireframeLinewidth),
      this.wireframeLinecap !== "round" &&
        (n.wireframeLinecap = this.wireframeLinecap),
      this.wireframeLinejoin !== "round" &&
        (n.wireframeLinejoin = this.wireframeLinejoin),
      this.flatShading === !0 && (n.flatShading = this.flatShading),
      this.visible === !1 && (n.visible = !1),
      this.toneMapped === !1 && (n.toneMapped = !1),
      this.fog === !1 && (n.fog = !1),
      Object.keys(this.userData).length > 0 && (n.userData = this.userData);
    function r(s) {
      const a = [];
      for (const o in s) {
        const l = s[o];
        delete l.metadata, a.push(l);
      }
      return a;
    }
    if (i) {
      const s = r(e.textures),
        a = r(e.images);
      s.length > 0 && (n.textures = s), a.length > 0 && (n.images = a);
    }
    return n;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.name = e.name),
      (this.blending = e.blending),
      (this.side = e.side),
      (this.vertexColors = e.vertexColors),
      (this.opacity = e.opacity),
      (this.transparent = e.transparent),
      (this.blendSrc = e.blendSrc),
      (this.blendDst = e.blendDst),
      (this.blendEquation = e.blendEquation),
      (this.blendSrcAlpha = e.blendSrcAlpha),
      (this.blendDstAlpha = e.blendDstAlpha),
      (this.blendEquationAlpha = e.blendEquationAlpha),
      (this.depthFunc = e.depthFunc),
      (this.depthTest = e.depthTest),
      (this.depthWrite = e.depthWrite),
      (this.stencilWriteMask = e.stencilWriteMask),
      (this.stencilFunc = e.stencilFunc),
      (this.stencilRef = e.stencilRef),
      (this.stencilFuncMask = e.stencilFuncMask),
      (this.stencilFail = e.stencilFail),
      (this.stencilZFail = e.stencilZFail),
      (this.stencilZPass = e.stencilZPass),
      (this.stencilWrite = e.stencilWrite);
    const i = e.clippingPlanes;
    let n = null;
    if (i !== null) {
      const r = i.length;
      n = new Array(r);
      for (let s = 0; s !== r; ++s) n[s] = i[s].clone();
    }
    return (
      (this.clippingPlanes = n),
      (this.clipIntersection = e.clipIntersection),
      (this.clipShadows = e.clipShadows),
      (this.shadowSide = e.shadowSide),
      (this.colorWrite = e.colorWrite),
      (this.precision = e.precision),
      (this.polygonOffset = e.polygonOffset),
      (this.polygonOffsetFactor = e.polygonOffsetFactor),
      (this.polygonOffsetUnits = e.polygonOffsetUnits),
      (this.dithering = e.dithering),
      (this.alphaTest = e.alphaTest),
      (this.alphaHash = e.alphaHash),
      (this.alphaToCoverage = e.alphaToCoverage),
      (this.premultipliedAlpha = e.premultipliedAlpha),
      (this.forceSinglePass = e.forceSinglePass),
      (this.visible = e.visible),
      (this.toneMapped = e.toneMapped),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
}
const ox = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074,
  },
  On = { h: 0, s: 0, l: 0 },
  Bl = { h: 0, s: 0, l: 0 };
function mu(t, e, i) {
  return (
    i < 0 && (i += 1),
    i > 1 && (i -= 1),
    i < 1 / 6
      ? t + (e - t) * 6 * i
      : i < 1 / 2
      ? e
      : i < 2 / 3
      ? t + (e - t) * 6 * (2 / 3 - i)
      : t
  );
}
class tt {
  constructor(e, i, n) {
    return (
      (this.isColor = !0),
      (this.r = 1),
      (this.g = 1),
      (this.b = 1),
      this.set(e, i, n)
    );
  }
  set(e, i, n) {
    if (i === void 0 && n === void 0) {
      const r = e;
      r && r.isColor
        ? this.copy(r)
        : typeof r == "number"
        ? this.setHex(r)
        : typeof r == "string" && this.setStyle(r);
    } else this.setRGB(e, i, n);
    return this;
  }
  setScalar(e) {
    return (this.r = e), (this.g = e), (this.b = e), this;
  }
  setHex(e, i = gt) {
    return (
      (e = Math.floor(e)),
      (this.r = ((e >> 16) & 255) / 255),
      (this.g = ((e >> 8) & 255) / 255),
      (this.b = (e & 255) / 255),
      Ln.toWorkingColorSpace(this, i),
      this
    );
  }
  setRGB(e, i, n, r = Ln.workingColorSpace) {
    return (
      (this.r = e),
      (this.g = i),
      (this.b = n),
      Ln.toWorkingColorSpace(this, r),
      this
    );
  }
  setHSL(e, i, n, r = Ln.workingColorSpace) {
    if (((e = kf(e, 1)), (i = yi(i, 0, 1)), (n = yi(n, 0, 1)), i === 0))
      this.r = this.g = this.b = n;
    else {
      const s = n <= 0.5 ? n * (1 + i) : n + i - n * i,
        a = 2 * n - s;
      (this.r = mu(a, s, e + 1 / 3)),
        (this.g = mu(a, s, e)),
        (this.b = mu(a, s, e - 1 / 3));
    }
    return Ln.toWorkingColorSpace(this, r), this;
  }
  setStyle(e, i = gt) {
    function n(s) {
      s !== void 0 &&
        parseFloat(s) < 1 &&
        console.warn(
          "THREE.Color: Alpha component of " + e + " will be ignored."
        );
    }
    let r;
    if ((r = /^(\w+)\(([^\)]*)\)/.exec(e))) {
      let s;
      const a = r[1],
        o = r[2];
      switch (a) {
        case "rgb":
        case "rgba":
          if (
            (s =
              /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                o
              ))
          )
            return (
              n(s[4]),
              this.setRGB(
                Math.min(255, parseInt(s[1], 10)) / 255,
                Math.min(255, parseInt(s[2], 10)) / 255,
                Math.min(255, parseInt(s[3], 10)) / 255,
                i
              )
            );
          if (
            (s =
              /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                o
              ))
          )
            return (
              n(s[4]),
              this.setRGB(
                Math.min(100, parseInt(s[1], 10)) / 100,
                Math.min(100, parseInt(s[2], 10)) / 100,
                Math.min(100, parseInt(s[3], 10)) / 100,
                i
              )
            );
          break;
        case "hsl":
        case "hsla":
          if (
            (s =
              /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                o
              ))
          )
            return (
              n(s[4]),
              this.setHSL(
                parseFloat(s[1]) / 360,
                parseFloat(s[2]) / 100,
                parseFloat(s[3]) / 100,
                i
              )
            );
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + e);
      }
    } else if ((r = /^\#([A-Fa-f\d]+)$/.exec(e))) {
      const s = r[1],
        a = s.length;
      if (a === 3)
        return this.setRGB(
          parseInt(s.charAt(0), 16) / 15,
          parseInt(s.charAt(1), 16) / 15,
          parseInt(s.charAt(2), 16) / 15,
          i
        );
      if (a === 6) return this.setHex(parseInt(s, 16), i);
      console.warn("THREE.Color: Invalid hex color " + e);
    } else if (e && e.length > 0) return this.setColorName(e, i);
    return this;
  }
  setColorName(e, i = gt) {
    const n = ox[e.toLowerCase()];
    return (
      n !== void 0
        ? this.setHex(n, i)
        : console.warn("THREE.Color: Unknown color " + e),
      this
    );
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return (this.r = e.r), (this.g = e.g), (this.b = e.b), this;
  }
  copySRGBToLinear(e) {
    return (this.r = Na(e.r)), (this.g = Na(e.g)), (this.b = Na(e.b)), this;
  }
  copyLinearToSRGB(e) {
    return (this.r = nu(e.r)), (this.g = nu(e.g)), (this.b = nu(e.b)), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(e = gt) {
    return (
      Ln.fromWorkingColorSpace(Ri.copy(this), e),
      Math.round(yi(Ri.r * 255, 0, 255)) * 65536 +
        Math.round(yi(Ri.g * 255, 0, 255)) * 256 +
        Math.round(yi(Ri.b * 255, 0, 255))
    );
  }
  getHexString(e = gt) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  getHSL(e, i = Ln.workingColorSpace) {
    Ln.fromWorkingColorSpace(Ri.copy(this), i);
    const n = Ri.r,
      r = Ri.g,
      s = Ri.b,
      a = Math.max(n, r, s),
      o = Math.min(n, r, s);
    let l, c;
    const d = (o + a) / 2;
    if (o === a) (l = 0), (c = 0);
    else {
      const h = a - o;
      switch (((c = d <= 0.5 ? h / (a + o) : h / (2 - a - o)), a)) {
        case n:
          l = (r - s) / h + (r < s ? 6 : 0);
          break;
        case r:
          l = (s - n) / h + 2;
          break;
        case s:
          l = (n - r) / h + 4;
          break;
      }
      l /= 6;
    }
    return (e.h = l), (e.s = c), (e.l = d), e;
  }
  getRGB(e, i = Ln.workingColorSpace) {
    return (
      Ln.fromWorkingColorSpace(Ri.copy(this), i),
      (e.r = Ri.r),
      (e.g = Ri.g),
      (e.b = Ri.b),
      e
    );
  }
  getStyle(e = gt) {
    Ln.fromWorkingColorSpace(Ri.copy(this), e);
    const i = Ri.r,
      n = Ri.g,
      r = Ri.b;
    return e !== gt
      ? `color(${e} ${i.toFixed(3)} ${n.toFixed(3)} ${r.toFixed(3)})`
      : `rgb(${Math.round(i * 255)},${Math.round(n * 255)},${Math.round(
          r * 255
        )})`;
  }
  offsetHSL(e, i, n) {
    return (
      this.getHSL(On),
      (On.h += e),
      (On.s += i),
      (On.l += n),
      this.setHSL(On.h, On.s, On.l),
      this
    );
  }
  add(e) {
    return (this.r += e.r), (this.g += e.g), (this.b += e.b), this;
  }
  addColors(e, i) {
    return (
      (this.r = e.r + i.r), (this.g = e.g + i.g), (this.b = e.b + i.b), this
    );
  }
  addScalar(e) {
    return (this.r += e), (this.g += e), (this.b += e), this;
  }
  sub(e) {
    return (
      (this.r = Math.max(0, this.r - e.r)),
      (this.g = Math.max(0, this.g - e.g)),
      (this.b = Math.max(0, this.b - e.b)),
      this
    );
  }
  multiply(e) {
    return (this.r *= e.r), (this.g *= e.g), (this.b *= e.b), this;
  }
  multiplyScalar(e) {
    return (this.r *= e), (this.g *= e), (this.b *= e), this;
  }
  lerp(e, i) {
    return (
      (this.r += (e.r - this.r) * i),
      (this.g += (e.g - this.g) * i),
      (this.b += (e.b - this.b) * i),
      this
    );
  }
  lerpColors(e, i, n) {
    return (
      (this.r = e.r + (i.r - e.r) * n),
      (this.g = e.g + (i.g - e.g) * n),
      (this.b = e.b + (i.b - e.b) * n),
      this
    );
  }
  lerpHSL(e, i) {
    this.getHSL(On), e.getHSL(Bl);
    const n = qo(On.h, Bl.h, i),
      r = qo(On.s, Bl.s, i),
      s = qo(On.l, Bl.l, i);
    return this.setHSL(n, r, s), this;
  }
  setFromVector3(e) {
    return (this.r = e.x), (this.g = e.y), (this.b = e.z), this;
  }
  applyMatrix3(e) {
    const i = this.r,
      n = this.g,
      r = this.b,
      s = e.elements;
    return (
      (this.r = s[0] * i + s[3] * n + s[6] * r),
      (this.g = s[1] * i + s[4] * n + s[7] * r),
      (this.b = s[2] * i + s[5] * n + s[8] * r),
      this
    );
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, i = 0) {
    return (this.r = e[i]), (this.g = e[i + 1]), (this.b = e[i + 2]), this;
  }
  toArray(e = [], i = 0) {
    return (e[i] = this.r), (e[i + 1] = this.g), (e[i + 2] = this.b), e;
  }
  fromBufferAttribute(e, i) {
    return (
      (this.r = e.getX(i)), (this.g = e.getY(i)), (this.b = e.getZ(i)), this
    );
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
const Ri = new tt();
tt.NAMES = ox;
class co extends lo {
  constructor(e) {
    super(),
      (this.isMeshBasicMaterial = !0),
      (this.type = "MeshBasicMaterial"),
      (this.color = new tt(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.combine = jy),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.fog = e.fog),
      this
    );
  }
}
const fi = new A(),
  Fl = new J();
class pt {
  constructor(e, i, n = !1) {
    if (Array.isArray(e))
      throw new TypeError(
        "THREE.BufferAttribute: array should be a Typed Array."
      );
    (this.isBufferAttribute = !0),
      (this.name = ""),
      (this.array = e),
      (this.itemSize = i),
      (this.count = e !== void 0 ? e.length / i : 0),
      (this.normalized = n),
      (this.usage = vd),
      (this.updateRange = { offset: 0, count: -1 }),
      (this.gpuType = lr),
      (this.version = 0);
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.array = new e.array.constructor(e.array)),
      (this.itemSize = e.itemSize),
      (this.count = e.count),
      (this.normalized = e.normalized),
      (this.usage = e.usage),
      (this.gpuType = e.gpuType),
      this
    );
  }
  copyAt(e, i, n) {
    (e *= this.itemSize), (n *= i.itemSize);
    for (let r = 0, s = this.itemSize; r < s; r++)
      this.array[e + r] = i.array[n + r];
    return this;
  }
  copyArray(e) {
    return this.array.set(e), this;
  }
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let i = 0, n = this.count; i < n; i++)
        Fl.fromBufferAttribute(this, i),
          Fl.applyMatrix3(e),
          this.setXY(i, Fl.x, Fl.y);
    else if (this.itemSize === 3)
      for (let i = 0, n = this.count; i < n; i++)
        fi.fromBufferAttribute(this, i),
          fi.applyMatrix3(e),
          this.setXYZ(i, fi.x, fi.y, fi.z);
    return this;
  }
  applyMatrix4(e) {
    for (let i = 0, n = this.count; i < n; i++)
      fi.fromBufferAttribute(this, i),
        fi.applyMatrix4(e),
        this.setXYZ(i, fi.x, fi.y, fi.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let i = 0, n = this.count; i < n; i++)
      fi.fromBufferAttribute(this, i),
        fi.applyNormalMatrix(e),
        this.setXYZ(i, fi.x, fi.y, fi.z);
    return this;
  }
  transformDirection(e) {
    for (let i = 0, n = this.count; i < n; i++)
      fi.fromBufferAttribute(this, i),
        fi.transformDirection(e),
        this.setXYZ(i, fi.x, fi.y, fi.z);
    return this;
  }
  set(e, i = 0) {
    return this.array.set(e, i), this;
  }
  getX(e) {
    let i = this.array[e * this.itemSize];
    return this.normalized && (i = Ir(i, this.array)), i;
  }
  setX(e, i) {
    return (
      this.normalized && (i = Wt(i, this.array)),
      (this.array[e * this.itemSize] = i),
      this
    );
  }
  getY(e) {
    let i = this.array[e * this.itemSize + 1];
    return this.normalized && (i = Ir(i, this.array)), i;
  }
  setY(e, i) {
    return (
      this.normalized && (i = Wt(i, this.array)),
      (this.array[e * this.itemSize + 1] = i),
      this
    );
  }
  getZ(e) {
    let i = this.array[e * this.itemSize + 2];
    return this.normalized && (i = Ir(i, this.array)), i;
  }
  setZ(e, i) {
    return (
      this.normalized && (i = Wt(i, this.array)),
      (this.array[e * this.itemSize + 2] = i),
      this
    );
  }
  getW(e) {
    let i = this.array[e * this.itemSize + 3];
    return this.normalized && (i = Ir(i, this.array)), i;
  }
  setW(e, i) {
    return (
      this.normalized && (i = Wt(i, this.array)),
      (this.array[e * this.itemSize + 3] = i),
      this
    );
  }
  setXY(e, i, n) {
    return (
      (e *= this.itemSize),
      this.normalized && ((i = Wt(i, this.array)), (n = Wt(n, this.array))),
      (this.array[e + 0] = i),
      (this.array[e + 1] = n),
      this
    );
  }
  setXYZ(e, i, n, r) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((i = Wt(i, this.array)),
        (n = Wt(n, this.array)),
        (r = Wt(r, this.array))),
      (this.array[e + 0] = i),
      (this.array[e + 1] = n),
      (this.array[e + 2] = r),
      this
    );
  }
  setXYZW(e, i, n, r, s) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((i = Wt(i, this.array)),
        (n = Wt(n, this.array)),
        (r = Wt(r, this.array)),
        (s = Wt(s, this.array))),
      (this.array[e + 0] = i),
      (this.array[e + 1] = n),
      (this.array[e + 2] = r),
      (this.array[e + 3] = s),
      this
    );
  }
  onUpload(e) {
    return (this.onUploadCallback = e), this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized,
    };
    return (
      this.name !== "" && (e.name = this.name),
      this.usage !== vd && (e.usage = this.usage),
      (this.updateRange.offset !== 0 || this.updateRange.count !== -1) &&
        (e.updateRange = this.updateRange),
      e
    );
  }
}
class lx extends pt {
  constructor(e, i, n) {
    super(new Uint16Array(e), i, n);
  }
}
class za extends pt {
  constructor(e, i, n) {
    super(new Uint32Array(e), i, n);
  }
}
class We extends pt {
  constructor(e, i, n) {
    super(new Float32Array(e), i, n);
  }
}
let fS = 0;
const mn = new ze(),
  gu = new Ht(),
  fa = new A(),
  cn = new An(),
  Eo = new An(),
  Si = new A();
class st extends Ys {
  constructor() {
    super(),
      (this.isBufferGeometry = !0),
      Object.defineProperty(this, "id", { value: fS++ }),
      (this.uuid = Gn()),
      (this.name = ""),
      (this.type = "BufferGeometry"),
      (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.morphTargetsRelative = !1),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.drawRange = { start: 0, count: 1 / 0 }),
      (this.userData = {});
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return (
      Array.isArray(e)
        ? (this.index = new (nx(e) ? za : lx)(e, 1))
        : (this.index = e),
      this
    );
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, i) {
    return (this.attributes[e] = i), this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, i, n = 0) {
    this.groups.push({ start: e, count: i, materialIndex: n });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, i) {
    (this.drawRange.start = e), (this.drawRange.count = i);
  }
  applyMatrix4(e) {
    const i = this.attributes.position;
    i !== void 0 && (i.applyMatrix4(e), (i.needsUpdate = !0));
    const n = this.attributes.normal;
    if (n !== void 0) {
      const s = new ft().getNormalMatrix(e);
      n.applyNormalMatrix(s), (n.needsUpdate = !0);
    }
    const r = this.attributes.tangent;
    return (
      r !== void 0 && (r.transformDirection(e), (r.needsUpdate = !0)),
      this.boundingBox !== null && this.computeBoundingBox(),
      this.boundingSphere !== null && this.computeBoundingSphere(),
      this
    );
  }
  applyQuaternion(e) {
    return mn.makeRotationFromQuaternion(e), this.applyMatrix4(mn), this;
  }
  rotateX(e) {
    return mn.makeRotationX(e), this.applyMatrix4(mn), this;
  }
  rotateY(e) {
    return mn.makeRotationY(e), this.applyMatrix4(mn), this;
  }
  rotateZ(e) {
    return mn.makeRotationZ(e), this.applyMatrix4(mn), this;
  }
  translate(e, i, n) {
    return mn.makeTranslation(e, i, n), this.applyMatrix4(mn), this;
  }
  scale(e, i, n) {
    return mn.makeScale(e, i, n), this.applyMatrix4(mn), this;
  }
  lookAt(e) {
    return gu.lookAt(e), gu.updateMatrix(), this.applyMatrix4(gu.matrix), this;
  }
  center() {
    return (
      this.computeBoundingBox(),
      this.boundingBox.getCenter(fa).negate(),
      this.translate(fa.x, fa.y, fa.z),
      this
    );
  }
  setFromPoints(e) {
    const i = [];
    for (let n = 0, r = e.length; n < r; n++) {
      const s = e[n];
      i.push(s.x, s.y, s.z || 0);
    }
    return this.setAttribute("position", new We(i, 3)), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new An());
    const e = this.attributes.position,
      i = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error(
        'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
        this
      ),
        this.boundingBox.set(
          new A(-1 / 0, -1 / 0, -1 / 0),
          new A(1 / 0, 1 / 0, 1 / 0)
        );
      return;
    }
    if (e !== void 0) {
      if ((this.boundingBox.setFromBufferAttribute(e), i))
        for (let n = 0, r = i.length; n < r; n++) {
          const s = i[n];
          cn.setFromBufferAttribute(s),
            this.morphTargetsRelative
              ? (Si.addVectors(this.boundingBox.min, cn.min),
                this.boundingBox.expandByPoint(Si),
                Si.addVectors(this.boundingBox.max, cn.max),
                this.boundingBox.expandByPoint(Si))
              : (this.boundingBox.expandByPoint(cn.min),
                this.boundingBox.expandByPoint(cn.max));
        }
    } else this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) ||
      isNaN(this.boundingBox.min.y) ||
      isNaN(this.boundingBox.min.z)) &&
      console.error(
        'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
        this
      );
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Xn());
    const e = this.attributes.position,
      i = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error(
        'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',
        this
      ),
        this.boundingSphere.set(new A(), 1 / 0);
      return;
    }
    if (e) {
      const n = this.boundingSphere.center;
      if ((cn.setFromBufferAttribute(e), i))
        for (let s = 0, a = i.length; s < a; s++) {
          const o = i[s];
          Eo.setFromBufferAttribute(o),
            this.morphTargetsRelative
              ? (Si.addVectors(cn.min, Eo.min),
                cn.expandByPoint(Si),
                Si.addVectors(cn.max, Eo.max),
                cn.expandByPoint(Si))
              : (cn.expandByPoint(Eo.min), cn.expandByPoint(Eo.max));
        }
      cn.getCenter(n);
      let r = 0;
      for (let s = 0, a = e.count; s < a; s++)
        Si.fromBufferAttribute(e, s),
          (r = Math.max(r, n.distanceToSquared(Si)));
      if (i)
        for (let s = 0, a = i.length; s < a; s++) {
          const o = i[s],
            l = this.morphTargetsRelative;
          for (let c = 0, d = o.count; c < d; c++)
            Si.fromBufferAttribute(o, c),
              l && (fa.fromBufferAttribute(e, c), Si.add(fa)),
              (r = Math.max(r, n.distanceToSquared(Si)));
        }
      (this.boundingSphere.radius = Math.sqrt(r)),
        isNaN(this.boundingSphere.radius) &&
          console.error(
            'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
            this
          );
    }
  }
  computeTangents() {
    const e = this.index,
      i = this.attributes;
    if (
      e === null ||
      i.position === void 0 ||
      i.normal === void 0 ||
      i.uv === void 0
    ) {
      console.error(
        "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
      );
      return;
    }
    const n = e.array,
      r = i.position.array,
      s = i.normal.array,
      a = i.uv.array,
      o = r.length / 3;
    this.hasAttribute("tangent") === !1 &&
      this.setAttribute("tangent", new pt(new Float32Array(4 * o), 4));
    const l = this.getAttribute("tangent").array,
      c = [],
      d = [];
    for (let w = 0; w < o; w++) (c[w] = new A()), (d[w] = new A());
    const h = new A(),
      u = new A(),
      f = new A(),
      p = new J(),
      v = new J(),
      g = new J(),
      m = new A(),
      x = new A();
    function y(w, C, L) {
      h.fromArray(r, w * 3),
        u.fromArray(r, C * 3),
        f.fromArray(r, L * 3),
        p.fromArray(a, w * 2),
        v.fromArray(a, C * 2),
        g.fromArray(a, L * 2),
        u.sub(h),
        f.sub(h),
        v.sub(p),
        g.sub(p);
      const P = 1 / (v.x * g.y - g.x * v.y);
      isFinite(P) &&
        (m
          .copy(u)
          .multiplyScalar(g.y)
          .addScaledVector(f, -v.y)
          .multiplyScalar(P),
        x
          .copy(f)
          .multiplyScalar(v.x)
          .addScaledVector(u, -g.x)
          .multiplyScalar(P),
        c[w].add(m),
        c[C].add(m),
        c[L].add(m),
        d[w].add(x),
        d[C].add(x),
        d[L].add(x));
    }
    let _ = this.groups;
    _.length === 0 && (_ = [{ start: 0, count: n.length }]);
    for (let w = 0, C = _.length; w < C; ++w) {
      const L = _[w],
        P = L.start,
        R = L.count;
      for (let I = P, W = P + R; I < W; I += 3) y(n[I + 0], n[I + 1], n[I + 2]);
    }
    const M = new A(),
      b = new A(),
      E = new A(),
      T = new A();
    function S(w) {
      E.fromArray(s, w * 3), T.copy(E);
      const C = c[w];
      M.copy(C),
        M.sub(E.multiplyScalar(E.dot(C))).normalize(),
        b.crossVectors(T, C);
      const P = b.dot(d[w]) < 0 ? -1 : 1;
      (l[w * 4] = M.x),
        (l[w * 4 + 1] = M.y),
        (l[w * 4 + 2] = M.z),
        (l[w * 4 + 3] = P);
    }
    for (let w = 0, C = _.length; w < C; ++w) {
      const L = _[w],
        P = L.start,
        R = L.count;
      for (let I = P, W = P + R; I < W; I += 3)
        S(n[I + 0]), S(n[I + 1]), S(n[I + 2]);
    }
  }
  computeVertexNormals() {
    const e = this.index,
      i = this.getAttribute("position");
    if (i !== void 0) {
      let n = this.getAttribute("normal");
      if (n === void 0)
        (n = new pt(new Float32Array(i.count * 3), 3)),
          this.setAttribute("normal", n);
      else for (let u = 0, f = n.count; u < f; u++) n.setXYZ(u, 0, 0, 0);
      const r = new A(),
        s = new A(),
        a = new A(),
        o = new A(),
        l = new A(),
        c = new A(),
        d = new A(),
        h = new A();
      if (e)
        for (let u = 0, f = e.count; u < f; u += 3) {
          const p = e.getX(u + 0),
            v = e.getX(u + 1),
            g = e.getX(u + 2);
          r.fromBufferAttribute(i, p),
            s.fromBufferAttribute(i, v),
            a.fromBufferAttribute(i, g),
            d.subVectors(a, s),
            h.subVectors(r, s),
            d.cross(h),
            o.fromBufferAttribute(n, p),
            l.fromBufferAttribute(n, v),
            c.fromBufferAttribute(n, g),
            o.add(d),
            l.add(d),
            c.add(d),
            n.setXYZ(p, o.x, o.y, o.z),
            n.setXYZ(v, l.x, l.y, l.z),
            n.setXYZ(g, c.x, c.y, c.z);
        }
      else
        for (let u = 0, f = i.count; u < f; u += 3)
          r.fromBufferAttribute(i, u + 0),
            s.fromBufferAttribute(i, u + 1),
            a.fromBufferAttribute(i, u + 2),
            d.subVectors(a, s),
            h.subVectors(r, s),
            d.cross(h),
            n.setXYZ(u + 0, d.x, d.y, d.z),
            n.setXYZ(u + 1, d.x, d.y, d.z),
            n.setXYZ(u + 2, d.x, d.y, d.z);
      this.normalizeNormals(), (n.needsUpdate = !0);
    }
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let i = 0, n = e.count; i < n; i++)
      Si.fromBufferAttribute(e, i),
        Si.normalize(),
        e.setXYZ(i, Si.x, Si.y, Si.z);
  }
  toNonIndexed() {
    function e(o, l) {
      const c = o.array,
        d = o.itemSize,
        h = o.normalized,
        u = new c.constructor(l.length * d);
      let f = 0,
        p = 0;
      for (let v = 0, g = l.length; v < g; v++) {
        o.isInterleavedBufferAttribute
          ? (f = l[v] * o.data.stride + o.offset)
          : (f = l[v] * d);
        for (let m = 0; m < d; m++) u[p++] = c[f++];
      }
      return new pt(u, d, h);
    }
    if (this.index === null)
      return (
        console.warn(
          "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."
        ),
        this
      );
    const i = new st(),
      n = this.index.array,
      r = this.attributes;
    for (const o in r) {
      const l = r[o],
        c = e(l, n);
      i.setAttribute(o, c);
    }
    const s = this.morphAttributes;
    for (const o in s) {
      const l = [],
        c = s[o];
      for (let d = 0, h = c.length; d < h; d++) {
        const u = c[d],
          f = e(u, n);
        l.push(f);
      }
      i.morphAttributes[o] = l;
    }
    i.morphTargetsRelative = this.morphTargetsRelative;
    const a = this.groups;
    for (let o = 0, l = a.length; o < l; o++) {
      const c = a[o];
      i.addGroup(c.start, c.count, c.materialIndex);
    }
    return i;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON",
      },
    };
    if (
      ((e.uuid = this.uuid),
      (e.type = this.type),
      this.name !== "" && (e.name = this.name),
      Object.keys(this.userData).length > 0 && (e.userData = this.userData),
      this.parameters !== void 0)
    ) {
      const l = this.parameters;
      for (const c in l) l[c] !== void 0 && (e[c] = l[c]);
      return e;
    }
    e.data = { attributes: {} };
    const i = this.index;
    i !== null &&
      (e.data.index = {
        type: i.array.constructor.name,
        array: Array.prototype.slice.call(i.array),
      });
    const n = this.attributes;
    for (const l in n) {
      const c = n[l];
      e.data.attributes[l] = c.toJSON(e.data);
    }
    const r = {};
    let s = !1;
    for (const l in this.morphAttributes) {
      const c = this.morphAttributes[l],
        d = [];
      for (let h = 0, u = c.length; h < u; h++) {
        const f = c[h];
        d.push(f.toJSON(e.data));
      }
      d.length > 0 && ((r[l] = d), (s = !0));
    }
    s &&
      ((e.data.morphAttributes = r),
      (e.data.morphTargetsRelative = this.morphTargetsRelative));
    const a = this.groups;
    a.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(a)));
    const o = this.boundingSphere;
    return (
      o !== null &&
        (e.data.boundingSphere = {
          center: o.center.toArray(),
          radius: o.radius,
        }),
      e
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null);
    const i = {};
    this.name = e.name;
    const n = e.index;
    n !== null && this.setIndex(n.clone(i));
    const r = e.attributes;
    for (const c in r) {
      const d = r[c];
      this.setAttribute(c, d.clone(i));
    }
    const s = e.morphAttributes;
    for (const c in s) {
      const d = [],
        h = s[c];
      for (let u = 0, f = h.length; u < f; u++) d.push(h[u].clone(i));
      this.morphAttributes[c] = d;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const a = e.groups;
    for (let c = 0, d = a.length; c < d; c++) {
      const h = a[c];
      this.addGroup(h.start, h.count, h.materialIndex);
    }
    const o = e.boundingBox;
    o !== null && (this.boundingBox = o.clone());
    const l = e.boundingSphere;
    return (
      l !== null && (this.boundingSphere = l.clone()),
      (this.drawRange.start = e.drawRange.start),
      (this.drawRange.count = e.drawRange.count),
      (this.userData = e.userData),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const $m = new ze(),
  Ms = new oo(),
  kl = new Xn(),
  Ym = new A(),
  pa = new A(),
  ma = new A(),
  ga = new A(),
  vu = new A(),
  Vl = new A(),
  Hl = new J(),
  Gl = new J(),
  jl = new J(),
  Zm = new A(),
  Km = new A(),
  Jm = new A(),
  Wl = new A(),
  ql = new A();
class Fn extends Ht {
  constructor(e = new st(), i = new co()) {
    super(),
      (this.isMesh = !0),
      (this.type = "Mesh"),
      (this.geometry = e),
      (this.material = i),
      this.updateMorphTargets();
  }
  copy(e, i) {
    return (
      super.copy(e, i),
      e.morphTargetInfluences !== void 0 &&
        (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
      e.morphTargetDictionary !== void 0 &&
        (this.morphTargetDictionary = Object.assign(
          {},
          e.morphTargetDictionary
        )),
      (this.material = e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  updateMorphTargets() {
    const i = this.geometry.morphAttributes,
      n = Object.keys(i);
    if (n.length > 0) {
      const r = i[n[0]];
      if (r !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let s = 0, a = r.length; s < a; s++) {
          const o = r[s].name || String(s);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[o] = s);
        }
      }
    }
  }
  getVertexPosition(e, i) {
    const n = this.geometry,
      r = n.attributes.position,
      s = n.morphAttributes.position,
      a = n.morphTargetsRelative;
    i.fromBufferAttribute(r, e);
    const o = this.morphTargetInfluences;
    if (s && o) {
      Vl.set(0, 0, 0);
      for (let l = 0, c = s.length; l < c; l++) {
        const d = o[l],
          h = s[l];
        d !== 0 &&
          (vu.fromBufferAttribute(h, e),
          a ? Vl.addScaledVector(vu, d) : Vl.addScaledVector(vu.sub(i), d));
      }
      i.add(Vl);
    }
    return i;
  }
  raycast(e, i) {
    const n = this.geometry,
      r = this.material,
      s = this.matrixWorld;
    r !== void 0 &&
      (n.boundingSphere === null && n.computeBoundingSphere(),
      kl.copy(n.boundingSphere),
      kl.applyMatrix4(s),
      Ms.copy(e.ray).recast(e.near),
      !(
        kl.containsPoint(Ms.origin) === !1 &&
        (Ms.intersectSphere(kl, Ym) === null ||
          Ms.origin.distanceToSquared(Ym) > (e.far - e.near) ** 2)
      ) &&
        ($m.copy(s).invert(),
        Ms.copy(e.ray).applyMatrix4($m),
        !(n.boundingBox !== null && Ms.intersectsBox(n.boundingBox) === !1) &&
          this._computeIntersections(e, i, Ms)));
  }
  _computeIntersections(e, i, n) {
    let r;
    const s = this.geometry,
      a = this.material,
      o = s.index,
      l = s.attributes.position,
      c = s.attributes.uv,
      d = s.attributes.uv1,
      h = s.attributes.normal,
      u = s.groups,
      f = s.drawRange;
    if (o !== null)
      if (Array.isArray(a))
        for (let p = 0, v = u.length; p < v; p++) {
          const g = u[p],
            m = a[g.materialIndex],
            x = Math.max(g.start, f.start),
            y = Math.min(
              o.count,
              Math.min(g.start + g.count, f.start + f.count)
            );
          for (let _ = x, M = y; _ < M; _ += 3) {
            const b = o.getX(_),
              E = o.getX(_ + 1),
              T = o.getX(_ + 2);
            (r = Xl(this, m, e, n, c, d, h, b, E, T)),
              r &&
                ((r.faceIndex = Math.floor(_ / 3)),
                (r.face.materialIndex = g.materialIndex),
                i.push(r));
          }
        }
      else {
        const p = Math.max(0, f.start),
          v = Math.min(o.count, f.start + f.count);
        for (let g = p, m = v; g < m; g += 3) {
          const x = o.getX(g),
            y = o.getX(g + 1),
            _ = o.getX(g + 2);
          (r = Xl(this, a, e, n, c, d, h, x, y, _)),
            r && ((r.faceIndex = Math.floor(g / 3)), i.push(r));
        }
      }
    else if (l !== void 0)
      if (Array.isArray(a))
        for (let p = 0, v = u.length; p < v; p++) {
          const g = u[p],
            m = a[g.materialIndex],
            x = Math.max(g.start, f.start),
            y = Math.min(
              l.count,
              Math.min(g.start + g.count, f.start + f.count)
            );
          for (let _ = x, M = y; _ < M; _ += 3) {
            const b = _,
              E = _ + 1,
              T = _ + 2;
            (r = Xl(this, m, e, n, c, d, h, b, E, T)),
              r &&
                ((r.faceIndex = Math.floor(_ / 3)),
                (r.face.materialIndex = g.materialIndex),
                i.push(r));
          }
        }
      else {
        const p = Math.max(0, f.start),
          v = Math.min(l.count, f.start + f.count);
        for (let g = p, m = v; g < m; g += 3) {
          const x = g,
            y = g + 1,
            _ = g + 2;
          (r = Xl(this, a, e, n, c, d, h, x, y, _)),
            r && ((r.faceIndex = Math.floor(g / 3)), i.push(r));
        }
      }
  }
}
function pS(t, e, i, n, r, s, a, o) {
  let l;
  if (
    (e.side === nn
      ? (l = n.intersectTriangle(a, s, r, !0, o))
      : (l = n.intersectTriangle(r, s, a, e.side === ds, o)),
    l === null)
  )
    return null;
  ql.copy(o), ql.applyMatrix4(t.matrixWorld);
  const c = i.ray.origin.distanceTo(ql);
  return c < i.near || c > i.far
    ? null
    : { distance: c, point: ql.clone(), object: t };
}
function Xl(t, e, i, n, r, s, a, o, l, c) {
  t.getVertexPosition(o, pa),
    t.getVertexPosition(l, ma),
    t.getVertexPosition(c, ga);
  const d = pS(t, e, i, n, pa, ma, ga, Wl);
  if (d) {
    r &&
      (Hl.fromBufferAttribute(r, o),
      Gl.fromBufferAttribute(r, l),
      jl.fromBufferAttribute(r, c),
      (d.uv = Ki.getInterpolation(Wl, pa, ma, ga, Hl, Gl, jl, new J()))),
      s &&
        (Hl.fromBufferAttribute(s, o),
        Gl.fromBufferAttribute(s, l),
        jl.fromBufferAttribute(s, c),
        (d.uv1 = Ki.getInterpolation(Wl, pa, ma, ga, Hl, Gl, jl, new J())),
        (d.uv2 = d.uv1)),
      a &&
        (Zm.fromBufferAttribute(a, o),
        Km.fromBufferAttribute(a, l),
        Jm.fromBufferAttribute(a, c),
        (d.normal = Ki.getInterpolation(Wl, pa, ma, ga, Zm, Km, Jm, new A())),
        d.normal.dot(n.direction) > 0 && d.normal.multiplyScalar(-1));
    const h = { a: o, b: l, c, normal: new A(), materialIndex: 0 };
    Ki.getNormal(pa, ma, ga, h.normal), (d.face = h);
  }
  return d;
}
class $n extends st {
  constructor(e = 1, i = 1, n = 1, r = 1, s = 1, a = 1) {
    super(),
      (this.type = "BoxGeometry"),
      (this.parameters = {
        width: e,
        height: i,
        depth: n,
        widthSegments: r,
        heightSegments: s,
        depthSegments: a,
      });
    const o = this;
    (r = Math.floor(r)), (s = Math.floor(s)), (a = Math.floor(a));
    const l = [],
      c = [],
      d = [],
      h = [];
    let u = 0,
      f = 0;
    p("z", "y", "x", -1, -1, n, i, e, a, s, 0),
      p("z", "y", "x", 1, -1, n, i, -e, a, s, 1),
      p("x", "z", "y", 1, 1, e, n, i, r, a, 2),
      p("x", "z", "y", 1, -1, e, n, -i, r, a, 3),
      p("x", "y", "z", 1, -1, e, i, n, r, s, 4),
      p("x", "y", "z", -1, -1, e, i, -n, r, s, 5),
      this.setIndex(l),
      this.setAttribute("position", new We(c, 3)),
      this.setAttribute("normal", new We(d, 3)),
      this.setAttribute("uv", new We(h, 2));
    function p(v, g, m, x, y, _, M, b, E, T, S) {
      const w = _ / E,
        C = M / T,
        L = _ / 2,
        P = M / 2,
        R = b / 2,
        I = E + 1,
        W = T + 1;
      let N = 0,
        U = 0;
      const G = new A();
      for (let k = 0; k < W; k++) {
        const B = k * C - P;
        for (let V = 0; V < I; V++) {
          const X = V * w - L;
          (G[v] = X * x),
            (G[g] = B * y),
            (G[m] = R),
            c.push(G.x, G.y, G.z),
            (G[v] = 0),
            (G[g] = 0),
            (G[m] = b > 0 ? 1 : -1),
            d.push(G.x, G.y, G.z),
            h.push(V / E),
            h.push(1 - k / T),
            (N += 1);
        }
      }
      for (let k = 0; k < T; k++)
        for (let B = 0; B < E; B++) {
          const V = u + B + I * k,
            X = u + B + I * (k + 1),
            H = u + (B + 1) + I * (k + 1),
            j = u + (B + 1) + I * k;
          l.push(V, X, j), l.push(X, H, j), (U += 6);
        }
      o.addGroup(f, U, S), (f += U), (u += N);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new $n(
      e.width,
      e.height,
      e.depth,
      e.widthSegments,
      e.heightSegments,
      e.depthSegments
    );
  }
}
function Ya(t) {
  const e = {};
  for (const i in t) {
    e[i] = {};
    for (const n in t[i]) {
      const r = t[i][n];
      r &&
      (r.isColor ||
        r.isMatrix3 ||
        r.isMatrix4 ||
        r.isVector2 ||
        r.isVector3 ||
        r.isVector4 ||
        r.isTexture ||
        r.isQuaternion)
        ? r.isRenderTargetTexture
          ? (console.warn(
              "UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."
            ),
            (e[i][n] = null))
          : (e[i][n] = r.clone())
        : Array.isArray(r)
        ? (e[i][n] = r.slice())
        : (e[i][n] = r);
    }
  }
  return e;
}
function Fi(t) {
  const e = {};
  for (let i = 0; i < t.length; i++) {
    const n = Ya(t[i]);
    for (const r in n) e[r] = n[r];
  }
  return e;
}
function mS(t) {
  const e = [];
  for (let i = 0; i < t.length; i++) e.push(t[i].clone());
  return e;
}
function cx(t) {
  return t.getRenderTarget() === null ? t.outputColorSpace : qn;
}
const un = { clone: Ya, merge: Fi };
var gS = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
  vS = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class Ti extends lo {
  constructor(e) {
    super(),
      (this.isShaderMaterial = !0),
      (this.type = "ShaderMaterial"),
      (this.defines = {}),
      (this.uniforms = {}),
      (this.uniformsGroups = []),
      (this.vertexShader = gS),
      (this.fragmentShader = vS),
      (this.linewidth = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.fog = !1),
      (this.lights = !1),
      (this.clipping = !1),
      (this.forceSinglePass = !0),
      (this.extensions = {
        derivatives: !1,
        fragDepth: !1,
        drawBuffers: !1,
        shaderTextureLOD: !1,
      }),
      (this.defaultAttributeValues = {
        color: [1, 1, 1],
        uv: [0, 0],
        uv1: [0, 0],
      }),
      (this.index0AttributeName = void 0),
      (this.uniformsNeedUpdate = !1),
      (this.glslVersion = null),
      e !== void 0 && this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.fragmentShader = e.fragmentShader),
      (this.vertexShader = e.vertexShader),
      (this.uniforms = Ya(e.uniforms)),
      (this.uniformsGroups = mS(e.uniformsGroups)),
      (this.defines = Object.assign({}, e.defines)),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.fog = e.fog),
      (this.lights = e.lights),
      (this.clipping = e.clipping),
      (this.extensions = Object.assign({}, e.extensions)),
      (this.glslVersion = e.glslVersion),
      this
    );
  }
  toJSON(e) {
    const i = super.toJSON(e);
    (i.glslVersion = this.glslVersion), (i.uniforms = {});
    for (const r in this.uniforms) {
      const a = this.uniforms[r].value;
      a && a.isTexture
        ? (i.uniforms[r] = { type: "t", value: a.toJSON(e).uuid })
        : a && a.isColor
        ? (i.uniforms[r] = { type: "c", value: a.getHex() })
        : a && a.isVector2
        ? (i.uniforms[r] = { type: "v2", value: a.toArray() })
        : a && a.isVector3
        ? (i.uniforms[r] = { type: "v3", value: a.toArray() })
        : a && a.isVector4
        ? (i.uniforms[r] = { type: "v4", value: a.toArray() })
        : a && a.isMatrix3
        ? (i.uniforms[r] = { type: "m3", value: a.toArray() })
        : a && a.isMatrix4
        ? (i.uniforms[r] = { type: "m4", value: a.toArray() })
        : (i.uniforms[r] = { value: a });
    }
    Object.keys(this.defines).length > 0 && (i.defines = this.defines),
      (i.vertexShader = this.vertexShader),
      (i.fragmentShader = this.fragmentShader),
      (i.lights = this.lights),
      (i.clipping = this.clipping);
    const n = {};
    for (const r in this.extensions) this.extensions[r] === !0 && (n[r] = !0);
    return Object.keys(n).length > 0 && (i.extensions = n), i;
  }
}
class vl extends Ht {
  constructor() {
    super(),
      (this.isCamera = !0),
      (this.type = "Camera"),
      (this.matrixWorldInverse = new ze()),
      (this.projectionMatrix = new ze()),
      (this.projectionMatrixInverse = new ze()),
      (this.coordinateSystem = Or);
  }
  copy(e, i) {
    return (
      super.copy(e, i),
      this.matrixWorldInverse.copy(e.matrixWorldInverse),
      this.projectionMatrix.copy(e.projectionMatrix),
      this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
      (this.coordinateSystem = e.coordinateSystem),
      this
    );
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const i = this.matrixWorld.elements;
    return e.set(-i[8], -i[9], -i[10]).normalize();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e),
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, i) {
    super.updateWorldMatrix(e, i),
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class ji extends vl {
  constructor(e = 50, i = 1, n = 0.1, r = 2e3) {
    super(),
      (this.isPerspectiveCamera = !0),
      (this.type = "PerspectiveCamera"),
      (this.fov = e),
      (this.zoom = 1),
      (this.near = n),
      (this.far = r),
      (this.focus = 10),
      (this.aspect = i),
      (this.view = null),
      (this.filmGauge = 35),
      (this.filmOffset = 0),
      this.updateProjectionMatrix();
  }
  copy(e, i) {
    return (
      super.copy(e, i),
      (this.fov = e.fov),
      (this.zoom = e.zoom),
      (this.near = e.near),
      (this.far = e.far),
      (this.focus = e.focus),
      (this.aspect = e.aspect),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      (this.filmGauge = e.filmGauge),
      (this.filmOffset = e.filmOffset),
      this
    );
  }
  setFocalLength(e) {
    const i = (0.5 * this.getFilmHeight()) / e;
    (this.fov = $a * 2 * Math.atan(i)), this.updateProjectionMatrix();
  }
  getFocalLength() {
    const e = Math.tan(Wo * 0.5 * this.fov);
    return (0.5 * this.getFilmHeight()) / e;
  }
  getEffectiveFOV() {
    return $a * 2 * Math.atan(Math.tan(Wo * 0.5 * this.fov) / this.zoom);
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  setViewOffset(e, i, n, r, s, a) {
    (this.aspect = e / i),
      this.view === null &&
        (this.view = {
          enabled: !0,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1,
        }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = i),
      (this.view.offsetX = n),
      (this.view.offsetY = r),
      (this.view.width = s),
      (this.view.height = a),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = this.near;
    let i = (e * Math.tan(Wo * 0.5 * this.fov)) / this.zoom,
      n = 2 * i,
      r = this.aspect * n,
      s = -0.5 * r;
    const a = this.view;
    if (this.view !== null && this.view.enabled) {
      const l = a.fullWidth,
        c = a.fullHeight;
      (s += (a.offsetX * r) / l),
        (i -= (a.offsetY * n) / c),
        (r *= a.width / l),
        (n *= a.height / c);
    }
    const o = this.filmOffset;
    o !== 0 && (s += (e * o) / this.getFilmWidth()),
      this.projectionMatrix.makePerspective(
        s,
        s + r,
        i,
        i - n,
        e,
        this.far,
        this.coordinateSystem
      ),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const i = super.toJSON(e);
    return (
      (i.object.fov = this.fov),
      (i.object.zoom = this.zoom),
      (i.object.near = this.near),
      (i.object.far = this.far),
      (i.object.focus = this.focus),
      (i.object.aspect = this.aspect),
      this.view !== null && (i.object.view = Object.assign({}, this.view)),
      (i.object.filmGauge = this.filmGauge),
      (i.object.filmOffset = this.filmOffset),
      i
    );
  }
}
const va = -90,
  ya = 1;
class yS extends Ht {
  constructor(e, i, n) {
    super(),
      (this.type = "CubeCamera"),
      (this.renderTarget = n),
      (this.coordinateSystem = null);
    const r = new ji(va, ya, e, i);
    (r.layers = this.layers), this.add(r);
    const s = new ji(va, ya, e, i);
    (s.layers = this.layers), this.add(s);
    const a = new ji(va, ya, e, i);
    (a.layers = this.layers), this.add(a);
    const o = new ji(va, ya, e, i);
    (o.layers = this.layers), this.add(o);
    const l = new ji(va, ya, e, i);
    (l.layers = this.layers), this.add(l);
    const c = new ji(va, ya, e, i);
    (c.layers = this.layers), this.add(c);
  }
  updateCoordinateSystem() {
    const e = this.coordinateSystem,
      i = this.children.concat(),
      [n, r, s, a, o, l] = i;
    for (const c of i) this.remove(c);
    if (e === Or)
      n.up.set(0, 1, 0),
        n.lookAt(1, 0, 0),
        r.up.set(0, 1, 0),
        r.lookAt(-1, 0, 0),
        s.up.set(0, 0, -1),
        s.lookAt(0, 1, 0),
        a.up.set(0, 0, 1),
        a.lookAt(0, -1, 0),
        o.up.set(0, 1, 0),
        o.lookAt(0, 0, 1),
        l.up.set(0, 1, 0),
        l.lookAt(0, 0, -1);
    else if (e === zc)
      n.up.set(0, -1, 0),
        n.lookAt(-1, 0, 0),
        r.up.set(0, -1, 0),
        r.lookAt(1, 0, 0),
        s.up.set(0, 0, 1),
        s.lookAt(0, 1, 0),
        a.up.set(0, 0, -1),
        a.lookAt(0, -1, 0),
        o.up.set(0, -1, 0),
        o.lookAt(0, 0, 1),
        l.up.set(0, -1, 0),
        l.lookAt(0, 0, -1);
    else
      throw new Error(
        "THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " +
          e
      );
    for (const c of i) this.add(c), c.updateMatrixWorld();
  }
  update(e, i) {
    this.parent === null && this.updateMatrixWorld();
    const n = this.renderTarget;
    this.coordinateSystem !== e.coordinateSystem &&
      ((this.coordinateSystem = e.coordinateSystem),
      this.updateCoordinateSystem());
    const [r, s, a, o, l, c] = this.children,
      d = e.getRenderTarget(),
      h = e.toneMapping,
      u = e.xr.enabled;
    (e.toneMapping = Nr), (e.xr.enabled = !1);
    const f = n.texture.generateMipmaps;
    (n.texture.generateMipmaps = !1),
      e.setRenderTarget(n, 0),
      e.render(i, r),
      e.setRenderTarget(n, 1),
      e.render(i, s),
      e.setRenderTarget(n, 2),
      e.render(i, a),
      e.setRenderTarget(n, 3),
      e.render(i, o),
      e.setRenderTarget(n, 4),
      e.render(i, l),
      (n.texture.generateMipmaps = f),
      e.setRenderTarget(n, 5),
      e.render(i, c),
      e.setRenderTarget(d),
      (e.toneMapping = h),
      (e.xr.enabled = u),
      (n.texture.needsPMREMUpdate = !0);
  }
}
class Hf extends Li {
  constructor(e, i, n, r, s, a, o, l, c, d) {
    (e = e !== void 0 ? e : []),
      (i = i !== void 0 ? i : Hs),
      super(e, i, n, r, s, a, o, l, c, d),
      (this.isCubeTexture = !0),
      (this.flipY = !1);
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
class xS extends rn {
  constructor(e = 1, i = {}) {
    super(e, e, i), (this.isWebGLCubeRenderTarget = !0);
    const n = { width: e, height: e, depth: 1 },
      r = [n, n, n, n, n, n];
    i.encoding !== void 0 &&
      (Xo(
        "THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace."
      ),
      (i.colorSpace = i.encoding === zr ? gt : Bs)),
      (this.texture = new Hf(
        r,
        i.mapping,
        i.wrapS,
        i.wrapT,
        i.magFilter,
        i.minFilter,
        i.format,
        i.type,
        i.anisotropy,
        i.colorSpace
      )),
      (this.texture.isRenderTargetTexture = !0),
      (this.texture.generateMipmaps =
        i.generateMipmaps !== void 0 ? i.generateMipmaps : !1),
      (this.texture.minFilter = i.minFilter !== void 0 ? i.minFilter : Zi);
  }
  fromEquirectangularTexture(e, i) {
    (this.texture.type = i.type),
      (this.texture.colorSpace = i.colorSpace),
      (this.texture.generateMipmaps = i.generateMipmaps),
      (this.texture.minFilter = i.minFilter),
      (this.texture.magFilter = i.magFilter);
    const n = {
        uniforms: { tEquirect: { value: null } },
        vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
        fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`,
      },
      r = new $n(5, 5, 5),
      s = new Ti({
        name: "CubemapFromEquirect",
        uniforms: Ya(n.uniforms),
        vertexShader: n.vertexShader,
        fragmentShader: n.fragmentShader,
        side: nn,
        blending: Pi,
      });
    s.uniforms.tEquirect.value = i;
    const a = new Fn(r, s),
      o = i.minFilter;
    return (
      i.minFilter === rl && (i.minFilter = Zi),
      new yS(1, 10, this).update(e, a),
      (i.minFilter = o),
      a.geometry.dispose(),
      a.material.dispose(),
      this
    );
  }
  clear(e, i, n, r) {
    const s = e.getRenderTarget();
    for (let a = 0; a < 6; a++) e.setRenderTarget(this, a), e.clear(i, n, r);
    e.setRenderTarget(s);
  }
}
const yu = new A(),
  _S = new A(),
  bS = new ft();
class qr {
  constructor(e = new A(1, 0, 0), i = 0) {
    (this.isPlane = !0), (this.normal = e), (this.constant = i);
  }
  set(e, i) {
    return this.normal.copy(e), (this.constant = i), this;
  }
  setComponents(e, i, n, r) {
    return this.normal.set(e, i, n), (this.constant = r), this;
  }
  setFromNormalAndCoplanarPoint(e, i) {
    return this.normal.copy(e), (this.constant = -i.dot(this.normal)), this;
  }
  setFromCoplanarPoints(e, i, n) {
    const r = yu.subVectors(n, i).cross(_S.subVectors(e, i)).normalize();
    return this.setFromNormalAndCoplanarPoint(r, e), this;
  }
  copy(e) {
    return this.normal.copy(e.normal), (this.constant = e.constant), this;
  }
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), (this.constant *= e), this;
  }
  negate() {
    return (this.constant *= -1), this.normal.negate(), this;
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  projectPoint(e, i) {
    return i.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
  }
  intersectLine(e, i) {
    const n = e.delta(yu),
      r = this.normal.dot(n);
    if (r === 0)
      return this.distanceToPoint(e.start) === 0 ? i.copy(e.start) : null;
    const s = -(e.start.dot(this.normal) + this.constant) / r;
    return s < 0 || s > 1 ? null : i.copy(e.start).addScaledVector(n, s);
  }
  intersectsLine(e) {
    const i = this.distanceToPoint(e.start),
      n = this.distanceToPoint(e.end);
    return (i < 0 && n > 0) || (n < 0 && i > 0);
  }
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e, i) {
    const n = i || bS.getNormalMatrix(e),
      r = this.coplanarPoint(yu).applyMatrix4(e),
      s = this.normal.applyMatrix3(n).normalize();
    return (this.constant = -r.dot(s)), this;
  }
  translate(e) {
    return (this.constant -= e.dot(this.normal)), this;
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Es = new Xn(),
  $l = new A();
class Gf {
  constructor(
    e = new qr(),
    i = new qr(),
    n = new qr(),
    r = new qr(),
    s = new qr(),
    a = new qr()
  ) {
    this.planes = [e, i, n, r, s, a];
  }
  set(e, i, n, r, s, a) {
    const o = this.planes;
    return (
      o[0].copy(e),
      o[1].copy(i),
      o[2].copy(n),
      o[3].copy(r),
      o[4].copy(s),
      o[5].copy(a),
      this
    );
  }
  copy(e) {
    const i = this.planes;
    for (let n = 0; n < 6; n++) i[n].copy(e.planes[n]);
    return this;
  }
  setFromProjectionMatrix(e, i = Or) {
    const n = this.planes,
      r = e.elements,
      s = r[0],
      a = r[1],
      o = r[2],
      l = r[3],
      c = r[4],
      d = r[5],
      h = r[6],
      u = r[7],
      f = r[8],
      p = r[9],
      v = r[10],
      g = r[11],
      m = r[12],
      x = r[13],
      y = r[14],
      _ = r[15];
    if (
      (n[0].setComponents(l - s, u - c, g - f, _ - m).normalize(),
      n[1].setComponents(l + s, u + c, g + f, _ + m).normalize(),
      n[2].setComponents(l + a, u + d, g + p, _ + x).normalize(),
      n[3].setComponents(l - a, u - d, g - p, _ - x).normalize(),
      n[4].setComponents(l - o, u - h, g - v, _ - y).normalize(),
      i === Or)
    )
      n[5].setComponents(l + o, u + h, g + v, _ + y).normalize();
    else if (i === zc) n[5].setComponents(o, h, v, y).normalize();
    else
      throw new Error(
        "THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " +
          i
      );
    return this;
  }
  intersectsObject(e) {
    if (e.boundingSphere !== void 0)
      e.boundingSphere === null && e.computeBoundingSphere(),
        Es.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
    else {
      const i = e.geometry;
      i.boundingSphere === null && i.computeBoundingSphere(),
        Es.copy(i.boundingSphere).applyMatrix4(e.matrixWorld);
    }
    return this.intersectsSphere(Es);
  }
  intersectsSprite(e) {
    return (
      Es.center.set(0, 0, 0),
      (Es.radius = 0.7071067811865476),
      Es.applyMatrix4(e.matrixWorld),
      this.intersectsSphere(Es)
    );
  }
  intersectsSphere(e) {
    const i = this.planes,
      n = e.center,
      r = -e.radius;
    for (let s = 0; s < 6; s++) if (i[s].distanceToPoint(n) < r) return !1;
    return !0;
  }
  intersectsBox(e) {
    const i = this.planes;
    for (let n = 0; n < 6; n++) {
      const r = i[n];
      if (
        (($l.x = r.normal.x > 0 ? e.max.x : e.min.x),
        ($l.y = r.normal.y > 0 ? e.max.y : e.min.y),
        ($l.z = r.normal.z > 0 ? e.max.z : e.min.z),
        r.distanceToPoint($l) < 0)
      )
        return !1;
    }
    return !0;
  }
  containsPoint(e) {
    const i = this.planes;
    for (let n = 0; n < 6; n++) if (i[n].distanceToPoint(e) < 0) return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function hx() {
  let t = null,
    e = !1,
    i = null,
    n = null;
  function r(s, a) {
    i(s, a), (n = t.requestAnimationFrame(r));
  }
  return {
    start: function () {
      e !== !0 && i !== null && ((n = t.requestAnimationFrame(r)), (e = !0));
    },
    stop: function () {
      t.cancelAnimationFrame(n), (e = !1);
    },
    setAnimationLoop: function (s) {
      i = s;
    },
    setContext: function (s) {
      t = s;
    },
  };
}
function wS(t, e) {
  const i = e.isWebGL2,
    n = new WeakMap();
  function r(c, d) {
    const h = c.array,
      u = c.usage,
      f = t.createBuffer();
    t.bindBuffer(d, f), t.bufferData(d, h, u), c.onUploadCallback();
    let p;
    if (h instanceof Float32Array) p = t.FLOAT;
    else if (h instanceof Uint16Array)
      if (c.isFloat16BufferAttribute)
        if (i) p = t.HALF_FLOAT;
        else
          throw new Error(
            "THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."
          );
      else p = t.UNSIGNED_SHORT;
    else if (h instanceof Int16Array) p = t.SHORT;
    else if (h instanceof Uint32Array) p = t.UNSIGNED_INT;
    else if (h instanceof Int32Array) p = t.INT;
    else if (h instanceof Int8Array) p = t.BYTE;
    else if (h instanceof Uint8Array) p = t.UNSIGNED_BYTE;
    else if (h instanceof Uint8ClampedArray) p = t.UNSIGNED_BYTE;
    else
      throw new Error(
        "THREE.WebGLAttributes: Unsupported buffer data format: " + h
      );
    return {
      buffer: f,
      type: p,
      bytesPerElement: h.BYTES_PER_ELEMENT,
      version: c.version,
    };
  }
  function s(c, d, h) {
    const u = d.array,
      f = d.updateRange;
    t.bindBuffer(h, c),
      f.count === -1
        ? t.bufferSubData(h, 0, u)
        : (i
            ? t.bufferSubData(
                h,
                f.offset * u.BYTES_PER_ELEMENT,
                u,
                f.offset,
                f.count
              )
            : t.bufferSubData(
                h,
                f.offset * u.BYTES_PER_ELEMENT,
                u.subarray(f.offset, f.offset + f.count)
              ),
          (f.count = -1)),
      d.onUploadCallback();
  }
  function a(c) {
    return c.isInterleavedBufferAttribute && (c = c.data), n.get(c);
  }
  function o(c) {
    c.isInterleavedBufferAttribute && (c = c.data);
    const d = n.get(c);
    d && (t.deleteBuffer(d.buffer), n.delete(c));
  }
  function l(c, d) {
    if (c.isGLBufferAttribute) {
      const u = n.get(c);
      (!u || u.version < c.version) &&
        n.set(c, {
          buffer: c.buffer,
          type: c.type,
          bytesPerElement: c.elementSize,
          version: c.version,
        });
      return;
    }
    c.isInterleavedBufferAttribute && (c = c.data);
    const h = n.get(c);
    h === void 0
      ? n.set(c, r(c, d))
      : h.version < c.version && (s(h.buffer, c, d), (h.version = c.version));
  }
  return { get: a, remove: o, update: l };
}
class yl extends st {
  constructor(e = 1, i = 1, n = 1, r = 1) {
    super(),
      (this.type = "PlaneGeometry"),
      (this.parameters = {
        width: e,
        height: i,
        widthSegments: n,
        heightSegments: r,
      });
    const s = e / 2,
      a = i / 2,
      o = Math.floor(n),
      l = Math.floor(r),
      c = o + 1,
      d = l + 1,
      h = e / o,
      u = i / l,
      f = [],
      p = [],
      v = [],
      g = [];
    for (let m = 0; m < d; m++) {
      const x = m * u - a;
      for (let y = 0; y < c; y++) {
        const _ = y * h - s;
        p.push(_, -x, 0), v.push(0, 0, 1), g.push(y / o), g.push(1 - m / l);
      }
    }
    for (let m = 0; m < l; m++)
      for (let x = 0; x < o; x++) {
        const y = x + c * m,
          _ = x + c * (m + 1),
          M = x + 1 + c * (m + 1),
          b = x + 1 + c * m;
        f.push(y, _, b), f.push(_, M, b);
      }
    this.setIndex(f),
      this.setAttribute("position", new We(p, 3)),
      this.setAttribute("normal", new We(v, 3)),
      this.setAttribute("uv", new We(g, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new yl(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
var SS = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,
  MS = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,
  ES = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,
  TS = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  AS = `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,
  CS = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
  PS = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
  LS = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
  DS = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,
  RS = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
  OS = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,
  IS = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			 return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float R21 = R12;
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,
  US = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = dFdx( surf_pos.xyz );
		vec3 vSigmaY = dFdy( surf_pos.xyz );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
  NS = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,
  zS = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
  BS = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
  FS = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
  kS = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
  VS = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
  HS = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,
  GS = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,
  jS = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,
  WS = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_v0 0.339
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_v1 0.276
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_v4 0.046
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_v5 0.016
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_v6 0.0038
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
  qS = `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
  XS = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
  $S = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,
  YS = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
  ZS = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
  KS = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
  JS = `vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,
  QS = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
  eM = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,
  tM = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
  iM = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
  nM = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
  rM = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
  sM = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
  aM = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
  oM = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
  lM = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,
  cM = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,
  hM = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
  uM = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,
  dM = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,
  fM = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( LEGACY_LIGHTS )
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#else
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
  pM = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,
  mM = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
  gM = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,
  vM = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
  yM = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,
  xM = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	anisotropyV /= material.anisotropy;
	material.anisotropy = saturate( material.anisotropy );
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x - tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x + tbn[ 0 ] * anisotropyV.y;
#endif`,
  _M = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
  bM = `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometry.viewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
  wM = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometry.viewDir, geometry.normal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
  SM = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,
  MM = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
  EM = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
  TM = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,
  AM = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,
  CM = `#ifdef USE_MAP
	diffuseColor *= texture2D( map, vMapUv );
#endif`,
  PM = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
  LM = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
  DM = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  RM = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
  OM = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
  IM = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,
  UM = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,
  NM = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,
  zM = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,
  BM = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 geometryNormal = normal;`,
  FM = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
  kM = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  VM = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  HM = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
  GM = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,
  jM = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,
  WM = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,
  qM = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,
  XM = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,
  $M = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
  YM = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,
  ZM = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
  KM = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
  JM = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
  QM = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
  e2 = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
  t2 = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
  i2 = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,
  n2 = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
  r2 = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,
  s2 = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
  a2 = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
  o2 = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`,
  l2 = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
  c2 = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
  h2 = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
  u2 = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
  d2 = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
  f2 = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
  p2 = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,
  m2 = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,
  g2 = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  v2 = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  y2 = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,
  x2 = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const _2 = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
  b2 = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  w2 = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  S2 = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  M2 = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  E2 = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  T2 = `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
  A2 = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,
  C2 = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
  P2 = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
  L2 = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
  D2 = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  R2 = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  O2 = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  I2 = `#include <common>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
  U2 = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  N2 = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  z2 = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  B2 = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
  F2 = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  k2 = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
  V2 = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
  H2 = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  G2 = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  j2 = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
  W2 = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  q2 = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  X2 = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  $2 = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
  Y2 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  Z2 = `#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  K2 = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
  J2 = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  Q2 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
  ct = {
    alphahash_fragment: SS,
    alphahash_pars_fragment: MS,
    alphamap_fragment: ES,
    alphamap_pars_fragment: TS,
    alphatest_fragment: AS,
    alphatest_pars_fragment: CS,
    aomap_fragment: PS,
    aomap_pars_fragment: LS,
    begin_vertex: DS,
    beginnormal_vertex: RS,
    bsdfs: OS,
    iridescence_fragment: IS,
    bumpmap_pars_fragment: US,
    clipping_planes_fragment: NS,
    clipping_planes_pars_fragment: zS,
    clipping_planes_pars_vertex: BS,
    clipping_planes_vertex: FS,
    color_fragment: kS,
    color_pars_fragment: VS,
    color_pars_vertex: HS,
    color_vertex: GS,
    common: jS,
    cube_uv_reflection_fragment: WS,
    defaultnormal_vertex: qS,
    displacementmap_pars_vertex: XS,
    displacementmap_vertex: $S,
    emissivemap_fragment: YS,
    emissivemap_pars_fragment: ZS,
    colorspace_fragment: KS,
    colorspace_pars_fragment: JS,
    envmap_fragment: QS,
    envmap_common_pars_fragment: eM,
    envmap_pars_fragment: tM,
    envmap_pars_vertex: iM,
    envmap_physical_pars_fragment: pM,
    envmap_vertex: nM,
    fog_vertex: rM,
    fog_pars_vertex: sM,
    fog_fragment: aM,
    fog_pars_fragment: oM,
    gradientmap_pars_fragment: lM,
    lightmap_fragment: cM,
    lightmap_pars_fragment: hM,
    lights_lambert_fragment: uM,
    lights_lambert_pars_fragment: dM,
    lights_pars_begin: fM,
    lights_toon_fragment: mM,
    lights_toon_pars_fragment: gM,
    lights_phong_fragment: vM,
    lights_phong_pars_fragment: yM,
    lights_physical_fragment: xM,
    lights_physical_pars_fragment: _M,
    lights_fragment_begin: bM,
    lights_fragment_maps: wM,
    lights_fragment_end: SM,
    logdepthbuf_fragment: MM,
    logdepthbuf_pars_fragment: EM,
    logdepthbuf_pars_vertex: TM,
    logdepthbuf_vertex: AM,
    map_fragment: CM,
    map_pars_fragment: PM,
    map_particle_fragment: LM,
    map_particle_pars_fragment: DM,
    metalnessmap_fragment: RM,
    metalnessmap_pars_fragment: OM,
    morphcolor_vertex: IM,
    morphnormal_vertex: UM,
    morphtarget_pars_vertex: NM,
    morphtarget_vertex: zM,
    normal_fragment_begin: BM,
    normal_fragment_maps: FM,
    normal_pars_fragment: kM,
    normal_pars_vertex: VM,
    normal_vertex: HM,
    normalmap_pars_fragment: GM,
    clearcoat_normal_fragment_begin: jM,
    clearcoat_normal_fragment_maps: WM,
    clearcoat_pars_fragment: qM,
    iridescence_pars_fragment: XM,
    opaque_fragment: $M,
    packing: YM,
    premultiplied_alpha_fragment: ZM,
    project_vertex: KM,
    dithering_fragment: JM,
    dithering_pars_fragment: QM,
    roughnessmap_fragment: e2,
    roughnessmap_pars_fragment: t2,
    shadowmap_pars_fragment: i2,
    shadowmap_pars_vertex: n2,
    shadowmap_vertex: r2,
    shadowmask_pars_fragment: s2,
    skinbase_vertex: a2,
    skinning_pars_vertex: o2,
    skinning_vertex: l2,
    skinnormal_vertex: c2,
    specularmap_fragment: h2,
    specularmap_pars_fragment: u2,
    tonemapping_fragment: d2,
    tonemapping_pars_fragment: f2,
    transmission_fragment: p2,
    transmission_pars_fragment: m2,
    uv_pars_fragment: g2,
    uv_pars_vertex: v2,
    uv_vertex: y2,
    worldpos_vertex: x2,
    background_vert: _2,
    background_frag: b2,
    backgroundCube_vert: w2,
    backgroundCube_frag: S2,
    cube_vert: M2,
    cube_frag: E2,
    depth_vert: T2,
    depth_frag: A2,
    distanceRGBA_vert: C2,
    distanceRGBA_frag: P2,
    equirect_vert: L2,
    equirect_frag: D2,
    linedashed_vert: R2,
    linedashed_frag: O2,
    meshbasic_vert: I2,
    meshbasic_frag: U2,
    meshlambert_vert: N2,
    meshlambert_frag: z2,
    meshmatcap_vert: B2,
    meshmatcap_frag: F2,
    meshnormal_vert: k2,
    meshnormal_frag: V2,
    meshphong_vert: H2,
    meshphong_frag: G2,
    meshphysical_vert: j2,
    meshphysical_frag: W2,
    meshtoon_vert: q2,
    meshtoon_frag: X2,
    points_vert: $2,
    points_frag: Y2,
    shadow_vert: Z2,
    shadow_frag: K2,
    sprite_vert: J2,
    sprite_frag: Q2,
  },
  Pe = {
    common: {
      diffuse: { value: new tt(16777215) },
      opacity: { value: 1 },
      map: { value: null },
      mapTransform: { value: new ft() },
      alphaMap: { value: null },
      alphaMapTransform: { value: new ft() },
      alphaTest: { value: 0 },
    },
    specularmap: {
      specularMap: { value: null },
      specularMapTransform: { value: new ft() },
    },
    envmap: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
      reflectivity: { value: 1 },
      ior: { value: 1.5 },
      refractionRatio: { value: 0.98 },
    },
    aomap: {
      aoMap: { value: null },
      aoMapIntensity: { value: 1 },
      aoMapTransform: { value: new ft() },
    },
    lightmap: {
      lightMap: { value: null },
      lightMapIntensity: { value: 1 },
      lightMapTransform: { value: new ft() },
    },
    bumpmap: {
      bumpMap: { value: null },
      bumpMapTransform: { value: new ft() },
      bumpScale: { value: 1 },
    },
    normalmap: {
      normalMap: { value: null },
      normalMapTransform: { value: new ft() },
      normalScale: { value: new J(1, 1) },
    },
    displacementmap: {
      displacementMap: { value: null },
      displacementMapTransform: { value: new ft() },
      displacementScale: { value: 1 },
      displacementBias: { value: 0 },
    },
    emissivemap: {
      emissiveMap: { value: null },
      emissiveMapTransform: { value: new ft() },
    },
    metalnessmap: {
      metalnessMap: { value: null },
      metalnessMapTransform: { value: new ft() },
    },
    roughnessmap: {
      roughnessMap: { value: null },
      roughnessMapTransform: { value: new ft() },
    },
    gradientmap: { gradientMap: { value: null } },
    fog: {
      fogDensity: { value: 25e-5 },
      fogNear: { value: 1 },
      fogFar: { value: 2e3 },
      fogColor: { value: new tt(16777215) },
    },
    lights: {
      ambientLightColor: { value: [] },
      lightProbe: { value: [] },
      directionalLights: {
        value: [],
        properties: { direction: {}, color: {} },
      },
      directionalLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      directionalShadowMap: { value: [] },
      directionalShadowMatrix: { value: [] },
      spotLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          direction: {},
          distance: {},
          coneCos: {},
          penumbraCos: {},
          decay: {},
        },
      },
      spotLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      spotLightMap: { value: [] },
      spotShadowMap: { value: [] },
      spotLightMatrix: { value: [] },
      pointLights: {
        value: [],
        properties: { color: {}, position: {}, decay: {}, distance: {} },
      },
      pointLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
          shadowCameraNear: {},
          shadowCameraFar: {},
        },
      },
      pointShadowMap: { value: [] },
      pointShadowMatrix: { value: [] },
      hemisphereLights: {
        value: [],
        properties: { direction: {}, skyColor: {}, groundColor: {} },
      },
      rectAreaLights: {
        value: [],
        properties: { color: {}, position: {}, width: {}, height: {} },
      },
      ltc_1: { value: null },
      ltc_2: { value: null },
    },
    points: {
      diffuse: { value: new tt(16777215) },
      opacity: { value: 1 },
      size: { value: 1 },
      scale: { value: 1 },
      map: { value: null },
      alphaMap: { value: null },
      alphaMapTransform: { value: new ft() },
      alphaTest: { value: 0 },
      uvTransform: { value: new ft() },
    },
    sprite: {
      diffuse: { value: new tt(16777215) },
      opacity: { value: 1 },
      center: { value: new J(0.5, 0.5) },
      rotation: { value: 0 },
      map: { value: null },
      mapTransform: { value: new ft() },
      alphaMap: { value: null },
      alphaMapTransform: { value: new ft() },
      alphaTest: { value: 0 },
    },
  },
  Nn = {
    basic: {
      uniforms: Fi([
        Pe.common,
        Pe.specularmap,
        Pe.envmap,
        Pe.aomap,
        Pe.lightmap,
        Pe.fog,
      ]),
      vertexShader: ct.meshbasic_vert,
      fragmentShader: ct.meshbasic_frag,
    },
    lambert: {
      uniforms: Fi([
        Pe.common,
        Pe.specularmap,
        Pe.envmap,
        Pe.aomap,
        Pe.lightmap,
        Pe.emissivemap,
        Pe.bumpmap,
        Pe.normalmap,
        Pe.displacementmap,
        Pe.fog,
        Pe.lights,
        { emissive: { value: new tt(0) } },
      ]),
      vertexShader: ct.meshlambert_vert,
      fragmentShader: ct.meshlambert_frag,
    },
    phong: {
      uniforms: Fi([
        Pe.common,
        Pe.specularmap,
        Pe.envmap,
        Pe.aomap,
        Pe.lightmap,
        Pe.emissivemap,
        Pe.bumpmap,
        Pe.normalmap,
        Pe.displacementmap,
        Pe.fog,
        Pe.lights,
        {
          emissive: { value: new tt(0) },
          specular: { value: new tt(1118481) },
          shininess: { value: 30 },
        },
      ]),
      vertexShader: ct.meshphong_vert,
      fragmentShader: ct.meshphong_frag,
    },
    standard: {
      uniforms: Fi([
        Pe.common,
        Pe.envmap,
        Pe.aomap,
        Pe.lightmap,
        Pe.emissivemap,
        Pe.bumpmap,
        Pe.normalmap,
        Pe.displacementmap,
        Pe.roughnessmap,
        Pe.metalnessmap,
        Pe.fog,
        Pe.lights,
        {
          emissive: { value: new tt(0) },
          roughness: { value: 1 },
          metalness: { value: 0 },
          envMapIntensity: { value: 1 },
        },
      ]),
      vertexShader: ct.meshphysical_vert,
      fragmentShader: ct.meshphysical_frag,
    },
    toon: {
      uniforms: Fi([
        Pe.common,
        Pe.aomap,
        Pe.lightmap,
        Pe.emissivemap,
        Pe.bumpmap,
        Pe.normalmap,
        Pe.displacementmap,
        Pe.gradientmap,
        Pe.fog,
        Pe.lights,
        { emissive: { value: new tt(0) } },
      ]),
      vertexShader: ct.meshtoon_vert,
      fragmentShader: ct.meshtoon_frag,
    },
    matcap: {
      uniforms: Fi([
        Pe.common,
        Pe.bumpmap,
        Pe.normalmap,
        Pe.displacementmap,
        Pe.fog,
        { matcap: { value: null } },
      ]),
      vertexShader: ct.meshmatcap_vert,
      fragmentShader: ct.meshmatcap_frag,
    },
    points: {
      uniforms: Fi([Pe.points, Pe.fog]),
      vertexShader: ct.points_vert,
      fragmentShader: ct.points_frag,
    },
    dashed: {
      uniforms: Fi([
        Pe.common,
        Pe.fog,
        {
          scale: { value: 1 },
          dashSize: { value: 1 },
          totalSize: { value: 2 },
        },
      ]),
      vertexShader: ct.linedashed_vert,
      fragmentShader: ct.linedashed_frag,
    },
    depth: {
      uniforms: Fi([Pe.common, Pe.displacementmap]),
      vertexShader: ct.depth_vert,
      fragmentShader: ct.depth_frag,
    },
    normal: {
      uniforms: Fi([
        Pe.common,
        Pe.bumpmap,
        Pe.normalmap,
        Pe.displacementmap,
        { opacity: { value: 1 } },
      ]),
      vertexShader: ct.meshnormal_vert,
      fragmentShader: ct.meshnormal_frag,
    },
    sprite: {
      uniforms: Fi([Pe.sprite, Pe.fog]),
      vertexShader: ct.sprite_vert,
      fragmentShader: ct.sprite_frag,
    },
    background: {
      uniforms: {
        uvTransform: { value: new ft() },
        t2D: { value: null },
        backgroundIntensity: { value: 1 },
      },
      vertexShader: ct.background_vert,
      fragmentShader: ct.background_frag,
    },
    backgroundCube: {
      uniforms: {
        envMap: { value: null },
        flipEnvMap: { value: -1 },
        backgroundBlurriness: { value: 0 },
        backgroundIntensity: { value: 1 },
      },
      vertexShader: ct.backgroundCube_vert,
      fragmentShader: ct.backgroundCube_frag,
    },
    cube: {
      uniforms: {
        tCube: { value: null },
        tFlip: { value: -1 },
        opacity: { value: 1 },
      },
      vertexShader: ct.cube_vert,
      fragmentShader: ct.cube_frag,
    },
    equirect: {
      uniforms: { tEquirect: { value: null } },
      vertexShader: ct.equirect_vert,
      fragmentShader: ct.equirect_frag,
    },
    distanceRGBA: {
      uniforms: Fi([
        Pe.common,
        Pe.displacementmap,
        {
          referencePosition: { value: new A() },
          nearDistance: { value: 1 },
          farDistance: { value: 1e3 },
        },
      ]),
      vertexShader: ct.distanceRGBA_vert,
      fragmentShader: ct.distanceRGBA_frag,
    },
    shadow: {
      uniforms: Fi([
        Pe.lights,
        Pe.fog,
        { color: { value: new tt(0) }, opacity: { value: 1 } },
      ]),
      vertexShader: ct.shadow_vert,
      fragmentShader: ct.shadow_frag,
    },
  };
Nn.physical = {
  uniforms: Fi([
    Nn.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: new ft() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: new ft() },
      clearcoatNormalScale: { value: new J(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: new ft() },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: new ft() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: new ft() },
      sheen: { value: 0 },
      sheenColor: { value: new tt(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: new ft() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: new ft() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: new ft() },
      transmissionSamplerSize: { value: new J() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: new ft() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: new tt(0) },
      specularColor: { value: new tt(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: new ft() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: new ft() },
      anisotropyVector: { value: new J() },
      anisotropyMap: { value: null },
      anisotropyMapTransform: { value: new ft() },
    },
  ]),
  vertexShader: ct.meshphysical_vert,
  fragmentShader: ct.meshphysical_frag,
};
const Yl = { r: 0, b: 0, g: 0 };
function eE(t, e, i, n, r, s, a) {
  const o = new tt(0);
  let l = s === !0 ? 0 : 1,
    c,
    d,
    h = null,
    u = 0,
    f = null;
  function p(g, m) {
    let x = !1,
      y = m.isScene === !0 ? m.background : null;
    switch (
      (y && y.isTexture && (y = (m.backgroundBlurriness > 0 ? i : e).get(y)),
      y === null ? v(o, l) : y && y.isColor && (v(y, 1), (x = !0)),
      t.xr.getEnvironmentBlendMode())
    ) {
      case "opaque":
        x = !0;
        break;
      case "additive":
        n.buffers.color.setClear(0, 0, 0, 1, a), (x = !0);
        break;
      case "alpha-blend":
        n.buffers.color.setClear(0, 0, 0, 0, a), (x = !0);
        break;
    }
    (t.autoClear || x) &&
      t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil),
      y && (y.isCubeTexture || y.mapping === gl)
        ? (d === void 0 &&
            ((d = new Fn(
              new $n(1, 1, 1),
              new Ti({
                name: "BackgroundCubeMaterial",
                uniforms: Ya(Nn.backgroundCube.uniforms),
                vertexShader: Nn.backgroundCube.vertexShader,
                fragmentShader: Nn.backgroundCube.fragmentShader,
                side: nn,
                depthTest: !1,
                depthWrite: !1,
                fog: !1,
              })
            )),
            d.geometry.deleteAttribute("normal"),
            d.geometry.deleteAttribute("uv"),
            (d.onBeforeRender = function (b, E, T) {
              this.matrixWorld.copyPosition(T.matrixWorld);
            }),
            Object.defineProperty(d.material, "envMap", {
              get: function () {
                return this.uniforms.envMap.value;
              },
            }),
            r.update(d)),
          (d.material.uniforms.envMap.value = y),
          (d.material.uniforms.flipEnvMap.value =
            y.isCubeTexture && y.isRenderTargetTexture === !1 ? -1 : 1),
          (d.material.uniforms.backgroundBlurriness.value =
            m.backgroundBlurriness),
          (d.material.uniforms.backgroundIntensity.value =
            m.backgroundIntensity),
          (d.material.toneMapped = y.colorSpace !== gt),
          (h !== y || u !== y.version || f !== t.toneMapping) &&
            ((d.material.needsUpdate = !0),
            (h = y),
            (u = y.version),
            (f = t.toneMapping)),
          d.layers.enableAll(),
          g.unshift(d, d.geometry, d.material, 0, 0, null))
        : y &&
          y.isTexture &&
          (c === void 0 &&
            ((c = new Fn(
              new yl(2, 2),
              new Ti({
                name: "BackgroundMaterial",
                uniforms: Ya(Nn.background.uniforms),
                vertexShader: Nn.background.vertexShader,
                fragmentShader: Nn.background.fragmentShader,
                side: ds,
                depthTest: !1,
                depthWrite: !1,
                fog: !1,
              })
            )),
            c.geometry.deleteAttribute("normal"),
            Object.defineProperty(c.material, "map", {
              get: function () {
                return this.uniforms.t2D.value;
              },
            }),
            r.update(c)),
          (c.material.uniforms.t2D.value = y),
          (c.material.uniforms.backgroundIntensity.value =
            m.backgroundIntensity),
          (c.material.toneMapped = y.colorSpace !== gt),
          y.matrixAutoUpdate === !0 && y.updateMatrix(),
          c.material.uniforms.uvTransform.value.copy(y.matrix),
          (h !== y || u !== y.version || f !== t.toneMapping) &&
            ((c.material.needsUpdate = !0),
            (h = y),
            (u = y.version),
            (f = t.toneMapping)),
          c.layers.enableAll(),
          g.unshift(c, c.geometry, c.material, 0, 0, null));
  }
  function v(g, m) {
    g.getRGB(Yl, cx(t)), n.buffers.color.setClear(Yl.r, Yl.g, Yl.b, m, a);
  }
  return {
    getClearColor: function () {
      return o;
    },
    setClearColor: function (g, m = 1) {
      o.set(g), (l = m), v(o, l);
    },
    getClearAlpha: function () {
      return l;
    },
    setClearAlpha: function (g) {
      (l = g), v(o, l);
    },
    render: p,
  };
}
function tE(t, e, i, n) {
  const r = t.getParameter(t.MAX_VERTEX_ATTRIBS),
    s = n.isWebGL2 ? null : e.get("OES_vertex_array_object"),
    a = n.isWebGL2 || s !== null,
    o = {},
    l = g(null);
  let c = l,
    d = !1;
  function h(R, I, W, N, U) {
    let G = !1;
    if (a) {
      const k = v(N, W, I);
      c !== k && ((c = k), f(c.object)),
        (G = m(R, N, W, U)),
        G && x(R, N, W, U);
    } else {
      const k = I.wireframe === !0;
      (c.geometry !== N.id || c.program !== W.id || c.wireframe !== k) &&
        ((c.geometry = N.id), (c.program = W.id), (c.wireframe = k), (G = !0));
    }
    U !== null && i.update(U, t.ELEMENT_ARRAY_BUFFER),
      (G || d) &&
        ((d = !1),
        T(R, I, W, N),
        U !== null && t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, i.get(U).buffer));
  }
  function u() {
    return n.isWebGL2 ? t.createVertexArray() : s.createVertexArrayOES();
  }
  function f(R) {
    return n.isWebGL2 ? t.bindVertexArray(R) : s.bindVertexArrayOES(R);
  }
  function p(R) {
    return n.isWebGL2 ? t.deleteVertexArray(R) : s.deleteVertexArrayOES(R);
  }
  function v(R, I, W) {
    const N = W.wireframe === !0;
    let U = o[R.id];
    U === void 0 && ((U = {}), (o[R.id] = U));
    let G = U[I.id];
    G === void 0 && ((G = {}), (U[I.id] = G));
    let k = G[N];
    return k === void 0 && ((k = g(u())), (G[N] = k)), k;
  }
  function g(R) {
    const I = [],
      W = [],
      N = [];
    for (let U = 0; U < r; U++) (I[U] = 0), (W[U] = 0), (N[U] = 0);
    return {
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: I,
      enabledAttributes: W,
      attributeDivisors: N,
      object: R,
      attributes: {},
      index: null,
    };
  }
  function m(R, I, W, N) {
    const U = c.attributes,
      G = I.attributes;
    let k = 0;
    const B = W.getAttributes();
    for (const V in B)
      if (B[V].location >= 0) {
        const H = U[V];
        let j = G[V];
        if (
          (j === void 0 &&
            (V === "instanceMatrix" &&
              R.instanceMatrix &&
              (j = R.instanceMatrix),
            V === "instanceColor" && R.instanceColor && (j = R.instanceColor)),
          H === void 0 || H.attribute !== j || (j && H.data !== j.data))
        )
          return !0;
        k++;
      }
    return c.attributesNum !== k || c.index !== N;
  }
  function x(R, I, W, N) {
    const U = {},
      G = I.attributes;
    let k = 0;
    const B = W.getAttributes();
    for (const V in B)
      if (B[V].location >= 0) {
        let H = G[V];
        H === void 0 &&
          (V === "instanceMatrix" && R.instanceMatrix && (H = R.instanceMatrix),
          V === "instanceColor" && R.instanceColor && (H = R.instanceColor));
        const j = {};
        (j.attribute = H), H && H.data && (j.data = H.data), (U[V] = j), k++;
      }
    (c.attributes = U), (c.attributesNum = k), (c.index = N);
  }
  function y() {
    const R = c.newAttributes;
    for (let I = 0, W = R.length; I < W; I++) R[I] = 0;
  }
  function _(R) {
    M(R, 0);
  }
  function M(R, I) {
    const W = c.newAttributes,
      N = c.enabledAttributes,
      U = c.attributeDivisors;
    (W[R] = 1),
      N[R] === 0 && (t.enableVertexAttribArray(R), (N[R] = 1)),
      U[R] !== I &&
        ((n.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[
          n.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"
        ](R, I),
        (U[R] = I));
  }
  function b() {
    const R = c.newAttributes,
      I = c.enabledAttributes;
    for (let W = 0, N = I.length; W < N; W++)
      I[W] !== R[W] && (t.disableVertexAttribArray(W), (I[W] = 0));
  }
  function E(R, I, W, N, U, G, k) {
    k === !0
      ? t.vertexAttribIPointer(R, I, W, U, G)
      : t.vertexAttribPointer(R, I, W, N, U, G);
  }
  function T(R, I, W, N) {
    if (
      n.isWebGL2 === !1 &&
      (R.isInstancedMesh || N.isInstancedBufferGeometry) &&
      e.get("ANGLE_instanced_arrays") === null
    )
      return;
    y();
    const U = N.attributes,
      G = W.getAttributes(),
      k = I.defaultAttributeValues;
    for (const B in G) {
      const V = G[B];
      if (V.location >= 0) {
        let X = U[B];
        if (
          (X === void 0 &&
            (B === "instanceMatrix" &&
              R.instanceMatrix &&
              (X = R.instanceMatrix),
            B === "instanceColor" && R.instanceColor && (X = R.instanceColor)),
          X !== void 0)
        ) {
          const H = X.normalized,
            j = X.itemSize,
            Y = i.get(X);
          if (Y === void 0) continue;
          const ee = Y.buffer,
            Z = Y.type,
            K = Y.bytesPerElement,
            me =
              n.isWebGL2 === !0 &&
              (Z === t.INT || Z === t.UNSIGNED_INT || X.gpuType === qy);
          if (X.isInterleavedBufferAttribute) {
            const re = X.data,
              F = re.stride,
              Te = X.offset;
            if (re.isInstancedInterleavedBuffer) {
              for (let be = 0; be < V.locationSize; be++)
                M(V.location + be, re.meshPerAttribute);
              R.isInstancedMesh !== !0 &&
                N._maxInstanceCount === void 0 &&
                (N._maxInstanceCount = re.meshPerAttribute * re.count);
            } else
              for (let be = 0; be < V.locationSize; be++) _(V.location + be);
            t.bindBuffer(t.ARRAY_BUFFER, ee);
            for (let be = 0; be < V.locationSize; be++)
              E(
                V.location + be,
                j / V.locationSize,
                Z,
                H,
                F * K,
                (Te + (j / V.locationSize) * be) * K,
                me
              );
          } else {
            if (X.isInstancedBufferAttribute) {
              for (let re = 0; re < V.locationSize; re++)
                M(V.location + re, X.meshPerAttribute);
              R.isInstancedMesh !== !0 &&
                N._maxInstanceCount === void 0 &&
                (N._maxInstanceCount = X.meshPerAttribute * X.count);
            } else
              for (let re = 0; re < V.locationSize; re++) _(V.location + re);
            t.bindBuffer(t.ARRAY_BUFFER, ee);
            for (let re = 0; re < V.locationSize; re++)
              E(
                V.location + re,
                j / V.locationSize,
                Z,
                H,
                j * K,
                (j / V.locationSize) * re * K,
                me
              );
          }
        } else if (k !== void 0) {
          const H = k[B];
          if (H !== void 0)
            switch (H.length) {
              case 2:
                t.vertexAttrib2fv(V.location, H);
                break;
              case 3:
                t.vertexAttrib3fv(V.location, H);
                break;
              case 4:
                t.vertexAttrib4fv(V.location, H);
                break;
              default:
                t.vertexAttrib1fv(V.location, H);
            }
        }
      }
    }
    b();
  }
  function S() {
    L();
    for (const R in o) {
      const I = o[R];
      for (const W in I) {
        const N = I[W];
        for (const U in N) p(N[U].object), delete N[U];
        delete I[W];
      }
      delete o[R];
    }
  }
  function w(R) {
    if (o[R.id] === void 0) return;
    const I = o[R.id];
    for (const W in I) {
      const N = I[W];
      for (const U in N) p(N[U].object), delete N[U];
      delete I[W];
    }
    delete o[R.id];
  }
  function C(R) {
    for (const I in o) {
      const W = o[I];
      if (W[R.id] === void 0) continue;
      const N = W[R.id];
      for (const U in N) p(N[U].object), delete N[U];
      delete W[R.id];
    }
  }
  function L() {
    P(), (d = !0), c !== l && ((c = l), f(c.object));
  }
  function P() {
    (l.geometry = null), (l.program = null), (l.wireframe = !1);
  }
  return {
    setup: h,
    reset: L,
    resetDefaultState: P,
    dispose: S,
    releaseStatesOfGeometry: w,
    releaseStatesOfProgram: C,
    initAttributes: y,
    enableAttribute: _,
    disableUnusedAttributes: b,
  };
}
function iE(t, e, i, n) {
  const r = n.isWebGL2;
  let s;
  function a(c) {
    s = c;
  }
  function o(c, d) {
    t.drawArrays(s, c, d), i.update(d, s, 1);
  }
  function l(c, d, h) {
    if (h === 0) return;
    let u, f;
    if (r) (u = t), (f = "drawArraysInstanced");
    else if (
      ((u = e.get("ANGLE_instanced_arrays")),
      (f = "drawArraysInstancedANGLE"),
      u === null)
    ) {
      console.error(
        "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
      );
      return;
    }
    u[f](s, c, d, h), i.update(d, s, h);
  }
  (this.setMode = a), (this.render = o), (this.renderInstances = l);
}
function nE(t, e, i) {
  let n;
  function r() {
    if (n !== void 0) return n;
    if (e.has("EXT_texture_filter_anisotropic") === !0) {
      const E = e.get("EXT_texture_filter_anisotropic");
      n = t.getParameter(E.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else n = 0;
    return n;
  }
  function s(E) {
    if (E === "highp") {
      if (
        t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.HIGH_FLOAT).precision >
          0 &&
        t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT).precision >
          0
      )
        return "highp";
      E = "mediump";
    }
    return E === "mediump" &&
      t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.MEDIUM_FLOAT).precision >
        0 &&
      t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.MEDIUM_FLOAT).precision >
        0
      ? "mediump"
      : "lowp";
  }
  const a =
    typeof WebGL2RenderingContext < "u" &&
    t.constructor.name === "WebGL2RenderingContext";
  let o = i.precision !== void 0 ? i.precision : "highp";
  const l = s(o);
  l !== o &&
    (console.warn(
      "THREE.WebGLRenderer:",
      o,
      "not supported, using",
      l,
      "instead."
    ),
    (o = l));
  const c = a || e.has("WEBGL_draw_buffers"),
    d = i.logarithmicDepthBuffer === !0,
    h = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),
    u = t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
    f = t.getParameter(t.MAX_TEXTURE_SIZE),
    p = t.getParameter(t.MAX_CUBE_MAP_TEXTURE_SIZE),
    v = t.getParameter(t.MAX_VERTEX_ATTRIBS),
    g = t.getParameter(t.MAX_VERTEX_UNIFORM_VECTORS),
    m = t.getParameter(t.MAX_VARYING_VECTORS),
    x = t.getParameter(t.MAX_FRAGMENT_UNIFORM_VECTORS),
    y = u > 0,
    _ = a || e.has("OES_texture_float"),
    M = y && _,
    b = a ? t.getParameter(t.MAX_SAMPLES) : 0;
  return {
    isWebGL2: a,
    drawBuffers: c,
    getMaxAnisotropy: r,
    getMaxPrecision: s,
    precision: o,
    logarithmicDepthBuffer: d,
    maxTextures: h,
    maxVertexTextures: u,
    maxTextureSize: f,
    maxCubemapSize: p,
    maxAttributes: v,
    maxVertexUniforms: g,
    maxVaryings: m,
    maxFragmentUniforms: x,
    vertexTextures: y,
    floatFragmentTextures: _,
    floatVertexTextures: M,
    maxSamples: b,
  };
}
function rE(t) {
  const e = this;
  let i = null,
    n = 0,
    r = !1,
    s = !1;
  const a = new qr(),
    o = new ft(),
    l = { value: null, needsUpdate: !1 };
  (this.uniform = l),
    (this.numPlanes = 0),
    (this.numIntersection = 0),
    (this.init = function (h, u) {
      const f = h.length !== 0 || u || n !== 0 || r;
      return (r = u), (n = h.length), f;
    }),
    (this.beginShadows = function () {
      (s = !0), d(null);
    }),
    (this.endShadows = function () {
      s = !1;
    }),
    (this.setGlobalState = function (h, u) {
      i = d(h, u, 0);
    }),
    (this.setState = function (h, u, f) {
      const p = h.clippingPlanes,
        v = h.clipIntersection,
        g = h.clipShadows,
        m = t.get(h);
      if (!r || p === null || p.length === 0 || (s && !g)) s ? d(null) : c();
      else {
        const x = s ? 0 : n,
          y = x * 4;
        let _ = m.clippingState || null;
        (l.value = _), (_ = d(p, u, y, f));
        for (let M = 0; M !== y; ++M) _[M] = i[M];
        (m.clippingState = _),
          (this.numIntersection = v ? this.numPlanes : 0),
          (this.numPlanes += x);
      }
    });
  function c() {
    l.value !== i && ((l.value = i), (l.needsUpdate = n > 0)),
      (e.numPlanes = n),
      (e.numIntersection = 0);
  }
  function d(h, u, f, p) {
    const v = h !== null ? h.length : 0;
    let g = null;
    if (v !== 0) {
      if (((g = l.value), p !== !0 || g === null)) {
        const m = f + v * 4,
          x = u.matrixWorldInverse;
        o.getNormalMatrix(x),
          (g === null || g.length < m) && (g = new Float32Array(m));
        for (let y = 0, _ = f; y !== v; ++y, _ += 4)
          a.copy(h[y]).applyMatrix4(x, o),
            a.normal.toArray(g, _),
            (g[_ + 3] = a.constant);
      }
      (l.value = g), (l.needsUpdate = !0);
    }
    return (e.numPlanes = v), (e.numIntersection = 0), g;
  }
}
function sE(t) {
  let e = new WeakMap();
  function i(a, o) {
    return o === pd ? (a.mapping = Hs) : o === md && (a.mapping = Gs), a;
  }
  function n(a) {
    if (a && a.isTexture && a.isRenderTargetTexture === !1) {
      const o = a.mapping;
      if (o === pd || o === md)
        if (e.has(a)) {
          const l = e.get(a).texture;
          return i(l, a.mapping);
        } else {
          const l = a.image;
          if (l && l.height > 0) {
            const c = new xS(l.height / 2);
            return (
              c.fromEquirectangularTexture(t, a),
              e.set(a, c),
              a.addEventListener("dispose", r),
              i(c.texture, a.mapping)
            );
          } else return null;
        }
    }
    return a;
  }
  function r(a) {
    const o = a.target;
    o.removeEventListener("dispose", r);
    const l = e.get(o);
    l !== void 0 && (e.delete(o), l.dispose());
  }
  function s() {
    e = new WeakMap();
  }
  return { get: n, dispose: s };
}
class _h extends vl {
  constructor(e = -1, i = 1, n = 1, r = -1, s = 0.1, a = 2e3) {
    super(),
      (this.isOrthographicCamera = !0),
      (this.type = "OrthographicCamera"),
      (this.zoom = 1),
      (this.view = null),
      (this.left = e),
      (this.right = i),
      (this.top = n),
      (this.bottom = r),
      (this.near = s),
      (this.far = a),
      this.updateProjectionMatrix();
  }
  copy(e, i) {
    return (
      super.copy(e, i),
      (this.left = e.left),
      (this.right = e.right),
      (this.top = e.top),
      (this.bottom = e.bottom),
      (this.near = e.near),
      (this.far = e.far),
      (this.zoom = e.zoom),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      this
    );
  }
  setViewOffset(e, i, n, r, s, a) {
    this.view === null &&
      (this.view = {
        enabled: !0,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1,
      }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = i),
      (this.view.offsetX = n),
      (this.view.offsetY = r),
      (this.view.width = s),
      (this.view.height = a),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom),
      i = (this.top - this.bottom) / (2 * this.zoom),
      n = (this.right + this.left) / 2,
      r = (this.top + this.bottom) / 2;
    let s = n - e,
      a = n + e,
      o = r + i,
      l = r - i;
    if (this.view !== null && this.view.enabled) {
      const c = (this.right - this.left) / this.view.fullWidth / this.zoom,
        d = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      (s += c * this.view.offsetX),
        (a = s + c * this.view.width),
        (o -= d * this.view.offsetY),
        (l = o - d * this.view.height);
    }
    this.projectionMatrix.makeOrthographic(
      s,
      a,
      o,
      l,
      this.near,
      this.far,
      this.coordinateSystem
    ),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const i = super.toJSON(e);
    return (
      (i.object.zoom = this.zoom),
      (i.object.left = this.left),
      (i.object.right = this.right),
      (i.object.top = this.top),
      (i.object.bottom = this.bottom),
      (i.object.near = this.near),
      (i.object.far = this.far),
      this.view !== null && (i.object.view = Object.assign({}, this.view)),
      i
    );
  }
}
const La = 4,
  Qm = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
  Rs = 20,
  xu = new _h(),
  eg = new tt();
let _u = null;
const Cs = (1 + Math.sqrt(5)) / 2,
  xa = 1 / Cs,
  tg = [
    new A(1, 1, 1),
    new A(-1, 1, 1),
    new A(1, 1, -1),
    new A(-1, 1, -1),
    new A(0, Cs, xa),
    new A(0, Cs, -xa),
    new A(xa, 0, Cs),
    new A(-xa, 0, Cs),
    new A(Cs, xa, 0),
    new A(-Cs, xa, 0),
  ];
class ig {
  constructor(e) {
    (this._renderer = e),
      (this._pingPongRenderTarget = null),
      (this._lodMax = 0),
      (this._cubeSize = 0),
      (this._lodPlanes = []),
      (this._sizeLods = []),
      (this._sigmas = []),
      (this._blurMaterial = null),
      (this._cubemapMaterial = null),
      (this._equirectMaterial = null),
      this._compileMaterial(this._blurMaterial);
  }
  fromScene(e, i = 0, n = 0.1, r = 100) {
    (_u = this._renderer.getRenderTarget()), this._setSize(256);
    const s = this._allocateTargets();
    return (
      (s.depthBuffer = !0),
      this._sceneToCubeUV(e, n, r, s),
      i > 0 && this._blur(s, 0, 0, i),
      this._applyPMREM(s),
      this._cleanup(s),
      s
    );
  }
  fromEquirectangular(e, i = null) {
    return this._fromTexture(e, i);
  }
  fromCubemap(e, i = null) {
    return this._fromTexture(e, i);
  }
  compileCubemapShader() {
    this._cubemapMaterial === null &&
      ((this._cubemapMaterial = sg()),
      this._compileMaterial(this._cubemapMaterial));
  }
  compileEquirectangularShader() {
    this._equirectMaterial === null &&
      ((this._equirectMaterial = rg()),
      this._compileMaterial(this._equirectMaterial));
  }
  dispose() {
    this._dispose(),
      this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
      this._equirectMaterial !== null && this._equirectMaterial.dispose();
  }
  _setSize(e) {
    (this._lodMax = Math.floor(Math.log2(e))),
      (this._cubeSize = Math.pow(2, this._lodMax));
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(),
      this._pingPongRenderTarget !== null &&
        this._pingPongRenderTarget.dispose();
    for (let e = 0; e < this._lodPlanes.length; e++)
      this._lodPlanes[e].dispose();
  }
  _cleanup(e) {
    this._renderer.setRenderTarget(_u),
      (e.scissorTest = !1),
      Zl(e, 0, 0, e.width, e.height);
  }
  _fromTexture(e, i) {
    e.mapping === Hs || e.mapping === Gs
      ? this._setSize(
          e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width
        )
      : this._setSize(e.image.width / 4),
      (_u = this._renderer.getRenderTarget());
    const n = i || this._allocateTargets();
    return (
      this._textureToCubeUV(e, n), this._applyPMREM(n), this._cleanup(n), n
    );
  }
  _allocateTargets() {
    const e = 3 * Math.max(this._cubeSize, 112),
      i = 4 * this._cubeSize,
      n = {
        magFilter: Zi,
        minFilter: Zi,
        generateMipmaps: !1,
        type: Mn,
        format: wn,
        colorSpace: qn,
        depthBuffer: !1,
      },
      r = ng(e, i, n);
    if (
      this._pingPongRenderTarget === null ||
      this._pingPongRenderTarget.width !== e ||
      this._pingPongRenderTarget.height !== i
    ) {
      this._pingPongRenderTarget !== null && this._dispose(),
        (this._pingPongRenderTarget = ng(e, i, n));
      const { _lodMax: s } = this;
      ({
        sizeLods: this._sizeLods,
        lodPlanes: this._lodPlanes,
        sigmas: this._sigmas,
      } = aE(s)),
        (this._blurMaterial = oE(s, e, i));
    }
    return r;
  }
  _compileMaterial(e) {
    const i = new Fn(this._lodPlanes[0], e);
    this._renderer.compile(i, xu);
  }
  _sceneToCubeUV(e, i, n, r) {
    const o = new ji(90, 1, i, n),
      l = [1, -1, 1, 1, 1, 1],
      c = [1, 1, 1, -1, -1, -1],
      d = this._renderer,
      h = d.autoClear,
      u = d.toneMapping;
    d.getClearColor(eg), (d.toneMapping = Nr), (d.autoClear = !1);
    const f = new co({
        name: "PMREM.Background",
        side: nn,
        depthWrite: !1,
        depthTest: !1,
      }),
      p = new Fn(new $n(), f);
    let v = !1;
    const g = e.background;
    g
      ? g.isColor && (f.color.copy(g), (e.background = null), (v = !0))
      : (f.color.copy(eg), (v = !0));
    for (let m = 0; m < 6; m++) {
      const x = m % 3;
      x === 0
        ? (o.up.set(0, l[m], 0), o.lookAt(c[m], 0, 0))
        : x === 1
        ? (o.up.set(0, 0, l[m]), o.lookAt(0, c[m], 0))
        : (o.up.set(0, l[m], 0), o.lookAt(0, 0, c[m]));
      const y = this._cubeSize;
      Zl(r, x * y, m > 2 ? y : 0, y, y),
        d.setRenderTarget(r),
        v && d.render(p, o),
        d.render(e, o);
    }
    p.geometry.dispose(),
      p.material.dispose(),
      (d.toneMapping = u),
      (d.autoClear = h),
      (e.background = g);
  }
  _textureToCubeUV(e, i) {
    const n = this._renderer,
      r = e.mapping === Hs || e.mapping === Gs;
    r
      ? (this._cubemapMaterial === null && (this._cubemapMaterial = sg()),
        (this._cubemapMaterial.uniforms.flipEnvMap.value =
          e.isRenderTargetTexture === !1 ? -1 : 1))
      : this._equirectMaterial === null && (this._equirectMaterial = rg());
    const s = r ? this._cubemapMaterial : this._equirectMaterial,
      a = new Fn(this._lodPlanes[0], s),
      o = s.uniforms;
    o.envMap.value = e;
    const l = this._cubeSize;
    Zl(i, 0, 0, 3 * l, 2 * l), n.setRenderTarget(i), n.render(a, xu);
  }
  _applyPMREM(e) {
    const i = this._renderer,
      n = i.autoClear;
    i.autoClear = !1;
    for (let r = 1; r < this._lodPlanes.length; r++) {
      const s = Math.sqrt(
          this._sigmas[r] * this._sigmas[r] -
            this._sigmas[r - 1] * this._sigmas[r - 1]
        ),
        a = tg[(r - 1) % tg.length];
      this._blur(e, r - 1, r, s, a);
    }
    i.autoClear = n;
  }
  _blur(e, i, n, r, s) {
    const a = this._pingPongRenderTarget;
    this._halfBlur(e, a, i, n, r, "latitudinal", s),
      this._halfBlur(a, e, n, n, r, "longitudinal", s);
  }
  _halfBlur(e, i, n, r, s, a, o) {
    const l = this._renderer,
      c = this._blurMaterial;
    a !== "latitudinal" &&
      a !== "longitudinal" &&
      console.error(
        "blur direction must be either latitudinal or longitudinal!"
      );
    const d = 3,
      h = new Fn(this._lodPlanes[r], c),
      u = c.uniforms,
      f = this._sizeLods[n] - 1,
      p = isFinite(s) ? Math.PI / (2 * f) : (2 * Math.PI) / (2 * Rs - 1),
      v = s / p,
      g = isFinite(s) ? 1 + Math.floor(d * v) : Rs;
    g > Rs &&
      console.warn(
        `sigmaRadians, ${s}, is too large and will clip, as it requested ${g} samples when the maximum is set to ${Rs}`
      );
    const m = [];
    let x = 0;
    for (let E = 0; E < Rs; ++E) {
      const T = E / v,
        S = Math.exp((-T * T) / 2);
      m.push(S), E === 0 ? (x += S) : E < g && (x += 2 * S);
    }
    for (let E = 0; E < m.length; E++) m[E] = m[E] / x;
    (u.envMap.value = e.texture),
      (u.samples.value = g),
      (u.weights.value = m),
      (u.latitudinal.value = a === "latitudinal"),
      o && (u.poleAxis.value = o);
    const { _lodMax: y } = this;
    (u.dTheta.value = p), (u.mipInt.value = y - n);
    const _ = this._sizeLods[r],
      M = 3 * _ * (r > y - La ? r - y + La : 0),
      b = 4 * (this._cubeSize - _);
    Zl(i, M, b, 3 * _, 2 * _), l.setRenderTarget(i), l.render(h, xu);
  }
}
function aE(t) {
  const e = [],
    i = [],
    n = [];
  let r = t;
  const s = t - La + 1 + Qm.length;
  for (let a = 0; a < s; a++) {
    const o = Math.pow(2, r);
    i.push(o);
    let l = 1 / o;
    a > t - La ? (l = Qm[a - t + La - 1]) : a === 0 && (l = 0), n.push(l);
    const c = 1 / (o - 2),
      d = -c,
      h = 1 + c,
      u = [d, d, h, d, h, h, d, d, h, h, d, h],
      f = 6,
      p = 6,
      v = 3,
      g = 2,
      m = 1,
      x = new Float32Array(v * p * f),
      y = new Float32Array(g * p * f),
      _ = new Float32Array(m * p * f);
    for (let b = 0; b < f; b++) {
      const E = ((b % 3) * 2) / 3 - 1,
        T = b > 2 ? 0 : -1,
        S = [
          E,
          T,
          0,
          E + 2 / 3,
          T,
          0,
          E + 2 / 3,
          T + 1,
          0,
          E,
          T,
          0,
          E + 2 / 3,
          T + 1,
          0,
          E,
          T + 1,
          0,
        ];
      x.set(S, v * p * b), y.set(u, g * p * b);
      const w = [b, b, b, b, b, b];
      _.set(w, m * p * b);
    }
    const M = new st();
    M.setAttribute("position", new pt(x, v)),
      M.setAttribute("uv", new pt(y, g)),
      M.setAttribute("faceIndex", new pt(_, m)),
      e.push(M),
      r > La && r--;
  }
  return { lodPlanes: e, sizeLods: i, sigmas: n };
}
function ng(t, e, i) {
  const n = new rn(t, e, i);
  return (
    (n.texture.mapping = gl),
    (n.texture.name = "PMREM.cubeUv"),
    (n.scissorTest = !0),
    n
  );
}
function Zl(t, e, i, n, r) {
  t.viewport.set(e, i, n, r), t.scissor.set(e, i, n, r);
}
function oE(t, e, i) {
  const n = new Float32Array(Rs),
    r = new A(0, 1, 0);
  return new Ti({
    name: "SphericalGaussianBlur",
    defines: {
      n: Rs,
      CUBEUV_TEXEL_WIDTH: 1 / e,
      CUBEUV_TEXEL_HEIGHT: 1 / i,
      CUBEUV_MAX_MIP: `${t}.0`,
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: n },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: r },
    },
    vertexShader: jf(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
    blending: Pi,
    depthTest: !1,
    depthWrite: !1,
  });
}
function rg() {
  return new Ti({
    name: "EquirectangularToCubeUV",
    uniforms: { envMap: { value: null } },
    vertexShader: jf(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
    blending: Pi,
    depthTest: !1,
    depthWrite: !1,
  });
}
function sg() {
  return new Ti({
    name: "CubemapToCubeUV",
    uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } },
    vertexShader: jf(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
    blending: Pi,
    depthTest: !1,
    depthWrite: !1,
  });
}
function jf() {
  return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
}
function lE(t) {
  let e = new WeakMap(),
    i = null;
  function n(o) {
    if (o && o.isTexture) {
      const l = o.mapping,
        c = l === pd || l === md,
        d = l === Hs || l === Gs;
      if (c || d)
        if (o.isRenderTargetTexture && o.needsPMREMUpdate === !0) {
          o.needsPMREMUpdate = !1;
          let h = e.get(o);
          return (
            i === null && (i = new ig(t)),
            (h = c ? i.fromEquirectangular(o, h) : i.fromCubemap(o, h)),
            e.set(o, h),
            h.texture
          );
        } else {
          if (e.has(o)) return e.get(o).texture;
          {
            const h = o.image;
            if ((c && h && h.height > 0) || (d && h && r(h))) {
              i === null && (i = new ig(t));
              const u = c ? i.fromEquirectangular(o) : i.fromCubemap(o);
              return e.set(o, u), o.addEventListener("dispose", s), u.texture;
            } else return null;
          }
        }
    }
    return o;
  }
  function r(o) {
    let l = 0;
    const c = 6;
    for (let d = 0; d < c; d++) o[d] !== void 0 && l++;
    return l === c;
  }
  function s(o) {
    const l = o.target;
    l.removeEventListener("dispose", s);
    const c = e.get(l);
    c !== void 0 && (e.delete(l), c.dispose());
  }
  function a() {
    (e = new WeakMap()), i !== null && (i.dispose(), (i = null));
  }
  return { get: n, dispose: a };
}
function cE(t) {
  const e = {};
  function i(n) {
    if (e[n] !== void 0) return e[n];
    let r;
    switch (n) {
      case "WEBGL_depth_texture":
        r =
          t.getExtension("WEBGL_depth_texture") ||
          t.getExtension("MOZ_WEBGL_depth_texture") ||
          t.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        r =
          t.getExtension("EXT_texture_filter_anisotropic") ||
          t.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
          t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        r =
          t.getExtension("WEBGL_compressed_texture_s3tc") ||
          t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
          t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        r =
          t.getExtension("WEBGL_compressed_texture_pvrtc") ||
          t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        r = t.getExtension(n);
    }
    return (e[n] = r), r;
  }
  return {
    has: function (n) {
      return i(n) !== null;
    },
    init: function (n) {
      n.isWebGL2
        ? i("EXT_color_buffer_float")
        : (i("WEBGL_depth_texture"),
          i("OES_texture_float"),
          i("OES_texture_half_float"),
          i("OES_texture_half_float_linear"),
          i("OES_standard_derivatives"),
          i("OES_element_index_uint"),
          i("OES_vertex_array_object"),
          i("ANGLE_instanced_arrays")),
        i("OES_texture_float_linear"),
        i("EXT_color_buffer_half_float"),
        i("WEBGL_multisampled_render_to_texture");
    },
    get: function (n) {
      const r = i(n);
      return (
        r === null &&
          console.warn(
            "THREE.WebGLRenderer: " + n + " extension not supported."
          ),
        r
      );
    },
  };
}
function hE(t, e, i, n) {
  const r = {},
    s = new WeakMap();
  function a(h) {
    const u = h.target;
    u.index !== null && e.remove(u.index);
    for (const p in u.attributes) e.remove(u.attributes[p]);
    for (const p in u.morphAttributes) {
      const v = u.morphAttributes[p];
      for (let g = 0, m = v.length; g < m; g++) e.remove(v[g]);
    }
    u.removeEventListener("dispose", a), delete r[u.id];
    const f = s.get(u);
    f && (e.remove(f), s.delete(u)),
      n.releaseStatesOfGeometry(u),
      u.isInstancedBufferGeometry === !0 && delete u._maxInstanceCount,
      i.memory.geometries--;
  }
  function o(h, u) {
    return (
      r[u.id] === !0 ||
        (u.addEventListener("dispose", a),
        (r[u.id] = !0),
        i.memory.geometries++),
      u
    );
  }
  function l(h) {
    const u = h.attributes;
    for (const p in u) e.update(u[p], t.ARRAY_BUFFER);
    const f = h.morphAttributes;
    for (const p in f) {
      const v = f[p];
      for (let g = 0, m = v.length; g < m; g++) e.update(v[g], t.ARRAY_BUFFER);
    }
  }
  function c(h) {
    const u = [],
      f = h.index,
      p = h.attributes.position;
    let v = 0;
    if (f !== null) {
      const x = f.array;
      v = f.version;
      for (let y = 0, _ = x.length; y < _; y += 3) {
        const M = x[y + 0],
          b = x[y + 1],
          E = x[y + 2];
        u.push(M, b, b, E, E, M);
      }
    } else {
      const x = p.array;
      v = p.version;
      for (let y = 0, _ = x.length / 3 - 1; y < _; y += 3) {
        const M = y + 0,
          b = y + 1,
          E = y + 2;
        u.push(M, b, b, E, E, M);
      }
    }
    const g = new (nx(u) ? za : lx)(u, 1);
    g.version = v;
    const m = s.get(h);
    m && e.remove(m), s.set(h, g);
  }
  function d(h) {
    const u = s.get(h);
    if (u) {
      const f = h.index;
      f !== null && u.version < f.version && c(h);
    } else c(h);
    return s.get(h);
  }
  return { get: o, update: l, getWireframeAttribute: d };
}
function uE(t, e, i, n) {
  const r = n.isWebGL2;
  let s;
  function a(u) {
    s = u;
  }
  let o, l;
  function c(u) {
    (o = u.type), (l = u.bytesPerElement);
  }
  function d(u, f) {
    t.drawElements(s, f, o, u * l), i.update(f, s, 1);
  }
  function h(u, f, p) {
    if (p === 0) return;
    let v, g;
    if (r) (v = t), (g = "drawElementsInstanced");
    else if (
      ((v = e.get("ANGLE_instanced_arrays")),
      (g = "drawElementsInstancedANGLE"),
      v === null)
    ) {
      console.error(
        "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
      );
      return;
    }
    v[g](s, f, o, u * l, p), i.update(f, s, p);
  }
  (this.setMode = a),
    (this.setIndex = c),
    (this.render = d),
    (this.renderInstances = h);
}
function dE(t) {
  const e = { geometries: 0, textures: 0 },
    i = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
  function n(s, a, o) {
    switch ((i.calls++, a)) {
      case t.TRIANGLES:
        i.triangles += o * (s / 3);
        break;
      case t.LINES:
        i.lines += o * (s / 2);
        break;
      case t.LINE_STRIP:
        i.lines += o * (s - 1);
        break;
      case t.LINE_LOOP:
        i.lines += o * s;
        break;
      case t.POINTS:
        i.points += o * s;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", a);
        break;
    }
  }
  function r() {
    (i.calls = 0), (i.triangles = 0), (i.points = 0), (i.lines = 0);
  }
  return {
    memory: e,
    render: i,
    programs: null,
    autoReset: !0,
    reset: r,
    update: n,
  };
}
function fE(t, e) {
  return t[0] - e[0];
}
function pE(t, e) {
  return Math.abs(e[1]) - Math.abs(t[1]);
}
function mE(t, e, i) {
  const n = {},
    r = new Float32Array(8),
    s = new WeakMap(),
    a = new yt(),
    o = [];
  for (let c = 0; c < 8; c++) o[c] = [c, 0];
  function l(c, d, h) {
    const u = c.morphTargetInfluences;
    if (e.isWebGL2 === !0) {
      const f =
          d.morphAttributes.position ||
          d.morphAttributes.normal ||
          d.morphAttributes.color,
        p = f !== void 0 ? f.length : 0;
      let v = s.get(d);
      if (v === void 0 || v.count !== p) {
        let R = function () {
          L.dispose(), s.delete(d), d.removeEventListener("dispose", R);
        };
        v !== void 0 && v.texture.dispose();
        const x = d.morphAttributes.position !== void 0,
          y = d.morphAttributes.normal !== void 0,
          _ = d.morphAttributes.color !== void 0,
          M = d.morphAttributes.position || [],
          b = d.morphAttributes.normal || [],
          E = d.morphAttributes.color || [];
        let T = 0;
        x === !0 && (T = 1), y === !0 && (T = 2), _ === !0 && (T = 3);
        let S = d.attributes.position.count * T,
          w = 1;
        S > e.maxTextureSize &&
          ((w = Math.ceil(S / e.maxTextureSize)), (S = e.maxTextureSize));
        const C = new Float32Array(S * w * 4 * p),
          L = new ax(C, S, w, p);
        (L.type = lr), (L.needsUpdate = !0);
        const P = T * 4;
        for (let I = 0; I < p; I++) {
          const W = M[I],
            N = b[I],
            U = E[I],
            G = S * w * 4 * I;
          for (let k = 0; k < W.count; k++) {
            const B = k * P;
            x === !0 &&
              (a.fromBufferAttribute(W, k),
              (C[G + B + 0] = a.x),
              (C[G + B + 1] = a.y),
              (C[G + B + 2] = a.z),
              (C[G + B + 3] = 0)),
              y === !0 &&
                (a.fromBufferAttribute(N, k),
                (C[G + B + 4] = a.x),
                (C[G + B + 5] = a.y),
                (C[G + B + 6] = a.z),
                (C[G + B + 7] = 0)),
              _ === !0 &&
                (a.fromBufferAttribute(U, k),
                (C[G + B + 8] = a.x),
                (C[G + B + 9] = a.y),
                (C[G + B + 10] = a.z),
                (C[G + B + 11] = U.itemSize === 4 ? a.w : 1));
          }
        }
        (v = { count: p, texture: L, size: new J(S, w) }),
          s.set(d, v),
          d.addEventListener("dispose", R);
      }
      let g = 0;
      for (let x = 0; x < u.length; x++) g += u[x];
      const m = d.morphTargetsRelative ? 1 : 1 - g;
      h.getUniforms().setValue(t, "morphTargetBaseInfluence", m),
        h.getUniforms().setValue(t, "morphTargetInfluences", u),
        h.getUniforms().setValue(t, "morphTargetsTexture", v.texture, i),
        h.getUniforms().setValue(t, "morphTargetsTextureSize", v.size);
    } else {
      const f = u === void 0 ? 0 : u.length;
      let p = n[d.id];
      if (p === void 0 || p.length !== f) {
        p = [];
        for (let y = 0; y < f; y++) p[y] = [y, 0];
        n[d.id] = p;
      }
      for (let y = 0; y < f; y++) {
        const _ = p[y];
        (_[0] = y), (_[1] = u[y]);
      }
      p.sort(pE);
      for (let y = 0; y < 8; y++)
        y < f && p[y][1]
          ? ((o[y][0] = p[y][0]), (o[y][1] = p[y][1]))
          : ((o[y][0] = Number.MAX_SAFE_INTEGER), (o[y][1] = 0));
      o.sort(fE);
      const v = d.morphAttributes.position,
        g = d.morphAttributes.normal;
      let m = 0;
      for (let y = 0; y < 8; y++) {
        const _ = o[y],
          M = _[0],
          b = _[1];
        M !== Number.MAX_SAFE_INTEGER && b
          ? (v &&
              d.getAttribute("morphTarget" + y) !== v[M] &&
              d.setAttribute("morphTarget" + y, v[M]),
            g &&
              d.getAttribute("morphNormal" + y) !== g[M] &&
              d.setAttribute("morphNormal" + y, g[M]),
            (r[y] = b),
            (m += b))
          : (v &&
              d.hasAttribute("morphTarget" + y) === !0 &&
              d.deleteAttribute("morphTarget" + y),
            g &&
              d.hasAttribute("morphNormal" + y) === !0 &&
              d.deleteAttribute("morphNormal" + y),
            (r[y] = 0));
      }
      const x = d.morphTargetsRelative ? 1 : 1 - m;
      h.getUniforms().setValue(t, "morphTargetBaseInfluence", x),
        h.getUniforms().setValue(t, "morphTargetInfluences", r);
    }
  }
  return { update: l };
}
function gE(t, e, i, n) {
  let r = new WeakMap();
  function s(l) {
    const c = n.render.frame,
      d = l.geometry,
      h = e.get(l, d);
    if (
      (r.get(h) !== c && (e.update(h), r.set(h, c)),
      l.isInstancedMesh &&
        (l.hasEventListener("dispose", o) === !1 &&
          l.addEventListener("dispose", o),
        r.get(l) !== c &&
          (i.update(l.instanceMatrix, t.ARRAY_BUFFER),
          l.instanceColor !== null && i.update(l.instanceColor, t.ARRAY_BUFFER),
          r.set(l, c))),
      l.isSkinnedMesh)
    ) {
      const u = l.skeleton;
      r.get(u) !== c && (u.update(), r.set(u, c));
    }
    return h;
  }
  function a() {
    r = new WeakMap();
  }
  function o(l) {
    const c = l.target;
    c.removeEventListener("dispose", o),
      i.remove(c.instanceMatrix),
      c.instanceColor !== null && i.remove(c.instanceColor);
  }
  return { update: s, dispose: a };
}
const ux = new Li(),
  dx = new ax(),
  fx = new rS(),
  px = new Hf(),
  ag = [],
  og = [],
  lg = new Float32Array(16),
  cg = new Float32Array(9),
  hg = new Float32Array(4);
function ho(t, e, i) {
  const n = t[0];
  if (n <= 0 || n > 0) return t;
  const r = e * i;
  let s = ag[r];
  if ((s === void 0 && ((s = new Float32Array(r)), (ag[r] = s)), e !== 0)) {
    n.toArray(s, 0);
    for (let a = 1, o = 0; a !== e; ++a) (o += i), t[a].toArray(s, o);
  }
  return s;
}
function _i(t, e) {
  if (t.length !== e.length) return !1;
  for (let i = 0, n = t.length; i < n; i++) if (t[i] !== e[i]) return !1;
  return !0;
}
function bi(t, e) {
  for (let i = 0, n = e.length; i < n; i++) t[i] = e[i];
}
function bh(t, e) {
  let i = og[e];
  i === void 0 && ((i = new Int32Array(e)), (og[e] = i));
  for (let n = 0; n !== e; ++n) i[n] = t.allocateTextureUnit();
  return i;
}
function vE(t, e) {
  const i = this.cache;
  i[0] !== e && (t.uniform1f(this.addr, e), (i[0] = e));
}
function yE(t, e) {
  const i = this.cache;
  if (e.x !== void 0)
    (i[0] !== e.x || i[1] !== e.y) &&
      (t.uniform2f(this.addr, e.x, e.y), (i[0] = e.x), (i[1] = e.y));
  else {
    if (_i(i, e)) return;
    t.uniform2fv(this.addr, e), bi(i, e);
  }
}
function xE(t, e) {
  const i = this.cache;
  if (e.x !== void 0)
    (i[0] !== e.x || i[1] !== e.y || i[2] !== e.z) &&
      (t.uniform3f(this.addr, e.x, e.y, e.z),
      (i[0] = e.x),
      (i[1] = e.y),
      (i[2] = e.z));
  else if (e.r !== void 0)
    (i[0] !== e.r || i[1] !== e.g || i[2] !== e.b) &&
      (t.uniform3f(this.addr, e.r, e.g, e.b),
      (i[0] = e.r),
      (i[1] = e.g),
      (i[2] = e.b));
  else {
    if (_i(i, e)) return;
    t.uniform3fv(this.addr, e), bi(i, e);
  }
}
function _E(t, e) {
  const i = this.cache;
  if (e.x !== void 0)
    (i[0] !== e.x || i[1] !== e.y || i[2] !== e.z || i[3] !== e.w) &&
      (t.uniform4f(this.addr, e.x, e.y, e.z, e.w),
      (i[0] = e.x),
      (i[1] = e.y),
      (i[2] = e.z),
      (i[3] = e.w));
  else {
    if (_i(i, e)) return;
    t.uniform4fv(this.addr, e), bi(i, e);
  }
}
function bE(t, e) {
  const i = this.cache,
    n = e.elements;
  if (n === void 0) {
    if (_i(i, e)) return;
    t.uniformMatrix2fv(this.addr, !1, e), bi(i, e);
  } else {
    if (_i(i, n)) return;
    hg.set(n), t.uniformMatrix2fv(this.addr, !1, hg), bi(i, n);
  }
}
function wE(t, e) {
  const i = this.cache,
    n = e.elements;
  if (n === void 0) {
    if (_i(i, e)) return;
    t.uniformMatrix3fv(this.addr, !1, e), bi(i, e);
  } else {
    if (_i(i, n)) return;
    cg.set(n), t.uniformMatrix3fv(this.addr, !1, cg), bi(i, n);
  }
}
function SE(t, e) {
  const i = this.cache,
    n = e.elements;
  if (n === void 0) {
    if (_i(i, e)) return;
    t.uniformMatrix4fv(this.addr, !1, e), bi(i, e);
  } else {
    if (_i(i, n)) return;
    lg.set(n), t.uniformMatrix4fv(this.addr, !1, lg), bi(i, n);
  }
}
function ME(t, e) {
  const i = this.cache;
  i[0] !== e && (t.uniform1i(this.addr, e), (i[0] = e));
}
function EE(t, e) {
  const i = this.cache;
  if (e.x !== void 0)
    (i[0] !== e.x || i[1] !== e.y) &&
      (t.uniform2i(this.addr, e.x, e.y), (i[0] = e.x), (i[1] = e.y));
  else {
    if (_i(i, e)) return;
    t.uniform2iv(this.addr, e), bi(i, e);
  }
}
function TE(t, e) {
  const i = this.cache;
  if (e.x !== void 0)
    (i[0] !== e.x || i[1] !== e.y || i[2] !== e.z) &&
      (t.uniform3i(this.addr, e.x, e.y, e.z),
      (i[0] = e.x),
      (i[1] = e.y),
      (i[2] = e.z));
  else {
    if (_i(i, e)) return;
    t.uniform3iv(this.addr, e), bi(i, e);
  }
}
function AE(t, e) {
  const i = this.cache;
  if (e.x !== void 0)
    (i[0] !== e.x || i[1] !== e.y || i[2] !== e.z || i[3] !== e.w) &&
      (t.uniform4i(this.addr, e.x, e.y, e.z, e.w),
      (i[0] = e.x),
      (i[1] = e.y),
      (i[2] = e.z),
      (i[3] = e.w));
  else {
    if (_i(i, e)) return;
    t.uniform4iv(this.addr, e), bi(i, e);
  }
}
function CE(t, e) {
  const i = this.cache;
  i[0] !== e && (t.uniform1ui(this.addr, e), (i[0] = e));
}
function PE(t, e) {
  const i = this.cache;
  if (e.x !== void 0)
    (i[0] !== e.x || i[1] !== e.y) &&
      (t.uniform2ui(this.addr, e.x, e.y), (i[0] = e.x), (i[1] = e.y));
  else {
    if (_i(i, e)) return;
    t.uniform2uiv(this.addr, e), bi(i, e);
  }
}
function LE(t, e) {
  const i = this.cache;
  if (e.x !== void 0)
    (i[0] !== e.x || i[1] !== e.y || i[2] !== e.z) &&
      (t.uniform3ui(this.addr, e.x, e.y, e.z),
      (i[0] = e.x),
      (i[1] = e.y),
      (i[2] = e.z));
  else {
    if (_i(i, e)) return;
    t.uniform3uiv(this.addr, e), bi(i, e);
  }
}
function DE(t, e) {
  const i = this.cache;
  if (e.x !== void 0)
    (i[0] !== e.x || i[1] !== e.y || i[2] !== e.z || i[3] !== e.w) &&
      (t.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
      (i[0] = e.x),
      (i[1] = e.y),
      (i[2] = e.z),
      (i[3] = e.w));
  else {
    if (_i(i, e)) return;
    t.uniform4uiv(this.addr, e), bi(i, e);
  }
}
function RE(t, e, i) {
  const n = this.cache,
    r = i.allocateTextureUnit();
  n[0] !== r && (t.uniform1i(this.addr, r), (n[0] = r)),
    i.setTexture2D(e || ux, r);
}
function OE(t, e, i) {
  const n = this.cache,
    r = i.allocateTextureUnit();
  n[0] !== r && (t.uniform1i(this.addr, r), (n[0] = r)),
    i.setTexture3D(e || fx, r);
}
function IE(t, e, i) {
  const n = this.cache,
    r = i.allocateTextureUnit();
  n[0] !== r && (t.uniform1i(this.addr, r), (n[0] = r)),
    i.setTextureCube(e || px, r);
}
function UE(t, e, i) {
  const n = this.cache,
    r = i.allocateTextureUnit();
  n[0] !== r && (t.uniform1i(this.addr, r), (n[0] = r)),
    i.setTexture2DArray(e || dx, r);
}
function NE(t) {
  switch (t) {
    case 5126:
      return vE;
    case 35664:
      return yE;
    case 35665:
      return xE;
    case 35666:
      return _E;
    case 35674:
      return bE;
    case 35675:
      return wE;
    case 35676:
      return SE;
    case 5124:
    case 35670:
      return ME;
    case 35667:
    case 35671:
      return EE;
    case 35668:
    case 35672:
      return TE;
    case 35669:
    case 35673:
      return AE;
    case 5125:
      return CE;
    case 36294:
      return PE;
    case 36295:
      return LE;
    case 36296:
      return DE;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return RE;
    case 35679:
    case 36299:
    case 36307:
      return OE;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return IE;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return UE;
  }
}
function zE(t, e) {
  t.uniform1fv(this.addr, e);
}
function BE(t, e) {
  const i = ho(e, this.size, 2);
  t.uniform2fv(this.addr, i);
}
function FE(t, e) {
  const i = ho(e, this.size, 3);
  t.uniform3fv(this.addr, i);
}
function kE(t, e) {
  const i = ho(e, this.size, 4);
  t.uniform4fv(this.addr, i);
}
function VE(t, e) {
  const i = ho(e, this.size, 4);
  t.uniformMatrix2fv(this.addr, !1, i);
}
function HE(t, e) {
  const i = ho(e, this.size, 9);
  t.uniformMatrix3fv(this.addr, !1, i);
}
function GE(t, e) {
  const i = ho(e, this.size, 16);
  t.uniformMatrix4fv(this.addr, !1, i);
}
function jE(t, e) {
  t.uniform1iv(this.addr, e);
}
function WE(t, e) {
  t.uniform2iv(this.addr, e);
}
function qE(t, e) {
  t.uniform3iv(this.addr, e);
}
function XE(t, e) {
  t.uniform4iv(this.addr, e);
}
function $E(t, e) {
  t.uniform1uiv(this.addr, e);
}
function YE(t, e) {
  t.uniform2uiv(this.addr, e);
}
function ZE(t, e) {
  t.uniform3uiv(this.addr, e);
}
function KE(t, e) {
  t.uniform4uiv(this.addr, e);
}
function JE(t, e, i) {
  const n = this.cache,
    r = e.length,
    s = bh(i, r);
  _i(n, s) || (t.uniform1iv(this.addr, s), bi(n, s));
  for (let a = 0; a !== r; ++a) i.setTexture2D(e[a] || ux, s[a]);
}
function QE(t, e, i) {
  const n = this.cache,
    r = e.length,
    s = bh(i, r);
  _i(n, s) || (t.uniform1iv(this.addr, s), bi(n, s));
  for (let a = 0; a !== r; ++a) i.setTexture3D(e[a] || fx, s[a]);
}
function eT(t, e, i) {
  const n = this.cache,
    r = e.length,
    s = bh(i, r);
  _i(n, s) || (t.uniform1iv(this.addr, s), bi(n, s));
  for (let a = 0; a !== r; ++a) i.setTextureCube(e[a] || px, s[a]);
}
function tT(t, e, i) {
  const n = this.cache,
    r = e.length,
    s = bh(i, r);
  _i(n, s) || (t.uniform1iv(this.addr, s), bi(n, s));
  for (let a = 0; a !== r; ++a) i.setTexture2DArray(e[a] || dx, s[a]);
}
function iT(t) {
  switch (t) {
    case 5126:
      return zE;
    case 35664:
      return BE;
    case 35665:
      return FE;
    case 35666:
      return kE;
    case 35674:
      return VE;
    case 35675:
      return HE;
    case 35676:
      return GE;
    case 5124:
    case 35670:
      return jE;
    case 35667:
    case 35671:
      return WE;
    case 35668:
    case 35672:
      return qE;
    case 35669:
    case 35673:
      return XE;
    case 5125:
      return $E;
    case 36294:
      return YE;
    case 36295:
      return ZE;
    case 36296:
      return KE;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return JE;
    case 35679:
    case 36299:
    case 36307:
      return QE;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return eT;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return tT;
  }
}
class nT {
  constructor(e, i, n) {
    (this.id = e),
      (this.addr = n),
      (this.cache = []),
      (this.setValue = NE(i.type));
  }
}
class rT {
  constructor(e, i, n) {
    (this.id = e),
      (this.addr = n),
      (this.cache = []),
      (this.size = i.size),
      (this.setValue = iT(i.type));
  }
}
class sT {
  constructor(e) {
    (this.id = e), (this.seq = []), (this.map = {});
  }
  setValue(e, i, n) {
    const r = this.seq;
    for (let s = 0, a = r.length; s !== a; ++s) {
      const o = r[s];
      o.setValue(e, i[o.id], n);
    }
  }
}
const bu = /(\w+)(\])?(\[|\.)?/g;
function ug(t, e) {
  t.seq.push(e), (t.map[e.id] = e);
}
function aT(t, e, i) {
  const n = t.name,
    r = n.length;
  for (bu.lastIndex = 0; ; ) {
    const s = bu.exec(n),
      a = bu.lastIndex;
    let o = s[1];
    const l = s[2] === "]",
      c = s[3];
    if ((l && (o = o | 0), c === void 0 || (c === "[" && a + 2 === r))) {
      ug(i, c === void 0 ? new nT(o, t, e) : new rT(o, t, e));
      break;
    } else {
      let h = i.map[o];
      h === void 0 && ((h = new sT(o)), ug(i, h)), (i = h);
    }
  }
}
class Lc {
  constructor(e, i) {
    (this.seq = []), (this.map = {});
    const n = e.getProgramParameter(i, e.ACTIVE_UNIFORMS);
    for (let r = 0; r < n; ++r) {
      const s = e.getActiveUniform(i, r),
        a = e.getUniformLocation(i, s.name);
      aT(s, a, this);
    }
  }
  setValue(e, i, n, r) {
    const s = this.map[i];
    s !== void 0 && s.setValue(e, n, r);
  }
  setOptional(e, i, n) {
    const r = i[n];
    r !== void 0 && this.setValue(e, n, r);
  }
  static upload(e, i, n, r) {
    for (let s = 0, a = i.length; s !== a; ++s) {
      const o = i[s],
        l = n[o.id];
      l.needsUpdate !== !1 && o.setValue(e, l.value, r);
    }
  }
  static seqWithValue(e, i) {
    const n = [];
    for (let r = 0, s = e.length; r !== s; ++r) {
      const a = e[r];
      a.id in i && n.push(a);
    }
    return n;
  }
}
function dg(t, e, i) {
  const n = t.createShader(e);
  return t.shaderSource(n, i), t.compileShader(n), n;
}
let oT = 0;
function lT(t, e) {
  const i = t.split(`
`),
    n = [],
    r = Math.max(e - 6, 0),
    s = Math.min(e + 6, i.length);
  for (let a = r; a < s; a++) {
    const o = a + 1;
    n.push(`${o === e ? ">" : " "} ${o}: ${i[a]}`);
  }
  return n.join(`
`);
}
function cT(t) {
  switch (t) {
    case qn:
      return ["Linear", "( value )"];
    case gt:
      return ["sRGB", "( value )"];
    default:
      return (
        console.warn("THREE.WebGLProgram: Unsupported color space:", t),
        ["Linear", "( value )"]
      );
  }
}
function fg(t, e, i) {
  const n = t.getShaderParameter(e, t.COMPILE_STATUS),
    r = t.getShaderInfoLog(e).trim();
  if (n && r === "") return "";
  const s = /ERROR: 0:(\d+)/.exec(r);
  if (s) {
    const a = parseInt(s[1]);
    return (
      i.toUpperCase() +
      `

` +
      r +
      `

` +
      lT(t.getShaderSource(e), a)
    );
  } else return r;
}
function hT(t, e) {
  const i = cT(e);
  return "vec4 " + t + "( vec4 value ) { return LinearTo" + i[0] + i[1] + "; }";
}
function uT(t, e) {
  let i;
  switch (e) {
    case uw:
      i = "Linear";
      break;
    case dw:
      i = "Reinhard";
      break;
    case fw:
      i = "OptimizedCineon";
      break;
    case pw:
      i = "ACESFilmic";
      break;
    case mw:
      i = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
        (i = "Linear");
  }
  return (
    "vec3 " + t + "( vec3 color ) { return " + i + "ToneMapping( color ); }"
  );
}
function dT(t) {
  return [
    t.extensionDerivatives ||
    t.envMapCubeUVHeight ||
    t.bumpMap ||
    t.normalMapTangentSpace ||
    t.clearcoatNormalMap ||
    t.flatShading ||
    t.shaderID === "physical"
      ? "#extension GL_OES_standard_derivatives : enable"
      : "",
    (t.extensionFragDepth || t.logarithmicDepthBuffer) &&
    t.rendererExtensionFragDepth
      ? "#extension GL_EXT_frag_depth : enable"
      : "",
    t.extensionDrawBuffers && t.rendererExtensionDrawBuffers
      ? "#extension GL_EXT_draw_buffers : require"
      : "",
    (t.extensionShaderTextureLOD || t.envMap || t.transmission) &&
    t.rendererExtensionShaderTextureLod
      ? "#extension GL_EXT_shader_texture_lod : enable"
      : "",
  ].filter(Bo).join(`
`);
}
function fT(t) {
  const e = [];
  for (const i in t) {
    const n = t[i];
    n !== !1 && e.push("#define " + i + " " + n);
  }
  return e.join(`
`);
}
function pT(t, e) {
  const i = {},
    n = t.getProgramParameter(e, t.ACTIVE_ATTRIBUTES);
  for (let r = 0; r < n; r++) {
    const s = t.getActiveAttrib(e, r),
      a = s.name;
    let o = 1;
    s.type === t.FLOAT_MAT2 && (o = 2),
      s.type === t.FLOAT_MAT3 && (o = 3),
      s.type === t.FLOAT_MAT4 && (o = 4),
      (i[a] = {
        type: s.type,
        location: t.getAttribLocation(e, a),
        locationSize: o,
      });
  }
  return i;
}
function Bo(t) {
  return t !== "";
}
function pg(t, e) {
  const i =
    e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
  return t
    .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
    .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
    .replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps)
    .replace(/NUM_SPOT_LIGHT_COORDS/g, i)
    .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
    .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
    .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
    .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
    .replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps)
    .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
    .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function mg(t, e) {
  return t
    .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
    .replace(
      /UNION_CLIPPING_PLANES/g,
      e.numClippingPlanes - e.numClipIntersection
    );
}
const mT = /^[ \t]*#include +<([\w\d./]+)>/gm;
function _d(t) {
  return t.replace(mT, vT);
}
const gT = new Map([
  ["encodings_fragment", "colorspace_fragment"],
  ["encodings_pars_fragment", "colorspace_pars_fragment"],
  ["output_fragment", "opaque_fragment"],
]);
function vT(t, e) {
  let i = ct[e];
  if (i === void 0) {
    const n = gT.get(e);
    if (n !== void 0)
      (i = ct[n]),
        console.warn(
          'THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',
          e,
          n
        );
    else throw new Error("Can not resolve #include <" + e + ">");
  }
  return _d(i);
}
const yT =
  /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function gg(t) {
  return t.replace(yT, xT);
}
function xT(t, e, i, n) {
  let r = "";
  for (let s = parseInt(e); s < parseInt(i); s++)
    r += n
      .replace(/\[\s*i\s*\]/g, "[ " + s + " ]")
      .replace(/UNROLLED_LOOP_INDEX/g, s);
  return r;
}
function vg(t) {
  let e =
    "precision " +
    t.precision +
    ` float;
precision ` +
    t.precision +
    " int;";
  return (
    t.precision === "highp"
      ? (e += `
#define HIGH_PRECISION`)
      : t.precision === "mediump"
      ? (e += `
#define MEDIUM_PRECISION`)
      : t.precision === "lowp" &&
        (e += `
#define LOW_PRECISION`),
    e
  );
}
function _T(t) {
  let e = "SHADOWMAP_TYPE_BASIC";
  return (
    t.shadowMapType === zy
      ? (e = "SHADOWMAP_TYPE_PCF")
      : t.shadowMapType === By
      ? (e = "SHADOWMAP_TYPE_PCF_SOFT")
      : t.shadowMapType === Mr && (e = "SHADOWMAP_TYPE_VSM"),
    e
  );
}
function bT(t) {
  let e = "ENVMAP_TYPE_CUBE";
  if (t.envMap)
    switch (t.envMapMode) {
      case Hs:
      case Gs:
        e = "ENVMAP_TYPE_CUBE";
        break;
      case gl:
        e = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  return e;
}
function wT(t) {
  let e = "ENVMAP_MODE_REFLECTION";
  if (t.envMap)
    switch (t.envMapMode) {
      case Gs:
        e = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return e;
}
function ST(t) {
  let e = "ENVMAP_BLENDING_NONE";
  if (t.envMap)
    switch (t.combine) {
      case jy:
        e = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case cw:
        e = "ENVMAP_BLENDING_MIX";
        break;
      case hw:
        e = "ENVMAP_BLENDING_ADD";
        break;
    }
  return e;
}
function MT(t) {
  const e = t.envMapCubeUVHeight;
  if (e === null) return null;
  const i = Math.log2(e) - 2,
    n = 1 / e;
  return {
    texelWidth: 1 / (3 * Math.max(Math.pow(2, i), 7 * 16)),
    texelHeight: n,
    maxMip: i,
  };
}
function ET(t, e, i, n) {
  const r = t.getContext(),
    s = i.defines;
  let a = i.vertexShader,
    o = i.fragmentShader;
  const l = _T(i),
    c = bT(i),
    d = wT(i),
    h = ST(i),
    u = MT(i),
    f = i.isWebGL2 ? "" : dT(i),
    p = fT(s),
    v = r.createProgram();
  let g,
    m,
    x = i.glslVersion
      ? "#version " +
        i.glslVersion +
        `
`
      : "";
  i.isRawShaderMaterial
    ? ((g = [
        "#define SHADER_TYPE " + i.shaderType,
        "#define SHADER_NAME " + i.shaderName,
        p,
      ].filter(Bo).join(`
`)),
      g.length > 0 &&
        (g += `
`),
      (m = [
        f,
        "#define SHADER_TYPE " + i.shaderType,
        "#define SHADER_NAME " + i.shaderName,
        p,
      ].filter(Bo).join(`
`)),
      m.length > 0 &&
        (m += `
`))
    : ((g = [
        vg(i),
        "#define SHADER_TYPE " + i.shaderType,
        "#define SHADER_NAME " + i.shaderName,
        p,
        i.instancing ? "#define USE_INSTANCING" : "",
        i.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
        i.useFog && i.fog ? "#define USE_FOG" : "",
        i.useFog && i.fogExp2 ? "#define FOG_EXP2" : "",
        i.map ? "#define USE_MAP" : "",
        i.envMap ? "#define USE_ENVMAP" : "",
        i.envMap ? "#define " + d : "",
        i.lightMap ? "#define USE_LIGHTMAP" : "",
        i.aoMap ? "#define USE_AOMAP" : "",
        i.bumpMap ? "#define USE_BUMPMAP" : "",
        i.normalMap ? "#define USE_NORMALMAP" : "",
        i.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
        i.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
        i.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
        i.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        i.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
        i.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        i.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        i.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        i.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        i.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        i.specularMap ? "#define USE_SPECULARMAP" : "",
        i.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
        i.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
        i.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        i.metalnessMap ? "#define USE_METALNESSMAP" : "",
        i.alphaMap ? "#define USE_ALPHAMAP" : "",
        i.alphaHash ? "#define USE_ALPHAHASH" : "",
        i.transmission ? "#define USE_TRANSMISSION" : "",
        i.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        i.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        i.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
        i.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
        i.mapUv ? "#define MAP_UV " + i.mapUv : "",
        i.alphaMapUv ? "#define ALPHAMAP_UV " + i.alphaMapUv : "",
        i.lightMapUv ? "#define LIGHTMAP_UV " + i.lightMapUv : "",
        i.aoMapUv ? "#define AOMAP_UV " + i.aoMapUv : "",
        i.emissiveMapUv ? "#define EMISSIVEMAP_UV " + i.emissiveMapUv : "",
        i.bumpMapUv ? "#define BUMPMAP_UV " + i.bumpMapUv : "",
        i.normalMapUv ? "#define NORMALMAP_UV " + i.normalMapUv : "",
        i.displacementMapUv
          ? "#define DISPLACEMENTMAP_UV " + i.displacementMapUv
          : "",
        i.metalnessMapUv ? "#define METALNESSMAP_UV " + i.metalnessMapUv : "",
        i.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + i.roughnessMapUv : "",
        i.anisotropyMapUv
          ? "#define ANISOTROPYMAP_UV " + i.anisotropyMapUv
          : "",
        i.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + i.clearcoatMapUv : "",
        i.clearcoatNormalMapUv
          ? "#define CLEARCOAT_NORMALMAP_UV " + i.clearcoatNormalMapUv
          : "",
        i.clearcoatRoughnessMapUv
          ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + i.clearcoatRoughnessMapUv
          : "",
        i.iridescenceMapUv
          ? "#define IRIDESCENCEMAP_UV " + i.iridescenceMapUv
          : "",
        i.iridescenceThicknessMapUv
          ? "#define IRIDESCENCE_THICKNESSMAP_UV " + i.iridescenceThicknessMapUv
          : "",
        i.sheenColorMapUv
          ? "#define SHEEN_COLORMAP_UV " + i.sheenColorMapUv
          : "",
        i.sheenRoughnessMapUv
          ? "#define SHEEN_ROUGHNESSMAP_UV " + i.sheenRoughnessMapUv
          : "",
        i.specularMapUv ? "#define SPECULARMAP_UV " + i.specularMapUv : "",
        i.specularColorMapUv
          ? "#define SPECULAR_COLORMAP_UV " + i.specularColorMapUv
          : "",
        i.specularIntensityMapUv
          ? "#define SPECULAR_INTENSITYMAP_UV " + i.specularIntensityMapUv
          : "",
        i.transmissionMapUv
          ? "#define TRANSMISSIONMAP_UV " + i.transmissionMapUv
          : "",
        i.thicknessMapUv ? "#define THICKNESSMAP_UV " + i.thicknessMapUv : "",
        i.vertexTangents && i.flatShading === !1 ? "#define USE_TANGENT" : "",
        i.vertexColors ? "#define USE_COLOR" : "",
        i.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        i.vertexUv1s ? "#define USE_UV1" : "",
        i.vertexUv2s ? "#define USE_UV2" : "",
        i.vertexUv3s ? "#define USE_UV3" : "",
        i.pointsUvs ? "#define USE_POINTS_UV" : "",
        i.flatShading ? "#define FLAT_SHADED" : "",
        i.skinning ? "#define USE_SKINNING" : "",
        i.morphTargets ? "#define USE_MORPHTARGETS" : "",
        i.morphNormals && i.flatShading === !1
          ? "#define USE_MORPHNORMALS"
          : "",
        i.morphColors && i.isWebGL2 ? "#define USE_MORPHCOLORS" : "",
        i.morphTargetsCount > 0 && i.isWebGL2
          ? "#define MORPHTARGETS_TEXTURE"
          : "",
        i.morphTargetsCount > 0 && i.isWebGL2
          ? "#define MORPHTARGETS_TEXTURE_STRIDE " + i.morphTextureStride
          : "",
        i.morphTargetsCount > 0 && i.isWebGL2
          ? "#define MORPHTARGETS_COUNT " + i.morphTargetsCount
          : "",
        i.doubleSided ? "#define DOUBLE_SIDED" : "",
        i.flipSided ? "#define FLIP_SIDED" : "",
        i.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        i.shadowMapEnabled ? "#define " + l : "",
        i.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
        i.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
        i.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        i.logarithmicDepthBuffer && i.rendererExtensionFragDepth
          ? "#define USE_LOGDEPTHBUF_EXT"
          : "",
        "uniform mat4 modelMatrix;",
        "uniform mat4 modelViewMatrix;",
        "uniform mat4 projectionMatrix;",
        "uniform mat4 viewMatrix;",
        "uniform mat3 normalMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        "#ifdef USE_INSTANCING",
        "	attribute mat4 instanceMatrix;",
        "#endif",
        "#ifdef USE_INSTANCING_COLOR",
        "	attribute vec3 instanceColor;",
        "#endif",
        "attribute vec3 position;",
        "attribute vec3 normal;",
        "attribute vec2 uv;",
        "#ifdef USE_UV1",
        "	attribute vec2 uv1;",
        "#endif",
        "#ifdef USE_UV2",
        "	attribute vec2 uv2;",
        "#endif",
        "#ifdef USE_UV3",
        "	attribute vec2 uv3;",
        "#endif",
        "#ifdef USE_TANGENT",
        "	attribute vec4 tangent;",
        "#endif",
        "#if defined( USE_COLOR_ALPHA )",
        "	attribute vec4 color;",
        "#elif defined( USE_COLOR )",
        "	attribute vec3 color;",
        "#endif",
        "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
        "	attribute vec3 morphTarget0;",
        "	attribute vec3 morphTarget1;",
        "	attribute vec3 morphTarget2;",
        "	attribute vec3 morphTarget3;",
        "	#ifdef USE_MORPHNORMALS",
        "		attribute vec3 morphNormal0;",
        "		attribute vec3 morphNormal1;",
        "		attribute vec3 morphNormal2;",
        "		attribute vec3 morphNormal3;",
        "	#else",
        "		attribute vec3 morphTarget4;",
        "		attribute vec3 morphTarget5;",
        "		attribute vec3 morphTarget6;",
        "		attribute vec3 morphTarget7;",
        "	#endif",
        "#endif",
        "#ifdef USE_SKINNING",
        "	attribute vec4 skinIndex;",
        "	attribute vec4 skinWeight;",
        "#endif",
        `
`,
      ].filter(Bo).join(`
`)),
      (m = [
        f,
        vg(i),
        "#define SHADER_TYPE " + i.shaderType,
        "#define SHADER_NAME " + i.shaderName,
        p,
        i.useFog && i.fog ? "#define USE_FOG" : "",
        i.useFog && i.fogExp2 ? "#define FOG_EXP2" : "",
        i.map ? "#define USE_MAP" : "",
        i.matcap ? "#define USE_MATCAP" : "",
        i.envMap ? "#define USE_ENVMAP" : "",
        i.envMap ? "#define " + c : "",
        i.envMap ? "#define " + d : "",
        i.envMap ? "#define " + h : "",
        u ? "#define CUBEUV_TEXEL_WIDTH " + u.texelWidth : "",
        u ? "#define CUBEUV_TEXEL_HEIGHT " + u.texelHeight : "",
        u ? "#define CUBEUV_MAX_MIP " + u.maxMip + ".0" : "",
        i.lightMap ? "#define USE_LIGHTMAP" : "",
        i.aoMap ? "#define USE_AOMAP" : "",
        i.bumpMap ? "#define USE_BUMPMAP" : "",
        i.normalMap ? "#define USE_NORMALMAP" : "",
        i.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
        i.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
        i.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        i.anisotropy ? "#define USE_ANISOTROPY" : "",
        i.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
        i.clearcoat ? "#define USE_CLEARCOAT" : "",
        i.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        i.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        i.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        i.iridescence ? "#define USE_IRIDESCENCE" : "",
        i.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        i.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        i.specularMap ? "#define USE_SPECULARMAP" : "",
        i.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
        i.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
        i.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        i.metalnessMap ? "#define USE_METALNESSMAP" : "",
        i.alphaMap ? "#define USE_ALPHAMAP" : "",
        i.alphaTest ? "#define USE_ALPHATEST" : "",
        i.alphaHash ? "#define USE_ALPHAHASH" : "",
        i.sheen ? "#define USE_SHEEN" : "",
        i.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
        i.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
        i.transmission ? "#define USE_TRANSMISSION" : "",
        i.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        i.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        i.vertexTangents && i.flatShading === !1 ? "#define USE_TANGENT" : "",
        i.vertexColors || i.instancingColor ? "#define USE_COLOR" : "",
        i.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        i.vertexUv1s ? "#define USE_UV1" : "",
        i.vertexUv2s ? "#define USE_UV2" : "",
        i.vertexUv3s ? "#define USE_UV3" : "",
        i.pointsUvs ? "#define USE_POINTS_UV" : "",
        i.gradientMap ? "#define USE_GRADIENTMAP" : "",
        i.flatShading ? "#define FLAT_SHADED" : "",
        i.doubleSided ? "#define DOUBLE_SIDED" : "",
        i.flipSided ? "#define FLIP_SIDED" : "",
        i.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        i.shadowMapEnabled ? "#define " + l : "",
        i.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
        i.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
        i.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        i.logarithmicDepthBuffer && i.rendererExtensionFragDepth
          ? "#define USE_LOGDEPTHBUF_EXT"
          : "",
        "uniform mat4 viewMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        i.toneMapping !== Nr ? "#define TONE_MAPPING" : "",
        i.toneMapping !== Nr ? ct.tonemapping_pars_fragment : "",
        i.toneMapping !== Nr ? uT("toneMapping", i.toneMapping) : "",
        i.dithering ? "#define DITHERING" : "",
        i.opaque ? "#define OPAQUE" : "",
        ct.colorspace_pars_fragment,
        hT("linearToOutputTexel", i.outputColorSpace),
        i.useDepthPacking ? "#define DEPTH_PACKING " + i.depthPacking : "",
        `
`,
      ].filter(Bo).join(`
`))),
    (a = _d(a)),
    (a = pg(a, i)),
    (a = mg(a, i)),
    (o = _d(o)),
    (o = pg(o, i)),
    (o = mg(o, i)),
    (a = gg(a)),
    (o = gg(o)),
    i.isWebGL2 &&
      i.isRawShaderMaterial !== !0 &&
      ((x = `#version 300 es
`),
      (g =
        [
          "precision mediump sampler2DArray;",
          "#define attribute in",
          "#define varying out",
          "#define texture2D texture",
        ].join(`
`) +
        `
` +
        g),
      (m =
        [
          "#define varying in",
          i.glslVersion === Nm
            ? ""
            : "layout(location = 0) out highp vec4 pc_fragColor;",
          i.glslVersion === Nm ? "" : "#define gl_FragColor pc_fragColor",
          "#define gl_FragDepthEXT gl_FragDepth",
          "#define texture2D texture",
          "#define textureCube texture",
          "#define texture2DProj textureProj",
          "#define texture2DLodEXT textureLod",
          "#define texture2DProjLodEXT textureProjLod",
          "#define textureCubeLodEXT textureLod",
          "#define texture2DGradEXT textureGrad",
          "#define texture2DProjGradEXT textureProjGrad",
          "#define textureCubeGradEXT textureGrad",
        ].join(`
`) +
        `
` +
        m));
  const y = x + g + a,
    _ = x + m + o,
    M = dg(r, r.VERTEX_SHADER, y),
    b = dg(r, r.FRAGMENT_SHADER, _);
  if (
    (r.attachShader(v, M),
    r.attachShader(v, b),
    i.index0AttributeName !== void 0
      ? r.bindAttribLocation(v, 0, i.index0AttributeName)
      : i.morphTargets === !0 && r.bindAttribLocation(v, 0, "position"),
    r.linkProgram(v),
    t.debug.checkShaderErrors)
  ) {
    const S = r.getProgramInfoLog(v).trim(),
      w = r.getShaderInfoLog(M).trim(),
      C = r.getShaderInfoLog(b).trim();
    let L = !0,
      P = !0;
    if (r.getProgramParameter(v, r.LINK_STATUS) === !1)
      if (((L = !1), typeof t.debug.onShaderError == "function"))
        t.debug.onShaderError(r, v, M, b);
      else {
        const R = fg(r, M, "vertex"),
          I = fg(r, b, "fragment");
        console.error(
          "THREE.WebGLProgram: Shader Error " +
            r.getError() +
            " - VALIDATE_STATUS " +
            r.getProgramParameter(v, r.VALIDATE_STATUS) +
            `

Program Info Log: ` +
            S +
            `
` +
            R +
            `
` +
            I
        );
      }
    else
      S !== ""
        ? console.warn("THREE.WebGLProgram: Program Info Log:", S)
        : (w === "" || C === "") && (P = !1);
    P &&
      (this.diagnostics = {
        runnable: L,
        programLog: S,
        vertexShader: { log: w, prefix: g },
        fragmentShader: { log: C, prefix: m },
      });
  }
  r.deleteShader(M), r.deleteShader(b);
  let E;
  this.getUniforms = function () {
    return E === void 0 && (E = new Lc(r, v)), E;
  };
  let T;
  return (
    (this.getAttributes = function () {
      return T === void 0 && (T = pT(r, v)), T;
    }),
    (this.destroy = function () {
      n.releaseStatesOfProgram(this),
        r.deleteProgram(v),
        (this.program = void 0);
    }),
    (this.type = i.shaderType),
    (this.name = i.shaderName),
    (this.id = oT++),
    (this.cacheKey = e),
    (this.usedTimes = 1),
    (this.program = v),
    (this.vertexShader = M),
    (this.fragmentShader = b),
    this
  );
}
let TT = 0;
class AT {
  constructor() {
    (this.shaderCache = new Map()), (this.materialCache = new Map());
  }
  update(e) {
    const i = e.vertexShader,
      n = e.fragmentShader,
      r = this._getShaderStage(i),
      s = this._getShaderStage(n),
      a = this._getShaderCacheForMaterial(e);
    return (
      a.has(r) === !1 && (a.add(r), r.usedTimes++),
      a.has(s) === !1 && (a.add(s), s.usedTimes++),
      this
    );
  }
  remove(e) {
    const i = this.materialCache.get(e);
    for (const n of i)
      n.usedTimes--, n.usedTimes === 0 && this.shaderCache.delete(n.code);
    return this.materialCache.delete(e), this;
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id;
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(e) {
    const i = this.materialCache;
    let n = i.get(e);
    return n === void 0 && ((n = new Set()), i.set(e, n)), n;
  }
  _getShaderStage(e) {
    const i = this.shaderCache;
    let n = i.get(e);
    return n === void 0 && ((n = new CT(e)), i.set(e, n)), n;
  }
}
class CT {
  constructor(e) {
    (this.id = TT++), (this.code = e), (this.usedTimes = 0);
  }
}
function PT(t, e, i, n, r, s, a) {
  const o = new Vf(),
    l = new AT(),
    c = [],
    d = r.isWebGL2,
    h = r.logarithmicDepthBuffer,
    u = r.vertexTextures;
  let f = r.precision;
  const p = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite",
  };
  function v(S) {
    return S === 0 ? "uv" : `uv${S}`;
  }
  function g(S, w, C, L, P) {
    const R = L.fog,
      I = P.geometry,
      W = S.isMeshStandardMaterial ? L.environment : null,
      N = (S.isMeshStandardMaterial ? i : e).get(S.envMap || W),
      U = N && N.mapping === gl ? N.image.height : null,
      G = p[S.type];
    S.precision !== null &&
      ((f = r.getMaxPrecision(S.precision)),
      f !== S.precision &&
        console.warn(
          "THREE.WebGLProgram.getParameters:",
          S.precision,
          "not supported, using",
          f,
          "instead."
        ));
    const k =
        I.morphAttributes.position ||
        I.morphAttributes.normal ||
        I.morphAttributes.color,
      B = k !== void 0 ? k.length : 0;
    let V = 0;
    I.morphAttributes.position !== void 0 && (V = 1),
      I.morphAttributes.normal !== void 0 && (V = 2),
      I.morphAttributes.color !== void 0 && (V = 3);
    let X, H, j, Y;
    if (G) {
      const Ut = Nn[G];
      (X = Ut.vertexShader), (H = Ut.fragmentShader);
    } else
      (X = S.vertexShader),
        (H = S.fragmentShader),
        l.update(S),
        (j = l.getVertexShaderID(S)),
        (Y = l.getFragmentShaderID(S));
    const ee = t.getRenderTarget(),
      Z = P.isInstancedMesh === !0,
      K = !!S.map,
      me = !!S.matcap,
      re = !!N,
      F = !!S.aoMap,
      Te = !!S.lightMap,
      be = !!S.bumpMap,
      oe = !!S.normalMap,
      Me = !!S.displacementMap,
      Ae = !!S.emissiveMap,
      ye = !!S.metalnessMap,
      _e = !!S.roughnessMap,
      Ee = S.anisotropy > 0,
      Le = S.clearcoat > 0,
      it = S.iridescence > 0,
      O = S.sheen > 0,
      D = S.transmission > 0,
      ne = Ee && !!S.anisotropyMap,
      pe = Le && !!S.clearcoatMap,
      xe = Le && !!S.clearcoatNormalMap,
      we = Le && !!S.clearcoatRoughnessMap,
      Fe = it && !!S.iridescenceMap,
      Se = it && !!S.iridescenceThicknessMap,
      le = O && !!S.sheenColorMap,
      je = O && !!S.sheenRoughnessMap,
      $e = !!S.specularMap,
      Ye = !!S.specularColorMap,
      He = !!S.specularIntensityMap,
      Ge = D && !!S.transmissionMap,
      nt = D && !!S.thicknessMap,
      wt = !!S.gradientMap,
      q = !!S.alphaMap,
      De = S.alphaTest > 0,
      se = !!S.alphaHash,
      Ce = !!S.extensions,
      Ne = !!I.attributes.uv1,
      xt = !!I.attributes.uv2,
      It = !!I.attributes.uv3;
    return {
      isWebGL2: d,
      shaderID: G,
      shaderType: S.type,
      shaderName: S.name,
      vertexShader: X,
      fragmentShader: H,
      defines: S.defines,
      customVertexShaderID: j,
      customFragmentShaderID: Y,
      isRawShaderMaterial: S.isRawShaderMaterial === !0,
      glslVersion: S.glslVersion,
      precision: f,
      instancing: Z,
      instancingColor: Z && P.instanceColor !== null,
      supportsVertexTextures: u,
      outputColorSpace:
        ee === null
          ? t.outputColorSpace
          : ee.isXRRenderTarget === !0
          ? ee.texture.colorSpace
          : qn,
      map: K,
      matcap: me,
      envMap: re,
      envMapMode: re && N.mapping,
      envMapCubeUVHeight: U,
      aoMap: F,
      lightMap: Te,
      bumpMap: be,
      normalMap: oe,
      displacementMap: u && Me,
      emissiveMap: Ae,
      normalMapObjectSpace: oe && S.normalMapType === Tw,
      normalMapTangentSpace: oe && S.normalMapType === ex,
      metalnessMap: ye,
      roughnessMap: _e,
      anisotropy: Ee,
      anisotropyMap: ne,
      clearcoat: Le,
      clearcoatMap: pe,
      clearcoatNormalMap: xe,
      clearcoatRoughnessMap: we,
      iridescence: it,
      iridescenceMap: Fe,
      iridescenceThicknessMap: Se,
      sheen: O,
      sheenColorMap: le,
      sheenRoughnessMap: je,
      specularMap: $e,
      specularColorMap: Ye,
      specularIntensityMap: He,
      transmission: D,
      transmissionMap: Ge,
      thicknessMap: nt,
      gradientMap: wt,
      opaque: S.transparent === !1 && S.blending === Ua,
      alphaMap: q,
      alphaTest: De,
      alphaHash: se,
      combine: S.combine,
      mapUv: K && v(S.map.channel),
      aoMapUv: F && v(S.aoMap.channel),
      lightMapUv: Te && v(S.lightMap.channel),
      bumpMapUv: be && v(S.bumpMap.channel),
      normalMapUv: oe && v(S.normalMap.channel),
      displacementMapUv: Me && v(S.displacementMap.channel),
      emissiveMapUv: Ae && v(S.emissiveMap.channel),
      metalnessMapUv: ye && v(S.metalnessMap.channel),
      roughnessMapUv: _e && v(S.roughnessMap.channel),
      anisotropyMapUv: ne && v(S.anisotropyMap.channel),
      clearcoatMapUv: pe && v(S.clearcoatMap.channel),
      clearcoatNormalMapUv: xe && v(S.clearcoatNormalMap.channel),
      clearcoatRoughnessMapUv: we && v(S.clearcoatRoughnessMap.channel),
      iridescenceMapUv: Fe && v(S.iridescenceMap.channel),
      iridescenceThicknessMapUv: Se && v(S.iridescenceThicknessMap.channel),
      sheenColorMapUv: le && v(S.sheenColorMap.channel),
      sheenRoughnessMapUv: je && v(S.sheenRoughnessMap.channel),
      specularMapUv: $e && v(S.specularMap.channel),
      specularColorMapUv: Ye && v(S.specularColorMap.channel),
      specularIntensityMapUv: He && v(S.specularIntensityMap.channel),
      transmissionMapUv: Ge && v(S.transmissionMap.channel),
      thicknessMapUv: nt && v(S.thicknessMap.channel),
      alphaMapUv: q && v(S.alphaMap.channel),
      vertexTangents: !!I.attributes.tangent && (oe || Ee),
      vertexColors: S.vertexColors,
      vertexAlphas:
        S.vertexColors === !0 &&
        !!I.attributes.color &&
        I.attributes.color.itemSize === 4,
      vertexUv1s: Ne,
      vertexUv2s: xt,
      vertexUv3s: It,
      pointsUvs: P.isPoints === !0 && !!I.attributes.uv && (K || q),
      fog: !!R,
      useFog: S.fog === !0,
      fogExp2: R && R.isFogExp2,
      flatShading: S.flatShading === !0,
      sizeAttenuation: S.sizeAttenuation === !0,
      logarithmicDepthBuffer: h,
      skinning: P.isSkinnedMesh === !0,
      morphTargets: I.morphAttributes.position !== void 0,
      morphNormals: I.morphAttributes.normal !== void 0,
      morphColors: I.morphAttributes.color !== void 0,
      morphTargetsCount: B,
      morphTextureStride: V,
      numDirLights: w.directional.length,
      numPointLights: w.point.length,
      numSpotLights: w.spot.length,
      numSpotLightMaps: w.spotLightMap.length,
      numRectAreaLights: w.rectArea.length,
      numHemiLights: w.hemi.length,
      numDirLightShadows: w.directionalShadowMap.length,
      numPointLightShadows: w.pointShadowMap.length,
      numSpotLightShadows: w.spotShadowMap.length,
      numSpotLightShadowsWithMaps: w.numSpotLightShadowsWithMaps,
      numClippingPlanes: a.numPlanes,
      numClipIntersection: a.numIntersection,
      dithering: S.dithering,
      shadowMapEnabled: t.shadowMap.enabled && C.length > 0,
      shadowMapType: t.shadowMap.type,
      toneMapping: S.toneMapped ? t.toneMapping : Nr,
      useLegacyLights: t.useLegacyLights,
      premultipliedAlpha: S.premultipliedAlpha,
      doubleSided: S.side === Dr,
      flipSided: S.side === nn,
      useDepthPacking: S.depthPacking >= 0,
      depthPacking: S.depthPacking || 0,
      index0AttributeName: S.index0AttributeName,
      extensionDerivatives: Ce && S.extensions.derivatives === !0,
      extensionFragDepth: Ce && S.extensions.fragDepth === !0,
      extensionDrawBuffers: Ce && S.extensions.drawBuffers === !0,
      extensionShaderTextureLOD: Ce && S.extensions.shaderTextureLOD === !0,
      rendererExtensionFragDepth: d || n.has("EXT_frag_depth"),
      rendererExtensionDrawBuffers: d || n.has("WEBGL_draw_buffers"),
      rendererExtensionShaderTextureLod: d || n.has("EXT_shader_texture_lod"),
      customProgramCacheKey: S.customProgramCacheKey(),
    };
  }
  function m(S) {
    const w = [];
    if (
      (S.shaderID
        ? w.push(S.shaderID)
        : (w.push(S.customVertexShaderID), w.push(S.customFragmentShaderID)),
      S.defines !== void 0)
    )
      for (const C in S.defines) w.push(C), w.push(S.defines[C]);
    return (
      S.isRawShaderMaterial === !1 &&
        (x(w, S), y(w, S), w.push(t.outputColorSpace)),
      w.push(S.customProgramCacheKey),
      w.join()
    );
  }
  function x(S, w) {
    S.push(w.precision),
      S.push(w.outputColorSpace),
      S.push(w.envMapMode),
      S.push(w.envMapCubeUVHeight),
      S.push(w.mapUv),
      S.push(w.alphaMapUv),
      S.push(w.lightMapUv),
      S.push(w.aoMapUv),
      S.push(w.bumpMapUv),
      S.push(w.normalMapUv),
      S.push(w.displacementMapUv),
      S.push(w.emissiveMapUv),
      S.push(w.metalnessMapUv),
      S.push(w.roughnessMapUv),
      S.push(w.anisotropyMapUv),
      S.push(w.clearcoatMapUv),
      S.push(w.clearcoatNormalMapUv),
      S.push(w.clearcoatRoughnessMapUv),
      S.push(w.iridescenceMapUv),
      S.push(w.iridescenceThicknessMapUv),
      S.push(w.sheenColorMapUv),
      S.push(w.sheenRoughnessMapUv),
      S.push(w.specularMapUv),
      S.push(w.specularColorMapUv),
      S.push(w.specularIntensityMapUv),
      S.push(w.transmissionMapUv),
      S.push(w.thicknessMapUv),
      S.push(w.combine),
      S.push(w.fogExp2),
      S.push(w.sizeAttenuation),
      S.push(w.morphTargetsCount),
      S.push(w.morphAttributeCount),
      S.push(w.numDirLights),
      S.push(w.numPointLights),
      S.push(w.numSpotLights),
      S.push(w.numSpotLightMaps),
      S.push(w.numHemiLights),
      S.push(w.numRectAreaLights),
      S.push(w.numDirLightShadows),
      S.push(w.numPointLightShadows),
      S.push(w.numSpotLightShadows),
      S.push(w.numSpotLightShadowsWithMaps),
      S.push(w.shadowMapType),
      S.push(w.toneMapping),
      S.push(w.numClippingPlanes),
      S.push(w.numClipIntersection),
      S.push(w.depthPacking);
  }
  function y(S, w) {
    o.disableAll(),
      w.isWebGL2 && o.enable(0),
      w.supportsVertexTextures && o.enable(1),
      w.instancing && o.enable(2),
      w.instancingColor && o.enable(3),
      w.matcap && o.enable(4),
      w.envMap && o.enable(5),
      w.normalMapObjectSpace && o.enable(6),
      w.normalMapTangentSpace && o.enable(7),
      w.clearcoat && o.enable(8),
      w.iridescence && o.enable(9),
      w.alphaTest && o.enable(10),
      w.vertexColors && o.enable(11),
      w.vertexAlphas && o.enable(12),
      w.vertexUv1s && o.enable(13),
      w.vertexUv2s && o.enable(14),
      w.vertexUv3s && o.enable(15),
      w.vertexTangents && o.enable(16),
      w.anisotropy && o.enable(17),
      S.push(o.mask),
      o.disableAll(),
      w.fog && o.enable(0),
      w.useFog && o.enable(1),
      w.flatShading && o.enable(2),
      w.logarithmicDepthBuffer && o.enable(3),
      w.skinning && o.enable(4),
      w.morphTargets && o.enable(5),
      w.morphNormals && o.enable(6),
      w.morphColors && o.enable(7),
      w.premultipliedAlpha && o.enable(8),
      w.shadowMapEnabled && o.enable(9),
      w.useLegacyLights && o.enable(10),
      w.doubleSided && o.enable(11),
      w.flipSided && o.enable(12),
      w.useDepthPacking && o.enable(13),
      w.dithering && o.enable(14),
      w.transmission && o.enable(15),
      w.sheen && o.enable(16),
      w.opaque && o.enable(17),
      w.pointsUvs && o.enable(18),
      S.push(o.mask);
  }
  function _(S) {
    const w = p[S.type];
    let C;
    if (w) {
      const L = Nn[w];
      C = un.clone(L.uniforms);
    } else C = S.uniforms;
    return C;
  }
  function M(S, w) {
    let C;
    for (let L = 0, P = c.length; L < P; L++) {
      const R = c[L];
      if (R.cacheKey === w) {
        (C = R), ++C.usedTimes;
        break;
      }
    }
    return C === void 0 && ((C = new ET(t, w, S, s)), c.push(C)), C;
  }
  function b(S) {
    if (--S.usedTimes === 0) {
      const w = c.indexOf(S);
      (c[w] = c[c.length - 1]), c.pop(), S.destroy();
    }
  }
  function E(S) {
    l.remove(S);
  }
  function T() {
    l.dispose();
  }
  return {
    getParameters: g,
    getProgramCacheKey: m,
    getUniforms: _,
    acquireProgram: M,
    releaseProgram: b,
    releaseShaderCache: E,
    programs: c,
    dispose: T,
  };
}
function LT() {
  let t = new WeakMap();
  function e(s) {
    let a = t.get(s);
    return a === void 0 && ((a = {}), t.set(s, a)), a;
  }
  function i(s) {
    t.delete(s);
  }
  function n(s, a, o) {
    t.get(s)[a] = o;
  }
  function r() {
    t = new WeakMap();
  }
  return { get: e, remove: i, update: n, dispose: r };
}
function DT(t, e) {
  return t.groupOrder !== e.groupOrder
    ? t.groupOrder - e.groupOrder
    : t.renderOrder !== e.renderOrder
    ? t.renderOrder - e.renderOrder
    : t.material.id !== e.material.id
    ? t.material.id - e.material.id
    : t.z !== e.z
    ? t.z - e.z
    : t.id - e.id;
}
function yg(t, e) {
  return t.groupOrder !== e.groupOrder
    ? t.groupOrder - e.groupOrder
    : t.renderOrder !== e.renderOrder
    ? t.renderOrder - e.renderOrder
    : t.z !== e.z
    ? e.z - t.z
    : t.id - e.id;
}
function xg() {
  const t = [];
  let e = 0;
  const i = [],
    n = [],
    r = [];
  function s() {
    (e = 0), (i.length = 0), (n.length = 0), (r.length = 0);
  }
  function a(h, u, f, p, v, g) {
    let m = t[e];
    return (
      m === void 0
        ? ((m = {
            id: h.id,
            object: h,
            geometry: u,
            material: f,
            groupOrder: p,
            renderOrder: h.renderOrder,
            z: v,
            group: g,
          }),
          (t[e] = m))
        : ((m.id = h.id),
          (m.object = h),
          (m.geometry = u),
          (m.material = f),
          (m.groupOrder = p),
          (m.renderOrder = h.renderOrder),
          (m.z = v),
          (m.group = g)),
      e++,
      m
    );
  }
  function o(h, u, f, p, v, g) {
    const m = a(h, u, f, p, v, g);
    f.transmission > 0
      ? n.push(m)
      : f.transparent === !0
      ? r.push(m)
      : i.push(m);
  }
  function l(h, u, f, p, v, g) {
    const m = a(h, u, f, p, v, g);
    f.transmission > 0
      ? n.unshift(m)
      : f.transparent === !0
      ? r.unshift(m)
      : i.unshift(m);
  }
  function c(h, u) {
    i.length > 1 && i.sort(h || DT),
      n.length > 1 && n.sort(u || yg),
      r.length > 1 && r.sort(u || yg);
  }
  function d() {
    for (let h = e, u = t.length; h < u; h++) {
      const f = t[h];
      if (f.id === null) break;
      (f.id = null),
        (f.object = null),
        (f.geometry = null),
        (f.material = null),
        (f.group = null);
    }
  }
  return {
    opaque: i,
    transmissive: n,
    transparent: r,
    init: s,
    push: o,
    unshift: l,
    finish: d,
    sort: c,
  };
}
function RT() {
  let t = new WeakMap();
  function e(n, r) {
    const s = t.get(n);
    let a;
    return (
      s === void 0
        ? ((a = new xg()), t.set(n, [a]))
        : r >= s.length
        ? ((a = new xg()), s.push(a))
        : (a = s[r]),
      a
    );
  }
  function i() {
    t = new WeakMap();
  }
  return { get: e, dispose: i };
}
function OT() {
  const t = {};
  return {
    get: function (e) {
      if (t[e.id] !== void 0) return t[e.id];
      let i;
      switch (e.type) {
        case "DirectionalLight":
          i = { direction: new A(), color: new tt() };
          break;
        case "SpotLight":
          i = {
            position: new A(),
            direction: new A(),
            color: new tt(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0,
          };
          break;
        case "PointLight":
          i = { position: new A(), color: new tt(), distance: 0, decay: 0 };
          break;
        case "HemisphereLight":
          i = { direction: new A(), skyColor: new tt(), groundColor: new tt() };
          break;
        case "RectAreaLight":
          i = {
            color: new tt(),
            position: new A(),
            halfWidth: new A(),
            halfHeight: new A(),
          };
          break;
      }
      return (t[e.id] = i), i;
    },
  };
}
function IT() {
  const t = {};
  return {
    get: function (e) {
      if (t[e.id] !== void 0) return t[e.id];
      let i;
      switch (e.type) {
        case "DirectionalLight":
          i = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new J(),
          };
          break;
        case "SpotLight":
          i = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new J(),
          };
          break;
        case "PointLight":
          i = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new J(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3,
          };
          break;
      }
      return (t[e.id] = i), i;
    },
  };
}
let UT = 0;
function NT(t, e) {
  return (
    (e.castShadow ? 2 : 0) -
    (t.castShadow ? 2 : 0) +
    (e.map ? 1 : 0) -
    (t.map ? 1 : 0)
  );
}
function zT(t, e) {
  const i = new OT(),
    n = IT(),
    r = {
      version: 0,
      hash: {
        directionalLength: -1,
        pointLength: -1,
        spotLength: -1,
        rectAreaLength: -1,
        hemiLength: -1,
        numDirectionalShadows: -1,
        numPointShadows: -1,
        numSpotShadows: -1,
        numSpotMaps: -1,
      },
      ambient: [0, 0, 0],
      probe: [],
      directional: [],
      directionalShadow: [],
      directionalShadowMap: [],
      directionalShadowMatrix: [],
      spot: [],
      spotLightMap: [],
      spotShadow: [],
      spotShadowMap: [],
      spotLightMatrix: [],
      rectArea: [],
      rectAreaLTC1: null,
      rectAreaLTC2: null,
      point: [],
      pointShadow: [],
      pointShadowMap: [],
      pointShadowMatrix: [],
      hemi: [],
      numSpotLightShadowsWithMaps: 0,
    };
  for (let d = 0; d < 9; d++) r.probe.push(new A());
  const s = new A(),
    a = new ze(),
    o = new ze();
  function l(d, h) {
    let u = 0,
      f = 0,
      p = 0;
    for (let C = 0; C < 9; C++) r.probe[C].set(0, 0, 0);
    let v = 0,
      g = 0,
      m = 0,
      x = 0,
      y = 0,
      _ = 0,
      M = 0,
      b = 0,
      E = 0,
      T = 0;
    d.sort(NT);
    const S = h === !0 ? Math.PI : 1;
    for (let C = 0, L = d.length; C < L; C++) {
      const P = d[C],
        R = P.color,
        I = P.intensity,
        W = P.distance,
        N = P.shadow && P.shadow.map ? P.shadow.map.texture : null;
      if (P.isAmbientLight)
        (u += R.r * I * S), (f += R.g * I * S), (p += R.b * I * S);
      else if (P.isLightProbe)
        for (let U = 0; U < 9; U++)
          r.probe[U].addScaledVector(P.sh.coefficients[U], I);
      else if (P.isDirectionalLight) {
        const U = i.get(P);
        if (
          (U.color.copy(P.color).multiplyScalar(P.intensity * S), P.castShadow)
        ) {
          const G = P.shadow,
            k = n.get(P);
          (k.shadowBias = G.bias),
            (k.shadowNormalBias = G.normalBias),
            (k.shadowRadius = G.radius),
            (k.shadowMapSize = G.mapSize),
            (r.directionalShadow[v] = k),
            (r.directionalShadowMap[v] = N),
            (r.directionalShadowMatrix[v] = P.shadow.matrix),
            _++;
        }
        (r.directional[v] = U), v++;
      } else if (P.isSpotLight) {
        const U = i.get(P);
        U.position.setFromMatrixPosition(P.matrixWorld),
          U.color.copy(R).multiplyScalar(I * S),
          (U.distance = W),
          (U.coneCos = Math.cos(P.angle)),
          (U.penumbraCos = Math.cos(P.angle * (1 - P.penumbra))),
          (U.decay = P.decay),
          (r.spot[m] = U);
        const G = P.shadow;
        if (
          (P.map &&
            ((r.spotLightMap[E] = P.map),
            E++,
            G.updateMatrices(P),
            P.castShadow && T++),
          (r.spotLightMatrix[m] = G.matrix),
          P.castShadow)
        ) {
          const k = n.get(P);
          (k.shadowBias = G.bias),
            (k.shadowNormalBias = G.normalBias),
            (k.shadowRadius = G.radius),
            (k.shadowMapSize = G.mapSize),
            (r.spotShadow[m] = k),
            (r.spotShadowMap[m] = N),
            b++;
        }
        m++;
      } else if (P.isRectAreaLight) {
        const U = i.get(P);
        U.color.copy(R).multiplyScalar(I),
          U.halfWidth.set(P.width * 0.5, 0, 0),
          U.halfHeight.set(0, P.height * 0.5, 0),
          (r.rectArea[x] = U),
          x++;
      } else if (P.isPointLight) {
        const U = i.get(P);
        if (
          (U.color.copy(P.color).multiplyScalar(P.intensity * S),
          (U.distance = P.distance),
          (U.decay = P.decay),
          P.castShadow)
        ) {
          const G = P.shadow,
            k = n.get(P);
          (k.shadowBias = G.bias),
            (k.shadowNormalBias = G.normalBias),
            (k.shadowRadius = G.radius),
            (k.shadowMapSize = G.mapSize),
            (k.shadowCameraNear = G.camera.near),
            (k.shadowCameraFar = G.camera.far),
            (r.pointShadow[g] = k),
            (r.pointShadowMap[g] = N),
            (r.pointShadowMatrix[g] = P.shadow.matrix),
            M++;
        }
        (r.point[g] = U), g++;
      } else if (P.isHemisphereLight) {
        const U = i.get(P);
        U.skyColor.copy(P.color).multiplyScalar(I * S),
          U.groundColor.copy(P.groundColor).multiplyScalar(I * S),
          (r.hemi[y] = U),
          y++;
      }
    }
    x > 0 &&
      (e.isWebGL2 || t.has("OES_texture_float_linear") === !0
        ? ((r.rectAreaLTC1 = Pe.LTC_FLOAT_1), (r.rectAreaLTC2 = Pe.LTC_FLOAT_2))
        : t.has("OES_texture_half_float_linear") === !0
        ? ((r.rectAreaLTC1 = Pe.LTC_HALF_1), (r.rectAreaLTC2 = Pe.LTC_HALF_2))
        : console.error(
            "THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions."
          )),
      (r.ambient[0] = u),
      (r.ambient[1] = f),
      (r.ambient[2] = p);
    const w = r.hash;
    (w.directionalLength !== v ||
      w.pointLength !== g ||
      w.spotLength !== m ||
      w.rectAreaLength !== x ||
      w.hemiLength !== y ||
      w.numDirectionalShadows !== _ ||
      w.numPointShadows !== M ||
      w.numSpotShadows !== b ||
      w.numSpotMaps !== E) &&
      ((r.directional.length = v),
      (r.spot.length = m),
      (r.rectArea.length = x),
      (r.point.length = g),
      (r.hemi.length = y),
      (r.directionalShadow.length = _),
      (r.directionalShadowMap.length = _),
      (r.pointShadow.length = M),
      (r.pointShadowMap.length = M),
      (r.spotShadow.length = b),
      (r.spotShadowMap.length = b),
      (r.directionalShadowMatrix.length = _),
      (r.pointShadowMatrix.length = M),
      (r.spotLightMatrix.length = b + E - T),
      (r.spotLightMap.length = E),
      (r.numSpotLightShadowsWithMaps = T),
      (w.directionalLength = v),
      (w.pointLength = g),
      (w.spotLength = m),
      (w.rectAreaLength = x),
      (w.hemiLength = y),
      (w.numDirectionalShadows = _),
      (w.numPointShadows = M),
      (w.numSpotShadows = b),
      (w.numSpotMaps = E),
      (r.version = UT++));
  }
  function c(d, h) {
    let u = 0,
      f = 0,
      p = 0,
      v = 0,
      g = 0;
    const m = h.matrixWorldInverse;
    for (let x = 0, y = d.length; x < y; x++) {
      const _ = d[x];
      if (_.isDirectionalLight) {
        const M = r.directional[u];
        M.direction.setFromMatrixPosition(_.matrixWorld),
          s.setFromMatrixPosition(_.target.matrixWorld),
          M.direction.sub(s),
          M.direction.transformDirection(m),
          u++;
      } else if (_.isSpotLight) {
        const M = r.spot[p];
        M.position.setFromMatrixPosition(_.matrixWorld),
          M.position.applyMatrix4(m),
          M.direction.setFromMatrixPosition(_.matrixWorld),
          s.setFromMatrixPosition(_.target.matrixWorld),
          M.direction.sub(s),
          M.direction.transformDirection(m),
          p++;
      } else if (_.isRectAreaLight) {
        const M = r.rectArea[v];
        M.position.setFromMatrixPosition(_.matrixWorld),
          M.position.applyMatrix4(m),
          o.identity(),
          a.copy(_.matrixWorld),
          a.premultiply(m),
          o.extractRotation(a),
          M.halfWidth.set(_.width * 0.5, 0, 0),
          M.halfHeight.set(0, _.height * 0.5, 0),
          M.halfWidth.applyMatrix4(o),
          M.halfHeight.applyMatrix4(o),
          v++;
      } else if (_.isPointLight) {
        const M = r.point[f];
        M.position.setFromMatrixPosition(_.matrixWorld),
          M.position.applyMatrix4(m),
          f++;
      } else if (_.isHemisphereLight) {
        const M = r.hemi[g];
        M.direction.setFromMatrixPosition(_.matrixWorld),
          M.direction.transformDirection(m),
          g++;
      }
    }
  }
  return { setup: l, setupView: c, state: r };
}
function _g(t, e) {
  const i = new zT(t, e),
    n = [],
    r = [];
  function s() {
    (n.length = 0), (r.length = 0);
  }
  function a(h) {
    n.push(h);
  }
  function o(h) {
    r.push(h);
  }
  function l(h) {
    i.setup(n, h);
  }
  function c(h) {
    i.setupView(n, h);
  }
  return {
    init: s,
    state: { lightsArray: n, shadowsArray: r, lights: i },
    setupLights: l,
    setupLightsView: c,
    pushLight: a,
    pushShadow: o,
  };
}
function BT(t, e) {
  let i = new WeakMap();
  function n(s, a = 0) {
    const o = i.get(s);
    let l;
    return (
      o === void 0
        ? ((l = new _g(t, e)), i.set(s, [l]))
        : a >= o.length
        ? ((l = new _g(t, e)), o.push(l))
        : (l = o[a]),
      l
    );
  }
  function r() {
    i = new WeakMap();
  }
  return { get: n, dispose: r };
}
class FT extends lo {
  constructor(e) {
    super(),
      (this.isMeshDepthMaterial = !0),
      (this.type = "MeshDepthMaterial"),
      (this.depthPacking = Mw),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.depthPacking = e.depthPacking),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      this
    );
  }
}
class kT extends lo {
  constructor(e) {
    super(),
      (this.isMeshDistanceMaterial = !0),
      (this.type = "MeshDistanceMaterial"),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      this
    );
  }
}
const VT = `void main() {
	gl_Position = vec4( position, 1.0 );
}`,
  HT = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function GT(t, e, i) {
  let n = new Gf();
  const r = new J(),
    s = new J(),
    a = new yt(),
    o = new FT({ depthPacking: Ew }),
    l = new kT(),
    c = {},
    d = i.maxTextureSize,
    h = { [ds]: nn, [nn]: ds, [Dr]: Dr },
    u = new Ti({
      defines: { VSM_SAMPLES: 8 },
      uniforms: {
        shadow_pass: { value: null },
        resolution: { value: new J() },
        radius: { value: 4 },
      },
      vertexShader: VT,
      fragmentShader: HT,
    }),
    f = u.clone();
  f.defines.HORIZONTAL_PASS = 1;
  const p = new st();
  p.setAttribute(
    "position",
    new pt(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
  );
  const v = new Fn(p, u),
    g = this;
  (this.enabled = !1),
    (this.autoUpdate = !0),
    (this.needsUpdate = !1),
    (this.type = zy);
  let m = this.type;
  this.render = function (M, b, E) {
    if (
      g.enabled === !1 ||
      (g.autoUpdate === !1 && g.needsUpdate === !1) ||
      M.length === 0
    )
      return;
    const T = t.getRenderTarget(),
      S = t.getActiveCubeFace(),
      w = t.getActiveMipmapLevel(),
      C = t.state;
    C.setBlending(Pi),
      C.buffers.color.setClear(1, 1, 1, 1),
      C.buffers.depth.setTest(!0),
      C.setScissorTest(!1);
    const L = m !== Mr && this.type === Mr,
      P = m === Mr && this.type !== Mr;
    for (let R = 0, I = M.length; R < I; R++) {
      const W = M[R],
        N = W.shadow;
      if (N === void 0) {
        console.warn("THREE.WebGLShadowMap:", W, "has no shadow.");
        continue;
      }
      if (N.autoUpdate === !1 && N.needsUpdate === !1) continue;
      r.copy(N.mapSize);
      const U = N.getFrameExtents();
      if (
        (r.multiply(U),
        s.copy(N.mapSize),
        (r.x > d || r.y > d) &&
          (r.x > d &&
            ((s.x = Math.floor(d / U.x)),
            (r.x = s.x * U.x),
            (N.mapSize.x = s.x)),
          r.y > d &&
            ((s.y = Math.floor(d / U.y)),
            (r.y = s.y * U.y),
            (N.mapSize.y = s.y))),
        N.map === null || L === !0 || P === !0)
      ) {
        const k = this.type !== Mr ? { minFilter: vi, magFilter: vi } : {};
        N.map !== null && N.map.dispose(),
          (N.map = new rn(r.x, r.y, k)),
          (N.map.texture.name = W.name + ".shadowMap"),
          N.camera.updateProjectionMatrix();
      }
      t.setRenderTarget(N.map), t.clear();
      const G = N.getViewportCount();
      for (let k = 0; k < G; k++) {
        const B = N.getViewport(k);
        a.set(s.x * B.x, s.y * B.y, s.x * B.z, s.y * B.w),
          C.viewport(a),
          N.updateMatrices(W, k),
          (n = N.getFrustum()),
          _(b, E, N.camera, W, this.type);
      }
      N.isPointLightShadow !== !0 && this.type === Mr && x(N, E),
        (N.needsUpdate = !1);
    }
    (m = this.type), (g.needsUpdate = !1), t.setRenderTarget(T, S, w);
  };
  function x(M, b) {
    const E = e.update(v);
    u.defines.VSM_SAMPLES !== M.blurSamples &&
      ((u.defines.VSM_SAMPLES = M.blurSamples),
      (f.defines.VSM_SAMPLES = M.blurSamples),
      (u.needsUpdate = !0),
      (f.needsUpdate = !0)),
      M.mapPass === null && (M.mapPass = new rn(r.x, r.y)),
      (u.uniforms.shadow_pass.value = M.map.texture),
      (u.uniforms.resolution.value = M.mapSize),
      (u.uniforms.radius.value = M.radius),
      t.setRenderTarget(M.mapPass),
      t.clear(),
      t.renderBufferDirect(b, null, E, u, v, null),
      (f.uniforms.shadow_pass.value = M.mapPass.texture),
      (f.uniforms.resolution.value = M.mapSize),
      (f.uniforms.radius.value = M.radius),
      t.setRenderTarget(M.map),
      t.clear(),
      t.renderBufferDirect(b, null, E, f, v, null);
  }
  function y(M, b, E, T) {
    let S = null;
    const w =
      E.isPointLight === !0 ? M.customDistanceMaterial : M.customDepthMaterial;
    if (w !== void 0) S = w;
    else if (
      ((S = E.isPointLight === !0 ? l : o),
      (t.localClippingEnabled &&
        b.clipShadows === !0 &&
        Array.isArray(b.clippingPlanes) &&
        b.clippingPlanes.length !== 0) ||
        (b.displacementMap && b.displacementScale !== 0) ||
        (b.alphaMap && b.alphaTest > 0) ||
        (b.map && b.alphaTest > 0))
    ) {
      const C = S.uuid,
        L = b.uuid;
      let P = c[C];
      P === void 0 && ((P = {}), (c[C] = P));
      let R = P[L];
      R === void 0 && ((R = S.clone()), (P[L] = R)), (S = R);
    }
    if (
      ((S.visible = b.visible),
      (S.wireframe = b.wireframe),
      T === Mr
        ? (S.side = b.shadowSide !== null ? b.shadowSide : b.side)
        : (S.side = b.shadowSide !== null ? b.shadowSide : h[b.side]),
      (S.alphaMap = b.alphaMap),
      (S.alphaTest = b.alphaTest),
      (S.map = b.map),
      (S.clipShadows = b.clipShadows),
      (S.clippingPlanes = b.clippingPlanes),
      (S.clipIntersection = b.clipIntersection),
      (S.displacementMap = b.displacementMap),
      (S.displacementScale = b.displacementScale),
      (S.displacementBias = b.displacementBias),
      (S.wireframeLinewidth = b.wireframeLinewidth),
      (S.linewidth = b.linewidth),
      E.isPointLight === !0 && S.isMeshDistanceMaterial === !0)
    ) {
      const C = t.properties.get(S);
      C.light = E;
    }
    return S;
  }
  function _(M, b, E, T, S) {
    if (M.visible === !1) return;
    if (
      M.layers.test(b.layers) &&
      (M.isMesh || M.isLine || M.isPoints) &&
      (M.castShadow || (M.receiveShadow && S === Mr)) &&
      (!M.frustumCulled || n.intersectsObject(M))
    ) {
      M.modelViewMatrix.multiplyMatrices(E.matrixWorldInverse, M.matrixWorld);
      const L = e.update(M),
        P = M.material;
      if (Array.isArray(P)) {
        const R = L.groups;
        for (let I = 0, W = R.length; I < W; I++) {
          const N = R[I],
            U = P[N.materialIndex];
          if (U && U.visible) {
            const G = y(M, U, T, S);
            t.renderBufferDirect(E, null, L, G, M, N);
          }
        }
      } else if (P.visible) {
        const R = y(M, P, T, S);
        t.renderBufferDirect(E, null, L, R, M, null);
      }
    }
    const C = M.children;
    for (let L = 0, P = C.length; L < P; L++) _(C[L], b, E, T, S);
  }
}
function jT(t, e, i) {
  const n = i.isWebGL2;
  function r() {
    let q = !1;
    const De = new yt();
    let se = null;
    const Ce = new yt(0, 0, 0, 0);
    return {
      setMask: function (Ne) {
        se !== Ne && !q && (t.colorMask(Ne, Ne, Ne, Ne), (se = Ne));
      },
      setLocked: function (Ne) {
        q = Ne;
      },
      setClear: function (Ne, xt, It, oi, Ut) {
        Ut === !0 && ((Ne *= oi), (xt *= oi), (It *= oi)),
          De.set(Ne, xt, It, oi),
          Ce.equals(De) === !1 && (t.clearColor(Ne, xt, It, oi), Ce.copy(De));
      },
      reset: function () {
        (q = !1), (se = null), Ce.set(-1, 0, 0, 0);
      },
    };
  }
  function s() {
    let q = !1,
      De = null,
      se = null,
      Ce = null;
    return {
      setTest: function (Ne) {
        Ne ? ee(t.DEPTH_TEST) : Z(t.DEPTH_TEST);
      },
      setMask: function (Ne) {
        De !== Ne && !q && (t.depthMask(Ne), (De = Ne));
      },
      setFunc: function (Ne) {
        if (se !== Ne) {
          switch (Ne) {
            case iw:
              t.depthFunc(t.NEVER);
              break;
            case nw:
              t.depthFunc(t.ALWAYS);
              break;
            case rw:
              t.depthFunc(t.LESS);
              break;
            case fd:
              t.depthFunc(t.LEQUAL);
              break;
            case sw:
              t.depthFunc(t.EQUAL);
              break;
            case aw:
              t.depthFunc(t.GEQUAL);
              break;
            case ow:
              t.depthFunc(t.GREATER);
              break;
            case lw:
              t.depthFunc(t.NOTEQUAL);
              break;
            default:
              t.depthFunc(t.LEQUAL);
          }
          se = Ne;
        }
      },
      setLocked: function (Ne) {
        q = Ne;
      },
      setClear: function (Ne) {
        Ce !== Ne && (t.clearDepth(Ne), (Ce = Ne));
      },
      reset: function () {
        (q = !1), (De = null), (se = null), (Ce = null);
      },
    };
  }
  function a() {
    let q = !1,
      De = null,
      se = null,
      Ce = null,
      Ne = null,
      xt = null,
      It = null,
      oi = null,
      Ut = null;
    return {
      setTest: function (dt) {
        q || (dt ? ee(t.STENCIL_TEST) : Z(t.STENCIL_TEST));
      },
      setMask: function (dt) {
        De !== dt && !q && (t.stencilMask(dt), (De = dt));
      },
      setFunc: function (dt, Nt, Et) {
        (se !== dt || Ce !== Nt || Ne !== Et) &&
          (t.stencilFunc(dt, Nt, Et), (se = dt), (Ce = Nt), (Ne = Et));
      },
      setOp: function (dt, Nt, Et) {
        (xt !== dt || It !== Nt || oi !== Et) &&
          (t.stencilOp(dt, Nt, Et), (xt = dt), (It = Nt), (oi = Et));
      },
      setLocked: function (dt) {
        q = dt;
      },
      setClear: function (dt) {
        Ut !== dt && (t.clearStencil(dt), (Ut = dt));
      },
      reset: function () {
        (q = !1),
          (De = null),
          (se = null),
          (Ce = null),
          (Ne = null),
          (xt = null),
          (It = null),
          (oi = null),
          (Ut = null);
      },
    };
  }
  const o = new r(),
    l = new s(),
    c = new a(),
    d = new WeakMap(),
    h = new WeakMap();
  let u = {},
    f = {},
    p = new WeakMap(),
    v = [],
    g = null,
    m = !1,
    x = null,
    y = null,
    _ = null,
    M = null,
    b = null,
    E = null,
    T = null,
    S = !1,
    w = null,
    C = null,
    L = null,
    P = null,
    R = null;
  const I = t.getParameter(t.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let W = !1,
    N = 0;
  const U = t.getParameter(t.VERSION);
  U.indexOf("WebGL") !== -1
    ? ((N = parseFloat(/^WebGL (\d)/.exec(U)[1])), (W = N >= 1))
    : U.indexOf("OpenGL ES") !== -1 &&
      ((N = parseFloat(/^OpenGL ES (\d)/.exec(U)[1])), (W = N >= 2));
  let G = null,
    k = {};
  const B = t.getParameter(t.SCISSOR_BOX),
    V = t.getParameter(t.VIEWPORT),
    X = new yt().fromArray(B),
    H = new yt().fromArray(V);
  function j(q, De, se, Ce) {
    const Ne = new Uint8Array(4),
      xt = t.createTexture();
    t.bindTexture(q, xt),
      t.texParameteri(q, t.TEXTURE_MIN_FILTER, t.NEAREST),
      t.texParameteri(q, t.TEXTURE_MAG_FILTER, t.NEAREST);
    for (let It = 0; It < se; It++)
      n && (q === t.TEXTURE_3D || q === t.TEXTURE_2D_ARRAY)
        ? t.texImage3D(De, 0, t.RGBA, 1, 1, Ce, 0, t.RGBA, t.UNSIGNED_BYTE, Ne)
        : t.texImage2D(
            De + It,
            0,
            t.RGBA,
            1,
            1,
            0,
            t.RGBA,
            t.UNSIGNED_BYTE,
            Ne
          );
    return xt;
  }
  const Y = {};
  (Y[t.TEXTURE_2D] = j(t.TEXTURE_2D, t.TEXTURE_2D, 1)),
    (Y[t.TEXTURE_CUBE_MAP] = j(
      t.TEXTURE_CUBE_MAP,
      t.TEXTURE_CUBE_MAP_POSITIVE_X,
      6
    )),
    n &&
      ((Y[t.TEXTURE_2D_ARRAY] = j(
        t.TEXTURE_2D_ARRAY,
        t.TEXTURE_2D_ARRAY,
        1,
        1
      )),
      (Y[t.TEXTURE_3D] = j(t.TEXTURE_3D, t.TEXTURE_3D, 1, 1))),
    o.setClear(0, 0, 0, 1),
    l.setClear(1),
    c.setClear(0),
    ee(t.DEPTH_TEST),
    l.setFunc(fd),
    Me(!1),
    Ae(om),
    ee(t.CULL_FACE),
    be(Pi);
  function ee(q) {
    u[q] !== !0 && (t.enable(q), (u[q] = !0));
  }
  function Z(q) {
    u[q] !== !1 && (t.disable(q), (u[q] = !1));
  }
  function K(q, De) {
    return f[q] !== De
      ? (t.bindFramebuffer(q, De),
        (f[q] = De),
        n &&
          (q === t.DRAW_FRAMEBUFFER && (f[t.FRAMEBUFFER] = De),
          q === t.FRAMEBUFFER && (f[t.DRAW_FRAMEBUFFER] = De)),
        !0)
      : !1;
  }
  function me(q, De) {
    let se = v,
      Ce = !1;
    if (q)
      if (
        ((se = p.get(De)),
        se === void 0 && ((se = []), p.set(De, se)),
        q.isWebGLMultipleRenderTargets)
      ) {
        const Ne = q.texture;
        if (se.length !== Ne.length || se[0] !== t.COLOR_ATTACHMENT0) {
          for (let xt = 0, It = Ne.length; xt < It; xt++)
            se[xt] = t.COLOR_ATTACHMENT0 + xt;
          (se.length = Ne.length), (Ce = !0);
        }
      } else
        se[0] !== t.COLOR_ATTACHMENT0 &&
          ((se[0] = t.COLOR_ATTACHMENT0), (Ce = !0));
    else se[0] !== t.BACK && ((se[0] = t.BACK), (Ce = !0));
    Ce &&
      (i.isWebGL2
        ? t.drawBuffers(se)
        : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(se));
  }
  function re(q) {
    return g !== q ? (t.useProgram(q), (g = q), !0) : !1;
  }
  const F = {
    [Xr]: t.FUNC_ADD,
    [$b]: t.FUNC_SUBTRACT,
    [Yb]: t.FUNC_REVERSE_SUBTRACT,
  };
  if (n) (F[hm] = t.MIN), (F[um] = t.MAX);
  else {
    const q = e.get("EXT_blend_minmax");
    q !== null && ((F[hm] = q.MIN_EXT), (F[um] = q.MAX_EXT));
  }
  const Te = {
    [dd]: t.ZERO,
    [Zb]: t.ONE,
    [Kb]: t.SRC_COLOR,
    [ky]: t.SRC_ALPHA,
    [tw]: t.SRC_ALPHA_SATURATE,
    [Gy]: t.DST_COLOR,
    [Hy]: t.DST_ALPHA,
    [Jb]: t.ONE_MINUS_SRC_COLOR,
    [Vy]: t.ONE_MINUS_SRC_ALPHA,
    [ew]: t.ONE_MINUS_DST_COLOR,
    [Qb]: t.ONE_MINUS_DST_ALPHA,
  };
  function be(q, De, se, Ce, Ne, xt, It, oi) {
    if (q === Pi) {
      m === !0 && (Z(t.BLEND), (m = !1));
      return;
    }
    if ((m === !1 && (ee(t.BLEND), (m = !0)), q !== Fy)) {
      if (q !== x || oi !== S) {
        if (
          ((y !== Xr || b !== Xr) &&
            (t.blendEquation(t.FUNC_ADD), (y = Xr), (b = Xr)),
          oi)
        )
          switch (q) {
            case Ua:
              t.blendFuncSeparate(
                t.ONE,
                t.ONE_MINUS_SRC_ALPHA,
                t.ONE,
                t.ONE_MINUS_SRC_ALPHA
              );
              break;
            case ud:
              t.blendFunc(t.ONE, t.ONE);
              break;
            case lm:
              t.blendFuncSeparate(t.ZERO, t.ONE_MINUS_SRC_COLOR, t.ZERO, t.ONE);
              break;
            case cm:
              t.blendFuncSeparate(t.ZERO, t.SRC_COLOR, t.ZERO, t.SRC_ALPHA);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", q);
              break;
          }
        else
          switch (q) {
            case Ua:
              t.blendFuncSeparate(
                t.SRC_ALPHA,
                t.ONE_MINUS_SRC_ALPHA,
                t.ONE,
                t.ONE_MINUS_SRC_ALPHA
              );
              break;
            case ud:
              t.blendFunc(t.SRC_ALPHA, t.ONE);
              break;
            case lm:
              t.blendFuncSeparate(t.ZERO, t.ONE_MINUS_SRC_COLOR, t.ZERO, t.ONE);
              break;
            case cm:
              t.blendFunc(t.ZERO, t.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", q);
              break;
          }
        (_ = null), (M = null), (E = null), (T = null), (x = q), (S = oi);
      }
      return;
    }
    (Ne = Ne || De),
      (xt = xt || se),
      (It = It || Ce),
      (De !== y || Ne !== b) &&
        (t.blendEquationSeparate(F[De], F[Ne]), (y = De), (b = Ne)),
      (se !== _ || Ce !== M || xt !== E || It !== T) &&
        (t.blendFuncSeparate(Te[se], Te[Ce], Te[xt], Te[It]),
        (_ = se),
        (M = Ce),
        (E = xt),
        (T = It)),
      (x = q),
      (S = !1);
  }
  function oe(q, De) {
    q.side === Dr ? Z(t.CULL_FACE) : ee(t.CULL_FACE);
    let se = q.side === nn;
    De && (se = !se),
      Me(se),
      q.blending === Ua && q.transparent === !1
        ? be(Pi)
        : be(
            q.blending,
            q.blendEquation,
            q.blendSrc,
            q.blendDst,
            q.blendEquationAlpha,
            q.blendSrcAlpha,
            q.blendDstAlpha,
            q.premultipliedAlpha
          ),
      l.setFunc(q.depthFunc),
      l.setTest(q.depthTest),
      l.setMask(q.depthWrite),
      o.setMask(q.colorWrite);
    const Ce = q.stencilWrite;
    c.setTest(Ce),
      Ce &&
        (c.setMask(q.stencilWriteMask),
        c.setFunc(q.stencilFunc, q.stencilRef, q.stencilFuncMask),
        c.setOp(q.stencilFail, q.stencilZFail, q.stencilZPass)),
      _e(q.polygonOffset, q.polygonOffsetFactor, q.polygonOffsetUnits),
      q.alphaToCoverage === !0
        ? ee(t.SAMPLE_ALPHA_TO_COVERAGE)
        : Z(t.SAMPLE_ALPHA_TO_COVERAGE);
  }
  function Me(q) {
    w !== q && (q ? t.frontFace(t.CW) : t.frontFace(t.CCW), (w = q));
  }
  function Ae(q) {
    q !== qb
      ? (ee(t.CULL_FACE),
        q !== C &&
          (q === om
            ? t.cullFace(t.BACK)
            : q === Xb
            ? t.cullFace(t.FRONT)
            : t.cullFace(t.FRONT_AND_BACK)))
      : Z(t.CULL_FACE),
      (C = q);
  }
  function ye(q) {
    q !== L && (W && t.lineWidth(q), (L = q));
  }
  function _e(q, De, se) {
    q
      ? (ee(t.POLYGON_OFFSET_FILL),
        (P !== De || R !== se) && (t.polygonOffset(De, se), (P = De), (R = se)))
      : Z(t.POLYGON_OFFSET_FILL);
  }
  function Ee(q) {
    q ? ee(t.SCISSOR_TEST) : Z(t.SCISSOR_TEST);
  }
  function Le(q) {
    q === void 0 && (q = t.TEXTURE0 + I - 1),
      G !== q && (t.activeTexture(q), (G = q));
  }
  function it(q, De, se) {
    se === void 0 && (G === null ? (se = t.TEXTURE0 + I - 1) : (se = G));
    let Ce = k[se];
    Ce === void 0 && ((Ce = { type: void 0, texture: void 0 }), (k[se] = Ce)),
      (Ce.type !== q || Ce.texture !== De) &&
        (G !== se && (t.activeTexture(se), (G = se)),
        t.bindTexture(q, De || Y[q]),
        (Ce.type = q),
        (Ce.texture = De));
  }
  function O() {
    const q = k[G];
    q !== void 0 &&
      q.type !== void 0 &&
      (t.bindTexture(q.type, null), (q.type = void 0), (q.texture = void 0));
  }
  function D() {
    try {
      t.compressedTexImage2D.apply(t, arguments);
    } catch (q) {
      console.error("THREE.WebGLState:", q);
    }
  }
  function ne() {
    try {
      t.compressedTexImage3D.apply(t, arguments);
    } catch (q) {
      console.error("THREE.WebGLState:", q);
    }
  }
  function pe() {
    try {
      t.texSubImage2D.apply(t, arguments);
    } catch (q) {
      console.error("THREE.WebGLState:", q);
    }
  }
  function xe() {
    try {
      t.texSubImage3D.apply(t, arguments);
    } catch (q) {
      console.error("THREE.WebGLState:", q);
    }
  }
  function we() {
    try {
      t.compressedTexSubImage2D.apply(t, arguments);
    } catch (q) {
      console.error("THREE.WebGLState:", q);
    }
  }
  function Fe() {
    try {
      t.compressedTexSubImage3D.apply(t, arguments);
    } catch (q) {
      console.error("THREE.WebGLState:", q);
    }
  }
  function Se() {
    try {
      t.texStorage2D.apply(t, arguments);
    } catch (q) {
      console.error("THREE.WebGLState:", q);
    }
  }
  function le() {
    try {
      t.texStorage3D.apply(t, arguments);
    } catch (q) {
      console.error("THREE.WebGLState:", q);
    }
  }
  function je() {
    try {
      t.texImage2D.apply(t, arguments);
    } catch (q) {
      console.error("THREE.WebGLState:", q);
    }
  }
  function $e() {
    try {
      t.texImage3D.apply(t, arguments);
    } catch (q) {
      console.error("THREE.WebGLState:", q);
    }
  }
  function Ye(q) {
    X.equals(q) === !1 && (t.scissor(q.x, q.y, q.z, q.w), X.copy(q));
  }
  function He(q) {
    H.equals(q) === !1 && (t.viewport(q.x, q.y, q.z, q.w), H.copy(q));
  }
  function Ge(q, De) {
    let se = h.get(De);
    se === void 0 && ((se = new WeakMap()), h.set(De, se));
    let Ce = se.get(q);
    Ce === void 0 && ((Ce = t.getUniformBlockIndex(De, q.name)), se.set(q, Ce));
  }
  function nt(q, De) {
    const Ce = h.get(De).get(q);
    d.get(De) !== Ce &&
      (t.uniformBlockBinding(De, Ce, q.__bindingPointIndex), d.set(De, Ce));
  }
  function wt() {
    t.disable(t.BLEND),
      t.disable(t.CULL_FACE),
      t.disable(t.DEPTH_TEST),
      t.disable(t.POLYGON_OFFSET_FILL),
      t.disable(t.SCISSOR_TEST),
      t.disable(t.STENCIL_TEST),
      t.disable(t.SAMPLE_ALPHA_TO_COVERAGE),
      t.blendEquation(t.FUNC_ADD),
      t.blendFunc(t.ONE, t.ZERO),
      t.blendFuncSeparate(t.ONE, t.ZERO, t.ONE, t.ZERO),
      t.colorMask(!0, !0, !0, !0),
      t.clearColor(0, 0, 0, 0),
      t.depthMask(!0),
      t.depthFunc(t.LESS),
      t.clearDepth(1),
      t.stencilMask(4294967295),
      t.stencilFunc(t.ALWAYS, 0, 4294967295),
      t.stencilOp(t.KEEP, t.KEEP, t.KEEP),
      t.clearStencil(0),
      t.cullFace(t.BACK),
      t.frontFace(t.CCW),
      t.polygonOffset(0, 0),
      t.activeTexture(t.TEXTURE0),
      t.bindFramebuffer(t.FRAMEBUFFER, null),
      n === !0 &&
        (t.bindFramebuffer(t.DRAW_FRAMEBUFFER, null),
        t.bindFramebuffer(t.READ_FRAMEBUFFER, null)),
      t.useProgram(null),
      t.lineWidth(1),
      t.scissor(0, 0, t.canvas.width, t.canvas.height),
      t.viewport(0, 0, t.canvas.width, t.canvas.height),
      (u = {}),
      (G = null),
      (k = {}),
      (f = {}),
      (p = new WeakMap()),
      (v = []),
      (g = null),
      (m = !1),
      (x = null),
      (y = null),
      (_ = null),
      (M = null),
      (b = null),
      (E = null),
      (T = null),
      (S = !1),
      (w = null),
      (C = null),
      (L = null),
      (P = null),
      (R = null),
      X.set(0, 0, t.canvas.width, t.canvas.height),
      H.set(0, 0, t.canvas.width, t.canvas.height),
      o.reset(),
      l.reset(),
      c.reset();
  }
  return {
    buffers: { color: o, depth: l, stencil: c },
    enable: ee,
    disable: Z,
    bindFramebuffer: K,
    drawBuffers: me,
    useProgram: re,
    setBlending: be,
    setMaterial: oe,
    setFlipSided: Me,
    setCullFace: Ae,
    setLineWidth: ye,
    setPolygonOffset: _e,
    setScissorTest: Ee,
    activeTexture: Le,
    bindTexture: it,
    unbindTexture: O,
    compressedTexImage2D: D,
    compressedTexImage3D: ne,
    texImage2D: je,
    texImage3D: $e,
    updateUBOMapping: Ge,
    uniformBlockBinding: nt,
    texStorage2D: Se,
    texStorage3D: le,
    texSubImage2D: pe,
    texSubImage3D: xe,
    compressedTexSubImage2D: we,
    compressedTexSubImage3D: Fe,
    scissor: Ye,
    viewport: He,
    reset: wt,
  };
}
function WT(t, e, i, n, r, s, a) {
  const o = r.isWebGL2,
    l = r.maxTextures,
    c = r.maxCubemapSize,
    d = r.maxTextureSize,
    h = r.maxSamples,
    u = e.has("WEBGL_multisampled_render_to_texture")
      ? e.get("WEBGL_multisampled_render_to_texture")
      : null,
    f =
      typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent),
    p = new WeakMap();
  let v;
  const g = new WeakMap();
  let m = !1;
  try {
    m =
      typeof OffscreenCanvas < "u" &&
      new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {}
  function x(O, D) {
    return m ? new OffscreenCanvas(O, D) : Fc("canvas");
  }
  function y(O, D, ne, pe) {
    let xe = 1;
    if (
      ((O.width > pe || O.height > pe) &&
        (xe = pe / Math.max(O.width, O.height)),
      xe < 1 || D === !0)
    )
      if (
        (typeof HTMLImageElement < "u" && O instanceof HTMLImageElement) ||
        (typeof HTMLCanvasElement < "u" && O instanceof HTMLCanvasElement) ||
        (typeof ImageBitmap < "u" && O instanceof ImageBitmap)
      ) {
        const we = D ? Bc : Math.floor,
          Fe = we(xe * O.width),
          Se = we(xe * O.height);
        v === void 0 && (v = x(Fe, Se));
        const le = ne ? x(Fe, Se) : v;
        return (
          (le.width = Fe),
          (le.height = Se),
          le.getContext("2d").drawImage(O, 0, 0, Fe, Se),
          console.warn(
            "THREE.WebGLRenderer: Texture has been resized from (" +
              O.width +
              "x" +
              O.height +
              ") to (" +
              Fe +
              "x" +
              Se +
              ")."
          ),
          le
        );
      } else
        return (
          "data" in O &&
            console.warn(
              "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                O.width +
                "x" +
                O.height +
                ")."
            ),
          O
        );
    return O;
  }
  function _(O) {
    return xd(O.width) && xd(O.height);
  }
  function M(O) {
    return o
      ? !1
      : O.wrapS !== Bn ||
          O.wrapT !== Bn ||
          (O.minFilter !== vi && O.minFilter !== Zi);
  }
  function b(O, D) {
    return O.generateMipmaps && D && O.minFilter !== vi && O.minFilter !== Zi;
  }
  function E(O) {
    t.generateMipmap(O);
  }
  function T(O, D, ne, pe, xe = !1) {
    if (o === !1) return D;
    if (O !== null) {
      if (t[O] !== void 0) return t[O];
      console.warn(
        "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
          O +
          "'"
      );
    }
    let we = D;
    return (
      D === t.RED &&
        (ne === t.FLOAT && (we = t.R32F),
        ne === t.HALF_FLOAT && (we = t.R16F),
        ne === t.UNSIGNED_BYTE && (we = t.R8)),
      D === t.RG &&
        (ne === t.FLOAT && (we = t.RG32F),
        ne === t.HALF_FLOAT && (we = t.RG16F),
        ne === t.UNSIGNED_BYTE && (we = t.RG8)),
      D === t.RGBA &&
        (ne === t.FLOAT && (we = t.RGBA32F),
        ne === t.HALF_FLOAT && (we = t.RGBA16F),
        ne === t.UNSIGNED_BYTE &&
          (we = pe === gt && xe === !1 ? t.SRGB8_ALPHA8 : t.RGBA8),
        ne === t.UNSIGNED_SHORT_4_4_4_4 && (we = t.RGBA4),
        ne === t.UNSIGNED_SHORT_5_5_5_1 && (we = t.RGB5_A1)),
      (we === t.R16F ||
        we === t.R32F ||
        we === t.RG16F ||
        we === t.RG32F ||
        we === t.RGBA16F ||
        we === t.RGBA32F) &&
        e.get("EXT_color_buffer_float"),
      we
    );
  }
  function S(O, D, ne) {
    return b(O, ne) === !0 ||
      (O.isFramebufferTexture && O.minFilter !== vi && O.minFilter !== Zi)
      ? Math.log2(Math.max(D.width, D.height)) + 1
      : O.mipmaps !== void 0 && O.mipmaps.length > 0
      ? O.mipmaps.length
      : O.isCompressedTexture && Array.isArray(O.image)
      ? D.mipmaps.length
      : 1;
  }
  function w(O) {
    return O === vi || O === dm || O === Yh ? t.NEAREST : t.LINEAR;
  }
  function C(O) {
    const D = O.target;
    D.removeEventListener("dispose", C), P(D), D.isVideoTexture && p.delete(D);
  }
  function L(O) {
    const D = O.target;
    D.removeEventListener("dispose", L), I(D);
  }
  function P(O) {
    const D = n.get(O);
    if (D.__webglInit === void 0) return;
    const ne = O.source,
      pe = g.get(ne);
    if (pe) {
      const xe = pe[D.__cacheKey];
      xe.usedTimes--,
        xe.usedTimes === 0 && R(O),
        Object.keys(pe).length === 0 && g.delete(ne);
    }
    n.remove(O);
  }
  function R(O) {
    const D = n.get(O);
    t.deleteTexture(D.__webglTexture);
    const ne = O.source,
      pe = g.get(ne);
    delete pe[D.__cacheKey], a.memory.textures--;
  }
  function I(O) {
    const D = O.texture,
      ne = n.get(O),
      pe = n.get(D);
    if (
      (pe.__webglTexture !== void 0 &&
        (t.deleteTexture(pe.__webglTexture), a.memory.textures--),
      O.depthTexture && O.depthTexture.dispose(),
      O.isWebGLCubeRenderTarget)
    )
      for (let xe = 0; xe < 6; xe++)
        t.deleteFramebuffer(ne.__webglFramebuffer[xe]),
          ne.__webglDepthbuffer &&
            t.deleteRenderbuffer(ne.__webglDepthbuffer[xe]);
    else {
      if (
        (t.deleteFramebuffer(ne.__webglFramebuffer),
        ne.__webglDepthbuffer && t.deleteRenderbuffer(ne.__webglDepthbuffer),
        ne.__webglMultisampledFramebuffer &&
          t.deleteFramebuffer(ne.__webglMultisampledFramebuffer),
        ne.__webglColorRenderbuffer)
      )
        for (let xe = 0; xe < ne.__webglColorRenderbuffer.length; xe++)
          ne.__webglColorRenderbuffer[xe] &&
            t.deleteRenderbuffer(ne.__webglColorRenderbuffer[xe]);
      ne.__webglDepthRenderbuffer &&
        t.deleteRenderbuffer(ne.__webglDepthRenderbuffer);
    }
    if (O.isWebGLMultipleRenderTargets)
      for (let xe = 0, we = D.length; xe < we; xe++) {
        const Fe = n.get(D[xe]);
        Fe.__webglTexture &&
          (t.deleteTexture(Fe.__webglTexture), a.memory.textures--),
          n.remove(D[xe]);
      }
    n.remove(D), n.remove(O);
  }
  let W = 0;
  function N() {
    W = 0;
  }
  function U() {
    const O = W;
    return (
      O >= l &&
        console.warn(
          "THREE.WebGLTextures: Trying to use " +
            O +
            " texture units while this GPU supports only " +
            l
        ),
      (W += 1),
      O
    );
  }
  function G(O) {
    const D = [];
    return (
      D.push(O.wrapS),
      D.push(O.wrapT),
      D.push(O.wrapR || 0),
      D.push(O.magFilter),
      D.push(O.minFilter),
      D.push(O.anisotropy),
      D.push(O.internalFormat),
      D.push(O.format),
      D.push(O.type),
      D.push(O.generateMipmaps),
      D.push(O.premultiplyAlpha),
      D.push(O.flipY),
      D.push(O.unpackAlignment),
      D.push(O.colorSpace),
      D.join()
    );
  }
  function k(O, D) {
    const ne = n.get(O);
    if (
      (O.isVideoTexture && Le(O),
      O.isRenderTargetTexture === !1 &&
        O.version > 0 &&
        ne.__version !== O.version)
    ) {
      const pe = O.image;
      if (pe === null)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but no image data found."
        );
      else if (pe.complete === !1)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
        );
      else {
        K(ne, O, D);
        return;
      }
    }
    i.bindTexture(t.TEXTURE_2D, ne.__webglTexture, t.TEXTURE0 + D);
  }
  function B(O, D) {
    const ne = n.get(O);
    if (O.version > 0 && ne.__version !== O.version) {
      K(ne, O, D);
      return;
    }
    i.bindTexture(t.TEXTURE_2D_ARRAY, ne.__webglTexture, t.TEXTURE0 + D);
  }
  function V(O, D) {
    const ne = n.get(O);
    if (O.version > 0 && ne.__version !== O.version) {
      K(ne, O, D);
      return;
    }
    i.bindTexture(t.TEXTURE_3D, ne.__webglTexture, t.TEXTURE0 + D);
  }
  function X(O, D) {
    const ne = n.get(O);
    if (O.version > 0 && ne.__version !== O.version) {
      me(ne, O, D);
      return;
    }
    i.bindTexture(t.TEXTURE_CUBE_MAP, ne.__webglTexture, t.TEXTURE0 + D);
  }
  const H = { [nl]: t.REPEAT, [Bn]: t.CLAMP_TO_EDGE, [gd]: t.MIRRORED_REPEAT },
    j = {
      [vi]: t.NEAREST,
      [dm]: t.NEAREST_MIPMAP_NEAREST,
      [Yh]: t.NEAREST_MIPMAP_LINEAR,
      [Zi]: t.LINEAR,
      [gw]: t.LINEAR_MIPMAP_NEAREST,
      [rl]: t.LINEAR_MIPMAP_LINEAR,
    },
    Y = {
      [Cw]: t.NEVER,
      [Uw]: t.ALWAYS,
      [Pw]: t.LESS,
      [Dw]: t.LEQUAL,
      [Lw]: t.EQUAL,
      [Iw]: t.GEQUAL,
      [Rw]: t.GREATER,
      [Ow]: t.NOTEQUAL,
    };
  function ee(O, D, ne) {
    if (
      (ne
        ? (t.texParameteri(O, t.TEXTURE_WRAP_S, H[D.wrapS]),
          t.texParameteri(O, t.TEXTURE_WRAP_T, H[D.wrapT]),
          (O === t.TEXTURE_3D || O === t.TEXTURE_2D_ARRAY) &&
            t.texParameteri(O, t.TEXTURE_WRAP_R, H[D.wrapR]),
          t.texParameteri(O, t.TEXTURE_MAG_FILTER, j[D.magFilter]),
          t.texParameteri(O, t.TEXTURE_MIN_FILTER, j[D.minFilter]))
        : (t.texParameteri(O, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE),
          t.texParameteri(O, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE),
          (O === t.TEXTURE_3D || O === t.TEXTURE_2D_ARRAY) &&
            t.texParameteri(O, t.TEXTURE_WRAP_R, t.CLAMP_TO_EDGE),
          (D.wrapS !== Bn || D.wrapT !== Bn) &&
            console.warn(
              "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."
            ),
          t.texParameteri(O, t.TEXTURE_MAG_FILTER, w(D.magFilter)),
          t.texParameteri(O, t.TEXTURE_MIN_FILTER, w(D.minFilter)),
          D.minFilter !== vi &&
            D.minFilter !== Zi &&
            console.warn(
              "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."
            )),
      D.compareFunction &&
        (t.texParameteri(O, t.TEXTURE_COMPARE_MODE, t.COMPARE_REF_TO_TEXTURE),
        t.texParameteri(O, t.TEXTURE_COMPARE_FUNC, Y[D.compareFunction])),
      e.has("EXT_texture_filter_anisotropic") === !0)
    ) {
      const pe = e.get("EXT_texture_filter_anisotropic");
      if (
        D.magFilter === vi ||
        (D.minFilter !== Yh && D.minFilter !== rl) ||
        (D.type === lr && e.has("OES_texture_float_linear") === !1) ||
        (o === !1 &&
          D.type === Mn &&
          e.has("OES_texture_half_float_linear") === !1)
      )
        return;
      (D.anisotropy > 1 || n.get(D).__currentAnisotropy) &&
        (t.texParameterf(
          O,
          pe.TEXTURE_MAX_ANISOTROPY_EXT,
          Math.min(D.anisotropy, r.getMaxAnisotropy())
        ),
        (n.get(D).__currentAnisotropy = D.anisotropy));
    }
  }
  function Z(O, D) {
    let ne = !1;
    O.__webglInit === void 0 &&
      ((O.__webglInit = !0), D.addEventListener("dispose", C));
    const pe = D.source;
    let xe = g.get(pe);
    xe === void 0 && ((xe = {}), g.set(pe, xe));
    const we = G(D);
    if (we !== O.__cacheKey) {
      xe[we] === void 0 &&
        ((xe[we] = { texture: t.createTexture(), usedTimes: 0 }),
        a.memory.textures++,
        (ne = !0)),
        xe[we].usedTimes++;
      const Fe = xe[O.__cacheKey];
      Fe !== void 0 &&
        (xe[O.__cacheKey].usedTimes--, Fe.usedTimes === 0 && R(D)),
        (O.__cacheKey = we),
        (O.__webglTexture = xe[we].texture);
    }
    return ne;
  }
  function K(O, D, ne) {
    let pe = t.TEXTURE_2D;
    (D.isDataArrayTexture || D.isCompressedArrayTexture) &&
      (pe = t.TEXTURE_2D_ARRAY),
      D.isData3DTexture && (pe = t.TEXTURE_3D);
    const xe = Z(O, D),
      we = D.source;
    i.bindTexture(pe, O.__webglTexture, t.TEXTURE0 + ne);
    const Fe = n.get(we);
    if (we.version !== Fe.__version || xe === !0) {
      i.activeTexture(t.TEXTURE0 + ne),
        t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, D.flipY),
        t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, D.premultiplyAlpha),
        t.pixelStorei(t.UNPACK_ALIGNMENT, D.unpackAlignment),
        t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, t.NONE);
      const Se = M(D) && _(D.image) === !1;
      let le = y(D.image, Se, !1, d);
      le = it(D, le);
      const je = _(le) || o,
        $e = s.convert(D.format, D.colorSpace);
      let Ye = s.convert(D.type),
        He = T(D.internalFormat, $e, Ye, D.colorSpace);
      ee(pe, D, je);
      let Ge;
      const nt = D.mipmaps,
        wt = o && D.isVideoTexture !== !0,
        q = Fe.__version === void 0 || xe === !0,
        De = S(D, le, je);
      if (D.isDepthTexture)
        (He = t.DEPTH_COMPONENT),
          o
            ? D.type === lr
              ? (He = t.DEPTH_COMPONENT32F)
              : D.type === Zr
              ? (He = t.DEPTH_COMPONENT24)
              : D.type === ss
              ? (He = t.DEPTH24_STENCIL8)
              : (He = t.DEPTH_COMPONENT16)
            : D.type === lr &&
              console.error(
                "WebGLRenderer: Floating point depth texture requires WebGL2."
              ),
          D.format === zs &&
            He === t.DEPTH_COMPONENT &&
            D.type !== Ff &&
            D.type !== Zr &&
            (console.warn(
              "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."
            ),
            (D.type = Zr),
            (Ye = s.convert(D.type))),
          D.format === js &&
            He === t.DEPTH_COMPONENT &&
            ((He = t.DEPTH_STENCIL),
            D.type !== ss &&
              (console.warn(
                "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."
              ),
              (D.type = ss),
              (Ye = s.convert(D.type)))),
          q &&
            (wt
              ? i.texStorage2D(t.TEXTURE_2D, 1, He, le.width, le.height)
              : i.texImage2D(
                  t.TEXTURE_2D,
                  0,
                  He,
                  le.width,
                  le.height,
                  0,
                  $e,
                  Ye,
                  null
                ));
      else if (D.isDataTexture)
        if (nt.length > 0 && je) {
          wt &&
            q &&
            i.texStorage2D(t.TEXTURE_2D, De, He, nt[0].width, nt[0].height);
          for (let se = 0, Ce = nt.length; se < Ce; se++)
            (Ge = nt[se]),
              wt
                ? i.texSubImage2D(
                    t.TEXTURE_2D,
                    se,
                    0,
                    0,
                    Ge.width,
                    Ge.height,
                    $e,
                    Ye,
                    Ge.data
                  )
                : i.texImage2D(
                    t.TEXTURE_2D,
                    se,
                    He,
                    Ge.width,
                    Ge.height,
                    0,
                    $e,
                    Ye,
                    Ge.data
                  );
          D.generateMipmaps = !1;
        } else
          wt
            ? (q && i.texStorage2D(t.TEXTURE_2D, De, He, le.width, le.height),
              i.texSubImage2D(
                t.TEXTURE_2D,
                0,
                0,
                0,
                le.width,
                le.height,
                $e,
                Ye,
                le.data
              ))
            : i.texImage2D(
                t.TEXTURE_2D,
                0,
                He,
                le.width,
                le.height,
                0,
                $e,
                Ye,
                le.data
              );
      else if (D.isCompressedTexture)
        if (D.isCompressedArrayTexture) {
          wt &&
            q &&
            i.texStorage3D(
              t.TEXTURE_2D_ARRAY,
              De,
              He,
              nt[0].width,
              nt[0].height,
              le.depth
            );
          for (let se = 0, Ce = nt.length; se < Ce; se++)
            (Ge = nt[se]),
              D.format !== wn
                ? $e !== null
                  ? wt
                    ? i.compressedTexSubImage3D(
                        t.TEXTURE_2D_ARRAY,
                        se,
                        0,
                        0,
                        0,
                        Ge.width,
                        Ge.height,
                        le.depth,
                        $e,
                        Ge.data,
                        0,
                        0
                      )
                    : i.compressedTexImage3D(
                        t.TEXTURE_2D_ARRAY,
                        se,
                        He,
                        Ge.width,
                        Ge.height,
                        le.depth,
                        0,
                        Ge.data,
                        0,
                        0
                      )
                  : console.warn(
                      "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                    )
                : wt
                ? i.texSubImage3D(
                    t.TEXTURE_2D_ARRAY,
                    se,
                    0,
                    0,
                    0,
                    Ge.width,
                    Ge.height,
                    le.depth,
                    $e,
                    Ye,
                    Ge.data
                  )
                : i.texImage3D(
                    t.TEXTURE_2D_ARRAY,
                    se,
                    He,
                    Ge.width,
                    Ge.height,
                    le.depth,
                    0,
                    $e,
                    Ye,
                    Ge.data
                  );
        } else {
          wt &&
            q &&
            i.texStorage2D(t.TEXTURE_2D, De, He, nt[0].width, nt[0].height);
          for (let se = 0, Ce = nt.length; se < Ce; se++)
            (Ge = nt[se]),
              D.format !== wn
                ? $e !== null
                  ? wt
                    ? i.compressedTexSubImage2D(
                        t.TEXTURE_2D,
                        se,
                        0,
                        0,
                        Ge.width,
                        Ge.height,
                        $e,
                        Ge.data
                      )
                    : i.compressedTexImage2D(
                        t.TEXTURE_2D,
                        se,
                        He,
                        Ge.width,
                        Ge.height,
                        0,
                        Ge.data
                      )
                  : console.warn(
                      "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                    )
                : wt
                ? i.texSubImage2D(
                    t.TEXTURE_2D,
                    se,
                    0,
                    0,
                    Ge.width,
                    Ge.height,
                    $e,
                    Ye,
                    Ge.data
                  )
                : i.texImage2D(
                    t.TEXTURE_2D,
                    se,
                    He,
                    Ge.width,
                    Ge.height,
                    0,
                    $e,
                    Ye,
                    Ge.data
                  );
        }
      else if (D.isDataArrayTexture)
        wt
          ? (q &&
              i.texStorage3D(
                t.TEXTURE_2D_ARRAY,
                De,
                He,
                le.width,
                le.height,
                le.depth
              ),
            i.texSubImage3D(
              t.TEXTURE_2D_ARRAY,
              0,
              0,
              0,
              0,
              le.width,
              le.height,
              le.depth,
              $e,
              Ye,
              le.data
            ))
          : i.texImage3D(
              t.TEXTURE_2D_ARRAY,
              0,
              He,
              le.width,
              le.height,
              le.depth,
              0,
              $e,
              Ye,
              le.data
            );
      else if (D.isData3DTexture)
        wt
          ? (q &&
              i.texStorage3D(
                t.TEXTURE_3D,
                De,
                He,
                le.width,
                le.height,
                le.depth
              ),
            i.texSubImage3D(
              t.TEXTURE_3D,
              0,
              0,
              0,
              0,
              le.width,
              le.height,
              le.depth,
              $e,
              Ye,
              le.data
            ))
          : i.texImage3D(
              t.TEXTURE_3D,
              0,
              He,
              le.width,
              le.height,
              le.depth,
              0,
              $e,
              Ye,
              le.data
            );
      else if (D.isFramebufferTexture) {
        if (q)
          if (wt) i.texStorage2D(t.TEXTURE_2D, De, He, le.width, le.height);
          else {
            let se = le.width,
              Ce = le.height;
            for (let Ne = 0; Ne < De; Ne++)
              i.texImage2D(t.TEXTURE_2D, Ne, He, se, Ce, 0, $e, Ye, null),
                (se >>= 1),
                (Ce >>= 1);
          }
      } else if (nt.length > 0 && je) {
        wt &&
          q &&
          i.texStorage2D(t.TEXTURE_2D, De, He, nt[0].width, nt[0].height);
        for (let se = 0, Ce = nt.length; se < Ce; se++)
          (Ge = nt[se]),
            wt
              ? i.texSubImage2D(t.TEXTURE_2D, se, 0, 0, $e, Ye, Ge)
              : i.texImage2D(t.TEXTURE_2D, se, He, $e, Ye, Ge);
        D.generateMipmaps = !1;
      } else
        wt
          ? (q && i.texStorage2D(t.TEXTURE_2D, De, He, le.width, le.height),
            i.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, $e, Ye, le))
          : i.texImage2D(t.TEXTURE_2D, 0, He, $e, Ye, le);
      b(D, je) && E(pe),
        (Fe.__version = we.version),
        D.onUpdate && D.onUpdate(D);
    }
    O.__version = D.version;
  }
  function me(O, D, ne) {
    if (D.image.length !== 6) return;
    const pe = Z(O, D),
      xe = D.source;
    i.bindTexture(t.TEXTURE_CUBE_MAP, O.__webglTexture, t.TEXTURE0 + ne);
    const we = n.get(xe);
    if (xe.version !== we.__version || pe === !0) {
      i.activeTexture(t.TEXTURE0 + ne),
        t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, D.flipY),
        t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, D.premultiplyAlpha),
        t.pixelStorei(t.UNPACK_ALIGNMENT, D.unpackAlignment),
        t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, t.NONE);
      const Fe = D.isCompressedTexture || D.image[0].isCompressedTexture,
        Se = D.image[0] && D.image[0].isDataTexture,
        le = [];
      for (let se = 0; se < 6; se++)
        !Fe && !Se
          ? (le[se] = y(D.image[se], !1, !0, c))
          : (le[se] = Se ? D.image[se].image : D.image[se]),
          (le[se] = it(D, le[se]));
      const je = le[0],
        $e = _(je) || o,
        Ye = s.convert(D.format, D.colorSpace),
        He = s.convert(D.type),
        Ge = T(D.internalFormat, Ye, He, D.colorSpace),
        nt = o && D.isVideoTexture !== !0,
        wt = we.__version === void 0 || pe === !0;
      let q = S(D, je, $e);
      ee(t.TEXTURE_CUBE_MAP, D, $e);
      let De;
      if (Fe) {
        nt &&
          wt &&
          i.texStorage2D(t.TEXTURE_CUBE_MAP, q, Ge, je.width, je.height);
        for (let se = 0; se < 6; se++) {
          De = le[se].mipmaps;
          for (let Ce = 0; Ce < De.length; Ce++) {
            const Ne = De[Ce];
            D.format !== wn
              ? Ye !== null
                ? nt
                  ? i.compressedTexSubImage2D(
                      t.TEXTURE_CUBE_MAP_POSITIVE_X + se,
                      Ce,
                      0,
                      0,
                      Ne.width,
                      Ne.height,
                      Ye,
                      Ne.data
                    )
                  : i.compressedTexImage2D(
                      t.TEXTURE_CUBE_MAP_POSITIVE_X + se,
                      Ce,
                      Ge,
                      Ne.width,
                      Ne.height,
                      0,
                      Ne.data
                    )
                : console.warn(
                    "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                  )
              : nt
              ? i.texSubImage2D(
                  t.TEXTURE_CUBE_MAP_POSITIVE_X + se,
                  Ce,
                  0,
                  0,
                  Ne.width,
                  Ne.height,
                  Ye,
                  He,
                  Ne.data
                )
              : i.texImage2D(
                  t.TEXTURE_CUBE_MAP_POSITIVE_X + se,
                  Ce,
                  Ge,
                  Ne.width,
                  Ne.height,
                  0,
                  Ye,
                  He,
                  Ne.data
                );
          }
        }
      } else {
        (De = D.mipmaps),
          nt &&
            wt &&
            (De.length > 0 && q++,
            i.texStorage2D(
              t.TEXTURE_CUBE_MAP,
              q,
              Ge,
              le[0].width,
              le[0].height
            ));
        for (let se = 0; se < 6; se++)
          if (Se) {
            nt
              ? i.texSubImage2D(
                  t.TEXTURE_CUBE_MAP_POSITIVE_X + se,
                  0,
                  0,
                  0,
                  le[se].width,
                  le[se].height,
                  Ye,
                  He,
                  le[se].data
                )
              : i.texImage2D(
                  t.TEXTURE_CUBE_MAP_POSITIVE_X + se,
                  0,
                  Ge,
                  le[se].width,
                  le[se].height,
                  0,
                  Ye,
                  He,
                  le[se].data
                );
            for (let Ce = 0; Ce < De.length; Ce++) {
              const xt = De[Ce].image[se].image;
              nt
                ? i.texSubImage2D(
                    t.TEXTURE_CUBE_MAP_POSITIVE_X + se,
                    Ce + 1,
                    0,
                    0,
                    xt.width,
                    xt.height,
                    Ye,
                    He,
                    xt.data
                  )
                : i.texImage2D(
                    t.TEXTURE_CUBE_MAP_POSITIVE_X + se,
                    Ce + 1,
                    Ge,
                    xt.width,
                    xt.height,
                    0,
                    Ye,
                    He,
                    xt.data
                  );
            }
          } else {
            nt
              ? i.texSubImage2D(
                  t.TEXTURE_CUBE_MAP_POSITIVE_X + se,
                  0,
                  0,
                  0,
                  Ye,
                  He,
                  le[se]
                )
              : i.texImage2D(
                  t.TEXTURE_CUBE_MAP_POSITIVE_X + se,
                  0,
                  Ge,
                  Ye,
                  He,
                  le[se]
                );
            for (let Ce = 0; Ce < De.length; Ce++) {
              const Ne = De[Ce];
              nt
                ? i.texSubImage2D(
                    t.TEXTURE_CUBE_MAP_POSITIVE_X + se,
                    Ce + 1,
                    0,
                    0,
                    Ye,
                    He,
                    Ne.image[se]
                  )
                : i.texImage2D(
                    t.TEXTURE_CUBE_MAP_POSITIVE_X + se,
                    Ce + 1,
                    Ge,
                    Ye,
                    He,
                    Ne.image[se]
                  );
            }
          }
      }
      b(D, $e) && E(t.TEXTURE_CUBE_MAP),
        (we.__version = xe.version),
        D.onUpdate && D.onUpdate(D);
    }
    O.__version = D.version;
  }
  function re(O, D, ne, pe, xe) {
    const we = s.convert(ne.format, ne.colorSpace),
      Fe = s.convert(ne.type),
      Se = T(ne.internalFormat, we, Fe, ne.colorSpace);
    n.get(D).__hasExternalTextures ||
      (xe === t.TEXTURE_3D || xe === t.TEXTURE_2D_ARRAY
        ? i.texImage3D(xe, 0, Se, D.width, D.height, D.depth, 0, we, Fe, null)
        : i.texImage2D(xe, 0, Se, D.width, D.height, 0, we, Fe, null)),
      i.bindFramebuffer(t.FRAMEBUFFER, O),
      Ee(D)
        ? u.framebufferTexture2DMultisampleEXT(
            t.FRAMEBUFFER,
            pe,
            xe,
            n.get(ne).__webglTexture,
            0,
            _e(D)
          )
        : (xe === t.TEXTURE_2D ||
            (xe >= t.TEXTURE_CUBE_MAP_POSITIVE_X &&
              xe <= t.TEXTURE_CUBE_MAP_NEGATIVE_Z)) &&
          t.framebufferTexture2D(
            t.FRAMEBUFFER,
            pe,
            xe,
            n.get(ne).__webglTexture,
            0
          ),
      i.bindFramebuffer(t.FRAMEBUFFER, null);
  }
  function F(O, D, ne) {
    if (
      (t.bindRenderbuffer(t.RENDERBUFFER, O), D.depthBuffer && !D.stencilBuffer)
    ) {
      let pe = t.DEPTH_COMPONENT16;
      if (ne || Ee(D)) {
        const xe = D.depthTexture;
        xe &&
          xe.isDepthTexture &&
          (xe.type === lr
            ? (pe = t.DEPTH_COMPONENT32F)
            : xe.type === Zr && (pe = t.DEPTH_COMPONENT24));
        const we = _e(D);
        Ee(D)
          ? u.renderbufferStorageMultisampleEXT(
              t.RENDERBUFFER,
              we,
              pe,
              D.width,
              D.height
            )
          : t.renderbufferStorageMultisample(
              t.RENDERBUFFER,
              we,
              pe,
              D.width,
              D.height
            );
      } else t.renderbufferStorage(t.RENDERBUFFER, pe, D.width, D.height);
      t.framebufferRenderbuffer(
        t.FRAMEBUFFER,
        t.DEPTH_ATTACHMENT,
        t.RENDERBUFFER,
        O
      );
    } else if (D.depthBuffer && D.stencilBuffer) {
      const pe = _e(D);
      ne && Ee(D) === !1
        ? t.renderbufferStorageMultisample(
            t.RENDERBUFFER,
            pe,
            t.DEPTH24_STENCIL8,
            D.width,
            D.height
          )
        : Ee(D)
        ? u.renderbufferStorageMultisampleEXT(
            t.RENDERBUFFER,
            pe,
            t.DEPTH24_STENCIL8,
            D.width,
            D.height
          )
        : t.renderbufferStorage(
            t.RENDERBUFFER,
            t.DEPTH_STENCIL,
            D.width,
            D.height
          ),
        t.framebufferRenderbuffer(
          t.FRAMEBUFFER,
          t.DEPTH_STENCIL_ATTACHMENT,
          t.RENDERBUFFER,
          O
        );
    } else {
      const pe =
        D.isWebGLMultipleRenderTargets === !0 ? D.texture : [D.texture];
      for (let xe = 0; xe < pe.length; xe++) {
        const we = pe[xe],
          Fe = s.convert(we.format, we.colorSpace),
          Se = s.convert(we.type),
          le = T(we.internalFormat, Fe, Se, we.colorSpace),
          je = _e(D);
        ne && Ee(D) === !1
          ? t.renderbufferStorageMultisample(
              t.RENDERBUFFER,
              je,
              le,
              D.width,
              D.height
            )
          : Ee(D)
          ? u.renderbufferStorageMultisampleEXT(
              t.RENDERBUFFER,
              je,
              le,
              D.width,
              D.height
            )
          : t.renderbufferStorage(t.RENDERBUFFER, le, D.width, D.height);
      }
    }
    t.bindRenderbuffer(t.RENDERBUFFER, null);
  }
  function Te(O, D) {
    if (D && D.isWebGLCubeRenderTarget)
      throw new Error(
        "Depth Texture with cube render targets is not supported"
      );
    if (
      (i.bindFramebuffer(t.FRAMEBUFFER, O),
      !(D.depthTexture && D.depthTexture.isDepthTexture))
    )
      throw new Error(
        "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
      );
    (!n.get(D.depthTexture).__webglTexture ||
      D.depthTexture.image.width !== D.width ||
      D.depthTexture.image.height !== D.height) &&
      ((D.depthTexture.image.width = D.width),
      (D.depthTexture.image.height = D.height),
      (D.depthTexture.needsUpdate = !0)),
      k(D.depthTexture, 0);
    const pe = n.get(D.depthTexture).__webglTexture,
      xe = _e(D);
    if (D.depthTexture.format === zs)
      Ee(D)
        ? u.framebufferTexture2DMultisampleEXT(
            t.FRAMEBUFFER,
            t.DEPTH_ATTACHMENT,
            t.TEXTURE_2D,
            pe,
            0,
            xe
          )
        : t.framebufferTexture2D(
            t.FRAMEBUFFER,
            t.DEPTH_ATTACHMENT,
            t.TEXTURE_2D,
            pe,
            0
          );
    else if (D.depthTexture.format === js)
      Ee(D)
        ? u.framebufferTexture2DMultisampleEXT(
            t.FRAMEBUFFER,
            t.DEPTH_STENCIL_ATTACHMENT,
            t.TEXTURE_2D,
            pe,
            0,
            xe
          )
        : t.framebufferTexture2D(
            t.FRAMEBUFFER,
            t.DEPTH_STENCIL_ATTACHMENT,
            t.TEXTURE_2D,
            pe,
            0
          );
    else throw new Error("Unknown depthTexture format");
  }
  function be(O) {
    const D = n.get(O),
      ne = O.isWebGLCubeRenderTarget === !0;
    if (O.depthTexture && !D.__autoAllocateDepthBuffer) {
      if (ne)
        throw new Error(
          "target.depthTexture not supported in Cube render targets"
        );
      Te(D.__webglFramebuffer, O);
    } else if (ne) {
      D.__webglDepthbuffer = [];
      for (let pe = 0; pe < 6; pe++)
        i.bindFramebuffer(t.FRAMEBUFFER, D.__webglFramebuffer[pe]),
          (D.__webglDepthbuffer[pe] = t.createRenderbuffer()),
          F(D.__webglDepthbuffer[pe], O, !1);
    } else
      i.bindFramebuffer(t.FRAMEBUFFER, D.__webglFramebuffer),
        (D.__webglDepthbuffer = t.createRenderbuffer()),
        F(D.__webglDepthbuffer, O, !1);
    i.bindFramebuffer(t.FRAMEBUFFER, null);
  }
  function oe(O, D, ne) {
    const pe = n.get(O);
    D !== void 0 &&
      re(
        pe.__webglFramebuffer,
        O,
        O.texture,
        t.COLOR_ATTACHMENT0,
        t.TEXTURE_2D
      ),
      ne !== void 0 && be(O);
  }
  function Me(O) {
    const D = O.texture,
      ne = n.get(O),
      pe = n.get(D);
    O.addEventListener("dispose", L),
      O.isWebGLMultipleRenderTargets !== !0 &&
        (pe.__webglTexture === void 0 &&
          (pe.__webglTexture = t.createTexture()),
        (pe.__version = D.version),
        a.memory.textures++);
    const xe = O.isWebGLCubeRenderTarget === !0,
      we = O.isWebGLMultipleRenderTargets === !0,
      Fe = _(O) || o;
    if (xe) {
      ne.__webglFramebuffer = [];
      for (let Se = 0; Se < 6; Se++)
        ne.__webglFramebuffer[Se] = t.createFramebuffer();
    } else {
      if (((ne.__webglFramebuffer = t.createFramebuffer()), we))
        if (r.drawBuffers) {
          const Se = O.texture;
          for (let le = 0, je = Se.length; le < je; le++) {
            const $e = n.get(Se[le]);
            $e.__webglTexture === void 0 &&
              (($e.__webglTexture = t.createTexture()), a.memory.textures++);
          }
        } else
          console.warn(
            "THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension."
          );
      if (o && O.samples > 0 && Ee(O) === !1) {
        const Se = we ? D : [D];
        (ne.__webglMultisampledFramebuffer = t.createFramebuffer()),
          (ne.__webglColorRenderbuffer = []),
          i.bindFramebuffer(t.FRAMEBUFFER, ne.__webglMultisampledFramebuffer);
        for (let le = 0; le < Se.length; le++) {
          const je = Se[le];
          (ne.__webglColorRenderbuffer[le] = t.createRenderbuffer()),
            t.bindRenderbuffer(t.RENDERBUFFER, ne.__webglColorRenderbuffer[le]);
          const $e = s.convert(je.format, je.colorSpace),
            Ye = s.convert(je.type),
            He = T(
              je.internalFormat,
              $e,
              Ye,
              je.colorSpace,
              O.isXRRenderTarget === !0
            ),
            Ge = _e(O);
          t.renderbufferStorageMultisample(
            t.RENDERBUFFER,
            Ge,
            He,
            O.width,
            O.height
          ),
            t.framebufferRenderbuffer(
              t.FRAMEBUFFER,
              t.COLOR_ATTACHMENT0 + le,
              t.RENDERBUFFER,
              ne.__webglColorRenderbuffer[le]
            );
        }
        t.bindRenderbuffer(t.RENDERBUFFER, null),
          O.depthBuffer &&
            ((ne.__webglDepthRenderbuffer = t.createRenderbuffer()),
            F(ne.__webglDepthRenderbuffer, O, !0)),
          i.bindFramebuffer(t.FRAMEBUFFER, null);
      }
    }
    if (xe) {
      i.bindTexture(t.TEXTURE_CUBE_MAP, pe.__webglTexture),
        ee(t.TEXTURE_CUBE_MAP, D, Fe);
      for (let Se = 0; Se < 6; Se++)
        re(
          ne.__webglFramebuffer[Se],
          O,
          D,
          t.COLOR_ATTACHMENT0,
          t.TEXTURE_CUBE_MAP_POSITIVE_X + Se
        );
      b(D, Fe) && E(t.TEXTURE_CUBE_MAP), i.unbindTexture();
    } else if (we) {
      const Se = O.texture;
      for (let le = 0, je = Se.length; le < je; le++) {
        const $e = Se[le],
          Ye = n.get($e);
        i.bindTexture(t.TEXTURE_2D, Ye.__webglTexture),
          ee(t.TEXTURE_2D, $e, Fe),
          re(
            ne.__webglFramebuffer,
            O,
            $e,
            t.COLOR_ATTACHMENT0 + le,
            t.TEXTURE_2D
          ),
          b($e, Fe) && E(t.TEXTURE_2D);
      }
      i.unbindTexture();
    } else {
      let Se = t.TEXTURE_2D;
      (O.isWebGL3DRenderTarget || O.isWebGLArrayRenderTarget) &&
        (o
          ? (Se = O.isWebGL3DRenderTarget ? t.TEXTURE_3D : t.TEXTURE_2D_ARRAY)
          : console.error(
              "THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2."
            )),
        i.bindTexture(Se, pe.__webglTexture),
        ee(Se, D, Fe),
        re(ne.__webglFramebuffer, O, D, t.COLOR_ATTACHMENT0, Se),
        b(D, Fe) && E(Se),
        i.unbindTexture();
    }
    O.depthBuffer && be(O);
  }
  function Ae(O) {
    const D = _(O) || o,
      ne = O.isWebGLMultipleRenderTargets === !0 ? O.texture : [O.texture];
    for (let pe = 0, xe = ne.length; pe < xe; pe++) {
      const we = ne[pe];
      if (b(we, D)) {
        const Fe = O.isWebGLCubeRenderTarget
            ? t.TEXTURE_CUBE_MAP
            : t.TEXTURE_2D,
          Se = n.get(we).__webglTexture;
        i.bindTexture(Fe, Se), E(Fe), i.unbindTexture();
      }
    }
  }
  function ye(O) {
    if (o && O.samples > 0 && Ee(O) === !1) {
      const D = O.isWebGLMultipleRenderTargets ? O.texture : [O.texture],
        ne = O.width,
        pe = O.height;
      let xe = t.COLOR_BUFFER_BIT;
      const we = [],
        Fe = O.stencilBuffer ? t.DEPTH_STENCIL_ATTACHMENT : t.DEPTH_ATTACHMENT,
        Se = n.get(O),
        le = O.isWebGLMultipleRenderTargets === !0;
      if (le)
        for (let je = 0; je < D.length; je++)
          i.bindFramebuffer(t.FRAMEBUFFER, Se.__webglMultisampledFramebuffer),
            t.framebufferRenderbuffer(
              t.FRAMEBUFFER,
              t.COLOR_ATTACHMENT0 + je,
              t.RENDERBUFFER,
              null
            ),
            i.bindFramebuffer(t.FRAMEBUFFER, Se.__webglFramebuffer),
            t.framebufferTexture2D(
              t.DRAW_FRAMEBUFFER,
              t.COLOR_ATTACHMENT0 + je,
              t.TEXTURE_2D,
              null,
              0
            );
      i.bindFramebuffer(t.READ_FRAMEBUFFER, Se.__webglMultisampledFramebuffer),
        i.bindFramebuffer(t.DRAW_FRAMEBUFFER, Se.__webglFramebuffer);
      for (let je = 0; je < D.length; je++) {
        we.push(t.COLOR_ATTACHMENT0 + je), O.depthBuffer && we.push(Fe);
        const $e =
          Se.__ignoreDepthValues !== void 0 ? Se.__ignoreDepthValues : !1;
        if (
          ($e === !1 &&
            (O.depthBuffer && (xe |= t.DEPTH_BUFFER_BIT),
            O.stencilBuffer && (xe |= t.STENCIL_BUFFER_BIT)),
          le &&
            t.framebufferRenderbuffer(
              t.READ_FRAMEBUFFER,
              t.COLOR_ATTACHMENT0,
              t.RENDERBUFFER,
              Se.__webglColorRenderbuffer[je]
            ),
          $e === !0 &&
            (t.invalidateFramebuffer(t.READ_FRAMEBUFFER, [Fe]),
            t.invalidateFramebuffer(t.DRAW_FRAMEBUFFER, [Fe])),
          le)
        ) {
          const Ye = n.get(D[je]).__webglTexture;
          t.framebufferTexture2D(
            t.DRAW_FRAMEBUFFER,
            t.COLOR_ATTACHMENT0,
            t.TEXTURE_2D,
            Ye,
            0
          );
        }
        t.blitFramebuffer(0, 0, ne, pe, 0, 0, ne, pe, xe, t.NEAREST),
          f && t.invalidateFramebuffer(t.READ_FRAMEBUFFER, we);
      }
      if (
        (i.bindFramebuffer(t.READ_FRAMEBUFFER, null),
        i.bindFramebuffer(t.DRAW_FRAMEBUFFER, null),
        le)
      )
        for (let je = 0; je < D.length; je++) {
          i.bindFramebuffer(t.FRAMEBUFFER, Se.__webglMultisampledFramebuffer),
            t.framebufferRenderbuffer(
              t.FRAMEBUFFER,
              t.COLOR_ATTACHMENT0 + je,
              t.RENDERBUFFER,
              Se.__webglColorRenderbuffer[je]
            );
          const $e = n.get(D[je]).__webglTexture;
          i.bindFramebuffer(t.FRAMEBUFFER, Se.__webglFramebuffer),
            t.framebufferTexture2D(
              t.DRAW_FRAMEBUFFER,
              t.COLOR_ATTACHMENT0 + je,
              t.TEXTURE_2D,
              $e,
              0
            );
        }
      i.bindFramebuffer(t.DRAW_FRAMEBUFFER, Se.__webglMultisampledFramebuffer);
    }
  }
  function _e(O) {
    return Math.min(h, O.samples);
  }
  function Ee(O) {
    const D = n.get(O);
    return (
      o &&
      O.samples > 0 &&
      e.has("WEBGL_multisampled_render_to_texture") === !0 &&
      D.__useRenderToTexture !== !1
    );
  }
  function Le(O) {
    const D = a.render.frame;
    p.get(O) !== D && (p.set(O, D), O.update());
  }
  function it(O, D) {
    const ne = O.colorSpace,
      pe = O.format,
      xe = O.type;
    return (
      O.isCompressedTexture === !0 ||
        O.format === yd ||
        (ne !== qn &&
          ne !== Bs &&
          (ne === gt
            ? o === !1
              ? e.has("EXT_sRGB") === !0 && pe === wn
                ? ((O.format = yd),
                  (O.minFilter = Zi),
                  (O.generateMipmaps = !1))
                : (D = rx.sRGBToLinear(D))
              : (pe !== wn || xe !== rs) &&
                console.warn(
                  "THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."
                )
            : console.error(
                "THREE.WebGLTextures: Unsupported texture color space:",
                ne
              ))),
      D
    );
  }
  (this.allocateTextureUnit = U),
    (this.resetTextureUnits = N),
    (this.setTexture2D = k),
    (this.setTexture2DArray = B),
    (this.setTexture3D = V),
    (this.setTextureCube = X),
    (this.rebindTextures = oe),
    (this.setupRenderTarget = Me),
    (this.updateRenderTargetMipmap = Ae),
    (this.updateMultisampleRenderTarget = ye),
    (this.setupDepthRenderbuffer = be),
    (this.setupFrameBufferTexture = re),
    (this.useMultisampledRTT = Ee);
}
function qT(t, e, i) {
  const n = i.isWebGL2;
  function r(s, a = Bs) {
    let o;
    if (s === rs) return t.UNSIGNED_BYTE;
    if (s === Xy) return t.UNSIGNED_SHORT_4_4_4_4;
    if (s === $y) return t.UNSIGNED_SHORT_5_5_5_1;
    if (s === vw) return t.BYTE;
    if (s === yw) return t.SHORT;
    if (s === Ff) return t.UNSIGNED_SHORT;
    if (s === qy) return t.INT;
    if (s === Zr) return t.UNSIGNED_INT;
    if (s === lr) return t.FLOAT;
    if (s === Mn)
      return n
        ? t.HALF_FLOAT
        : ((o = e.get("OES_texture_half_float")),
          o !== null ? o.HALF_FLOAT_OES : null);
    if (s === xw) return t.ALPHA;
    if (s === wn) return t.RGBA;
    if (s === Yy) return t.LUMINANCE;
    if (s === _w) return t.LUMINANCE_ALPHA;
    if (s === zs) return t.DEPTH_COMPONENT;
    if (s === js) return t.DEPTH_STENCIL;
    if (s === yd)
      return (o = e.get("EXT_sRGB")), o !== null ? o.SRGB_ALPHA_EXT : null;
    if (s === Zy) return t.RED;
    if (s === Ky) return t.RED_INTEGER;
    if (s === bw) return t.RG;
    if (s === Jy) return t.RG_INTEGER;
    if (s === Qy) return t.RGBA_INTEGER;
    if (s === Zh || s === Kh || s === Jh || s === Qh)
      if (a === gt)
        if (((o = e.get("WEBGL_compressed_texture_s3tc_srgb")), o !== null)) {
          if (s === Zh) return o.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (s === Kh) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (s === Jh) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (s === Qh) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else return null;
      else if (((o = e.get("WEBGL_compressed_texture_s3tc")), o !== null)) {
        if (s === Zh) return o.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (s === Kh) return o.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (s === Jh) return o.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (s === Qh) return o.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else return null;
    if (s === fm || s === pm || s === mm || s === gm)
      if (((o = e.get("WEBGL_compressed_texture_pvrtc")), o !== null)) {
        if (s === fm) return o.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (s === pm) return o.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (s === mm) return o.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (s === gm) return o.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else return null;
    if (s === ww)
      return (
        (o = e.get("WEBGL_compressed_texture_etc1")),
        o !== null ? o.COMPRESSED_RGB_ETC1_WEBGL : null
      );
    if (s === vm || s === ym)
      if (((o = e.get("WEBGL_compressed_texture_etc")), o !== null)) {
        if (s === vm)
          return a === gt ? o.COMPRESSED_SRGB8_ETC2 : o.COMPRESSED_RGB8_ETC2;
        if (s === ym)
          return a === gt
            ? o.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
            : o.COMPRESSED_RGBA8_ETC2_EAC;
      } else return null;
    if (
      s === xm ||
      s === _m ||
      s === bm ||
      s === wm ||
      s === Sm ||
      s === Mm ||
      s === Em ||
      s === Tm ||
      s === Am ||
      s === Cm ||
      s === Pm ||
      s === Lm ||
      s === Dm ||
      s === Rm
    )
      if (((o = e.get("WEBGL_compressed_texture_astc")), o !== null)) {
        if (s === xm)
          return a === gt
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
            : o.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (s === _m)
          return a === gt
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
            : o.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (s === bm)
          return a === gt
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
            : o.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (s === wm)
          return a === gt
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
            : o.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (s === Sm)
          return a === gt
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
            : o.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (s === Mm)
          return a === gt
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
            : o.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (s === Em)
          return a === gt
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
            : o.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (s === Tm)
          return a === gt
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
            : o.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (s === Am)
          return a === gt
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
            : o.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (s === Cm)
          return a === gt
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
            : o.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (s === Pm)
          return a === gt
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
            : o.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (s === Lm)
          return a === gt
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
            : o.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (s === Dm)
          return a === gt
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
            : o.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (s === Rm)
          return a === gt
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
            : o.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else return null;
    if (s === eu)
      if (((o = e.get("EXT_texture_compression_bptc")), o !== null)) {
        if (s === eu)
          return a === gt
            ? o.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
            : o.COMPRESSED_RGBA_BPTC_UNORM_EXT;
      } else return null;
    if (s === Sw || s === Om || s === Im || s === Um)
      if (((o = e.get("EXT_texture_compression_rgtc")), o !== null)) {
        if (s === eu) return o.COMPRESSED_RED_RGTC1_EXT;
        if (s === Om) return o.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (s === Im) return o.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (s === Um) return o.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else return null;
    return s === ss
      ? n
        ? t.UNSIGNED_INT_24_8
        : ((o = e.get("WEBGL_depth_texture")),
          o !== null ? o.UNSIGNED_INT_24_8_WEBGL : null)
      : t[s] !== void 0
      ? t[s]
      : null;
  }
  return { convert: r };
}
class XT extends ji {
  constructor(e = []) {
    super(), (this.isArrayCamera = !0), (this.cameras = e);
  }
}
class Da extends Ht {
  constructor() {
    super(), (this.isGroup = !0), (this.type = "Group");
  }
}
const $T = { type: "move" };
class wu {
  constructor() {
    (this._targetRay = null), (this._grip = null), (this._hand = null);
  }
  getHandSpace() {
    return (
      this._hand === null &&
        ((this._hand = new Da()),
        (this._hand.matrixAutoUpdate = !1),
        (this._hand.visible = !1),
        (this._hand.joints = {}),
        (this._hand.inputState = { pinching: !1 })),
      this._hand
    );
  }
  getTargetRaySpace() {
    return (
      this._targetRay === null &&
        ((this._targetRay = new Da()),
        (this._targetRay.matrixAutoUpdate = !1),
        (this._targetRay.visible = !1),
        (this._targetRay.hasLinearVelocity = !1),
        (this._targetRay.linearVelocity = new A()),
        (this._targetRay.hasAngularVelocity = !1),
        (this._targetRay.angularVelocity = new A())),
      this._targetRay
    );
  }
  getGripSpace() {
    return (
      this._grip === null &&
        ((this._grip = new Da()),
        (this._grip.matrixAutoUpdate = !1),
        (this._grip.visible = !1),
        (this._grip.hasLinearVelocity = !1),
        (this._grip.linearVelocity = new A()),
        (this._grip.hasAngularVelocity = !1),
        (this._grip.angularVelocity = new A())),
      this._grip
    );
  }
  dispatchEvent(e) {
    return (
      this._targetRay !== null && this._targetRay.dispatchEvent(e),
      this._grip !== null && this._grip.dispatchEvent(e),
      this._hand !== null && this._hand.dispatchEvent(e),
      this
    );
  }
  connect(e) {
    if (e && e.hand) {
      const i = this._hand;
      if (i) for (const n of e.hand.values()) this._getHandJoint(i, n);
    }
    return this.dispatchEvent({ type: "connected", data: e }), this;
  }
  disconnect(e) {
    return (
      this.dispatchEvent({ type: "disconnected", data: e }),
      this._targetRay !== null && (this._targetRay.visible = !1),
      this._grip !== null && (this._grip.visible = !1),
      this._hand !== null && (this._hand.visible = !1),
      this
    );
  }
  update(e, i, n) {
    let r = null,
      s = null,
      a = null;
    const o = this._targetRay,
      l = this._grip,
      c = this._hand;
    if (e && i.session.visibilityState !== "visible-blurred") {
      if (c && e.hand) {
        a = !0;
        for (const v of e.hand.values()) {
          const g = i.getJointPose(v, n),
            m = this._getHandJoint(c, v);
          g !== null &&
            (m.matrix.fromArray(g.transform.matrix),
            m.matrix.decompose(m.position, m.rotation, m.scale),
            (m.matrixWorldNeedsUpdate = !0),
            (m.jointRadius = g.radius)),
            (m.visible = g !== null);
        }
        const d = c.joints["index-finger-tip"],
          h = c.joints["thumb-tip"],
          u = d.position.distanceTo(h.position),
          f = 0.02,
          p = 0.005;
        c.inputState.pinching && u > f + p
          ? ((c.inputState.pinching = !1),
            this.dispatchEvent({
              type: "pinchend",
              handedness: e.handedness,
              target: this,
            }))
          : !c.inputState.pinching &&
            u <= f - p &&
            ((c.inputState.pinching = !0),
            this.dispatchEvent({
              type: "pinchstart",
              handedness: e.handedness,
              target: this,
            }));
      } else
        l !== null &&
          e.gripSpace &&
          ((s = i.getPose(e.gripSpace, n)),
          s !== null &&
            (l.matrix.fromArray(s.transform.matrix),
            l.matrix.decompose(l.position, l.rotation, l.scale),
            (l.matrixWorldNeedsUpdate = !0),
            s.linearVelocity
              ? ((l.hasLinearVelocity = !0),
                l.linearVelocity.copy(s.linearVelocity))
              : (l.hasLinearVelocity = !1),
            s.angularVelocity
              ? ((l.hasAngularVelocity = !0),
                l.angularVelocity.copy(s.angularVelocity))
              : (l.hasAngularVelocity = !1)));
      o !== null &&
        ((r = i.getPose(e.targetRaySpace, n)),
        r === null && s !== null && (r = s),
        r !== null &&
          (o.matrix.fromArray(r.transform.matrix),
          o.matrix.decompose(o.position, o.rotation, o.scale),
          (o.matrixWorldNeedsUpdate = !0),
          r.linearVelocity
            ? ((o.hasLinearVelocity = !0),
              o.linearVelocity.copy(r.linearVelocity))
            : (o.hasLinearVelocity = !1),
          r.angularVelocity
            ? ((o.hasAngularVelocity = !0),
              o.angularVelocity.copy(r.angularVelocity))
            : (o.hasAngularVelocity = !1),
          this.dispatchEvent($T)));
    }
    return (
      o !== null && (o.visible = r !== null),
      l !== null && (l.visible = s !== null),
      c !== null && (c.visible = a !== null),
      this
    );
  }
  _getHandJoint(e, i) {
    if (e.joints[i.jointName] === void 0) {
      const n = new Da();
      (n.matrixAutoUpdate = !1),
        (n.visible = !1),
        (e.joints[i.jointName] = n),
        e.add(n);
    }
    return e.joints[i.jointName];
  }
}
class mx extends Li {
  constructor(e, i, n, r, s, a, o, l, c, d) {
    if (((d = d !== void 0 ? d : zs), d !== zs && d !== js))
      throw new Error(
        "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
      );
    n === void 0 && d === zs && (n = Zr),
      n === void 0 && d === js && (n = ss),
      super(null, r, s, a, o, l, d, n, c),
      (this.isDepthTexture = !0),
      (this.image = { width: e, height: i }),
      (this.magFilter = o !== void 0 ? o : vi),
      (this.minFilter = l !== void 0 ? l : vi),
      (this.flipY = !1),
      (this.generateMipmaps = !1),
      (this.compareFunction = null);
  }
  copy(e) {
    return super.copy(e), (this.compareFunction = e.compareFunction), this;
  }
  toJSON(e) {
    const i = super.toJSON(e);
    return (
      this.compareFunction !== null &&
        (i.compareFunction = this.compareFunction),
      i
    );
  }
}
class YT extends Ys {
  constructor(e, i) {
    super();
    const n = this;
    let r = null,
      s = 1,
      a = null,
      o = "local-floor",
      l = 1,
      c = null,
      d = null,
      h = null,
      u = null,
      f = null,
      p = null;
    const v = i.getContextAttributes();
    let g = null,
      m = null;
    const x = [],
      y = [],
      _ = new ji();
    _.layers.enable(1), (_.viewport = new yt());
    const M = new ji();
    M.layers.enable(2), (M.viewport = new yt());
    const b = [_, M],
      E = new XT();
    E.layers.enable(1), E.layers.enable(2);
    let T = null,
      S = null;
    (this.cameraAutoUpdate = !0),
      (this.enabled = !1),
      (this.isPresenting = !1),
      (this.getController = function (B) {
        let V = x[B];
        return (
          V === void 0 && ((V = new wu()), (x[B] = V)), V.getTargetRaySpace()
        );
      }),
      (this.getControllerGrip = function (B) {
        let V = x[B];
        return V === void 0 && ((V = new wu()), (x[B] = V)), V.getGripSpace();
      }),
      (this.getHand = function (B) {
        let V = x[B];
        return V === void 0 && ((V = new wu()), (x[B] = V)), V.getHandSpace();
      });
    function w(B) {
      const V = y.indexOf(B.inputSource);
      if (V === -1) return;
      const X = x[V];
      X !== void 0 &&
        (X.update(B.inputSource, B.frame, c || a),
        X.dispatchEvent({ type: B.type, data: B.inputSource }));
    }
    function C() {
      r.removeEventListener("select", w),
        r.removeEventListener("selectstart", w),
        r.removeEventListener("selectend", w),
        r.removeEventListener("squeeze", w),
        r.removeEventListener("squeezestart", w),
        r.removeEventListener("squeezeend", w),
        r.removeEventListener("end", C),
        r.removeEventListener("inputsourceschange", L);
      for (let B = 0; B < x.length; B++) {
        const V = y[B];
        V !== null && ((y[B] = null), x[B].disconnect(V));
      }
      (T = null),
        (S = null),
        e.setRenderTarget(g),
        (f = null),
        (u = null),
        (h = null),
        (r = null),
        (m = null),
        k.stop(),
        (n.isPresenting = !1),
        n.dispatchEvent({ type: "sessionend" });
    }
    (this.setFramebufferScaleFactor = function (B) {
      (s = B),
        n.isPresenting === !0 &&
          console.warn(
            "THREE.WebXRManager: Cannot change framebuffer scale while presenting."
          );
    }),
      (this.setReferenceSpaceType = function (B) {
        (o = B),
          n.isPresenting === !0 &&
            console.warn(
              "THREE.WebXRManager: Cannot change reference space type while presenting."
            );
      }),
      (this.getReferenceSpace = function () {
        return c || a;
      }),
      (this.setReferenceSpace = function (B) {
        c = B;
      }),
      (this.getBaseLayer = function () {
        return u !== null ? u : f;
      }),
      (this.getBinding = function () {
        return h;
      }),
      (this.getFrame = function () {
        return p;
      }),
      (this.getSession = function () {
        return r;
      }),
      (this.setSession = async function (B) {
        if (((r = B), r !== null)) {
          if (
            ((g = e.getRenderTarget()),
            r.addEventListener("select", w),
            r.addEventListener("selectstart", w),
            r.addEventListener("selectend", w),
            r.addEventListener("squeeze", w),
            r.addEventListener("squeezestart", w),
            r.addEventListener("squeezeend", w),
            r.addEventListener("end", C),
            r.addEventListener("inputsourceschange", L),
            v.xrCompatible !== !0 && (await i.makeXRCompatible()),
            r.renderState.layers === void 0 || e.capabilities.isWebGL2 === !1)
          ) {
            const V = {
              antialias: r.renderState.layers === void 0 ? v.antialias : !0,
              alpha: !0,
              depth: v.depth,
              stencil: v.stencil,
              framebufferScaleFactor: s,
            };
            (f = new XRWebGLLayer(r, i, V)),
              r.updateRenderState({ baseLayer: f }),
              (m = new rn(f.framebufferWidth, f.framebufferHeight, {
                format: wn,
                type: rs,
                colorSpace: e.outputColorSpace,
                stencilBuffer: v.stencil,
              }));
          } else {
            let V = null,
              X = null,
              H = null;
            v.depth &&
              ((H = v.stencil ? i.DEPTH24_STENCIL8 : i.DEPTH_COMPONENT24),
              (V = v.stencil ? js : zs),
              (X = v.stencil ? ss : Zr));
            const j = { colorFormat: i.RGBA8, depthFormat: H, scaleFactor: s };
            (h = new XRWebGLBinding(r, i)),
              (u = h.createProjectionLayer(j)),
              r.updateRenderState({ layers: [u] }),
              (m = new rn(u.textureWidth, u.textureHeight, {
                format: wn,
                type: rs,
                depthTexture: new mx(
                  u.textureWidth,
                  u.textureHeight,
                  X,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  V
                ),
                stencilBuffer: v.stencil,
                colorSpace: e.outputColorSpace,
                samples: v.antialias ? 4 : 0,
              }));
            const Y = e.properties.get(m);
            Y.__ignoreDepthValues = u.ignoreDepthValues;
          }
          (m.isXRRenderTarget = !0),
            this.setFoveation(l),
            (c = null),
            (a = await r.requestReferenceSpace(o)),
            k.setContext(r),
            k.start(),
            (n.isPresenting = !0),
            n.dispatchEvent({ type: "sessionstart" });
        }
      }),
      (this.getEnvironmentBlendMode = function () {
        if (r !== null) return r.environmentBlendMode;
      });
    function L(B) {
      for (let V = 0; V < B.removed.length; V++) {
        const X = B.removed[V],
          H = y.indexOf(X);
        H >= 0 && ((y[H] = null), x[H].disconnect(X));
      }
      for (let V = 0; V < B.added.length; V++) {
        const X = B.added[V];
        let H = y.indexOf(X);
        if (H === -1) {
          for (let Y = 0; Y < x.length; Y++)
            if (Y >= y.length) {
              y.push(X), (H = Y);
              break;
            } else if (y[Y] === null) {
              (y[Y] = X), (H = Y);
              break;
            }
          if (H === -1) break;
        }
        const j = x[H];
        j && j.connect(X);
      }
    }
    const P = new A(),
      R = new A();
    function I(B, V, X) {
      P.setFromMatrixPosition(V.matrixWorld),
        R.setFromMatrixPosition(X.matrixWorld);
      const H = P.distanceTo(R),
        j = V.projectionMatrix.elements,
        Y = X.projectionMatrix.elements,
        ee = j[14] / (j[10] - 1),
        Z = j[14] / (j[10] + 1),
        K = (j[9] + 1) / j[5],
        me = (j[9] - 1) / j[5],
        re = (j[8] - 1) / j[0],
        F = (Y[8] + 1) / Y[0],
        Te = ee * re,
        be = ee * F,
        oe = H / (-re + F),
        Me = oe * -re;
      V.matrixWorld.decompose(B.position, B.quaternion, B.scale),
        B.translateX(Me),
        B.translateZ(oe),
        B.matrixWorld.compose(B.position, B.quaternion, B.scale),
        B.matrixWorldInverse.copy(B.matrixWorld).invert();
      const Ae = ee + oe,
        ye = Z + oe,
        _e = Te - Me,
        Ee = be + (H - Me),
        Le = ((K * Z) / ye) * Ae,
        it = ((me * Z) / ye) * Ae;
      B.projectionMatrix.makePerspective(_e, Ee, Le, it, Ae, ye),
        B.projectionMatrixInverse.copy(B.projectionMatrix).invert();
    }
    function W(B, V) {
      V === null
        ? B.matrixWorld.copy(B.matrix)
        : B.matrixWorld.multiplyMatrices(V.matrixWorld, B.matrix),
        B.matrixWorldInverse.copy(B.matrixWorld).invert();
    }
    this.updateCamera = function (B) {
      if (r === null) return;
      (E.near = M.near = _.near = B.near),
        (E.far = M.far = _.far = B.far),
        (T !== E.near || S !== E.far) &&
          (r.updateRenderState({ depthNear: E.near, depthFar: E.far }),
          (T = E.near),
          (S = E.far));
      const V = B.parent,
        X = E.cameras;
      W(E, V);
      for (let H = 0; H < X.length; H++) W(X[H], V);
      X.length === 2 ? I(E, _, M) : E.projectionMatrix.copy(_.projectionMatrix),
        N(B, E, V);
    };
    function N(B, V, X) {
      X === null
        ? B.matrix.copy(V.matrixWorld)
        : (B.matrix.copy(X.matrixWorld),
          B.matrix.invert(),
          B.matrix.multiply(V.matrixWorld)),
        B.matrix.decompose(B.position, B.quaternion, B.scale),
        B.updateMatrixWorld(!0);
      const H = B.children;
      for (let j = 0, Y = H.length; j < Y; j++) H[j].updateMatrixWorld(!0);
      B.projectionMatrix.copy(V.projectionMatrix),
        B.projectionMatrixInverse.copy(V.projectionMatrixInverse),
        B.isPerspectiveCamera &&
          ((B.fov = $a * 2 * Math.atan(1 / B.projectionMatrix.elements[5])),
          (B.zoom = 1));
    }
    (this.getCamera = function () {
      return E;
    }),
      (this.getFoveation = function () {
        if (!(u === null && f === null)) return l;
      }),
      (this.setFoveation = function (B) {
        (l = B),
          u !== null && (u.fixedFoveation = B),
          f !== null && f.fixedFoveation !== void 0 && (f.fixedFoveation = B);
      });
    let U = null;
    function G(B, V) {
      if (((d = V.getViewerPose(c || a)), (p = V), d !== null)) {
        const X = d.views;
        f !== null &&
          (e.setRenderTargetFramebuffer(m, f.framebuffer),
          e.setRenderTarget(m));
        let H = !1;
        X.length !== E.cameras.length && ((E.cameras.length = 0), (H = !0));
        for (let j = 0; j < X.length; j++) {
          const Y = X[j];
          let ee = null;
          if (f !== null) ee = f.getViewport(Y);
          else {
            const K = h.getViewSubImage(u, Y);
            (ee = K.viewport),
              j === 0 &&
                (e.setRenderTargetTextures(
                  m,
                  K.colorTexture,
                  u.ignoreDepthValues ? void 0 : K.depthStencilTexture
                ),
                e.setRenderTarget(m));
          }
          let Z = b[j];
          Z === void 0 &&
            ((Z = new ji()),
            Z.layers.enable(j),
            (Z.viewport = new yt()),
            (b[j] = Z)),
            Z.matrix.fromArray(Y.transform.matrix),
            Z.matrix.decompose(Z.position, Z.quaternion, Z.scale),
            Z.projectionMatrix.fromArray(Y.projectionMatrix),
            Z.projectionMatrixInverse.copy(Z.projectionMatrix).invert(),
            Z.viewport.set(ee.x, ee.y, ee.width, ee.height),
            j === 0 &&
              (E.matrix.copy(Z.matrix),
              E.matrix.decompose(E.position, E.quaternion, E.scale)),
            H === !0 && E.cameras.push(Z);
        }
      }
      for (let X = 0; X < x.length; X++) {
        const H = y[X],
          j = x[X];
        H !== null && j !== void 0 && j.update(H, V, c || a);
      }
      U && U(B, V),
        V.detectedPlanes &&
          n.dispatchEvent({ type: "planesdetected", data: V }),
        (p = null);
    }
    const k = new hx();
    k.setAnimationLoop(G),
      (this.setAnimationLoop = function (B) {
        U = B;
      }),
      (this.dispose = function () {});
  }
}
function ZT(t, e) {
  function i(g, m) {
    g.matrixAutoUpdate === !0 && g.updateMatrix(), m.value.copy(g.matrix);
  }
  function n(g, m) {
    m.color.getRGB(g.fogColor.value, cx(t)),
      m.isFog
        ? ((g.fogNear.value = m.near), (g.fogFar.value = m.far))
        : m.isFogExp2 && (g.fogDensity.value = m.density);
  }
  function r(g, m, x, y, _) {
    m.isMeshBasicMaterial || m.isMeshLambertMaterial
      ? s(g, m)
      : m.isMeshToonMaterial
      ? (s(g, m), h(g, m))
      : m.isMeshPhongMaterial
      ? (s(g, m), d(g, m))
      : m.isMeshStandardMaterial
      ? (s(g, m), u(g, m), m.isMeshPhysicalMaterial && f(g, m, _))
      : m.isMeshMatcapMaterial
      ? (s(g, m), p(g, m))
      : m.isMeshDepthMaterial
      ? s(g, m)
      : m.isMeshDistanceMaterial
      ? (s(g, m), v(g, m))
      : m.isMeshNormalMaterial
      ? s(g, m)
      : m.isLineBasicMaterial
      ? (a(g, m), m.isLineDashedMaterial && o(g, m))
      : m.isPointsMaterial
      ? l(g, m, x, y)
      : m.isSpriteMaterial
      ? c(g, m)
      : m.isShadowMaterial
      ? (g.color.value.copy(m.color), (g.opacity.value = m.opacity))
      : m.isShaderMaterial && (m.uniformsNeedUpdate = !1);
  }
  function s(g, m) {
    (g.opacity.value = m.opacity),
      m.color && g.diffuse.value.copy(m.color),
      m.emissive &&
        g.emissive.value.copy(m.emissive).multiplyScalar(m.emissiveIntensity),
      m.map && ((g.map.value = m.map), i(m.map, g.mapTransform)),
      m.alphaMap &&
        ((g.alphaMap.value = m.alphaMap), i(m.alphaMap, g.alphaMapTransform)),
      m.bumpMap &&
        ((g.bumpMap.value = m.bumpMap),
        i(m.bumpMap, g.bumpMapTransform),
        (g.bumpScale.value = m.bumpScale),
        m.side === nn && (g.bumpScale.value *= -1)),
      m.normalMap &&
        ((g.normalMap.value = m.normalMap),
        i(m.normalMap, g.normalMapTransform),
        g.normalScale.value.copy(m.normalScale),
        m.side === nn && g.normalScale.value.negate()),
      m.displacementMap &&
        ((g.displacementMap.value = m.displacementMap),
        i(m.displacementMap, g.displacementMapTransform),
        (g.displacementScale.value = m.displacementScale),
        (g.displacementBias.value = m.displacementBias)),
      m.emissiveMap &&
        ((g.emissiveMap.value = m.emissiveMap),
        i(m.emissiveMap, g.emissiveMapTransform)),
      m.specularMap &&
        ((g.specularMap.value = m.specularMap),
        i(m.specularMap, g.specularMapTransform)),
      m.alphaTest > 0 && (g.alphaTest.value = m.alphaTest);
    const x = e.get(m).envMap;
    if (
      (x &&
        ((g.envMap.value = x),
        (g.flipEnvMap.value =
          x.isCubeTexture && x.isRenderTargetTexture === !1 ? -1 : 1),
        (g.reflectivity.value = m.reflectivity),
        (g.ior.value = m.ior),
        (g.refractionRatio.value = m.refractionRatio)),
      m.lightMap)
    ) {
      g.lightMap.value = m.lightMap;
      const y = t.useLegacyLights === !0 ? Math.PI : 1;
      (g.lightMapIntensity.value = m.lightMapIntensity * y),
        i(m.lightMap, g.lightMapTransform);
    }
    m.aoMap &&
      ((g.aoMap.value = m.aoMap),
      (g.aoMapIntensity.value = m.aoMapIntensity),
      i(m.aoMap, g.aoMapTransform));
  }
  function a(g, m) {
    g.diffuse.value.copy(m.color),
      (g.opacity.value = m.opacity),
      m.map && ((g.map.value = m.map), i(m.map, g.mapTransform));
  }
  function o(g, m) {
    (g.dashSize.value = m.dashSize),
      (g.totalSize.value = m.dashSize + m.gapSize),
      (g.scale.value = m.scale);
  }
  function l(g, m, x, y) {
    g.diffuse.value.copy(m.color),
      (g.opacity.value = m.opacity),
      (g.size.value = m.size * x),
      (g.scale.value = y * 0.5),
      m.map && ((g.map.value = m.map), i(m.map, g.uvTransform)),
      m.alphaMap &&
        ((g.alphaMap.value = m.alphaMap), i(m.alphaMap, g.alphaMapTransform)),
      m.alphaTest > 0 && (g.alphaTest.value = m.alphaTest);
  }
  function c(g, m) {
    g.diffuse.value.copy(m.color),
      (g.opacity.value = m.opacity),
      (g.rotation.value = m.rotation),
      m.map && ((g.map.value = m.map), i(m.map, g.mapTransform)),
      m.alphaMap &&
        ((g.alphaMap.value = m.alphaMap), i(m.alphaMap, g.alphaMapTransform)),
      m.alphaTest > 0 && (g.alphaTest.value = m.alphaTest);
  }
  function d(g, m) {
    g.specular.value.copy(m.specular),
      (g.shininess.value = Math.max(m.shininess, 1e-4));
  }
  function h(g, m) {
    m.gradientMap && (g.gradientMap.value = m.gradientMap);
  }
  function u(g, m) {
    (g.metalness.value = m.metalness),
      m.metalnessMap &&
        ((g.metalnessMap.value = m.metalnessMap),
        i(m.metalnessMap, g.metalnessMapTransform)),
      (g.roughness.value = m.roughness),
      m.roughnessMap &&
        ((g.roughnessMap.value = m.roughnessMap),
        i(m.roughnessMap, g.roughnessMapTransform)),
      e.get(m).envMap && (g.envMapIntensity.value = m.envMapIntensity);
  }
  function f(g, m, x) {
    (g.ior.value = m.ior),
      m.sheen > 0 &&
        (g.sheenColor.value.copy(m.sheenColor).multiplyScalar(m.sheen),
        (g.sheenRoughness.value = m.sheenRoughness),
        m.sheenColorMap &&
          ((g.sheenColorMap.value = m.sheenColorMap),
          i(m.sheenColorMap, g.sheenColorMapTransform)),
        m.sheenRoughnessMap &&
          ((g.sheenRoughnessMap.value = m.sheenRoughnessMap),
          i(m.sheenRoughnessMap, g.sheenRoughnessMapTransform))),
      m.clearcoat > 0 &&
        ((g.clearcoat.value = m.clearcoat),
        (g.clearcoatRoughness.value = m.clearcoatRoughness),
        m.clearcoatMap &&
          ((g.clearcoatMap.value = m.clearcoatMap),
          i(m.clearcoatMap, g.clearcoatMapTransform)),
        m.clearcoatRoughnessMap &&
          ((g.clearcoatRoughnessMap.value = m.clearcoatRoughnessMap),
          i(m.clearcoatRoughnessMap, g.clearcoatRoughnessMapTransform)),
        m.clearcoatNormalMap &&
          ((g.clearcoatNormalMap.value = m.clearcoatNormalMap),
          i(m.clearcoatNormalMap, g.clearcoatNormalMapTransform),
          g.clearcoatNormalScale.value.copy(m.clearcoatNormalScale),
          m.side === nn && g.clearcoatNormalScale.value.negate())),
      m.iridescence > 0 &&
        ((g.iridescence.value = m.iridescence),
        (g.iridescenceIOR.value = m.iridescenceIOR),
        (g.iridescenceThicknessMinimum.value = m.iridescenceThicknessRange[0]),
        (g.iridescenceThicknessMaximum.value = m.iridescenceThicknessRange[1]),
        m.iridescenceMap &&
          ((g.iridescenceMap.value = m.iridescenceMap),
          i(m.iridescenceMap, g.iridescenceMapTransform)),
        m.iridescenceThicknessMap &&
          ((g.iridescenceThicknessMap.value = m.iridescenceThicknessMap),
          i(m.iridescenceThicknessMap, g.iridescenceThicknessMapTransform))),
      m.transmission > 0 &&
        ((g.transmission.value = m.transmission),
        (g.transmissionSamplerMap.value = x.texture),
        g.transmissionSamplerSize.value.set(x.width, x.height),
        m.transmissionMap &&
          ((g.transmissionMap.value = m.transmissionMap),
          i(m.transmissionMap, g.transmissionMapTransform)),
        (g.thickness.value = m.thickness),
        m.thicknessMap &&
          ((g.thicknessMap.value = m.thicknessMap),
          i(m.thicknessMap, g.thicknessMapTransform)),
        (g.attenuationDistance.value = m.attenuationDistance),
        g.attenuationColor.value.copy(m.attenuationColor)),
      m.anisotropy > 0 &&
        (g.anisotropyVector.value.set(
          m.anisotropy * Math.cos(m.anisotropyRotation),
          m.anisotropy * Math.sin(m.anisotropyRotation)
        ),
        m.anisotropyMap &&
          ((g.anisotropyMap.value = m.anisotropyMap),
          i(m.anisotropyMap, g.anisotropyMapTransform))),
      (g.specularIntensity.value = m.specularIntensity),
      g.specularColor.value.copy(m.specularColor),
      m.specularColorMap &&
        ((g.specularColorMap.value = m.specularColorMap),
        i(m.specularColorMap, g.specularColorMapTransform)),
      m.specularIntensityMap &&
        ((g.specularIntensityMap.value = m.specularIntensityMap),
        i(m.specularIntensityMap, g.specularIntensityMapTransform));
  }
  function p(g, m) {
    m.matcap && (g.matcap.value = m.matcap);
  }
  function v(g, m) {
    const x = e.get(m).light;
    g.referencePosition.value.setFromMatrixPosition(x.matrixWorld),
      (g.nearDistance.value = x.shadow.camera.near),
      (g.farDistance.value = x.shadow.camera.far);
  }
  return { refreshFogUniforms: n, refreshMaterialUniforms: r };
}
function KT(t, e, i, n) {
  let r = {},
    s = {},
    a = [];
  const o = i.isWebGL2 ? t.getParameter(t.MAX_UNIFORM_BUFFER_BINDINGS) : 0;
  function l(x, y) {
    const _ = y.program;
    n.uniformBlockBinding(x, _);
  }
  function c(x, y) {
    let _ = r[x.id];
    _ === void 0 &&
      (p(x), (_ = d(x)), (r[x.id] = _), x.addEventListener("dispose", g));
    const M = y.program;
    n.updateUBOMapping(x, M);
    const b = e.render.frame;
    s[x.id] !== b && (u(x), (s[x.id] = b));
  }
  function d(x) {
    const y = h();
    x.__bindingPointIndex = y;
    const _ = t.createBuffer(),
      M = x.__size,
      b = x.usage;
    return (
      t.bindBuffer(t.UNIFORM_BUFFER, _),
      t.bufferData(t.UNIFORM_BUFFER, M, b),
      t.bindBuffer(t.UNIFORM_BUFFER, null),
      t.bindBufferBase(t.UNIFORM_BUFFER, y, _),
      _
    );
  }
  function h() {
    for (let x = 0; x < o; x++) if (a.indexOf(x) === -1) return a.push(x), x;
    return (
      console.error(
        "THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."
      ),
      0
    );
  }
  function u(x) {
    const y = r[x.id],
      _ = x.uniforms,
      M = x.__cache;
    t.bindBuffer(t.UNIFORM_BUFFER, y);
    for (let b = 0, E = _.length; b < E; b++) {
      const T = _[b];
      if (f(T, b, M) === !0) {
        const S = T.__offset,
          w = Array.isArray(T.value) ? T.value : [T.value];
        let C = 0;
        for (let L = 0; L < w.length; L++) {
          const P = w[L],
            R = v(P);
          typeof P == "number"
            ? ((T.__data[0] = P),
              t.bufferSubData(t.UNIFORM_BUFFER, S + C, T.__data))
            : P.isMatrix3
            ? ((T.__data[0] = P.elements[0]),
              (T.__data[1] = P.elements[1]),
              (T.__data[2] = P.elements[2]),
              (T.__data[3] = P.elements[0]),
              (T.__data[4] = P.elements[3]),
              (T.__data[5] = P.elements[4]),
              (T.__data[6] = P.elements[5]),
              (T.__data[7] = P.elements[0]),
              (T.__data[8] = P.elements[6]),
              (T.__data[9] = P.elements[7]),
              (T.__data[10] = P.elements[8]),
              (T.__data[11] = P.elements[0]))
            : (P.toArray(T.__data, C),
              (C += R.storage / Float32Array.BYTES_PER_ELEMENT));
        }
        t.bufferSubData(t.UNIFORM_BUFFER, S, T.__data);
      }
    }
    t.bindBuffer(t.UNIFORM_BUFFER, null);
  }
  function f(x, y, _) {
    const M = x.value;
    if (_[y] === void 0) {
      if (typeof M == "number") _[y] = M;
      else {
        const b = Array.isArray(M) ? M : [M],
          E = [];
        for (let T = 0; T < b.length; T++) E.push(b[T].clone());
        _[y] = E;
      }
      return !0;
    } else if (typeof M == "number") {
      if (_[y] !== M) return (_[y] = M), !0;
    } else {
      const b = Array.isArray(_[y]) ? _[y] : [_[y]],
        E = Array.isArray(M) ? M : [M];
      for (let T = 0; T < b.length; T++) {
        const S = b[T];
        if (S.equals(E[T]) === !1) return S.copy(E[T]), !0;
      }
    }
    return !1;
  }
  function p(x) {
    const y = x.uniforms;
    let _ = 0;
    const M = 16;
    let b = 0;
    for (let E = 0, T = y.length; E < T; E++) {
      const S = y[E],
        w = { boundary: 0, storage: 0 },
        C = Array.isArray(S.value) ? S.value : [S.value];
      for (let L = 0, P = C.length; L < P; L++) {
        const R = C[L],
          I = v(R);
        (w.boundary += I.boundary), (w.storage += I.storage);
      }
      if (
        ((S.__data = new Float32Array(
          w.storage / Float32Array.BYTES_PER_ELEMENT
        )),
        (S.__offset = _),
        E > 0)
      ) {
        b = _ % M;
        const L = M - b;
        b !== 0 && L - w.boundary < 0 && ((_ += M - b), (S.__offset = _));
      }
      _ += w.storage;
    }
    return (
      (b = _ % M), b > 0 && (_ += M - b), (x.__size = _), (x.__cache = {}), this
    );
  }
  function v(x) {
    const y = { boundary: 0, storage: 0 };
    return (
      typeof x == "number"
        ? ((y.boundary = 4), (y.storage = 4))
        : x.isVector2
        ? ((y.boundary = 8), (y.storage = 8))
        : x.isVector3 || x.isColor
        ? ((y.boundary = 16), (y.storage = 12))
        : x.isVector4
        ? ((y.boundary = 16), (y.storage = 16))
        : x.isMatrix3
        ? ((y.boundary = 48), (y.storage = 48))
        : x.isMatrix4
        ? ((y.boundary = 64), (y.storage = 64))
        : x.isTexture
        ? console.warn(
            "THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."
          )
        : console.warn(
            "THREE.WebGLRenderer: Unsupported uniform value type.",
            x
          ),
      y
    );
  }
  function g(x) {
    const y = x.target;
    y.removeEventListener("dispose", g);
    const _ = a.indexOf(y.__bindingPointIndex);
    a.splice(_, 1), t.deleteBuffer(r[y.id]), delete r[y.id], delete s[y.id];
  }
  function m() {
    for (const x in r) t.deleteBuffer(r[x]);
    (a = []), (r = {}), (s = {});
  }
  return { bind: l, update: c, dispose: m };
}
function JT() {
  const t = Fc("canvas");
  return (t.style.display = "block"), t;
}
class gx {
  constructor(e = {}) {
    const {
      canvas: i = JT(),
      context: n = null,
      depth: r = !0,
      stencil: s = !0,
      alpha: a = !1,
      antialias: o = !1,
      premultipliedAlpha: l = !0,
      preserveDrawingBuffer: c = !1,
      powerPreference: d = "default",
      failIfMajorPerformanceCaveat: h = !1,
    } = e;
    this.isWebGLRenderer = !0;
    let u;
    n !== null ? (u = n.getContextAttributes().alpha) : (u = a);
    const f = new Uint32Array(4),
      p = new Int32Array(4);
    let v = null,
      g = null;
    const m = [],
      x = [];
    (this.domElement = i),
      (this.debug = { checkShaderErrors: !0, onShaderError: null }),
      (this.autoClear = !0),
      (this.autoClearColor = !0),
      (this.autoClearDepth = !0),
      (this.autoClearStencil = !0),
      (this.sortObjects = !0),
      (this.clippingPlanes = []),
      (this.localClippingEnabled = !1),
      (this.outputColorSpace = gt),
      (this.useLegacyLights = !0),
      (this.toneMapping = Nr),
      (this.toneMappingExposure = 1);
    const y = this;
    let _ = !1,
      M = 0,
      b = 0,
      E = null,
      T = -1,
      S = null;
    const w = new yt(),
      C = new yt();
    let L = null;
    const P = new tt(0);
    let R = 0,
      I = i.width,
      W = i.height,
      N = 1,
      U = null,
      G = null;
    const k = new yt(0, 0, I, W),
      B = new yt(0, 0, I, W);
    let V = !1;
    const X = new Gf();
    let H = !1,
      j = !1,
      Y = null;
    const ee = new ze(),
      Z = new J(),
      K = new A(),
      me = {
        background: null,
        fog: null,
        environment: null,
        overrideMaterial: null,
        isScene: !0,
      };
    function re() {
      return E === null ? N : 1;
    }
    let F = n;
    function Te(z, ae) {
      for (let de = 0; de < z.length; de++) {
        const te = z[de],
          ge = i.getContext(te, ae);
        if (ge !== null) return ge;
      }
      return null;
    }
    try {
      const z = {
        alpha: !0,
        depth: r,
        stencil: s,
        antialias: o,
        premultipliedAlpha: l,
        preserveDrawingBuffer: c,
        powerPreference: d,
        failIfMajorPerformanceCaveat: h,
      };
      if (
        ("setAttribute" in i &&
          i.setAttribute("data-engine", `three.js r${Bf}`),
        i.addEventListener("webglcontextlost", De, !1),
        i.addEventListener("webglcontextrestored", se, !1),
        i.addEventListener("webglcontextcreationerror", Ce, !1),
        F === null)
      ) {
        const ae = ["webgl2", "webgl", "experimental-webgl"];
        if (
          (y.isWebGL1Renderer === !0 && ae.shift(), (F = Te(ae, z)), F === null)
        )
          throw Te(ae)
            ? new Error(
                "Error creating WebGL context with your selected attributes."
              )
            : new Error("Error creating WebGL context.");
      }
      typeof WebGLRenderingContext < "u" &&
        F instanceof WebGLRenderingContext &&
        console.warn(
          "THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."
        ),
        F.getShaderPrecisionFormat === void 0 &&
          (F.getShaderPrecisionFormat = function () {
            return { rangeMin: 1, rangeMax: 1, precision: 1 };
          });
    } catch (z) {
      throw (console.error("THREE.WebGLRenderer: " + z.message), z);
    }
    let be,
      oe,
      Me,
      Ae,
      ye,
      _e,
      Ee,
      Le,
      it,
      O,
      D,
      ne,
      pe,
      xe,
      we,
      Fe,
      Se,
      le,
      je,
      $e,
      Ye,
      He,
      Ge,
      nt;
    function wt() {
      (be = new cE(F)),
        (oe = new nE(F, be, e)),
        be.init(oe),
        (He = new qT(F, be, oe)),
        (Me = new jT(F, be, oe)),
        (Ae = new dE(F)),
        (ye = new LT()),
        (_e = new WT(F, be, Me, ye, oe, He, Ae)),
        (Ee = new sE(y)),
        (Le = new lE(y)),
        (it = new wS(F, oe)),
        (Ge = new tE(F, be, it, oe)),
        (O = new hE(F, it, Ae, Ge)),
        (D = new gE(F, O, it, Ae)),
        (je = new mE(F, oe, _e)),
        (Fe = new rE(ye)),
        (ne = new PT(y, Ee, Le, be, oe, Ge, Fe)),
        (pe = new ZT(y, ye)),
        (xe = new RT()),
        (we = new BT(be, oe)),
        (le = new eE(y, Ee, Le, Me, D, u, l)),
        (Se = new GT(y, D, oe)),
        (nt = new KT(F, Ae, oe, Me)),
        ($e = new iE(F, be, Ae, oe)),
        (Ye = new uE(F, be, Ae, oe)),
        (Ae.programs = ne.programs),
        (y.capabilities = oe),
        (y.extensions = be),
        (y.properties = ye),
        (y.renderLists = xe),
        (y.shadowMap = Se),
        (y.state = Me),
        (y.info = Ae);
    }
    wt();
    const q = new YT(y, F);
    (this.xr = q),
      (this.getContext = function () {
        return F;
      }),
      (this.getContextAttributes = function () {
        return F.getContextAttributes();
      }),
      (this.forceContextLoss = function () {
        const z = be.get("WEBGL_lose_context");
        z && z.loseContext();
      }),
      (this.forceContextRestore = function () {
        const z = be.get("WEBGL_lose_context");
        z && z.restoreContext();
      }),
      (this.getPixelRatio = function () {
        return N;
      }),
      (this.setPixelRatio = function (z) {
        z !== void 0 && ((N = z), this.setSize(I, W, !1));
      }),
      (this.getSize = function (z) {
        return z.set(I, W);
      }),
      (this.setSize = function (z, ae, de = !0) {
        if (q.isPresenting) {
          console.warn(
            "THREE.WebGLRenderer: Can't change size while VR device is presenting."
          );
          return;
        }
        (I = z),
          (W = ae),
          (i.width = Math.floor(z * N)),
          (i.height = Math.floor(ae * N)),
          de === !0 &&
            ((i.style.width = z + "px"), (i.style.height = ae + "px")),
          this.setViewport(0, 0, z, ae);
      }),
      (this.getDrawingBufferSize = function (z) {
        return z.set(I * N, W * N).floor();
      }),
      (this.setDrawingBufferSize = function (z, ae, de) {
        (I = z),
          (W = ae),
          (N = de),
          (i.width = Math.floor(z * de)),
          (i.height = Math.floor(ae * de)),
          this.setViewport(0, 0, z, ae);
      }),
      (this.getCurrentViewport = function (z) {
        return z.copy(w);
      }),
      (this.getViewport = function (z) {
        return z.copy(k);
      }),
      (this.setViewport = function (z, ae, de, te) {
        z.isVector4 ? k.set(z.x, z.y, z.z, z.w) : k.set(z, ae, de, te),
          Me.viewport(w.copy(k).multiplyScalar(N).floor());
      }),
      (this.getScissor = function (z) {
        return z.copy(B);
      }),
      (this.setScissor = function (z, ae, de, te) {
        z.isVector4 ? B.set(z.x, z.y, z.z, z.w) : B.set(z, ae, de, te),
          Me.scissor(C.copy(B).multiplyScalar(N).floor());
      }),
      (this.getScissorTest = function () {
        return V;
      }),
      (this.setScissorTest = function (z) {
        Me.setScissorTest((V = z));
      }),
      (this.setOpaqueSort = function (z) {
        U = z;
      }),
      (this.setTransparentSort = function (z) {
        G = z;
      }),
      (this.getClearColor = function (z) {
        return z.copy(le.getClearColor());
      }),
      (this.setClearColor = function () {
        le.setClearColor.apply(le, arguments);
      }),
      (this.getClearAlpha = function () {
        return le.getClearAlpha();
      }),
      (this.setClearAlpha = function () {
        le.setClearAlpha.apply(le, arguments);
      }),
      (this.clear = function (z = !0, ae = !0, de = !0) {
        let te = 0;
        if (z) {
          let ge = !1;
          if (E !== null) {
            const qe = E.texture.format;
            ge = qe === Qy || qe === Jy || qe === Ky;
          }
          if (ge) {
            const qe = E.texture.type,
              Je =
                qe === rs ||
                qe === Zr ||
                qe === Ff ||
                qe === ss ||
                qe === Xy ||
                qe === $y,
              ot = le.getClearColor(),
              ut = le.getClearAlpha(),
              St = ot.r,
              mt = ot.g,
              _t = ot.b;
            Je
              ? ((f[0] = St),
                (f[1] = mt),
                (f[2] = _t),
                (f[3] = ut),
                F.clearBufferuiv(F.COLOR, 0, f))
              : ((p[0] = St),
                (p[1] = mt),
                (p[2] = _t),
                (p[3] = ut),
                F.clearBufferiv(F.COLOR, 0, p));
          } else te |= F.COLOR_BUFFER_BIT;
        }
        ae && (te |= F.DEPTH_BUFFER_BIT),
          de && (te |= F.STENCIL_BUFFER_BIT),
          F.clear(te);
      }),
      (this.clearColor = function () {
        this.clear(!0, !1, !1);
      }),
      (this.clearDepth = function () {
        this.clear(!1, !0, !1);
      }),
      (this.clearStencil = function () {
        this.clear(!1, !1, !0);
      }),
      (this.dispose = function () {
        i.removeEventListener("webglcontextlost", De, !1),
          i.removeEventListener("webglcontextrestored", se, !1),
          i.removeEventListener("webglcontextcreationerror", Ce, !1),
          xe.dispose(),
          we.dispose(),
          ye.dispose(),
          Ee.dispose(),
          Le.dispose(),
          D.dispose(),
          Ge.dispose(),
          nt.dispose(),
          ne.dispose(),
          q.dispose(),
          q.removeEventListener("sessionstart", dt),
          q.removeEventListener("sessionend", Nt),
          Y && (Y.dispose(), (Y = null)),
          Et.stop();
      });
    function De(z) {
      z.preventDefault(),
        console.log("THREE.WebGLRenderer: Context Lost."),
        (_ = !0);
    }
    function se() {
      console.log("THREE.WebGLRenderer: Context Restored."), (_ = !1);
      const z = Ae.autoReset,
        ae = Se.enabled,
        de = Se.autoUpdate,
        te = Se.needsUpdate,
        ge = Se.type;
      wt(),
        (Ae.autoReset = z),
        (Se.enabled = ae),
        (Se.autoUpdate = de),
        (Se.needsUpdate = te),
        (Se.type = ge);
    }
    function Ce(z) {
      console.error(
        "THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",
        z.statusMessage
      );
    }
    function Ne(z) {
      const ae = z.target;
      ae.removeEventListener("dispose", Ne), xt(ae);
    }
    function xt(z) {
      It(z), ye.remove(z);
    }
    function It(z) {
      const ae = ye.get(z).programs;
      ae !== void 0 &&
        (ae.forEach(function (de) {
          ne.releaseProgram(de);
        }),
        z.isShaderMaterial && ne.releaseShaderCache(z));
    }
    (this.renderBufferDirect = function (z, ae, de, te, ge, qe) {
      ae === null && (ae = me);
      const Je = ge.isMesh && ge.matrixWorld.determinant() < 0,
        ot = Cl(z, ae, de, te, ge);
      Me.setMaterial(te, Je);
      let ut = de.index,
        St = 1;
      te.wireframe === !0 && ((ut = O.getWireframeAttribute(de)), (St = 2));
      const mt = de.drawRange,
        _t = de.attributes.position;
      let ei = mt.start * St,
        ci = (mt.start + mt.count) * St;
      qe !== null &&
        ((ei = Math.max(ei, qe.start * St)),
        (ci = Math.min(ci, (qe.start + qe.count) * St))),
        ut !== null
          ? ((ei = Math.max(ei, 0)), (ci = Math.min(ci, ut.count)))
          : _t != null &&
            ((ei = Math.max(ei, 0)), (ci = Math.min(ci, _t.count)));
      const Pn = ci - ei;
      if (Pn < 0 || Pn === 1 / 0) return;
      Ge.setup(ge, te, ot, de, ut);
      let mr,
        di = $e;
      if (
        (ut !== null && ((mr = it.get(ut)), (di = Ye), di.setIndex(mr)),
        ge.isMesh)
      )
        te.wireframe === !0
          ? (Me.setLineWidth(te.wireframeLinewidth * re()), di.setMode(F.LINES))
          : di.setMode(F.TRIANGLES);
      else if (ge.isLine) {
        let Dt = te.linewidth;
        Dt === void 0 && (Dt = 1),
          Me.setLineWidth(Dt * re()),
          ge.isLineSegments
            ? di.setMode(F.LINES)
            : ge.isLineLoop
            ? di.setMode(F.LINE_LOOP)
            : di.setMode(F.LINE_STRIP);
      } else
        ge.isPoints
          ? di.setMode(F.POINTS)
          : ge.isSprite && di.setMode(F.TRIANGLES);
      if (ge.isInstancedMesh) di.renderInstances(ei, Pn, ge.count);
      else if (de.isInstancedBufferGeometry) {
        const Dt =
            de._maxInstanceCount !== void 0 ? de._maxInstanceCount : 1 / 0,
          Hh = Math.min(de.instanceCount, Dt);
        di.renderInstances(ei, Pn, Hh);
      } else di.render(ei, Pn);
    }),
      (this.compile = function (z, ae) {
        function de(te, ge, qe) {
          te.transparent === !0 && te.side === Dr && te.forceSinglePass === !1
            ? ((te.side = nn),
              (te.needsUpdate = !0),
              pn(te, ge, qe),
              (te.side = ds),
              (te.needsUpdate = !0),
              pn(te, ge, qe),
              (te.side = Dr))
            : pn(te, ge, qe);
        }
        (g = we.get(z)),
          g.init(),
          x.push(g),
          z.traverseVisible(function (te) {
            te.isLight &&
              te.layers.test(ae.layers) &&
              (g.pushLight(te), te.castShadow && g.pushShadow(te));
          }),
          g.setupLights(y.useLegacyLights),
          z.traverse(function (te) {
            const ge = te.material;
            if (ge)
              if (Array.isArray(ge))
                for (let qe = 0; qe < ge.length; qe++) {
                  const Je = ge[qe];
                  de(Je, z, te);
                }
              else de(ge, z, te);
          }),
          x.pop(),
          (g = null);
      });
    let oi = null;
    function Ut(z) {
      oi && oi(z);
    }
    function dt() {
      Et.stop();
    }
    function Nt() {
      Et.start();
    }
    const Et = new hx();
    Et.setAnimationLoop(Ut),
      typeof self < "u" && Et.setContext(self),
      (this.setAnimationLoop = function (z) {
        (oi = z), q.setAnimationLoop(z), z === null ? Et.stop() : Et.start();
      }),
      q.addEventListener("sessionstart", dt),
      q.addEventListener("sessionend", Nt),
      (this.render = function (z, ae) {
        if (ae !== void 0 && ae.isCamera !== !0) {
          console.error(
            "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
          );
          return;
        }
        if (_ === !0) return;
        z.matrixWorldAutoUpdate === !0 && z.updateMatrixWorld(),
          ae.parent === null &&
            ae.matrixWorldAutoUpdate === !0 &&
            ae.updateMatrixWorld(),
          q.enabled === !0 &&
            q.isPresenting === !0 &&
            (q.cameraAutoUpdate === !0 && q.updateCamera(ae),
            (ae = q.getCamera())),
          z.isScene === !0 && z.onBeforeRender(y, z, ae, E),
          (g = we.get(z, x.length)),
          g.init(),
          x.push(g),
          ee.multiplyMatrices(ae.projectionMatrix, ae.matrixWorldInverse),
          X.setFromProjectionMatrix(ee),
          (j = this.localClippingEnabled),
          (H = Fe.init(this.clippingPlanes, j)),
          (v = xe.get(z, m.length)),
          v.init(),
          m.push(v),
          Qt(z, ae, 0, y.sortObjects),
          v.finish(),
          y.sortObjects === !0 && v.sort(U, G),
          this.info.render.frame++,
          H === !0 && Fe.beginShadows();
        const de = g.state.shadowsArray;
        if (
          (Se.render(de, z, ae),
          H === !0 && Fe.endShadows(),
          this.info.autoReset === !0 && this.info.reset(),
          le.render(v, z),
          g.setupLights(y.useLegacyLights),
          ae.isArrayCamera)
        ) {
          const te = ae.cameras;
          for (let ge = 0, qe = te.length; ge < qe; ge++) {
            const Je = te[ge];
            Zt(v, z, Je, Je.viewport);
          }
        } else Zt(v, z, ae);
        E !== null &&
          (_e.updateMultisampleRenderTarget(E), _e.updateRenderTargetMipmap(E)),
          z.isScene === !0 && z.onAfterRender(y, z, ae),
          Ge.resetDefaultState(),
          (T = -1),
          (S = null),
          x.pop(),
          x.length > 0 ? (g = x[x.length - 1]) : (g = null),
          m.pop(),
          m.length > 0 ? (v = m[m.length - 1]) : (v = null);
      });
    function Qt(z, ae, de, te) {
      if (z.visible === !1) return;
      if (z.layers.test(ae.layers)) {
        if (z.isGroup) de = z.renderOrder;
        else if (z.isLOD) z.autoUpdate === !0 && z.update(ae);
        else if (z.isLight) g.pushLight(z), z.castShadow && g.pushShadow(z);
        else if (z.isSprite) {
          if (!z.frustumCulled || X.intersectsSprite(z)) {
            te && K.setFromMatrixPosition(z.matrixWorld).applyMatrix4(ee);
            const Je = D.update(z),
              ot = z.material;
            ot.visible && v.push(z, Je, ot, de, K.z, null);
          }
        } else if (
          (z.isMesh || z.isLine || z.isPoints) &&
          (!z.frustumCulled || X.intersectsObject(z))
        ) {
          const Je = D.update(z),
            ot = z.material;
          if (
            (te &&
              (z.boundingSphere !== void 0
                ? (z.boundingSphere === null && z.computeBoundingSphere(),
                  K.copy(z.boundingSphere.center))
                : (Je.boundingSphere === null && Je.computeBoundingSphere(),
                  K.copy(Je.boundingSphere.center)),
              K.applyMatrix4(z.matrixWorld).applyMatrix4(ee)),
            Array.isArray(ot))
          ) {
            const ut = Je.groups;
            for (let St = 0, mt = ut.length; St < mt; St++) {
              const _t = ut[St],
                ei = ot[_t.materialIndex];
              ei && ei.visible && v.push(z, Je, ei, de, K.z, _t);
            }
          } else ot.visible && v.push(z, Je, ot, de, K.z, null);
        }
      }
      const qe = z.children;
      for (let Je = 0, ot = qe.length; Je < ot; Je++) Qt(qe[Je], ae, de, te);
    }
    function Zt(z, ae, de, te) {
      const ge = z.opaque,
        qe = z.transmissive,
        Je = z.transparent;
      g.setupLightsView(de),
        H === !0 && Fe.setGlobalState(y.clippingPlanes, de),
        qe.length > 0 && li(ge, qe, ae, de),
        te && Me.viewport(w.copy(te)),
        ge.length > 0 && Ze(ge, ae, de),
        qe.length > 0 && Ze(qe, ae, de),
        Je.length > 0 && Ze(Je, ae, de),
        Me.buffers.depth.setTest(!0),
        Me.buffers.depth.setMask(!0),
        Me.buffers.color.setMask(!0),
        Me.setPolygonOffset(!1);
    }
    function li(z, ae, de, te) {
      const ge = oe.isWebGL2;
      Y === null &&
        (Y = new rn(1, 1, {
          generateMipmaps: !0,
          type: be.has("EXT_color_buffer_half_float") ? Mn : rs,
          minFilter: rl,
          samples: ge ? 4 : 0,
        })),
        y.getDrawingBufferSize(Z),
        ge ? Y.setSize(Z.x, Z.y) : Y.setSize(Bc(Z.x), Bc(Z.y));
      const qe = y.getRenderTarget();
      y.setRenderTarget(Y),
        y.getClearColor(P),
        (R = y.getClearAlpha()),
        R < 1 && y.setClearColor(16777215, 0.5),
        y.clear();
      const Je = y.toneMapping;
      (y.toneMapping = Nr),
        Ze(z, de, te),
        _e.updateMultisampleRenderTarget(Y),
        _e.updateRenderTargetMipmap(Y);
      let ot = !1;
      for (let ut = 0, St = ae.length; ut < St; ut++) {
        const mt = ae[ut],
          _t = mt.object,
          ei = mt.geometry,
          ci = mt.material,
          Pn = mt.group;
        if (ci.side === Dr && _t.layers.test(te.layers)) {
          const mr = ci.side;
          (ci.side = nn),
            (ci.needsUpdate = !0),
            vt(_t, de, te, ei, ci, Pn),
            (ci.side = mr),
            (ci.needsUpdate = !0),
            (ot = !0);
        }
      }
      ot === !0 &&
        (_e.updateMultisampleRenderTarget(Y), _e.updateRenderTargetMipmap(Y)),
        y.setRenderTarget(qe),
        y.setClearColor(P, R),
        (y.toneMapping = Je);
    }
    function Ze(z, ae, de) {
      const te = ae.isScene === !0 ? ae.overrideMaterial : null;
      for (let ge = 0, qe = z.length; ge < qe; ge++) {
        const Je = z[ge],
          ot = Je.object,
          ut = Je.geometry,
          St = te === null ? Je.material : te,
          mt = Je.group;
        ot.layers.test(de.layers) && vt(ot, ae, de, ut, St, mt);
      }
    }
    function vt(z, ae, de, te, ge, qe) {
      z.onBeforeRender(y, ae, de, te, ge, qe),
        z.modelViewMatrix.multiplyMatrices(
          de.matrixWorldInverse,
          z.matrixWorld
        ),
        z.normalMatrix.getNormalMatrix(z.modelViewMatrix),
        ge.onBeforeRender(y, ae, de, te, z, qe),
        ge.transparent === !0 && ge.side === Dr && ge.forceSinglePass === !1
          ? ((ge.side = nn),
            (ge.needsUpdate = !0),
            y.renderBufferDirect(de, ae, te, ge, z, qe),
            (ge.side = ds),
            (ge.needsUpdate = !0),
            y.renderBufferDirect(de, ae, te, ge, z, qe),
            (ge.side = Dr))
          : y.renderBufferDirect(de, ae, te, ge, z, qe),
        z.onAfterRender(y, ae, de, te, ge, qe);
    }
    function pn(z, ae, de) {
      ae.isScene !== !0 && (ae = me);
      const te = ye.get(z),
        ge = g.state.lights,
        qe = g.state.shadowsArray,
        Je = ge.state.version,
        ot = ne.getParameters(z, ge.state, qe, ae, de),
        ut = ne.getProgramCacheKey(ot);
      let St = te.programs;
      (te.environment = z.isMeshStandardMaterial ? ae.environment : null),
        (te.fog = ae.fog),
        (te.envMap = (z.isMeshStandardMaterial ? Le : Ee).get(
          z.envMap || te.environment
        )),
        St === void 0 &&
          (z.addEventListener("dispose", Ne),
          (St = new Map()),
          (te.programs = St));
      let mt = St.get(ut);
      if (mt !== void 0) {
        if (te.currentProgram === mt && te.lightsStateVersion === Je)
          return Cn(z, ot), mt;
      } else
        (ot.uniforms = ne.getUniforms(z)),
          z.onBuild(de, ot, y),
          z.onBeforeCompile(ot, y),
          (mt = ne.acquireProgram(ot, ut)),
          St.set(ut, mt),
          (te.uniforms = ot.uniforms);
      const _t = te.uniforms;
      ((!z.isShaderMaterial && !z.isRawShaderMaterial) || z.clipping === !0) &&
        (_t.clippingPlanes = Fe.uniform),
        Cn(z, ot),
        (te.needsLights = Kn(z)),
        (te.lightsStateVersion = Je),
        te.needsLights &&
          ((_t.ambientLightColor.value = ge.state.ambient),
          (_t.lightProbe.value = ge.state.probe),
          (_t.directionalLights.value = ge.state.directional),
          (_t.directionalLightShadows.value = ge.state.directionalShadow),
          (_t.spotLights.value = ge.state.spot),
          (_t.spotLightShadows.value = ge.state.spotShadow),
          (_t.rectAreaLights.value = ge.state.rectArea),
          (_t.ltc_1.value = ge.state.rectAreaLTC1),
          (_t.ltc_2.value = ge.state.rectAreaLTC2),
          (_t.pointLights.value = ge.state.point),
          (_t.pointLightShadows.value = ge.state.pointShadow),
          (_t.hemisphereLights.value = ge.state.hemi),
          (_t.directionalShadowMap.value = ge.state.directionalShadowMap),
          (_t.directionalShadowMatrix.value = ge.state.directionalShadowMatrix),
          (_t.spotShadowMap.value = ge.state.spotShadowMap),
          (_t.spotLightMatrix.value = ge.state.spotLightMatrix),
          (_t.spotLightMap.value = ge.state.spotLightMap),
          (_t.pointShadowMap.value = ge.state.pointShadowMap),
          (_t.pointShadowMatrix.value = ge.state.pointShadowMatrix));
      const ei = mt.getUniforms(),
        ci = Lc.seqWithValue(ei.seq, _t);
      return (te.currentProgram = mt), (te.uniformsList = ci), mt;
    }
    function Cn(z, ae) {
      const de = ye.get(z);
      (de.outputColorSpace = ae.outputColorSpace),
        (de.instancing = ae.instancing),
        (de.skinning = ae.skinning),
        (de.morphTargets = ae.morphTargets),
        (de.morphNormals = ae.morphNormals),
        (de.morphColors = ae.morphColors),
        (de.morphTargetsCount = ae.morphTargetsCount),
        (de.numClippingPlanes = ae.numClippingPlanes),
        (de.numIntersection = ae.numClipIntersection),
        (de.vertexAlphas = ae.vertexAlphas),
        (de.vertexTangents = ae.vertexTangents),
        (de.toneMapping = ae.toneMapping);
    }
    function Cl(z, ae, de, te, ge) {
      ae.isScene !== !0 && (ae = me), _e.resetTextureUnits();
      const qe = ae.fog,
        Je = te.isMeshStandardMaterial ? ae.environment : null,
        ot =
          E === null
            ? y.outputColorSpace
            : E.isXRRenderTarget === !0
            ? E.texture.colorSpace
            : qn,
        ut = (te.isMeshStandardMaterial ? Le : Ee).get(te.envMap || Je),
        St =
          te.vertexColors === !0 &&
          !!de.attributes.color &&
          de.attributes.color.itemSize === 4,
        mt = !!de.attributes.tangent && (!!te.normalMap || te.anisotropy > 0),
        _t = !!de.morphAttributes.position,
        ei = !!de.morphAttributes.normal,
        ci = !!de.morphAttributes.color,
        Pn = te.toneMapped ? y.toneMapping : Nr,
        mr =
          de.morphAttributes.position ||
          de.morphAttributes.normal ||
          de.morphAttributes.color,
        di = mr !== void 0 ? mr.length : 0,
        Dt = ye.get(te),
        Hh = g.state.lights;
      if (H === !0 && (j === !0 || z !== S)) {
        const on = z === S && te.id === T;
        Fe.setState(te, z, on);
      }
      let wi = !1;
      te.version === Dt.__version
        ? ((Dt.needsLights && Dt.lightsStateVersion !== Hh.state.version) ||
            Dt.outputColorSpace !== ot ||
            (ge.isInstancedMesh && Dt.instancing === !1) ||
            (!ge.isInstancedMesh && Dt.instancing === !0) ||
            (ge.isSkinnedMesh && Dt.skinning === !1) ||
            (!ge.isSkinnedMesh && Dt.skinning === !0) ||
            Dt.envMap !== ut ||
            (te.fog === !0 && Dt.fog !== qe) ||
            (Dt.numClippingPlanes !== void 0 &&
              (Dt.numClippingPlanes !== Fe.numPlanes ||
                Dt.numIntersection !== Fe.numIntersection)) ||
            Dt.vertexAlphas !== St ||
            Dt.vertexTangents !== mt ||
            Dt.morphTargets !== _t ||
            Dt.morphNormals !== ei ||
            Dt.morphColors !== ci ||
            Dt.toneMapping !== Pn ||
            (oe.isWebGL2 === !0 && Dt.morphTargetsCount !== di)) &&
          (wi = !0)
        : ((wi = !0), (Dt.__version = te.version));
      let _s = Dt.currentProgram;
      wi === !0 && (_s = pn(te, ae, ge));
      let Kp = !1,
        bo = !1,
        Gh = !1;
      const Ni = _s.getUniforms(),
        bs = Dt.uniforms;
      if (
        (Me.useProgram(_s.program) && ((Kp = !0), (bo = !0), (Gh = !0)),
        te.id !== T && ((T = te.id), (bo = !0)),
        Kp || S !== z)
      ) {
        if (
          (Ni.setValue(F, "projectionMatrix", z.projectionMatrix),
          oe.logarithmicDepthBuffer &&
            Ni.setValue(
              F,
              "logDepthBufFC",
              2 / (Math.log(z.far + 1) / Math.LN2)
            ),
          S !== z && ((S = z), (bo = !0), (Gh = !0)),
          te.isShaderMaterial ||
            te.isMeshPhongMaterial ||
            te.isMeshToonMaterial ||
            te.isMeshStandardMaterial ||
            te.envMap)
        ) {
          const on = Ni.map.cameraPosition;
          on !== void 0 &&
            on.setValue(F, K.setFromMatrixPosition(z.matrixWorld));
        }
        (te.isMeshPhongMaterial ||
          te.isMeshToonMaterial ||
          te.isMeshLambertMaterial ||
          te.isMeshBasicMaterial ||
          te.isMeshStandardMaterial ||
          te.isShaderMaterial) &&
          Ni.setValue(F, "isOrthographic", z.isOrthographicCamera === !0),
          (te.isMeshPhongMaterial ||
            te.isMeshToonMaterial ||
            te.isMeshLambertMaterial ||
            te.isMeshBasicMaterial ||
            te.isMeshStandardMaterial ||
            te.isShaderMaterial ||
            te.isShadowMaterial ||
            ge.isSkinnedMesh) &&
            Ni.setValue(F, "viewMatrix", z.matrixWorldInverse);
      }
      if (ge.isSkinnedMesh) {
        Ni.setOptional(F, ge, "bindMatrix"),
          Ni.setOptional(F, ge, "bindMatrixInverse");
        const on = ge.skeleton;
        on &&
          (oe.floatVertexTextures
            ? (on.boneTexture === null && on.computeBoneTexture(),
              Ni.setValue(F, "boneTexture", on.boneTexture, _e),
              Ni.setValue(F, "boneTextureSize", on.boneTextureSize))
            : console.warn(
                "THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."
              ));
      }
      const jh = de.morphAttributes;
      if (
        ((jh.position !== void 0 ||
          jh.normal !== void 0 ||
          (jh.color !== void 0 && oe.isWebGL2 === !0)) &&
          je.update(ge, de, _s),
        (bo || Dt.receiveShadow !== ge.receiveShadow) &&
          ((Dt.receiveShadow = ge.receiveShadow),
          Ni.setValue(F, "receiveShadow", ge.receiveShadow)),
        te.isMeshGouraudMaterial &&
          te.envMap !== null &&
          ((bs.envMap.value = ut),
          (bs.flipEnvMap.value =
            ut.isCubeTexture && ut.isRenderTargetTexture === !1 ? -1 : 1)),
        bo &&
          (Ni.setValue(F, "toneMappingExposure", y.toneMappingExposure),
          Dt.needsLights && na(bs, Gh),
          qe && te.fog === !0 && pe.refreshFogUniforms(bs, qe),
          pe.refreshMaterialUniforms(bs, te, N, W, Y),
          Lc.upload(F, Dt.uniformsList, bs, _e)),
        te.isShaderMaterial &&
          te.uniformsNeedUpdate === !0 &&
          (Lc.upload(F, Dt.uniformsList, bs, _e), (te.uniformsNeedUpdate = !1)),
        te.isSpriteMaterial && Ni.setValue(F, "center", ge.center),
        Ni.setValue(F, "modelViewMatrix", ge.modelViewMatrix),
        Ni.setValue(F, "normalMatrix", ge.normalMatrix),
        Ni.setValue(F, "modelMatrix", ge.matrixWorld),
        te.isShaderMaterial || te.isRawShaderMaterial)
      ) {
        const on = te.uniformsGroups;
        for (let Wh = 0, Z1 = on.length; Wh < Z1; Wh++)
          if (oe.isWebGL2) {
            const Jp = on[Wh];
            nt.update(Jp, _s), nt.bind(Jp, _s);
          } else
            console.warn(
              "THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2."
            );
      }
      return _s;
    }
    function na(z, ae) {
      (z.ambientLightColor.needsUpdate = ae),
        (z.lightProbe.needsUpdate = ae),
        (z.directionalLights.needsUpdate = ae),
        (z.directionalLightShadows.needsUpdate = ae),
        (z.pointLights.needsUpdate = ae),
        (z.pointLightShadows.needsUpdate = ae),
        (z.spotLights.needsUpdate = ae),
        (z.spotLightShadows.needsUpdate = ae),
        (z.rectAreaLights.needsUpdate = ae),
        (z.hemisphereLights.needsUpdate = ae);
    }
    function Kn(z) {
      return (
        z.isMeshLambertMaterial ||
        z.isMeshToonMaterial ||
        z.isMeshPhongMaterial ||
        z.isMeshStandardMaterial ||
        z.isShadowMaterial ||
        (z.isShaderMaterial && z.lights === !0)
      );
    }
    (this.getActiveCubeFace = function () {
      return M;
    }),
      (this.getActiveMipmapLevel = function () {
        return b;
      }),
      (this.getRenderTarget = function () {
        return E;
      }),
      (this.setRenderTargetTextures = function (z, ae, de) {
        (ye.get(z.texture).__webglTexture = ae),
          (ye.get(z.depthTexture).__webglTexture = de);
        const te = ye.get(z);
        (te.__hasExternalTextures = !0),
          te.__hasExternalTextures &&
            ((te.__autoAllocateDepthBuffer = de === void 0),
            te.__autoAllocateDepthBuffer ||
              (be.has("WEBGL_multisampled_render_to_texture") === !0 &&
                (console.warn(
                  "THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"
                ),
                (te.__useRenderToTexture = !1))));
      }),
      (this.setRenderTargetFramebuffer = function (z, ae) {
        const de = ye.get(z);
        (de.__webglFramebuffer = ae),
          (de.__useDefaultFramebuffer = ae === void 0);
      }),
      (this.setRenderTarget = function (z, ae = 0, de = 0) {
        (E = z), (M = ae), (b = de);
        let te = !0,
          ge = null,
          qe = !1,
          Je = !1;
        if (z) {
          const ut = ye.get(z);
          ut.__useDefaultFramebuffer !== void 0
            ? (Me.bindFramebuffer(F.FRAMEBUFFER, null), (te = !1))
            : ut.__webglFramebuffer === void 0
            ? _e.setupRenderTarget(z)
            : ut.__hasExternalTextures &&
              _e.rebindTextures(
                z,
                ye.get(z.texture).__webglTexture,
                ye.get(z.depthTexture).__webglTexture
              );
          const St = z.texture;
          (St.isData3DTexture ||
            St.isDataArrayTexture ||
            St.isCompressedArrayTexture) &&
            (Je = !0);
          const mt = ye.get(z).__webglFramebuffer;
          z.isWebGLCubeRenderTarget
            ? ((ge = mt[ae]), (qe = !0))
            : oe.isWebGL2 && z.samples > 0 && _e.useMultisampledRTT(z) === !1
            ? (ge = ye.get(z).__webglMultisampledFramebuffer)
            : (ge = mt),
            w.copy(z.viewport),
            C.copy(z.scissor),
            (L = z.scissorTest);
        } else
          w.copy(k).multiplyScalar(N).floor(),
            C.copy(B).multiplyScalar(N).floor(),
            (L = V);
        if (
          (Me.bindFramebuffer(F.FRAMEBUFFER, ge) &&
            oe.drawBuffers &&
            te &&
            Me.drawBuffers(z, ge),
          Me.viewport(w),
          Me.scissor(C),
          Me.setScissorTest(L),
          qe)
        ) {
          const ut = ye.get(z.texture);
          F.framebufferTexture2D(
            F.FRAMEBUFFER,
            F.COLOR_ATTACHMENT0,
            F.TEXTURE_CUBE_MAP_POSITIVE_X + ae,
            ut.__webglTexture,
            de
          );
        } else if (Je) {
          const ut = ye.get(z.texture),
            St = ae || 0;
          F.framebufferTextureLayer(
            F.FRAMEBUFFER,
            F.COLOR_ATTACHMENT0,
            ut.__webglTexture,
            de || 0,
            St
          );
        }
        T = -1;
      }),
      (this.readRenderTargetPixels = function (z, ae, de, te, ge, qe, Je) {
        if (!(z && z.isWebGLRenderTarget)) {
          console.error(
            "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
          );
          return;
        }
        let ot = ye.get(z).__webglFramebuffer;
        if ((z.isWebGLCubeRenderTarget && Je !== void 0 && (ot = ot[Je]), ot)) {
          Me.bindFramebuffer(F.FRAMEBUFFER, ot);
          try {
            const ut = z.texture,
              St = ut.format,
              mt = ut.type;
            if (
              St !== wn &&
              He.convert(St) !==
                F.getParameter(F.IMPLEMENTATION_COLOR_READ_FORMAT)
            ) {
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
              );
              return;
            }
            const _t =
              mt === Mn &&
              (be.has("EXT_color_buffer_half_float") ||
                (oe.isWebGL2 && be.has("EXT_color_buffer_float")));
            if (
              mt !== rs &&
              He.convert(mt) !==
                F.getParameter(F.IMPLEMENTATION_COLOR_READ_TYPE) &&
              !(
                mt === lr &&
                (oe.isWebGL2 ||
                  be.has("OES_texture_float") ||
                  be.has("WEBGL_color_buffer_float"))
              ) &&
              !_t
            ) {
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
              );
              return;
            }
            ae >= 0 &&
              ae <= z.width - te &&
              de >= 0 &&
              de <= z.height - ge &&
              F.readPixels(ae, de, te, ge, He.convert(St), He.convert(mt), qe);
          } finally {
            const ut = E !== null ? ye.get(E).__webglFramebuffer : null;
            Me.bindFramebuffer(F.FRAMEBUFFER, ut);
          }
        }
      }),
      (this.copyFramebufferToTexture = function (z, ae, de = 0) {
        const te = Math.pow(2, -de),
          ge = Math.floor(ae.image.width * te),
          qe = Math.floor(ae.image.height * te);
        _e.setTexture2D(ae, 0),
          F.copyTexSubImage2D(F.TEXTURE_2D, de, 0, 0, z.x, z.y, ge, qe),
          Me.unbindTexture();
      }),
      (this.copyTextureToTexture = function (z, ae, de, te = 0) {
        const ge = ae.image.width,
          qe = ae.image.height,
          Je = He.convert(de.format),
          ot = He.convert(de.type);
        _e.setTexture2D(de, 0),
          F.pixelStorei(F.UNPACK_FLIP_Y_WEBGL, de.flipY),
          F.pixelStorei(F.UNPACK_PREMULTIPLY_ALPHA_WEBGL, de.premultiplyAlpha),
          F.pixelStorei(F.UNPACK_ALIGNMENT, de.unpackAlignment),
          ae.isDataTexture
            ? F.texSubImage2D(
                F.TEXTURE_2D,
                te,
                z.x,
                z.y,
                ge,
                qe,
                Je,
                ot,
                ae.image.data
              )
            : ae.isCompressedTexture
            ? F.compressedTexSubImage2D(
                F.TEXTURE_2D,
                te,
                z.x,
                z.y,
                ae.mipmaps[0].width,
                ae.mipmaps[0].height,
                Je,
                ae.mipmaps[0].data
              )
            : F.texSubImage2D(F.TEXTURE_2D, te, z.x, z.y, Je, ot, ae.image),
          te === 0 && de.generateMipmaps && F.generateMipmap(F.TEXTURE_2D),
          Me.unbindTexture();
      }),
      (this.copyTextureToTexture3D = function (z, ae, de, te, ge = 0) {
        if (y.isWebGL1Renderer) {
          console.warn(
            "THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2."
          );
          return;
        }
        const qe = z.max.x - z.min.x + 1,
          Je = z.max.y - z.min.y + 1,
          ot = z.max.z - z.min.z + 1,
          ut = He.convert(te.format),
          St = He.convert(te.type);
        let mt;
        if (te.isData3DTexture) _e.setTexture3D(te, 0), (mt = F.TEXTURE_3D);
        else if (te.isDataArrayTexture)
          _e.setTexture2DArray(te, 0), (mt = F.TEXTURE_2D_ARRAY);
        else {
          console.warn(
            "THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."
          );
          return;
        }
        F.pixelStorei(F.UNPACK_FLIP_Y_WEBGL, te.flipY),
          F.pixelStorei(F.UNPACK_PREMULTIPLY_ALPHA_WEBGL, te.premultiplyAlpha),
          F.pixelStorei(F.UNPACK_ALIGNMENT, te.unpackAlignment);
        const _t = F.getParameter(F.UNPACK_ROW_LENGTH),
          ei = F.getParameter(F.UNPACK_IMAGE_HEIGHT),
          ci = F.getParameter(F.UNPACK_SKIP_PIXELS),
          Pn = F.getParameter(F.UNPACK_SKIP_ROWS),
          mr = F.getParameter(F.UNPACK_SKIP_IMAGES),
          di = de.isCompressedTexture ? de.mipmaps[0] : de.image;
        F.pixelStorei(F.UNPACK_ROW_LENGTH, di.width),
          F.pixelStorei(F.UNPACK_IMAGE_HEIGHT, di.height),
          F.pixelStorei(F.UNPACK_SKIP_PIXELS, z.min.x),
          F.pixelStorei(F.UNPACK_SKIP_ROWS, z.min.y),
          F.pixelStorei(F.UNPACK_SKIP_IMAGES, z.min.z),
          de.isDataTexture || de.isData3DTexture
            ? F.texSubImage3D(
                mt,
                ge,
                ae.x,
                ae.y,
                ae.z,
                qe,
                Je,
                ot,
                ut,
                St,
                di.data
              )
            : de.isCompressedArrayTexture
            ? (console.warn(
                "THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."
              ),
              F.compressedTexSubImage3D(
                mt,
                ge,
                ae.x,
                ae.y,
                ae.z,
                qe,
                Je,
                ot,
                ut,
                di.data
              ))
            : F.texSubImage3D(mt, ge, ae.x, ae.y, ae.z, qe, Je, ot, ut, St, di),
          F.pixelStorei(F.UNPACK_ROW_LENGTH, _t),
          F.pixelStorei(F.UNPACK_IMAGE_HEIGHT, ei),
          F.pixelStorei(F.UNPACK_SKIP_PIXELS, ci),
          F.pixelStorei(F.UNPACK_SKIP_ROWS, Pn),
          F.pixelStorei(F.UNPACK_SKIP_IMAGES, mr),
          ge === 0 && te.generateMipmaps && F.generateMipmap(mt),
          Me.unbindTexture();
      }),
      (this.initTexture = function (z) {
        z.isCubeTexture
          ? _e.setTextureCube(z, 0)
          : z.isData3DTexture
          ? _e.setTexture3D(z, 0)
          : z.isDataArrayTexture || z.isCompressedArrayTexture
          ? _e.setTexture2DArray(z, 0)
          : _e.setTexture2D(z, 0),
          Me.unbindTexture();
      }),
      (this.resetState = function () {
        (M = 0), (b = 0), (E = null), Me.reset(), Ge.reset();
      }),
      typeof __THREE_DEVTOOLS__ < "u" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", { detail: this })
        );
  }
  get coordinateSystem() {
    return Or;
  }
  get physicallyCorrectLights() {
    return (
      console.warn(
        "THREE.WebGLRenderer: the property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."
      ),
      !this.useLegacyLights
    );
  }
  set physicallyCorrectLights(e) {
    console.warn(
      "THREE.WebGLRenderer: the property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."
    ),
      (this.useLegacyLights = !e);
  }
  get outputEncoding() {
    return (
      console.warn(
        "THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."
      ),
      this.outputColorSpace === gt ? zr : sl
    );
  }
  set outputEncoding(e) {
    console.warn(
      "THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."
    ),
      (this.outputColorSpace = e === zr ? gt : qn);
  }
}
class QT extends gx {}
QT.prototype.isWebGL1Renderer = !0;
class Wf {
  constructor(e, i = 1, n = 1e3) {
    (this.isFog = !0),
      (this.name = ""),
      (this.color = new tt(e)),
      (this.near = i),
      (this.far = n);
  }
  clone() {
    return new Wf(this.color, this.near, this.far);
  }
  toJSON() {
    return {
      type: "Fog",
      color: this.color.getHex(),
      near: this.near,
      far: this.far,
    };
  }
}
class qf extends Ht {
  constructor() {
    super(),
      (this.isScene = !0),
      (this.type = "Scene"),
      (this.background = null),
      (this.environment = null),
      (this.fog = null),
      (this.backgroundBlurriness = 0),
      (this.backgroundIntensity = 1),
      (this.overrideMaterial = null),
      typeof __THREE_DEVTOOLS__ < "u" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", { detail: this })
        );
  }
  copy(e, i) {
    return (
      super.copy(e, i),
      e.background !== null && (this.background = e.background.clone()),
      e.environment !== null && (this.environment = e.environment.clone()),
      e.fog !== null && (this.fog = e.fog.clone()),
      (this.backgroundBlurriness = e.backgroundBlurriness),
      (this.backgroundIntensity = e.backgroundIntensity),
      e.overrideMaterial !== null &&
        (this.overrideMaterial = e.overrideMaterial.clone()),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this
    );
  }
  toJSON(e) {
    const i = super.toJSON(e);
    return (
      this.fog !== null && (i.object.fog = this.fog.toJSON()),
      this.backgroundBlurriness > 0 &&
        (i.object.backgroundBlurriness = this.backgroundBlurriness),
      this.backgroundIntensity !== 1 &&
        (i.object.backgroundIntensity = this.backgroundIntensity),
      i
    );
  }
}
class eA {
  constructor(e, i) {
    (this.isInterleavedBuffer = !0),
      (this.array = e),
      (this.stride = i),
      (this.count = e !== void 0 ? e.length / i : 0),
      (this.usage = vd),
      (this.updateRange = { offset: 0, count: -1 }),
      (this.version = 0),
      (this.uuid = Gn());
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  copy(e) {
    return (
      (this.array = new e.array.constructor(e.array)),
      (this.count = e.count),
      (this.stride = e.stride),
      (this.usage = e.usage),
      this
    );
  }
  copyAt(e, i, n) {
    (e *= this.stride), (n *= i.stride);
    for (let r = 0, s = this.stride; r < s; r++)
      this.array[e + r] = i.array[n + r];
    return this;
  }
  set(e, i = 0) {
    return this.array.set(e, i), this;
  }
  clone(e) {
    e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Gn()),
      e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const i = new this.array.constructor(
        e.arrayBuffers[this.array.buffer._uuid]
      ),
      n = new this.constructor(i, this.stride);
    return n.setUsage(this.usage), n;
  }
  onUpload(e) {
    return (this.onUploadCallback = e), this;
  }
  toJSON(e) {
    return (
      e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Gn()),
      e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (e.arrayBuffers[this.array.buffer._uuid] = Array.from(
          new Uint32Array(this.array.buffer)
        )),
      {
        uuid: this.uuid,
        buffer: this.array.buffer._uuid,
        type: this.array.constructor.name,
        stride: this.stride,
      }
    );
  }
}
const zi = new A();
class kc {
  constructor(e, i, n, r = !1) {
    (this.isInterleavedBufferAttribute = !0),
      (this.name = ""),
      (this.data = e),
      (this.itemSize = i),
      (this.offset = n),
      (this.normalized = r);
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(e) {
    this.data.needsUpdate = e;
  }
  applyMatrix4(e) {
    for (let i = 0, n = this.data.count; i < n; i++)
      zi.fromBufferAttribute(this, i),
        zi.applyMatrix4(e),
        this.setXYZ(i, zi.x, zi.y, zi.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let i = 0, n = this.count; i < n; i++)
      zi.fromBufferAttribute(this, i),
        zi.applyNormalMatrix(e),
        this.setXYZ(i, zi.x, zi.y, zi.z);
    return this;
  }
  transformDirection(e) {
    for (let i = 0, n = this.count; i < n; i++)
      zi.fromBufferAttribute(this, i),
        zi.transformDirection(e),
        this.setXYZ(i, zi.x, zi.y, zi.z);
    return this;
  }
  setX(e, i) {
    return (
      this.normalized && (i = Wt(i, this.array)),
      (this.data.array[e * this.data.stride + this.offset] = i),
      this
    );
  }
  setY(e, i) {
    return (
      this.normalized && (i = Wt(i, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 1] = i),
      this
    );
  }
  setZ(e, i) {
    return (
      this.normalized && (i = Wt(i, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 2] = i),
      this
    );
  }
  setW(e, i) {
    return (
      this.normalized && (i = Wt(i, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 3] = i),
      this
    );
  }
  getX(e) {
    let i = this.data.array[e * this.data.stride + this.offset];
    return this.normalized && (i = Ir(i, this.array)), i;
  }
  getY(e) {
    let i = this.data.array[e * this.data.stride + this.offset + 1];
    return this.normalized && (i = Ir(i, this.array)), i;
  }
  getZ(e) {
    let i = this.data.array[e * this.data.stride + this.offset + 2];
    return this.normalized && (i = Ir(i, this.array)), i;
  }
  getW(e) {
    let i = this.data.array[e * this.data.stride + this.offset + 3];
    return this.normalized && (i = Ir(i, this.array)), i;
  }
  setXY(e, i, n) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized && ((i = Wt(i, this.array)), (n = Wt(n, this.array))),
      (this.data.array[e + 0] = i),
      (this.data.array[e + 1] = n),
      this
    );
  }
  setXYZ(e, i, n, r) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized &&
        ((i = Wt(i, this.array)),
        (n = Wt(n, this.array)),
        (r = Wt(r, this.array))),
      (this.data.array[e + 0] = i),
      (this.data.array[e + 1] = n),
      (this.data.array[e + 2] = r),
      this
    );
  }
  setXYZW(e, i, n, r, s) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized &&
        ((i = Wt(i, this.array)),
        (n = Wt(n, this.array)),
        (r = Wt(r, this.array)),
        (s = Wt(s, this.array))),
      (this.data.array[e + 0] = i),
      (this.data.array[e + 1] = n),
      (this.data.array[e + 2] = r),
      (this.data.array[e + 3] = s),
      this
    );
  }
  clone(e) {
    if (e === void 0) {
      console.log(
        "THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data."
      );
      const i = [];
      for (let n = 0; n < this.count; n++) {
        const r = n * this.data.stride + this.offset;
        for (let s = 0; s < this.itemSize; s++) i.push(this.data.array[r + s]);
      }
      return new pt(
        new this.array.constructor(i),
        this.itemSize,
        this.normalized
      );
    } else
      return (
        e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
        e.interleavedBuffers[this.data.uuid] === void 0 &&
          (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
        new kc(
          e.interleavedBuffers[this.data.uuid],
          this.itemSize,
          this.offset,
          this.normalized
        )
      );
  }
  toJSON(e) {
    if (e === void 0) {
      console.log(
        "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data."
      );
      const i = [];
      for (let n = 0; n < this.count; n++) {
        const r = n * this.data.stride + this.offset;
        for (let s = 0; s < this.itemSize; s++) i.push(this.data.array[r + s]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: i,
        normalized: this.normalized,
      };
    } else
      return (
        e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
        e.interleavedBuffers[this.data.uuid] === void 0 &&
          (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
        {
          isInterleavedBufferAttribute: !0,
          itemSize: this.itemSize,
          data: this.data.uuid,
          offset: this.offset,
          normalized: this.normalized,
        }
      );
  }
}
class vx extends Ht {
  constructor() {
    super(), (this.isBone = !0), (this.type = "Bone");
  }
}
class yx extends Li {
  constructor(e = null, i = 1, n = 1, r, s, a, o, l, c = vi, d = vi, h, u) {
    super(null, a, o, l, c, d, r, s, h, u),
      (this.isDataTexture = !0),
      (this.image = { data: e, width: i, height: n }),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
const bg = new ze(),
  tA = new ze();
class wh {
  constructor(e = [], i = []) {
    (this.uuid = Gn()),
      (this.bones = e.slice(0)),
      (this.boneInverses = i),
      (this.boneMatrices = null),
      (this.boneTexture = null),
      (this.boneTextureSize = 0),
      this.init();
  }
  init() {
    const e = this.bones,
      i = this.boneInverses;
    if (((this.boneMatrices = new Float32Array(e.length * 16)), i.length === 0))
      this.calculateInverses();
    else if (e.length !== i.length) {
      console.warn(
        "THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."
      ),
        (this.boneInverses = []);
      for (let n = 0, r = this.bones.length; n < r; n++)
        this.boneInverses.push(new ze());
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let e = 0, i = this.bones.length; e < i; e++) {
      const n = new ze();
      this.bones[e] && n.copy(this.bones[e].matrixWorld).invert(),
        this.boneInverses.push(n);
    }
  }
  pose() {
    for (let e = 0, i = this.bones.length; e < i; e++) {
      const n = this.bones[e];
      n && n.matrixWorld.copy(this.boneInverses[e]).invert();
    }
    for (let e = 0, i = this.bones.length; e < i; e++) {
      const n = this.bones[e];
      n &&
        (n.parent && n.parent.isBone
          ? (n.matrix.copy(n.parent.matrixWorld).invert(),
            n.matrix.multiply(n.matrixWorld))
          : n.matrix.copy(n.matrixWorld),
        n.matrix.decompose(n.position, n.quaternion, n.scale));
    }
  }
  update() {
    const e = this.bones,
      i = this.boneInverses,
      n = this.boneMatrices,
      r = this.boneTexture;
    for (let s = 0, a = e.length; s < a; s++) {
      const o = e[s] ? e[s].matrixWorld : tA;
      bg.multiplyMatrices(o, i[s]), bg.toArray(n, s * 16);
    }
    r !== null && (r.needsUpdate = !0);
  }
  clone() {
    return new wh(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let e = Math.sqrt(this.bones.length * 4);
    (e = ix(e)), (e = Math.max(e, 4));
    const i = new Float32Array(e * e * 4);
    i.set(this.boneMatrices);
    const n = new yx(i, e, e, wn, lr);
    return (
      (n.needsUpdate = !0),
      (this.boneMatrices = i),
      (this.boneTexture = n),
      (this.boneTextureSize = e),
      this
    );
  }
  getBoneByName(e) {
    for (let i = 0, n = this.bones.length; i < n; i++) {
      const r = this.bones[i];
      if (r.name === e) return r;
    }
  }
  dispose() {
    this.boneTexture !== null &&
      (this.boneTexture.dispose(), (this.boneTexture = null));
  }
  fromJSON(e, i) {
    this.uuid = e.uuid;
    for (let n = 0, r = e.bones.length; n < r; n++) {
      const s = e.bones[n];
      let a = i[s];
      a === void 0 &&
        (console.warn("THREE.Skeleton: No bone found with UUID:", s),
        (a = new vx())),
        this.bones.push(a),
        this.boneInverses.push(new ze().fromArray(e.boneInverses[n]));
    }
    return this.init(), this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "Skeleton",
        generator: "Skeleton.toJSON",
      },
      bones: [],
      boneInverses: [],
    };
    e.uuid = this.uuid;
    const i = this.bones,
      n = this.boneInverses;
    for (let r = 0, s = i.length; r < s; r++) {
      const a = i[r];
      e.bones.push(a.uuid);
      const o = n[r];
      e.boneInverses.push(o.toArray());
    }
    return e;
  }
}
class iA extends pt {
  constructor(e, i, n, r = 1) {
    super(e, i, n),
      (this.isInstancedBufferAttribute = !0),
      (this.meshPerAttribute = r);
  }
  copy(e) {
    return super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.meshPerAttribute = this.meshPerAttribute),
      (e.isInstancedBufferAttribute = !0),
      e
    );
  }
}
class Ks extends lo {
  constructor(e) {
    super(),
      (this.isLineBasicMaterial = !0),
      (this.type = "LineBasicMaterial"),
      (this.color = new tt(16777215)),
      (this.map = null),
      (this.linewidth = 1),
      (this.linecap = "round"),
      (this.linejoin = "round"),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.linewidth = e.linewidth),
      (this.linecap = e.linecap),
      (this.linejoin = e.linejoin),
      (this.fog = e.fog),
      this
    );
  }
}
const wg = new A(),
  Sg = new A(),
  Mg = new ze(),
  Su = new oo(),
  Kl = new Xn();
class bd extends Ht {
  constructor(e = new st(), i = new Ks()) {
    super(),
      (this.isLine = !0),
      (this.type = "Line"),
      (this.geometry = e),
      (this.material = i),
      this.updateMorphTargets();
  }
  copy(e, i) {
    return (
      super.copy(e, i),
      (this.material = e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const i = e.attributes.position,
        n = [0];
      for (let r = 1, s = i.count; r < s; r++)
        wg.fromBufferAttribute(i, r - 1),
          Sg.fromBufferAttribute(i, r),
          (n[r] = n[r - 1]),
          (n[r] += wg.distanceTo(Sg));
      e.setAttribute("lineDistance", new We(n, 1));
    } else
      console.warn(
        "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
      );
    return this;
  }
  raycast(e, i) {
    const n = this.geometry,
      r = this.matrixWorld,
      s = e.params.Line.threshold,
      a = n.drawRange;
    if (
      (n.boundingSphere === null && n.computeBoundingSphere(),
      Kl.copy(n.boundingSphere),
      Kl.applyMatrix4(r),
      (Kl.radius += s),
      e.ray.intersectsSphere(Kl) === !1)
    )
      return;
    Mg.copy(r).invert(), Su.copy(e.ray).applyMatrix4(Mg);
    const o = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      l = o * o,
      c = new A(),
      d = new A(),
      h = new A(),
      u = new A(),
      f = this.isLineSegments ? 2 : 1,
      p = n.index,
      g = n.attributes.position;
    if (p !== null) {
      const m = Math.max(0, a.start),
        x = Math.min(p.count, a.start + a.count);
      for (let y = m, _ = x - 1; y < _; y += f) {
        const M = p.getX(y),
          b = p.getX(y + 1);
        if (
          (c.fromBufferAttribute(g, M),
          d.fromBufferAttribute(g, b),
          Su.distanceSqToSegment(c, d, u, h) > l)
        )
          continue;
        u.applyMatrix4(this.matrixWorld);
        const T = e.ray.origin.distanceTo(u);
        T < e.near ||
          T > e.far ||
          i.push({
            distance: T,
            point: h.clone().applyMatrix4(this.matrixWorld),
            index: y,
            face: null,
            faceIndex: null,
            object: this,
          });
      }
    } else {
      const m = Math.max(0, a.start),
        x = Math.min(g.count, a.start + a.count);
      for (let y = m, _ = x - 1; y < _; y += f) {
        if (
          (c.fromBufferAttribute(g, y),
          d.fromBufferAttribute(g, y + 1),
          Su.distanceSqToSegment(c, d, u, h) > l)
        )
          continue;
        u.applyMatrix4(this.matrixWorld);
        const b = e.ray.origin.distanceTo(u);
        b < e.near ||
          b > e.far ||
          i.push({
            distance: b,
            point: h.clone().applyMatrix4(this.matrixWorld),
            index: y,
            face: null,
            faceIndex: null,
            object: this,
          });
      }
    }
  }
  updateMorphTargets() {
    const i = this.geometry.morphAttributes,
      n = Object.keys(i);
    if (n.length > 0) {
      const r = i[n[0]];
      if (r !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let s = 0, a = r.length; s < a; s++) {
          const o = r[s].name || String(s);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[o] = s);
        }
      }
    }
  }
}
const Eg = new A(),
  Tg = new A();
class xl extends bd {
  constructor(e, i) {
    super(e, i), (this.isLineSegments = !0), (this.type = "LineSegments");
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const i = e.attributes.position,
        n = [];
      for (let r = 0, s = i.count; r < s; r += 2)
        Eg.fromBufferAttribute(i, r),
          Tg.fromBufferAttribute(i, r + 1),
          (n[r] = r === 0 ? 0 : n[r - 1]),
          (n[r + 1] = n[r] + Eg.distanceTo(Tg));
      e.setAttribute("lineDistance", new We(n, 1));
    } else
      console.warn(
        "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
      );
    return this;
  }
}
class nA extends Li {
  constructor(e, i, n, r, s, a, o, l, c) {
    super(e, i, n, r, s, a, o, l, c),
      (this.isVideoTexture = !0),
      (this.minFilter = a !== void 0 ? a : Zi),
      (this.magFilter = s !== void 0 ? s : Zi),
      (this.generateMipmaps = !1);
    const d = this;
    function h() {
      (d.needsUpdate = !0), e.requestVideoFrameCallback(h);
    }
    "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(h);
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  update() {
    const e = this.image;
    "requestVideoFrameCallback" in e === !1 &&
      e.readyState >= e.HAVE_CURRENT_DATA &&
      (this.needsUpdate = !0);
  }
}
class fr {
  constructor() {
    (this.type = "Curve"), (this.arcLengthDivisions = 200);
  }
  getPoint() {
    return console.warn("THREE.Curve: .getPoint() not implemented."), null;
  }
  getPointAt(e, i) {
    const n = this.getUtoTmapping(e);
    return this.getPoint(n, i);
  }
  getPoints(e = 5) {
    const i = [];
    for (let n = 0; n <= e; n++) i.push(this.getPoint(n / e));
    return i;
  }
  getSpacedPoints(e = 5) {
    const i = [];
    for (let n = 0; n <= e; n++) i.push(this.getPointAt(n / e));
    return i;
  }
  getLength() {
    const e = this.getLengths();
    return e[e.length - 1];
  }
  getLengths(e = this.arcLengthDivisions) {
    if (
      this.cacheArcLengths &&
      this.cacheArcLengths.length === e + 1 &&
      !this.needsUpdate
    )
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    const i = [];
    let n,
      r = this.getPoint(0),
      s = 0;
    i.push(0);
    for (let a = 1; a <= e; a++)
      (n = this.getPoint(a / e)), (s += n.distanceTo(r)), i.push(s), (r = n);
    return (this.cacheArcLengths = i), i;
  }
  updateArcLengths() {
    (this.needsUpdate = !0), this.getLengths();
  }
  getUtoTmapping(e, i) {
    const n = this.getLengths();
    let r = 0;
    const s = n.length;
    let a;
    i ? (a = i) : (a = e * n[s - 1]);
    let o = 0,
      l = s - 1,
      c;
    for (; o <= l; )
      if (((r = Math.floor(o + (l - o) / 2)), (c = n[r] - a), c < 0)) o = r + 1;
      else if (c > 0) l = r - 1;
      else {
        l = r;
        break;
      }
    if (((r = l), n[r] === a)) return r / (s - 1);
    const d = n[r],
      u = n[r + 1] - d,
      f = (a - d) / u;
    return (r + f) / (s - 1);
  }
  getTangent(e, i) {
    let r = e - 1e-4,
      s = e + 1e-4;
    r < 0 && (r = 0), s > 1 && (s = 1);
    const a = this.getPoint(r),
      o = this.getPoint(s),
      l = i || (a.isVector2 ? new J() : new A());
    return l.copy(o).sub(a).normalize(), l;
  }
  getTangentAt(e, i) {
    const n = this.getUtoTmapping(e);
    return this.getTangent(n, i);
  }
  computeFrenetFrames(e, i) {
    const n = new A(),
      r = [],
      s = [],
      a = [],
      o = new A(),
      l = new ze();
    for (let f = 0; f <= e; f++) {
      const p = f / e;
      r[f] = this.getTangentAt(p, new A());
    }
    (s[0] = new A()), (a[0] = new A());
    let c = Number.MAX_VALUE;
    const d = Math.abs(r[0].x),
      h = Math.abs(r[0].y),
      u = Math.abs(r[0].z);
    d <= c && ((c = d), n.set(1, 0, 0)),
      h <= c && ((c = h), n.set(0, 1, 0)),
      u <= c && n.set(0, 0, 1),
      o.crossVectors(r[0], n).normalize(),
      s[0].crossVectors(r[0], o),
      a[0].crossVectors(r[0], s[0]);
    for (let f = 1; f <= e; f++) {
      if (
        ((s[f] = s[f - 1].clone()),
        (a[f] = a[f - 1].clone()),
        o.crossVectors(r[f - 1], r[f]),
        o.length() > Number.EPSILON)
      ) {
        o.normalize();
        const p = Math.acos(yi(r[f - 1].dot(r[f]), -1, 1));
        s[f].applyMatrix4(l.makeRotationAxis(o, p));
      }
      a[f].crossVectors(r[f], s[f]);
    }
    if (i === !0) {
      let f = Math.acos(yi(s[0].dot(s[e]), -1, 1));
      (f /= e), r[0].dot(o.crossVectors(s[0], s[e])) > 0 && (f = -f);
      for (let p = 1; p <= e; p++)
        s[p].applyMatrix4(l.makeRotationAxis(r[p], f * p)),
          a[p].crossVectors(r[p], s[p]);
    }
    return { tangents: r, normals: s, binormals: a };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return (this.arcLengthDivisions = e.arcLengthDivisions), this;
  }
  toJSON() {
    const e = {
      metadata: { version: 4.6, type: "Curve", generator: "Curve.toJSON" },
    };
    return (
      (e.arcLengthDivisions = this.arcLengthDivisions), (e.type = this.type), e
    );
  }
  fromJSON(e) {
    return (this.arcLengthDivisions = e.arcLengthDivisions), this;
  }
}
class Sh extends fr {
  constructor(
    e = 0,
    i = 0,
    n = 1,
    r = 1,
    s = 0,
    a = Math.PI * 2,
    o = !1,
    l = 0
  ) {
    super(),
      (this.isEllipseCurve = !0),
      (this.type = "EllipseCurve"),
      (this.aX = e),
      (this.aY = i),
      (this.xRadius = n),
      (this.yRadius = r),
      (this.aStartAngle = s),
      (this.aEndAngle = a),
      (this.aClockwise = o),
      (this.aRotation = l);
  }
  getPoint(e, i) {
    const n = i || new J(),
      r = Math.PI * 2;
    let s = this.aEndAngle - this.aStartAngle;
    const a = Math.abs(s) < Number.EPSILON;
    for (; s < 0; ) s += r;
    for (; s > r; ) s -= r;
    s < Number.EPSILON && (a ? (s = 0) : (s = r)),
      this.aClockwise === !0 && !a && (s === r ? (s = -r) : (s = s - r));
    const o = this.aStartAngle + e * s;
    let l = this.aX + this.xRadius * Math.cos(o),
      c = this.aY + this.yRadius * Math.sin(o);
    if (this.aRotation !== 0) {
      const d = Math.cos(this.aRotation),
        h = Math.sin(this.aRotation),
        u = l - this.aX,
        f = c - this.aY;
      (l = u * d - f * h + this.aX), (c = u * h + f * d + this.aY);
    }
    return n.set(l, c);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.aX = e.aX),
      (this.aY = e.aY),
      (this.xRadius = e.xRadius),
      (this.yRadius = e.yRadius),
      (this.aStartAngle = e.aStartAngle),
      (this.aEndAngle = e.aEndAngle),
      (this.aClockwise = e.aClockwise),
      (this.aRotation = e.aRotation),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.aX = this.aX),
      (e.aY = this.aY),
      (e.xRadius = this.xRadius),
      (e.yRadius = this.yRadius),
      (e.aStartAngle = this.aStartAngle),
      (e.aEndAngle = this.aEndAngle),
      (e.aClockwise = this.aClockwise),
      (e.aRotation = this.aRotation),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      (this.aX = e.aX),
      (this.aY = e.aY),
      (this.xRadius = e.xRadius),
      (this.yRadius = e.yRadius),
      (this.aStartAngle = e.aStartAngle),
      (this.aEndAngle = e.aEndAngle),
      (this.aClockwise = e.aClockwise),
      (this.aRotation = e.aRotation),
      this
    );
  }
}
class rA extends Sh {
  constructor(e, i, n, r, s, a) {
    super(e, i, n, n, r, s, a),
      (this.isArcCurve = !0),
      (this.type = "ArcCurve");
  }
}
function Xf() {
  let t = 0,
    e = 0,
    i = 0,
    n = 0;
  function r(s, a, o, l) {
    (t = s),
      (e = o),
      (i = -3 * s + 3 * a - 2 * o - l),
      (n = 2 * s - 2 * a + o + l);
  }
  return {
    initCatmullRom: function (s, a, o, l, c) {
      r(a, o, c * (o - s), c * (l - a));
    },
    initNonuniformCatmullRom: function (s, a, o, l, c, d, h) {
      let u = (a - s) / c - (o - s) / (c + d) + (o - a) / d,
        f = (o - a) / d - (l - a) / (d + h) + (l - o) / h;
      (u *= d), (f *= d), r(a, o, u, f);
    },
    calc: function (s) {
      const a = s * s,
        o = a * s;
      return t + e * s + i * a + n * o;
    },
  };
}
const Jl = new A(),
  Mu = new Xf(),
  Eu = new Xf(),
  Tu = new Xf();
class sA extends fr {
  constructor(e = [], i = !1, n = "centripetal", r = 0.5) {
    super(),
      (this.isCatmullRomCurve3 = !0),
      (this.type = "CatmullRomCurve3"),
      (this.points = e),
      (this.closed = i),
      (this.curveType = n),
      (this.tension = r);
  }
  getPoint(e, i = new A()) {
    const n = i,
      r = this.points,
      s = r.length,
      a = (s - (this.closed ? 0 : 1)) * e;
    let o = Math.floor(a),
      l = a - o;
    this.closed
      ? (o += o > 0 ? 0 : (Math.floor(Math.abs(o) / s) + 1) * s)
      : l === 0 && o === s - 1 && ((o = s - 2), (l = 1));
    let c, d;
    this.closed || o > 0
      ? (c = r[(o - 1) % s])
      : (Jl.subVectors(r[0], r[1]).add(r[0]), (c = Jl));
    const h = r[o % s],
      u = r[(o + 1) % s];
    if (
      (this.closed || o + 2 < s
        ? (d = r[(o + 2) % s])
        : (Jl.subVectors(r[s - 1], r[s - 2]).add(r[s - 1]), (d = Jl)),
      this.curveType === "centripetal" || this.curveType === "chordal")
    ) {
      const f = this.curveType === "chordal" ? 0.5 : 0.25;
      let p = Math.pow(c.distanceToSquared(h), f),
        v = Math.pow(h.distanceToSquared(u), f),
        g = Math.pow(u.distanceToSquared(d), f);
      v < 1e-4 && (v = 1),
        p < 1e-4 && (p = v),
        g < 1e-4 && (g = v),
        Mu.initNonuniformCatmullRom(c.x, h.x, u.x, d.x, p, v, g),
        Eu.initNonuniformCatmullRom(c.y, h.y, u.y, d.y, p, v, g),
        Tu.initNonuniformCatmullRom(c.z, h.z, u.z, d.z, p, v, g);
    } else
      this.curveType === "catmullrom" &&
        (Mu.initCatmullRom(c.x, h.x, u.x, d.x, this.tension),
        Eu.initCatmullRom(c.y, h.y, u.y, d.y, this.tension),
        Tu.initCatmullRom(c.z, h.z, u.z, d.z, this.tension));
    return n.set(Mu.calc(l), Eu.calc(l), Tu.calc(l)), n;
  }
  copy(e) {
    super.copy(e), (this.points = []);
    for (let i = 0, n = e.points.length; i < n; i++) {
      const r = e.points[i];
      this.points.push(r.clone());
    }
    return (
      (this.closed = e.closed),
      (this.curveType = e.curveType),
      (this.tension = e.tension),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let i = 0, n = this.points.length; i < n; i++) {
      const r = this.points[i];
      e.points.push(r.toArray());
    }
    return (
      (e.closed = this.closed),
      (e.curveType = this.curveType),
      (e.tension = this.tension),
      e
    );
  }
  fromJSON(e) {
    super.fromJSON(e), (this.points = []);
    for (let i = 0, n = e.points.length; i < n; i++) {
      const r = e.points[i];
      this.points.push(new A().fromArray(r));
    }
    return (
      (this.closed = e.closed),
      (this.curveType = e.curveType),
      (this.tension = e.tension),
      this
    );
  }
}
function Ag(t, e, i, n, r) {
  const s = (n - e) * 0.5,
    a = (r - i) * 0.5,
    o = t * t,
    l = t * o;
  return (
    (2 * i - 2 * n + s + a) * l + (-3 * i + 3 * n - 2 * s - a) * o + s * t + i
  );
}
function aA(t, e) {
  const i = 1 - t;
  return i * i * e;
}
function oA(t, e) {
  return 2 * (1 - t) * t * e;
}
function lA(t, e) {
  return t * t * e;
}
function $o(t, e, i, n) {
  return aA(t, e) + oA(t, i) + lA(t, n);
}
function cA(t, e) {
  const i = 1 - t;
  return i * i * i * e;
}
function hA(t, e) {
  const i = 1 - t;
  return 3 * i * i * t * e;
}
function uA(t, e) {
  return 3 * (1 - t) * t * t * e;
}
function dA(t, e) {
  return t * t * t * e;
}
function Yo(t, e, i, n, r) {
  return cA(t, e) + hA(t, i) + uA(t, n) + dA(t, r);
}
class kn extends fr {
  constructor(e = new J(), i = new J(), n = new J(), r = new J()) {
    super(),
      (this.isCubicBezierCurve = !0),
      (this.type = "CubicBezierCurve"),
      (this.v0 = e),
      (this.v1 = i),
      (this.v2 = n),
      (this.v3 = r);
  }
  getPoint(e, i = new J()) {
    const n = i,
      r = this.v0,
      s = this.v1,
      a = this.v2,
      o = this.v3;
    return n.set(Yo(e, r.x, s.x, a.x, o.x), Yo(e, r.y, s.y, a.y, o.y)), n;
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this.v3.copy(e.v3),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      (e.v3 = this.v3.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this.v3.fromArray(e.v3),
      this
    );
  }
}
class Dc extends fr {
  constructor(e = new A(), i = new A(), n = new A(), r = new A()) {
    super(),
      (this.isCubicBezierCurve3 = !0),
      (this.type = "CubicBezierCurve3"),
      (this.v0 = e),
      (this.v1 = i),
      (this.v2 = n),
      (this.v3 = r);
  }
  getPoint(e, i = new A()) {
    const n = i,
      r = this.v0,
      s = this.v1,
      a = this.v2,
      o = this.v3;
    return (
      n.set(
        Yo(e, r.x, s.x, a.x, o.x),
        Yo(e, r.y, s.y, a.y, o.y),
        Yo(e, r.z, s.z, a.z, o.z)
      ),
      n
    );
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this.v3.copy(e.v3),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      (e.v3 = this.v3.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this.v3.fromArray(e.v3),
      this
    );
  }
}
class jn extends fr {
  constructor(e = new J(), i = new J()) {
    super(),
      (this.isLineCurve = !0),
      (this.type = "LineCurve"),
      (this.v1 = e),
      (this.v2 = i);
  }
  getPoint(e, i = new J()) {
    const n = i;
    return (
      e === 1
        ? n.copy(this.v2)
        : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)),
      n
    );
  }
  getPointAt(e, i) {
    return this.getPoint(e, i);
  }
  getTangent(e, i = new J()) {
    return i.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, i) {
    return this.getTangent(e, i);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
  }
  fromJSON(e) {
    return (
      super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    );
  }
}
class xx extends fr {
  constructor(e = new A(), i = new A()) {
    super(),
      (this.isLineCurve3 = !0),
      (this.type = "LineCurve3"),
      (this.v1 = e),
      (this.v2 = i);
  }
  getPoint(e, i = new A()) {
    const n = i;
    return (
      e === 1
        ? n.copy(this.v2)
        : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)),
      n
    );
  }
  getPointAt(e, i) {
    return this.getPoint(e, i);
  }
  getTangent(e, i = new A()) {
    return i.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, i) {
    return this.getTangent(e, i);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
  }
  fromJSON(e) {
    return (
      super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    );
  }
}
class fs extends fr {
  constructor(e = new J(), i = new J(), n = new J()) {
    super(),
      (this.isQuadraticBezierCurve = !0),
      (this.type = "QuadraticBezierCurve"),
      (this.v0 = e),
      (this.v1 = i),
      (this.v2 = n);
  }
  getPoint(e, i = new J()) {
    const n = i,
      r = this.v0,
      s = this.v1,
      a = this.v2;
    return n.set($o(e, r.x, s.x, a.x), $o(e, r.y, s.y, a.y)), n;
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this
    );
  }
}
class fA extends fr {
  constructor(e = new A(), i = new A(), n = new A()) {
    super(),
      (this.isQuadraticBezierCurve3 = !0),
      (this.type = "QuadraticBezierCurve3"),
      (this.v0 = e),
      (this.v1 = i),
      (this.v2 = n);
  }
  getPoint(e, i = new A()) {
    const n = i,
      r = this.v0,
      s = this.v1,
      a = this.v2;
    return (
      n.set($o(e, r.x, s.x, a.x), $o(e, r.y, s.y, a.y), $o(e, r.z, s.z, a.z)), n
    );
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this
    );
  }
}
class $f extends fr {
  constructor(e = []) {
    super(),
      (this.isSplineCurve = !0),
      (this.type = "SplineCurve"),
      (this.points = e);
  }
  getPoint(e, i = new J()) {
    const n = i,
      r = this.points,
      s = (r.length - 1) * e,
      a = Math.floor(s),
      o = s - a,
      l = r[a === 0 ? a : a - 1],
      c = r[a],
      d = r[a > r.length - 2 ? r.length - 1 : a + 1],
      h = r[a > r.length - 3 ? r.length - 1 : a + 2];
    return n.set(Ag(o, l.x, c.x, d.x, h.x), Ag(o, l.y, c.y, d.y, h.y)), n;
  }
  copy(e) {
    super.copy(e), (this.points = []);
    for (let i = 0, n = e.points.length; i < n; i++) {
      const r = e.points[i];
      this.points.push(r.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let i = 0, n = this.points.length; i < n; i++) {
      const r = this.points[i];
      e.points.push(r.toArray());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), (this.points = []);
    for (let i = 0, n = e.points.length; i < n; i++) {
      const r = e.points[i];
      this.points.push(new J().fromArray(r));
    }
    return this;
  }
}
var pA = Object.freeze({
  __proto__: null,
  ArcCurve: rA,
  CatmullRomCurve3: sA,
  CubicBezierCurve: kn,
  CubicBezierCurve3: Dc,
  EllipseCurve: Sh,
  LineCurve: jn,
  LineCurve3: xx,
  QuadraticBezierCurve: fs,
  QuadraticBezierCurve3: fA,
  SplineCurve: $f,
});
class _x extends fr {
  constructor() {
    super(),
      (this.type = "CurvePath"),
      (this.curves = []),
      (this.autoClose = !1);
  }
  add(e) {
    this.curves.push(e);
  }
  closePath() {
    const e = this.curves[0].getPoint(0),
      i = this.curves[this.curves.length - 1].getPoint(1);
    e.equals(i) || this.curves.push(new jn(i, e));
  }
  getPoint(e, i) {
    const n = e * this.getLength(),
      r = this.getCurveLengths();
    let s = 0;
    for (; s < r.length; ) {
      if (r[s] >= n) {
        const a = r[s] - n,
          o = this.curves[s],
          l = o.getLength(),
          c = l === 0 ? 0 : 1 - a / l;
        return o.getPointAt(c, i);
      }
      s++;
    }
    return null;
  }
  getLength() {
    const e = this.getCurveLengths();
    return e[e.length - 1];
  }
  updateArcLengths() {
    (this.needsUpdate = !0), (this.cacheLengths = null), this.getCurveLengths();
  }
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths;
    const e = [];
    let i = 0;
    for (let n = 0, r = this.curves.length; n < r; n++)
      (i += this.curves[n].getLength()), e.push(i);
    return (this.cacheLengths = e), e;
  }
  getSpacedPoints(e = 40) {
    const i = [];
    for (let n = 0; n <= e; n++) i.push(this.getPoint(n / e));
    return this.autoClose && i.push(i[0]), i;
  }
  getPoints(e = 12) {
    const i = [];
    let n;
    for (let r = 0, s = this.curves; r < s.length; r++) {
      const a = s[r],
        o = a.isEllipseCurve
          ? e * 2
          : a.isLineCurve || a.isLineCurve3
          ? 1
          : a.isSplineCurve
          ? e * a.points.length
          : e,
        l = a.getPoints(o);
      for (let c = 0; c < l.length; c++) {
        const d = l[c];
        (n && n.equals(d)) || (i.push(d), (n = d));
      }
    }
    return (
      this.autoClose &&
        i.length > 1 &&
        !i[i.length - 1].equals(i[0]) &&
        i.push(i[0]),
      i
    );
  }
  copy(e) {
    super.copy(e), (this.curves = []);
    for (let i = 0, n = e.curves.length; i < n; i++) {
      const r = e.curves[i];
      this.curves.push(r.clone());
    }
    return (this.autoClose = e.autoClose), this;
  }
  toJSON() {
    const e = super.toJSON();
    (e.autoClose = this.autoClose), (e.curves = []);
    for (let i = 0, n = this.curves.length; i < n; i++) {
      const r = this.curves[i];
      e.curves.push(r.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), (this.autoClose = e.autoClose), (this.curves = []);
    for (let i = 0, n = e.curves.length; i < n; i++) {
      const r = e.curves[i];
      this.curves.push(new pA[r.type]().fromJSON(r));
    }
    return this;
  }
}
class Vc extends _x {
  constructor(e) {
    super(),
      (this.type = "Path"),
      (this.currentPoint = new J()),
      e && this.setFromPoints(e);
  }
  setFromPoints(e) {
    this.moveTo(e[0].x, e[0].y);
    for (let i = 1, n = e.length; i < n; i++) this.lineTo(e[i].x, e[i].y);
    return this;
  }
  moveTo(e, i) {
    return this.currentPoint.set(e, i), this;
  }
  lineTo(e, i) {
    const n = new jn(this.currentPoint.clone(), new J(e, i));
    return this.curves.push(n), this.currentPoint.set(e, i), this;
  }
  quadraticCurveTo(e, i, n, r) {
    const s = new fs(this.currentPoint.clone(), new J(e, i), new J(n, r));
    return this.curves.push(s), this.currentPoint.set(n, r), this;
  }
  bezierCurveTo(e, i, n, r, s, a) {
    const o = new kn(
      this.currentPoint.clone(),
      new J(e, i),
      new J(n, r),
      new J(s, a)
    );
    return this.curves.push(o), this.currentPoint.set(s, a), this;
  }
  splineThru(e) {
    const i = [this.currentPoint.clone()].concat(e),
      n = new $f(i);
    return this.curves.push(n), this.currentPoint.copy(e[e.length - 1]), this;
  }
  arc(e, i, n, r, s, a) {
    const o = this.currentPoint.x,
      l = this.currentPoint.y;
    return this.absarc(e + o, i + l, n, r, s, a), this;
  }
  absarc(e, i, n, r, s, a) {
    return this.absellipse(e, i, n, n, r, s, a), this;
  }
  ellipse(e, i, n, r, s, a, o, l) {
    const c = this.currentPoint.x,
      d = this.currentPoint.y;
    return this.absellipse(e + c, i + d, n, r, s, a, o, l), this;
  }
  absellipse(e, i, n, r, s, a, o, l) {
    const c = new Sh(e, i, n, r, s, a, o, l);
    if (this.curves.length > 0) {
      const h = c.getPoint(0);
      h.equals(this.currentPoint) || this.lineTo(h.x, h.y);
    }
    this.curves.push(c);
    const d = c.getPoint(1);
    return this.currentPoint.copy(d), this;
  }
  copy(e) {
    return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (e.currentPoint = this.currentPoint.toArray()), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this;
  }
}
class Yf extends st {
  constructor(
    e = [new J(0, -0.5), new J(0.5, 0), new J(0, 0.5)],
    i = 12,
    n = 0,
    r = Math.PI * 2
  ) {
    super(),
      (this.type = "LatheGeometry"),
      (this.parameters = { points: e, segments: i, phiStart: n, phiLength: r }),
      (i = Math.floor(i)),
      (r = yi(r, 0, Math.PI * 2));
    const s = [],
      a = [],
      o = [],
      l = [],
      c = [],
      d = 1 / i,
      h = new A(),
      u = new J(),
      f = new A(),
      p = new A(),
      v = new A();
    let g = 0,
      m = 0;
    for (let x = 0; x <= e.length - 1; x++)
      switch (x) {
        case 0:
          (g = e[x + 1].x - e[x].x),
            (m = e[x + 1].y - e[x].y),
            (f.x = m * 1),
            (f.y = -g),
            (f.z = m * 0),
            v.copy(f),
            f.normalize(),
            l.push(f.x, f.y, f.z);
          break;
        case e.length - 1:
          l.push(v.x, v.y, v.z);
          break;
        default:
          (g = e[x + 1].x - e[x].x),
            (m = e[x + 1].y - e[x].y),
            (f.x = m * 1),
            (f.y = -g),
            (f.z = m * 0),
            p.copy(f),
            (f.x += v.x),
            (f.y += v.y),
            (f.z += v.z),
            f.normalize(),
            l.push(f.x, f.y, f.z),
            v.copy(p);
      }
    for (let x = 0; x <= i; x++) {
      const y = n + x * d * r,
        _ = Math.sin(y),
        M = Math.cos(y);
      for (let b = 0; b <= e.length - 1; b++) {
        (h.x = e[b].x * _),
          (h.y = e[b].y),
          (h.z = e[b].x * M),
          a.push(h.x, h.y, h.z),
          (u.x = x / i),
          (u.y = b / (e.length - 1)),
          o.push(u.x, u.y);
        const E = l[3 * b + 0] * _,
          T = l[3 * b + 1],
          S = l[3 * b + 0] * M;
        c.push(E, T, S);
      }
    }
    for (let x = 0; x < i; x++)
      for (let y = 0; y < e.length - 1; y++) {
        const _ = y + x * e.length,
          M = _,
          b = _ + e.length,
          E = _ + e.length + 1,
          T = _ + 1;
        s.push(M, b, T), s.push(E, T, b);
      }
    this.setIndex(s),
      this.setAttribute("position", new We(a, 3)),
      this.setAttribute("uv", new We(o, 2)),
      this.setAttribute("normal", new We(c, 3));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Yf(e.points, e.segments, e.phiStart, e.phiLength);
  }
}
class Mh extends st {
  constructor(
    e = 1,
    i = 1,
    n = 1,
    r = 32,
    s = 1,
    a = !1,
    o = 0,
    l = Math.PI * 2
  ) {
    super(),
      (this.type = "CylinderGeometry"),
      (this.parameters = {
        radiusTop: e,
        radiusBottom: i,
        height: n,
        radialSegments: r,
        heightSegments: s,
        openEnded: a,
        thetaStart: o,
        thetaLength: l,
      });
    const c = this;
    (r = Math.floor(r)), (s = Math.floor(s));
    const d = [],
      h = [],
      u = [],
      f = [];
    let p = 0;
    const v = [],
      g = n / 2;
    let m = 0;
    x(),
      a === !1 && (e > 0 && y(!0), i > 0 && y(!1)),
      this.setIndex(d),
      this.setAttribute("position", new We(h, 3)),
      this.setAttribute("normal", new We(u, 3)),
      this.setAttribute("uv", new We(f, 2));
    function x() {
      const _ = new A(),
        M = new A();
      let b = 0;
      const E = (i - e) / n;
      for (let T = 0; T <= s; T++) {
        const S = [],
          w = T / s,
          C = w * (i - e) + e;
        for (let L = 0; L <= r; L++) {
          const P = L / r,
            R = P * l + o,
            I = Math.sin(R),
            W = Math.cos(R);
          (M.x = C * I),
            (M.y = -w * n + g),
            (M.z = C * W),
            h.push(M.x, M.y, M.z),
            _.set(I, E, W).normalize(),
            u.push(_.x, _.y, _.z),
            f.push(P, 1 - w),
            S.push(p++);
        }
        v.push(S);
      }
      for (let T = 0; T < r; T++)
        for (let S = 0; S < s; S++) {
          const w = v[S][T],
            C = v[S + 1][T],
            L = v[S + 1][T + 1],
            P = v[S][T + 1];
          d.push(w, C, P), d.push(C, L, P), (b += 6);
        }
      c.addGroup(m, b, 0), (m += b);
    }
    function y(_) {
      const M = p,
        b = new J(),
        E = new A();
      let T = 0;
      const S = _ === !0 ? e : i,
        w = _ === !0 ? 1 : -1;
      for (let L = 1; L <= r; L++)
        h.push(0, g * w, 0), u.push(0, w, 0), f.push(0.5, 0.5), p++;
      const C = p;
      for (let L = 0; L <= r; L++) {
        const R = (L / r) * l + o,
          I = Math.cos(R),
          W = Math.sin(R);
        (E.x = S * W),
          (E.y = g * w),
          (E.z = S * I),
          h.push(E.x, E.y, E.z),
          u.push(0, w, 0),
          (b.x = I * 0.5 + 0.5),
          (b.y = W * 0.5 * w + 0.5),
          f.push(b.x, b.y),
          p++;
      }
      for (let L = 0; L < r; L++) {
        const P = M + L,
          R = C + L;
        _ === !0 ? d.push(R, R + 1, P) : d.push(R + 1, R, P), (T += 3);
      }
      c.addGroup(m, T, _ === !0 ? 1 : 2), (m += T);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Mh(
      e.radiusTop,
      e.radiusBottom,
      e.height,
      e.radialSegments,
      e.heightSegments,
      e.openEnded,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class Zf extends Mh {
  constructor(e = 1, i = 1, n = 32, r = 1, s = !1, a = 0, o = Math.PI * 2) {
    super(0, e, i, n, r, s, a, o),
      (this.type = "ConeGeometry"),
      (this.parameters = {
        radius: e,
        height: i,
        radialSegments: n,
        heightSegments: r,
        openEnded: s,
        thetaStart: a,
        thetaLength: o,
      });
  }
  static fromJSON(e) {
    return new Zf(
      e.radius,
      e.height,
      e.radialSegments,
      e.heightSegments,
      e.openEnded,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class Eh extends st {
  constructor(e = [], i = [], n = 1, r = 0) {
    super(),
      (this.type = "PolyhedronGeometry"),
      (this.parameters = { vertices: e, indices: i, radius: n, detail: r });
    const s = [],
      a = [];
    o(r),
      c(n),
      d(),
      this.setAttribute("position", new We(s, 3)),
      this.setAttribute("normal", new We(s.slice(), 3)),
      this.setAttribute("uv", new We(a, 2)),
      r === 0 ? this.computeVertexNormals() : this.normalizeNormals();
    function o(x) {
      const y = new A(),
        _ = new A(),
        M = new A();
      for (let b = 0; b < i.length; b += 3)
        f(i[b + 0], y), f(i[b + 1], _), f(i[b + 2], M), l(y, _, M, x);
    }
    function l(x, y, _, M) {
      const b = M + 1,
        E = [];
      for (let T = 0; T <= b; T++) {
        E[T] = [];
        const S = x.clone().lerp(_, T / b),
          w = y.clone().lerp(_, T / b),
          C = b - T;
        for (let L = 0; L <= C; L++)
          L === 0 && T === b
            ? (E[T][L] = S)
            : (E[T][L] = S.clone().lerp(w, L / C));
      }
      for (let T = 0; T < b; T++)
        for (let S = 0; S < 2 * (b - T) - 1; S++) {
          const w = Math.floor(S / 2);
          S % 2 === 0
            ? (u(E[T][w + 1]), u(E[T + 1][w]), u(E[T][w]))
            : (u(E[T][w + 1]), u(E[T + 1][w + 1]), u(E[T + 1][w]));
        }
    }
    function c(x) {
      const y = new A();
      for (let _ = 0; _ < s.length; _ += 3)
        (y.x = s[_ + 0]),
          (y.y = s[_ + 1]),
          (y.z = s[_ + 2]),
          y.normalize().multiplyScalar(x),
          (s[_ + 0] = y.x),
          (s[_ + 1] = y.y),
          (s[_ + 2] = y.z);
    }
    function d() {
      const x = new A();
      for (let y = 0; y < s.length; y += 3) {
        (x.x = s[y + 0]), (x.y = s[y + 1]), (x.z = s[y + 2]);
        const _ = g(x) / 2 / Math.PI + 0.5,
          M = m(x) / Math.PI + 0.5;
        a.push(_, 1 - M);
      }
      p(), h();
    }
    function h() {
      for (let x = 0; x < a.length; x += 6) {
        const y = a[x + 0],
          _ = a[x + 2],
          M = a[x + 4],
          b = Math.max(y, _, M),
          E = Math.min(y, _, M);
        b > 0.9 &&
          E < 0.1 &&
          (y < 0.2 && (a[x + 0] += 1),
          _ < 0.2 && (a[x + 2] += 1),
          M < 0.2 && (a[x + 4] += 1));
      }
    }
    function u(x) {
      s.push(x.x, x.y, x.z);
    }
    function f(x, y) {
      const _ = x * 3;
      (y.x = e[_ + 0]), (y.y = e[_ + 1]), (y.z = e[_ + 2]);
    }
    function p() {
      const x = new A(),
        y = new A(),
        _ = new A(),
        M = new A(),
        b = new J(),
        E = new J(),
        T = new J();
      for (let S = 0, w = 0; S < s.length; S += 9, w += 6) {
        x.set(s[S + 0], s[S + 1], s[S + 2]),
          y.set(s[S + 3], s[S + 4], s[S + 5]),
          _.set(s[S + 6], s[S + 7], s[S + 8]),
          b.set(a[w + 0], a[w + 1]),
          E.set(a[w + 2], a[w + 3]),
          T.set(a[w + 4], a[w + 5]),
          M.copy(x).add(y).add(_).divideScalar(3);
        const C = g(M);
        v(b, w + 0, x, C), v(E, w + 2, y, C), v(T, w + 4, _, C);
      }
    }
    function v(x, y, _, M) {
      M < 0 && x.x === 1 && (a[y] = x.x - 1),
        _.x === 0 && _.z === 0 && (a[y] = M / 2 / Math.PI + 0.5);
    }
    function g(x) {
      return Math.atan2(x.z, -x.x);
    }
    function m(x) {
      return Math.atan2(-x.y, Math.sqrt(x.x * x.x + x.z * x.z));
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Eh(e.vertices, e.indices, e.radius, e.details);
  }
}
class Kf extends Eh {
  constructor(e = 1, i = 0) {
    const n = (1 + Math.sqrt(5)) / 2,
      r = 1 / n,
      s = [
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        1,
        -1,
        -1,
        1,
        1,
        1,
        -1,
        -1,
        1,
        -1,
        1,
        1,
        1,
        -1,
        1,
        1,
        1,
        0,
        -r,
        -n,
        0,
        -r,
        n,
        0,
        r,
        -n,
        0,
        r,
        n,
        -r,
        -n,
        0,
        -r,
        n,
        0,
        r,
        -n,
        0,
        r,
        n,
        0,
        -n,
        0,
        -r,
        n,
        0,
        -r,
        -n,
        0,
        r,
        n,
        0,
        r,
      ],
      a = [
        3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8,
        17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18,
        0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13,
        18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5,
        11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14,
        5, 1, 5, 9,
      ];
    super(s, a, e, i),
      (this.type = "DodecahedronGeometry"),
      (this.parameters = { radius: e, detail: i });
  }
  static fromJSON(e) {
    return new Kf(e.radius, e.detail);
  }
}
class Hc extends Vc {
  constructor(e) {
    super(e), (this.uuid = Gn()), (this.type = "Shape"), (this.holes = []);
  }
  getPointsHoles(e) {
    const i = [];
    for (let n = 0, r = this.holes.length; n < r; n++)
      i[n] = this.holes[n].getPoints(e);
    return i;
  }
  extractPoints(e) {
    return { shape: this.getPoints(e), holes: this.getPointsHoles(e) };
  }
  copy(e) {
    super.copy(e), (this.holes = []);
    for (let i = 0, n = e.holes.length; i < n; i++) {
      const r = e.holes[i];
      this.holes.push(r.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    (e.uuid = this.uuid), (e.holes = []);
    for (let i = 0, n = this.holes.length; i < n; i++) {
      const r = this.holes[i];
      e.holes.push(r.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), (this.uuid = e.uuid), (this.holes = []);
    for (let i = 0, n = e.holes.length; i < n; i++) {
      const r = e.holes[i];
      this.holes.push(new Vc().fromJSON(r));
    }
    return this;
  }
}
const mA = {
  triangulate: function (t, e, i = 2) {
    const n = e && e.length,
      r = n ? e[0] * i : t.length;
    let s = bx(t, 0, r, i, !0);
    const a = [];
    if (!s || s.next === s.prev) return a;
    let o, l, c, d, h, u, f;
    if ((n && (s = _A(t, e, s, i)), t.length > 80 * i)) {
      (o = c = t[0]), (l = d = t[1]);
      for (let p = i; p < r; p += i)
        (h = t[p]),
          (u = t[p + 1]),
          h < o && (o = h),
          u < l && (l = u),
          h > c && (c = h),
          u > d && (d = u);
      (f = Math.max(c - o, d - l)), (f = f !== 0 ? 32767 / f : 0);
    }
    return al(s, a, i, o, l, f, 0), a;
  },
};
function bx(t, e, i, n, r) {
  let s, a;
  if (r === DA(t, e, i, n) > 0)
    for (s = e; s < i; s += n) a = Cg(s, t[s], t[s + 1], a);
  else for (s = i - n; s >= e; s -= n) a = Cg(s, t[s], t[s + 1], a);
  return a && Th(a, a.next) && (ll(a), (a = a.next)), a;
}
function Ws(t, e) {
  if (!t) return t;
  e || (e = t);
  let i = t,
    n;
  do
    if (
      ((n = !1), !i.steiner && (Th(i, i.next) || Kt(i.prev, i, i.next) === 0))
    ) {
      if ((ll(i), (i = e = i.prev), i === i.next)) break;
      n = !0;
    } else i = i.next;
  while (n || i !== e);
  return e;
}
function al(t, e, i, n, r, s, a) {
  if (!t) return;
  !a && s && EA(t, n, r, s);
  let o = t,
    l,
    c;
  for (; t.prev !== t.next; ) {
    if (((l = t.prev), (c = t.next), s ? vA(t, n, r, s) : gA(t))) {
      e.push((l.i / i) | 0),
        e.push((t.i / i) | 0),
        e.push((c.i / i) | 0),
        ll(t),
        (t = c.next),
        (o = c.next);
      continue;
    }
    if (((t = c), t === o)) {
      a
        ? a === 1
          ? ((t = yA(Ws(t), e, i)), al(t, e, i, n, r, s, 2))
          : a === 2 && xA(t, e, i, n, r, s)
        : al(Ws(t), e, i, n, r, s, 1);
      break;
    }
  }
}
function gA(t) {
  const e = t.prev,
    i = t,
    n = t.next;
  if (Kt(e, i, n) >= 0) return !1;
  const r = e.x,
    s = i.x,
    a = n.x,
    o = e.y,
    l = i.y,
    c = n.y,
    d = r < s ? (r < a ? r : a) : s < a ? s : a,
    h = o < l ? (o < c ? o : c) : l < c ? l : c,
    u = r > s ? (r > a ? r : a) : s > a ? s : a,
    f = o > l ? (o > c ? o : c) : l > c ? l : c;
  let p = n.next;
  for (; p !== e; ) {
    if (
      p.x >= d &&
      p.x <= u &&
      p.y >= h &&
      p.y <= f &&
      Ra(r, o, s, l, a, c, p.x, p.y) &&
      Kt(p.prev, p, p.next) >= 0
    )
      return !1;
    p = p.next;
  }
  return !0;
}
function vA(t, e, i, n) {
  const r = t.prev,
    s = t,
    a = t.next;
  if (Kt(r, s, a) >= 0) return !1;
  const o = r.x,
    l = s.x,
    c = a.x,
    d = r.y,
    h = s.y,
    u = a.y,
    f = o < l ? (o < c ? o : c) : l < c ? l : c,
    p = d < h ? (d < u ? d : u) : h < u ? h : u,
    v = o > l ? (o > c ? o : c) : l > c ? l : c,
    g = d > h ? (d > u ? d : u) : h > u ? h : u,
    m = wd(f, p, e, i, n),
    x = wd(v, g, e, i, n);
  let y = t.prevZ,
    _ = t.nextZ;
  for (; y && y.z >= m && _ && _.z <= x; ) {
    if (
      (y.x >= f &&
        y.x <= v &&
        y.y >= p &&
        y.y <= g &&
        y !== r &&
        y !== a &&
        Ra(o, d, l, h, c, u, y.x, y.y) &&
        Kt(y.prev, y, y.next) >= 0) ||
      ((y = y.prevZ),
      _.x >= f &&
        _.x <= v &&
        _.y >= p &&
        _.y <= g &&
        _ !== r &&
        _ !== a &&
        Ra(o, d, l, h, c, u, _.x, _.y) &&
        Kt(_.prev, _, _.next) >= 0)
    )
      return !1;
    _ = _.nextZ;
  }
  for (; y && y.z >= m; ) {
    if (
      y.x >= f &&
      y.x <= v &&
      y.y >= p &&
      y.y <= g &&
      y !== r &&
      y !== a &&
      Ra(o, d, l, h, c, u, y.x, y.y) &&
      Kt(y.prev, y, y.next) >= 0
    )
      return !1;
    y = y.prevZ;
  }
  for (; _ && _.z <= x; ) {
    if (
      _.x >= f &&
      _.x <= v &&
      _.y >= p &&
      _.y <= g &&
      _ !== r &&
      _ !== a &&
      Ra(o, d, l, h, c, u, _.x, _.y) &&
      Kt(_.prev, _, _.next) >= 0
    )
      return !1;
    _ = _.nextZ;
  }
  return !0;
}
function yA(t, e, i) {
  let n = t;
  do {
    const r = n.prev,
      s = n.next.next;
    !Th(r, s) &&
      wx(r, n, n.next, s) &&
      ol(r, s) &&
      ol(s, r) &&
      (e.push((r.i / i) | 0),
      e.push((n.i / i) | 0),
      e.push((s.i / i) | 0),
      ll(n),
      ll(n.next),
      (n = t = s)),
      (n = n.next);
  } while (n !== t);
  return Ws(n);
}
function xA(t, e, i, n, r, s) {
  let a = t;
  do {
    let o = a.next.next;
    for (; o !== a.prev; ) {
      if (a.i !== o.i && CA(a, o)) {
        let l = Sx(a, o);
        (a = Ws(a, a.next)),
          (l = Ws(l, l.next)),
          al(a, e, i, n, r, s, 0),
          al(l, e, i, n, r, s, 0);
        return;
      }
      o = o.next;
    }
    a = a.next;
  } while (a !== t);
}
function _A(t, e, i, n) {
  const r = [];
  let s, a, o, l, c;
  for (s = 0, a = e.length; s < a; s++)
    (o = e[s] * n),
      (l = s < a - 1 ? e[s + 1] * n : t.length),
      (c = bx(t, o, l, n, !1)),
      c === c.next && (c.steiner = !0),
      r.push(AA(c));
  for (r.sort(bA), s = 0; s < r.length; s++) i = wA(r[s], i);
  return i;
}
function bA(t, e) {
  return t.x - e.x;
}
function wA(t, e) {
  const i = SA(t, e);
  if (!i) return e;
  const n = Sx(i, t);
  return Ws(n, n.next), Ws(i, i.next);
}
function SA(t, e) {
  let i = e,
    n = -1 / 0,
    r;
  const s = t.x,
    a = t.y;
  do {
    if (a <= i.y && a >= i.next.y && i.next.y !== i.y) {
      const u = i.x + ((a - i.y) * (i.next.x - i.x)) / (i.next.y - i.y);
      if (
        u <= s &&
        u > n &&
        ((n = u), (r = i.x < i.next.x ? i : i.next), u === s)
      )
        return r;
    }
    i = i.next;
  } while (i !== e);
  if (!r) return null;
  const o = r,
    l = r.x,
    c = r.y;
  let d = 1 / 0,
    h;
  i = r;
  do
    s >= i.x &&
      i.x >= l &&
      s !== i.x &&
      Ra(a < c ? s : n, a, l, c, a < c ? n : s, a, i.x, i.y) &&
      ((h = Math.abs(a - i.y) / (s - i.x)),
      ol(i, t) &&
        (h < d || (h === d && (i.x > r.x || (i.x === r.x && MA(r, i))))) &&
        ((r = i), (d = h))),
      (i = i.next);
  while (i !== o);
  return r;
}
function MA(t, e) {
  return Kt(t.prev, t, e.prev) < 0 && Kt(e.next, t, t.next) < 0;
}
function EA(t, e, i, n) {
  let r = t;
  do
    r.z === 0 && (r.z = wd(r.x, r.y, e, i, n)),
      (r.prevZ = r.prev),
      (r.nextZ = r.next),
      (r = r.next);
  while (r !== t);
  (r.prevZ.nextZ = null), (r.prevZ = null), TA(r);
}
function TA(t) {
  let e,
    i,
    n,
    r,
    s,
    a,
    o,
    l,
    c = 1;
  do {
    for (i = t, t = null, s = null, a = 0; i; ) {
      for (a++, n = i, o = 0, e = 0; e < c && (o++, (n = n.nextZ), !!n); e++);
      for (l = c; o > 0 || (l > 0 && n); )
        o !== 0 && (l === 0 || !n || i.z <= n.z)
          ? ((r = i), (i = i.nextZ), o--)
          : ((r = n), (n = n.nextZ), l--),
          s ? (s.nextZ = r) : (t = r),
          (r.prevZ = s),
          (s = r);
      i = n;
    }
    (s.nextZ = null), (c *= 2);
  } while (a > 1);
  return t;
}
function wd(t, e, i, n, r) {
  return (
    (t = ((t - i) * r) | 0),
    (e = ((e - n) * r) | 0),
    (t = (t | (t << 8)) & 16711935),
    (t = (t | (t << 4)) & 252645135),
    (t = (t | (t << 2)) & 858993459),
    (t = (t | (t << 1)) & 1431655765),
    (e = (e | (e << 8)) & 16711935),
    (e = (e | (e << 4)) & 252645135),
    (e = (e | (e << 2)) & 858993459),
    (e = (e | (e << 1)) & 1431655765),
    t | (e << 1)
  );
}
function AA(t) {
  let e = t,
    i = t;
  do (e.x < i.x || (e.x === i.x && e.y < i.y)) && (i = e), (e = e.next);
  while (e !== t);
  return i;
}
function Ra(t, e, i, n, r, s, a, o) {
  return (
    (r - a) * (e - o) >= (t - a) * (s - o) &&
    (t - a) * (n - o) >= (i - a) * (e - o) &&
    (i - a) * (s - o) >= (r - a) * (n - o)
  );
}
function CA(t, e) {
  return (
    t.next.i !== e.i &&
    t.prev.i !== e.i &&
    !PA(t, e) &&
    ((ol(t, e) &&
      ol(e, t) &&
      LA(t, e) &&
      (Kt(t.prev, t, e.prev) || Kt(t, e.prev, e))) ||
      (Th(t, e) && Kt(t.prev, t, t.next) > 0 && Kt(e.prev, e, e.next) > 0))
  );
}
function Kt(t, e, i) {
  return (e.y - t.y) * (i.x - e.x) - (e.x - t.x) * (i.y - e.y);
}
function Th(t, e) {
  return t.x === e.x && t.y === e.y;
}
function wx(t, e, i, n) {
  const r = ec(Kt(t, e, i)),
    s = ec(Kt(t, e, n)),
    a = ec(Kt(i, n, t)),
    o = ec(Kt(i, n, e));
  return !!(
    (r !== s && a !== o) ||
    (r === 0 && Ql(t, i, e)) ||
    (s === 0 && Ql(t, n, e)) ||
    (a === 0 && Ql(i, t, n)) ||
    (o === 0 && Ql(i, e, n))
  );
}
function Ql(t, e, i) {
  return (
    e.x <= Math.max(t.x, i.x) &&
    e.x >= Math.min(t.x, i.x) &&
    e.y <= Math.max(t.y, i.y) &&
    e.y >= Math.min(t.y, i.y)
  );
}
function ec(t) {
  return t > 0 ? 1 : t < 0 ? -1 : 0;
}
function PA(t, e) {
  let i = t;
  do {
    if (
      i.i !== t.i &&
      i.next.i !== t.i &&
      i.i !== e.i &&
      i.next.i !== e.i &&
      wx(i, i.next, t, e)
    )
      return !0;
    i = i.next;
  } while (i !== t);
  return !1;
}
function ol(t, e) {
  return Kt(t.prev, t, t.next) < 0
    ? Kt(t, e, t.next) >= 0 && Kt(t, t.prev, e) >= 0
    : Kt(t, e, t.prev) < 0 || Kt(t, t.next, e) < 0;
}
function LA(t, e) {
  let i = t,
    n = !1;
  const r = (t.x + e.x) / 2,
    s = (t.y + e.y) / 2;
  do
    i.y > s != i.next.y > s &&
      i.next.y !== i.y &&
      r < ((i.next.x - i.x) * (s - i.y)) / (i.next.y - i.y) + i.x &&
      (n = !n),
      (i = i.next);
  while (i !== t);
  return n;
}
function Sx(t, e) {
  const i = new Sd(t.i, t.x, t.y),
    n = new Sd(e.i, e.x, e.y),
    r = t.next,
    s = e.prev;
  return (
    (t.next = e),
    (e.prev = t),
    (i.next = r),
    (r.prev = i),
    (n.next = i),
    (i.prev = n),
    (s.next = n),
    (n.prev = s),
    n
  );
}
function Cg(t, e, i, n) {
  const r = new Sd(t, e, i);
  return (
    n
      ? ((r.next = n.next), (r.prev = n), (n.next.prev = r), (n.next = r))
      : ((r.prev = r), (r.next = r)),
    r
  );
}
function ll(t) {
  (t.next.prev = t.prev),
    (t.prev.next = t.next),
    t.prevZ && (t.prevZ.nextZ = t.nextZ),
    t.nextZ && (t.nextZ.prevZ = t.prevZ);
}
function Sd(t, e, i) {
  (this.i = t),
    (this.x = e),
    (this.y = i),
    (this.prev = null),
    (this.next = null),
    (this.z = 0),
    (this.prevZ = null),
    (this.nextZ = null),
    (this.steiner = !1);
}
function DA(t, e, i, n) {
  let r = 0;
  for (let s = e, a = i - n; s < i; s += n)
    (r += (t[a] - t[s]) * (t[s + 1] + t[a + 1])), (a = s);
  return r;
}
class Jf {
  static area(e) {
    const i = e.length;
    let n = 0;
    for (let r = i - 1, s = 0; s < i; r = s++)
      n += e[r].x * e[s].y - e[s].x * e[r].y;
    return n * 0.5;
  }
  static isClockWise(e) {
    return Jf.area(e) < 0;
  }
  static triangulateShape(e, i) {
    const n = [],
      r = [],
      s = [];
    Pg(e), Lg(n, e);
    let a = e.length;
    i.forEach(Pg);
    for (let l = 0; l < i.length; l++)
      r.push(a), (a += i[l].length), Lg(n, i[l]);
    const o = mA.triangulate(n, r);
    for (let l = 0; l < o.length; l += 3) s.push(o.slice(l, l + 3));
    return s;
  }
}
function Pg(t) {
  const e = t.length;
  e > 2 && t[e - 1].equals(t[0]) && t.pop();
}
function Lg(t, e) {
  for (let i = 0; i < e.length; i++) t.push(e[i].x), t.push(e[i].y);
}
class Qf extends Eh {
  constructor(e = 1, i = 0) {
    const n = (1 + Math.sqrt(5)) / 2,
      r = [
        -1,
        n,
        0,
        1,
        n,
        0,
        -1,
        -n,
        0,
        1,
        -n,
        0,
        0,
        -1,
        n,
        0,
        1,
        n,
        0,
        -1,
        -n,
        0,
        1,
        -n,
        n,
        0,
        -1,
        n,
        0,
        1,
        -n,
        0,
        -1,
        -n,
        0,
        1,
      ],
      s = [
        0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11,
        10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9,
        4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1,
      ];
    super(r, s, e, i),
      (this.type = "IcosahedronGeometry"),
      (this.parameters = { radius: e, detail: i });
  }
  static fromJSON(e) {
    return new Qf(e.radius, e.detail);
  }
}
class Ah extends st {
  constructor(
    e = 1,
    i = 32,
    n = 16,
    r = 0,
    s = Math.PI * 2,
    a = 0,
    o = Math.PI
  ) {
    super(),
      (this.type = "SphereGeometry"),
      (this.parameters = {
        radius: e,
        widthSegments: i,
        heightSegments: n,
        phiStart: r,
        phiLength: s,
        thetaStart: a,
        thetaLength: o,
      }),
      (i = Math.max(3, Math.floor(i))),
      (n = Math.max(2, Math.floor(n)));
    const l = Math.min(a + o, Math.PI);
    let c = 0;
    const d = [],
      h = new A(),
      u = new A(),
      f = [],
      p = [],
      v = [],
      g = [];
    for (let m = 0; m <= n; m++) {
      const x = [],
        y = m / n;
      let _ = 0;
      m === 0 && a === 0
        ? (_ = 0.5 / i)
        : m === n && l === Math.PI && (_ = -0.5 / i);
      for (let M = 0; M <= i; M++) {
        const b = M / i;
        (h.x = -e * Math.cos(r + b * s) * Math.sin(a + y * o)),
          (h.y = e * Math.cos(a + y * o)),
          (h.z = e * Math.sin(r + b * s) * Math.sin(a + y * o)),
          p.push(h.x, h.y, h.z),
          u.copy(h).normalize(),
          v.push(u.x, u.y, u.z),
          g.push(b + _, 1 - y),
          x.push(c++);
      }
      d.push(x);
    }
    for (let m = 0; m < n; m++)
      for (let x = 0; x < i; x++) {
        const y = d[m][x + 1],
          _ = d[m][x],
          M = d[m + 1][x],
          b = d[m + 1][x + 1];
        (m !== 0 || a > 0) && f.push(y, _, b),
          (m !== n - 1 || l < Math.PI) && f.push(_, M, b);
      }
    this.setIndex(f),
      this.setAttribute("position", new We(p, 3)),
      this.setAttribute("normal", new We(v, 3)),
      this.setAttribute("uv", new We(g, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Ah(
      e.radius,
      e.widthSegments,
      e.heightSegments,
      e.phiStart,
      e.phiLength,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class ep extends st {
  constructor(e = 1, i = 0.4, n = 64, r = 8, s = 2, a = 3) {
    super(),
      (this.type = "TorusKnotGeometry"),
      (this.parameters = {
        radius: e,
        tube: i,
        tubularSegments: n,
        radialSegments: r,
        p: s,
        q: a,
      }),
      (n = Math.floor(n)),
      (r = Math.floor(r));
    const o = [],
      l = [],
      c = [],
      d = [],
      h = new A(),
      u = new A(),
      f = new A(),
      p = new A(),
      v = new A(),
      g = new A(),
      m = new A();
    for (let y = 0; y <= n; ++y) {
      const _ = (y / n) * s * Math.PI * 2;
      x(_, s, a, e, f),
        x(_ + 0.01, s, a, e, p),
        g.subVectors(p, f),
        m.addVectors(p, f),
        v.crossVectors(g, m),
        m.crossVectors(v, g),
        v.normalize(),
        m.normalize();
      for (let M = 0; M <= r; ++M) {
        const b = (M / r) * Math.PI * 2,
          E = -i * Math.cos(b),
          T = i * Math.sin(b);
        (h.x = f.x + (E * m.x + T * v.x)),
          (h.y = f.y + (E * m.y + T * v.y)),
          (h.z = f.z + (E * m.z + T * v.z)),
          l.push(h.x, h.y, h.z),
          u.subVectors(h, f).normalize(),
          c.push(u.x, u.y, u.z),
          d.push(y / n),
          d.push(M / r);
      }
    }
    for (let y = 1; y <= n; y++)
      for (let _ = 1; _ <= r; _++) {
        const M = (r + 1) * (y - 1) + (_ - 1),
          b = (r + 1) * y + (_ - 1),
          E = (r + 1) * y + _,
          T = (r + 1) * (y - 1) + _;
        o.push(M, b, T), o.push(b, E, T);
      }
    this.setIndex(o),
      this.setAttribute("position", new We(l, 3)),
      this.setAttribute("normal", new We(c, 3)),
      this.setAttribute("uv", new We(d, 2));
    function x(y, _, M, b, E) {
      const T = Math.cos(y),
        S = Math.sin(y),
        w = (M / _) * y,
        C = Math.cos(w);
      (E.x = b * (2 + C) * 0.5 * T),
        (E.y = b * (2 + C) * S * 0.5),
        (E.z = b * Math.sin(w) * 0.5);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new ep(
      e.radius,
      e.tube,
      e.tubularSegments,
      e.radialSegments,
      e.p,
      e.q
    );
  }
}
class RA extends lo {
  constructor(e) {
    super(),
      (this.isMeshNormalMaterial = !0),
      (this.type = "MeshNormalMaterial"),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = ex),
      (this.normalScale = new J(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.flatShading = !1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.flatShading = e.flatShading),
      this
    );
  }
}
const Dg = {
  enabled: !1,
  files: {},
  add: function (t, e) {
    this.enabled !== !1 && (this.files[t] = e);
  },
  get: function (t) {
    if (this.enabled !== !1) return this.files[t];
  },
  remove: function (t) {
    delete this.files[t];
  },
  clear: function () {
    this.files = {};
  },
};
class Mx {
  constructor(e, i, n) {
    const r = this;
    let s = !1,
      a = 0,
      o = 0,
      l;
    const c = [];
    (this.onStart = void 0),
      (this.onLoad = e),
      (this.onProgress = i),
      (this.onError = n),
      (this.itemStart = function (d) {
        o++, s === !1 && r.onStart !== void 0 && r.onStart(d, a, o), (s = !0);
      }),
      (this.itemEnd = function (d) {
        a++,
          r.onProgress !== void 0 && r.onProgress(d, a, o),
          a === o && ((s = !1), r.onLoad !== void 0 && r.onLoad());
      }),
      (this.itemError = function (d) {
        r.onError !== void 0 && r.onError(d);
      }),
      (this.resolveURL = function (d) {
        return l ? l(d) : d;
      }),
      (this.setURLModifier = function (d) {
        return (l = d), this;
      }),
      (this.addHandler = function (d, h) {
        return c.push(d, h), this;
      }),
      (this.removeHandler = function (d) {
        const h = c.indexOf(d);
        return h !== -1 && c.splice(h, 2), this;
      }),
      (this.getHandler = function (d) {
        for (let h = 0, u = c.length; h < u; h += 2) {
          const f = c[h],
            p = c[h + 1];
          if ((f.global && (f.lastIndex = 0), f.test(d))) return p;
        }
        return null;
      });
  }
}
const OA = new Mx();
class _l {
  constructor(e) {
    (this.manager = e !== void 0 ? e : OA),
      (this.crossOrigin = "anonymous"),
      (this.withCredentials = !1),
      (this.path = ""),
      (this.resourcePath = ""),
      (this.requestHeader = {});
  }
  load() {}
  loadAsync(e, i) {
    const n = this;
    return new Promise(function (r, s) {
      n.load(e, r, i, s);
    });
  }
  parse() {}
  setCrossOrigin(e) {
    return (this.crossOrigin = e), this;
  }
  setWithCredentials(e) {
    return (this.withCredentials = e), this;
  }
  setPath(e) {
    return (this.path = e), this;
  }
  setResourcePath(e) {
    return (this.resourcePath = e), this;
  }
  setRequestHeader(e) {
    return (this.requestHeader = e), this;
  }
}
_l.DEFAULT_MATERIAL_NAME = "__DEFAULT";
const wr = {};
class IA extends Error {
  constructor(e, i) {
    super(e), (this.response = i);
  }
}
class Gc extends _l {
  constructor(e) {
    super(e);
  }
  load(e, i, n, r) {
    e === void 0 && (e = ""),
      this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const s = Dg.get(e);
    if (s !== void 0)
      return (
        this.manager.itemStart(e),
        setTimeout(() => {
          i && i(s), this.manager.itemEnd(e);
        }, 0),
        s
      );
    if (wr[e] !== void 0) {
      wr[e].push({ onLoad: i, onProgress: n, onError: r });
      return;
    }
    (wr[e] = []), wr[e].push({ onLoad: i, onProgress: n, onError: r });
    const a = new Request(e, {
        headers: new Headers(this.requestHeader),
        credentials: this.withCredentials ? "include" : "same-origin",
      }),
      o = this.mimeType,
      l = this.responseType;
    fetch(a)
      .then((c) => {
        if (c.status === 200 || c.status === 0) {
          if (
            (c.status === 0 &&
              console.warn("THREE.FileLoader: HTTP Status 0 received."),
            typeof ReadableStream > "u" ||
              c.body === void 0 ||
              c.body.getReader === void 0)
          )
            return c;
          const d = wr[e],
            h = c.body.getReader(),
            u = c.headers.get("Content-Length") || c.headers.get("X-File-Size"),
            f = u ? parseInt(u) : 0,
            p = f !== 0;
          let v = 0;
          const g = new ReadableStream({
            start(m) {
              x();
              function x() {
                h.read().then(({ done: y, value: _ }) => {
                  if (y) m.close();
                  else {
                    v += _.byteLength;
                    const M = new ProgressEvent("progress", {
                      lengthComputable: p,
                      loaded: v,
                      total: f,
                    });
                    for (let b = 0, E = d.length; b < E; b++) {
                      const T = d[b];
                      T.onProgress && T.onProgress(M);
                    }
                    m.enqueue(_), x();
                  }
                });
              }
            },
          });
          return new Response(g);
        } else
          throw new IA(
            `fetch for "${c.url}" responded with ${c.status}: ${c.statusText}`,
            c
          );
      })
      .then((c) => {
        switch (l) {
          case "arraybuffer":
            return c.arrayBuffer();
          case "blob":
            return c.blob();
          case "document":
            return c.text().then((d) => new DOMParser().parseFromString(d, o));
          case "json":
            return c.json();
          default:
            if (o === void 0) return c.text();
            {
              const h = /charset="?([^;"\s]*)"?/i.exec(o),
                u = h && h[1] ? h[1].toLowerCase() : void 0,
                f = new TextDecoder(u);
              return c.arrayBuffer().then((p) => f.decode(p));
            }
        }
      })
      .then((c) => {
        Dg.add(e, c);
        const d = wr[e];
        delete wr[e];
        for (let h = 0, u = d.length; h < u; h++) {
          const f = d[h];
          f.onLoad && f.onLoad(c);
        }
      })
      .catch((c) => {
        const d = wr[e];
        if (d === void 0) throw (this.manager.itemError(e), c);
        delete wr[e];
        for (let h = 0, u = d.length; h < u; h++) {
          const f = d[h];
          f.onError && f.onError(c);
        }
        this.manager.itemError(e);
      })
      .finally(() => {
        this.manager.itemEnd(e);
      }),
      this.manager.itemStart(e);
  }
  setResponseType(e) {
    return (this.responseType = e), this;
  }
  setMimeType(e) {
    return (this.mimeType = e), this;
  }
}
class bl extends Ht {
  constructor(e, i = 1) {
    super(),
      (this.isLight = !0),
      (this.type = "Light"),
      (this.color = new tt(e)),
      (this.intensity = i);
  }
  dispose() {}
  copy(e, i) {
    return (
      super.copy(e, i),
      this.color.copy(e.color),
      (this.intensity = e.intensity),
      this
    );
  }
  toJSON(e) {
    const i = super.toJSON(e);
    return (
      (i.object.color = this.color.getHex()),
      (i.object.intensity = this.intensity),
      this.groundColor !== void 0 &&
        (i.object.groundColor = this.groundColor.getHex()),
      this.distance !== void 0 && (i.object.distance = this.distance),
      this.angle !== void 0 && (i.object.angle = this.angle),
      this.decay !== void 0 && (i.object.decay = this.decay),
      this.penumbra !== void 0 && (i.object.penumbra = this.penumbra),
      this.shadow !== void 0 && (i.object.shadow = this.shadow.toJSON()),
      i
    );
  }
}
class UA extends bl {
  constructor(e, i, n) {
    super(e, n),
      (this.isHemisphereLight = !0),
      (this.type = "HemisphereLight"),
      this.position.copy(Ht.DEFAULT_UP),
      this.updateMatrix(),
      (this.groundColor = new tt(i));
  }
  copy(e, i) {
    return super.copy(e, i), this.groundColor.copy(e.groundColor), this;
  }
}
const Au = new ze(),
  Rg = new A(),
  Og = new A();
class tp {
  constructor(e) {
    (this.camera = e),
      (this.bias = 0),
      (this.normalBias = 0),
      (this.radius = 1),
      (this.blurSamples = 8),
      (this.mapSize = new J(512, 512)),
      (this.map = null),
      (this.mapPass = null),
      (this.matrix = new ze()),
      (this.autoUpdate = !0),
      (this.needsUpdate = !1),
      (this._frustum = new Gf()),
      (this._frameExtents = new J(1, 1)),
      (this._viewportCount = 1),
      (this._viewports = [new yt(0, 0, 1, 1)]);
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(e) {
    const i = this.camera,
      n = this.matrix;
    Rg.setFromMatrixPosition(e.matrixWorld),
      i.position.copy(Rg),
      Og.setFromMatrixPosition(e.target.matrixWorld),
      i.lookAt(Og),
      i.updateMatrixWorld(),
      Au.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(Au),
      n.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
      n.multiply(Au);
  }
  getViewport(e) {
    return this._viewports[e];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(e) {
    return (
      (this.camera = e.camera.clone()),
      (this.bias = e.bias),
      (this.radius = e.radius),
      this.mapSize.copy(e.mapSize),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = {};
    return (
      this.bias !== 0 && (e.bias = this.bias),
      this.normalBias !== 0 && (e.normalBias = this.normalBias),
      this.radius !== 1 && (e.radius = this.radius),
      (this.mapSize.x !== 512 || this.mapSize.y !== 512) &&
        (e.mapSize = this.mapSize.toArray()),
      (e.camera = this.camera.toJSON(!1).object),
      delete e.camera.matrix,
      e
    );
  }
}
class NA extends tp {
  constructor() {
    super(new ji(50, 1, 0.5, 500)),
      (this.isSpotLightShadow = !0),
      (this.focus = 1);
  }
  updateMatrices(e) {
    const i = this.camera,
      n = $a * 2 * e.angle * this.focus,
      r = this.mapSize.width / this.mapSize.height,
      s = e.distance || i.far;
    (n !== i.fov || r !== i.aspect || s !== i.far) &&
      ((i.fov = n), (i.aspect = r), (i.far = s), i.updateProjectionMatrix()),
      super.updateMatrices(e);
  }
  copy(e) {
    return super.copy(e), (this.focus = e.focus), this;
  }
}
class zA extends bl {
  constructor(e, i, n = 0, r = Math.PI / 3, s = 0, a = 2) {
    super(e, i),
      (this.isSpotLight = !0),
      (this.type = "SpotLight"),
      this.position.copy(Ht.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new Ht()),
      (this.distance = n),
      (this.angle = r),
      (this.penumbra = s),
      (this.decay = a),
      (this.map = null),
      (this.shadow = new NA());
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, i) {
    return (
      super.copy(e, i),
      (this.distance = e.distance),
      (this.angle = e.angle),
      (this.penumbra = e.penumbra),
      (this.decay = e.decay),
      (this.target = e.target.clone()),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
const Ig = new ze(),
  To = new A(),
  Cu = new A();
class BA extends tp {
  constructor() {
    super(new ji(90, 1, 0.5, 500)),
      (this.isPointLightShadow = !0),
      (this._frameExtents = new J(4, 2)),
      (this._viewportCount = 6),
      (this._viewports = [
        new yt(2, 1, 1, 1),
        new yt(0, 1, 1, 1),
        new yt(3, 1, 1, 1),
        new yt(1, 1, 1, 1),
        new yt(3, 0, 1, 1),
        new yt(1, 0, 1, 1),
      ]),
      (this._cubeDirections = [
        new A(1, 0, 0),
        new A(-1, 0, 0),
        new A(0, 0, 1),
        new A(0, 0, -1),
        new A(0, 1, 0),
        new A(0, -1, 0),
      ]),
      (this._cubeUps = [
        new A(0, 1, 0),
        new A(0, 1, 0),
        new A(0, 1, 0),
        new A(0, 1, 0),
        new A(0, 0, 1),
        new A(0, 0, -1),
      ]);
  }
  updateMatrices(e, i = 0) {
    const n = this.camera,
      r = this.matrix,
      s = e.distance || n.far;
    s !== n.far && ((n.far = s), n.updateProjectionMatrix()),
      To.setFromMatrixPosition(e.matrixWorld),
      n.position.copy(To),
      Cu.copy(n.position),
      Cu.add(this._cubeDirections[i]),
      n.up.copy(this._cubeUps[i]),
      n.lookAt(Cu),
      n.updateMatrixWorld(),
      r.makeTranslation(-To.x, -To.y, -To.z),
      Ig.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(Ig);
  }
}
class Ex extends bl {
  constructor(e, i, n = 0, r = 2) {
    super(e, i),
      (this.isPointLight = !0),
      (this.type = "PointLight"),
      (this.distance = n),
      (this.decay = r),
      (this.shadow = new BA());
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, i) {
    return (
      super.copy(e, i),
      (this.distance = e.distance),
      (this.decay = e.decay),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
class FA extends tp {
  constructor() {
    super(new _h(-5, 5, 5, -5, 0.5, 500)), (this.isDirectionalLightShadow = !0);
  }
}
class kA extends bl {
  constructor(e, i) {
    super(e, i),
      (this.isDirectionalLight = !0),
      (this.type = "DirectionalLight"),
      this.position.copy(Ht.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new Ht()),
      (this.shadow = new FA());
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return (
      super.copy(e),
      (this.target = e.target.clone()),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
class VA extends st {
  constructor() {
    super(),
      (this.isInstancedBufferGeometry = !0),
      (this.type = "InstancedBufferGeometry"),
      (this.instanceCount = 1 / 0);
  }
  copy(e) {
    return super.copy(e), (this.instanceCount = e.instanceCount), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.instanceCount = this.instanceCount),
      (e.isInstancedBufferGeometry = !0),
      e
    );
  }
}
class Tx extends _l {
  constructor(e) {
    super(e);
  }
  load(e, i, n, r) {
    const s = this,
      a = new Gc(s.manager);
    a.setPath(s.path),
      a.setRequestHeader(s.requestHeader),
      a.setWithCredentials(s.withCredentials),
      a.load(
        e,
        function (o) {
          try {
            i(s.parse(JSON.parse(o)));
          } catch (l) {
            r ? r(l) : console.error(l), s.manager.itemError(e);
          }
        },
        n,
        r
      );
  }
  parse(e) {
    const i = {},
      n = {};
    function r(f, p) {
      if (i[p] !== void 0) return i[p];
      const g = f.interleavedBuffers[p],
        m = s(f, g.buffer),
        x = Ll(g.type, m),
        y = new eA(x, g.stride);
      return (y.uuid = g.uuid), (i[p] = y), y;
    }
    function s(f, p) {
      if (n[p] !== void 0) return n[p];
      const g = f.arrayBuffers[p],
        m = new Uint32Array(g).buffer;
      return (n[p] = m), m;
    }
    const a = e.isInstancedBufferGeometry ? new VA() : new st(),
      o = e.data.index;
    if (o !== void 0) {
      const f = Ll(o.type, o.array);
      a.setIndex(new pt(f, 1));
    }
    const l = e.data.attributes;
    for (const f in l) {
      const p = l[f];
      let v;
      if (p.isInterleavedBufferAttribute) {
        const g = r(e.data, p.data);
        v = new kc(g, p.itemSize, p.offset, p.normalized);
      } else {
        const g = Ll(p.type, p.array),
          m = p.isInstancedBufferAttribute ? iA : pt;
        v = new m(g, p.itemSize, p.normalized);
      }
      p.name !== void 0 && (v.name = p.name),
        p.usage !== void 0 && v.setUsage(p.usage),
        p.updateRange !== void 0 &&
          ((v.updateRange.offset = p.updateRange.offset),
          (v.updateRange.count = p.updateRange.count)),
        a.setAttribute(f, v);
    }
    const c = e.data.morphAttributes;
    if (c)
      for (const f in c) {
        const p = c[f],
          v = [];
        for (let g = 0, m = p.length; g < m; g++) {
          const x = p[g];
          let y;
          if (x.isInterleavedBufferAttribute) {
            const _ = r(e.data, x.data);
            y = new kc(_, x.itemSize, x.offset, x.normalized);
          } else {
            const _ = Ll(x.type, x.array);
            y = new pt(_, x.itemSize, x.normalized);
          }
          x.name !== void 0 && (y.name = x.name), v.push(y);
        }
        a.morphAttributes[f] = v;
      }
    e.data.morphTargetsRelative && (a.morphTargetsRelative = !0);
    const h = e.data.groups || e.data.drawcalls || e.data.offsets;
    if (h !== void 0)
      for (let f = 0, p = h.length; f !== p; ++f) {
        const v = h[f];
        a.addGroup(v.start, v.count, v.materialIndex);
      }
    const u = e.data.boundingSphere;
    if (u !== void 0) {
      const f = new A();
      u.center !== void 0 && f.fromArray(u.center),
        (a.boundingSphere = new Xn(f, u.radius));
    }
    return (
      e.name && (a.name = e.name), e.userData && (a.userData = e.userData), a
    );
  }
}
class HA {
  constructor(e = !0) {
    (this.autoStart = e),
      (this.startTime = 0),
      (this.oldTime = 0),
      (this.elapsedTime = 0),
      (this.running = !1);
  }
  start() {
    (this.startTime = Ug()),
      (this.oldTime = this.startTime),
      (this.elapsedTime = 0),
      (this.running = !0);
  }
  stop() {
    this.getElapsedTime(), (this.running = !1), (this.autoStart = !1);
  }
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime;
  }
  getDelta() {
    let e = 0;
    if (this.autoStart && !this.running) return this.start(), 0;
    if (this.running) {
      const i = Ug();
      (e = (i - this.oldTime) / 1e3),
        (this.oldTime = i),
        (this.elapsedTime += e);
    }
    return e;
  }
}
function Ug() {
  return (typeof performance > "u" ? Date : performance).now();
}
class Ax {
  constructor(e, i, n = 0, r = 1 / 0) {
    (this.ray = new oo(e, i)),
      (this.near = n),
      (this.far = r),
      (this.camera = null),
      (this.layers = new Vf()),
      (this.params = {
        Mesh: {},
        Line: { threshold: 1 },
        LOD: {},
        Points: { threshold: 1 },
        Sprite: {},
      });
  }
  set(e, i) {
    this.ray.set(e, i);
  }
  setFromCamera(e, i) {
    i.isPerspectiveCamera
      ? (this.ray.origin.setFromMatrixPosition(i.matrixWorld),
        this.ray.direction
          .set(e.x, e.y, 0.5)
          .unproject(i)
          .sub(this.ray.origin)
          .normalize(),
        (this.camera = i))
      : i.isOrthographicCamera
      ? (this.ray.origin
          .set(e.x, e.y, (i.near + i.far) / (i.near - i.far))
          .unproject(i),
        this.ray.direction.set(0, 0, -1).transformDirection(i.matrixWorld),
        (this.camera = i))
      : console.error("THREE.Raycaster: Unsupported camera type: " + i.type);
  }
  intersectObject(e, i = !0, n = []) {
    return Md(e, this, n, i), n.sort(Ng), n;
  }
  intersectObjects(e, i = !0, n = []) {
    for (let r = 0, s = e.length; r < s; r++) Md(e[r], this, n, i);
    return n.sort(Ng), n;
  }
}
function Ng(t, e) {
  return t.distance - e.distance;
}
function Md(t, e, i, n) {
  if ((t.layers.test(e.layers) && t.raycast(e, i), n === !0)) {
    const r = t.children;
    for (let s = 0, a = r.length; s < a; s++) Md(r[s], e, i, !0);
  }
}
const zg = new J();
class GA {
  constructor(e = new J(1 / 0, 1 / 0), i = new J(-1 / 0, -1 / 0)) {
    (this.isBox2 = !0), (this.min = e), (this.max = i);
  }
  set(e, i) {
    return this.min.copy(e), this.max.copy(i), this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let i = 0, n = e.length; i < n; i++) this.expandByPoint(e[i]);
    return this;
  }
  setFromCenterAndSize(e, i) {
    const n = zg.copy(i).multiplyScalar(0.5);
    return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = 1 / 0),
      (this.max.x = this.max.y = -1 / 0),
      this
    );
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }
  getCenter(e) {
    return this.isEmpty()
      ? e.set(0, 0)
      : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  containsPoint(e) {
    return !(
      e.x < this.min.x ||
      e.x > this.max.x ||
      e.y < this.min.y ||
      e.y > this.max.y
    );
  }
  containsBox(e) {
    return (
      this.min.x <= e.min.x &&
      e.max.x <= this.max.x &&
      this.min.y <= e.min.y &&
      e.max.y <= this.max.y
    );
  }
  getParameter(e, i) {
    return i.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y)
    );
  }
  intersectsBox(e) {
    return !(
      e.max.x < this.min.x ||
      e.min.x > this.max.x ||
      e.max.y < this.min.y ||
      e.min.y > this.max.y
    );
  }
  clampPoint(e, i) {
    return i.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, zg).distanceTo(e);
  }
  intersect(e) {
    return (
      this.min.max(e.min),
      this.max.min(e.max),
      this.isEmpty() && this.makeEmpty(),
      this
    );
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const Bg = new A(),
  tc = new A();
class jA {
  constructor(e = new A(), i = new A()) {
    (this.start = e), (this.end = i);
  }
  set(e, i) {
    return this.start.copy(e), this.end.copy(i), this;
  }
  copy(e) {
    return this.start.copy(e.start), this.end.copy(e.end), this;
  }
  getCenter(e) {
    return e.addVectors(this.start, this.end).multiplyScalar(0.5);
  }
  delta(e) {
    return e.subVectors(this.end, this.start);
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }
  distance() {
    return this.start.distanceTo(this.end);
  }
  at(e, i) {
    return this.delta(i).multiplyScalar(e).add(this.start);
  }
  closestPointToPointParameter(e, i) {
    Bg.subVectors(e, this.start), tc.subVectors(this.end, this.start);
    const n = tc.dot(tc);
    let s = tc.dot(Bg) / n;
    return i && (s = yi(s, 0, 1)), s;
  }
  closestPointToPoint(e, i, n) {
    const r = this.closestPointToPointParameter(e, i);
    return this.delta(n).multiplyScalar(r).add(this.start);
  }
  applyMatrix4(e) {
    return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
  }
  equals(e) {
    return e.start.equals(this.start) && e.end.equals(this.end);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Fg = new A();
class WA extends Ht {
  constructor(e, i) {
    super(),
      (this.light = e),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = i),
      (this.type = "SpotLightHelper");
    const n = new st(),
      r = [
        0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1,
        0, 0, 0, 0, -1, 1,
      ];
    for (let a = 0, o = 1, l = 32; a < l; a++, o++) {
      const c = (a / l) * Math.PI * 2,
        d = (o / l) * Math.PI * 2;
      r.push(Math.cos(c), Math.sin(c), 1, Math.cos(d), Math.sin(d), 1);
    }
    n.setAttribute("position", new We(r, 3));
    const s = new Ks({ fog: !1, toneMapped: !1 });
    (this.cone = new xl(n, s)), this.add(this.cone), this.update();
  }
  dispose() {
    this.cone.geometry.dispose(), this.cone.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1),
      this.light.target.updateWorldMatrix(!0, !1);
    const e = this.light.distance ? this.light.distance : 1e3,
      i = e * Math.tan(this.light.angle);
    this.cone.scale.set(i, i, e),
      Fg.setFromMatrixPosition(this.light.target.matrixWorld),
      this.cone.lookAt(Fg),
      this.color !== void 0
        ? this.cone.material.color.set(this.color)
        : this.cone.material.color.copy(this.light.color);
  }
}
class Cx extends Fn {
  constructor(e, i, n) {
    const r = new Ah(i, 4, 2),
      s = new co({ wireframe: !0, fog: !1, toneMapped: !1 });
    super(r, s),
      (this.light = e),
      (this.color = n),
      (this.type = "PointLightHelper"),
      (this.matrix = this.light.matrixWorld),
      (this.matrixAutoUpdate = !1),
      this.update();
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1),
      this.color !== void 0
        ? this.material.color.set(this.color)
        : this.material.color.copy(this.light.color);
  }
}
const kg = new A(),
  ic = new A(),
  Vg = new A();
class qA extends Ht {
  constructor(e, i, n) {
    super(),
      (this.light = e),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = n),
      (this.type = "DirectionalLightHelper"),
      i === void 0 && (i = 1);
    let r = new st();
    r.setAttribute(
      "position",
      new We([-i, i, 0, i, i, 0, i, -i, 0, -i, -i, 0, -i, i, 0], 3)
    );
    const s = new Ks({ fog: !1, toneMapped: !1 });
    (this.lightPlane = new bd(r, s)),
      this.add(this.lightPlane),
      (r = new st()),
      r.setAttribute("position", new We([0, 0, 0, 0, 0, 1], 3)),
      (this.targetLine = new bd(r, s)),
      this.add(this.targetLine),
      this.update();
  }
  dispose() {
    this.lightPlane.geometry.dispose(),
      this.lightPlane.material.dispose(),
      this.targetLine.geometry.dispose(),
      this.targetLine.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1),
      this.light.target.updateWorldMatrix(!0, !1),
      kg.setFromMatrixPosition(this.light.matrixWorld),
      ic.setFromMatrixPosition(this.light.target.matrixWorld),
      Vg.subVectors(ic, kg),
      this.lightPlane.lookAt(ic),
      this.color !== void 0
        ? (this.lightPlane.material.color.set(this.color),
          this.targetLine.material.color.set(this.color))
        : (this.lightPlane.material.color.copy(this.light.color),
          this.targetLine.material.color.copy(this.light.color)),
      this.targetLine.lookAt(ic),
      (this.targetLine.scale.z = Vg.length());
  }
}
const nc = new A(),
  ti = new vl();
class jc extends xl {
  constructor(e) {
    const i = new st(),
      n = new Ks({ color: 16777215, vertexColors: !0, toneMapped: !1 }),
      r = [],
      s = [],
      a = {};
    o("n1", "n2"),
      o("n2", "n4"),
      o("n4", "n3"),
      o("n3", "n1"),
      o("f1", "f2"),
      o("f2", "f4"),
      o("f4", "f3"),
      o("f3", "f1"),
      o("n1", "f1"),
      o("n2", "f2"),
      o("n3", "f3"),
      o("n4", "f4"),
      o("p", "n1"),
      o("p", "n2"),
      o("p", "n3"),
      o("p", "n4"),
      o("u1", "u2"),
      o("u2", "u3"),
      o("u3", "u1"),
      o("c", "t"),
      o("p", "c"),
      o("cn1", "cn2"),
      o("cn3", "cn4"),
      o("cf1", "cf2"),
      o("cf3", "cf4");
    function o(p, v) {
      l(p), l(v);
    }
    function l(p) {
      r.push(0, 0, 0),
        s.push(0, 0, 0),
        a[p] === void 0 && (a[p] = []),
        a[p].push(r.length / 3 - 1);
    }
    i.setAttribute("position", new We(r, 3)),
      i.setAttribute("color", new We(s, 3)),
      super(i, n),
      (this.type = "CameraHelper"),
      (this.camera = e),
      this.camera.updateProjectionMatrix &&
        this.camera.updateProjectionMatrix(),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.pointMap = a),
      this.update();
    const c = new tt(16755200),
      d = new tt(16711680),
      h = new tt(43775),
      u = new tt(16777215),
      f = new tt(3355443);
    this.setColors(c, d, h, u, f);
  }
  setColors(e, i, n, r, s) {
    const o = this.geometry.getAttribute("color");
    o.setXYZ(0, e.r, e.g, e.b),
      o.setXYZ(1, e.r, e.g, e.b),
      o.setXYZ(2, e.r, e.g, e.b),
      o.setXYZ(3, e.r, e.g, e.b),
      o.setXYZ(4, e.r, e.g, e.b),
      o.setXYZ(5, e.r, e.g, e.b),
      o.setXYZ(6, e.r, e.g, e.b),
      o.setXYZ(7, e.r, e.g, e.b),
      o.setXYZ(8, e.r, e.g, e.b),
      o.setXYZ(9, e.r, e.g, e.b),
      o.setXYZ(10, e.r, e.g, e.b),
      o.setXYZ(11, e.r, e.g, e.b),
      o.setXYZ(12, e.r, e.g, e.b),
      o.setXYZ(13, e.r, e.g, e.b),
      o.setXYZ(14, e.r, e.g, e.b),
      o.setXYZ(15, e.r, e.g, e.b),
      o.setXYZ(16, e.r, e.g, e.b),
      o.setXYZ(17, e.r, e.g, e.b),
      o.setXYZ(18, e.r, e.g, e.b),
      o.setXYZ(19, e.r, e.g, e.b),
      o.setXYZ(20, e.r, e.g, e.b),
      o.setXYZ(21, e.r, e.g, e.b),
      o.setXYZ(22, e.r, e.g, e.b),
      o.setXYZ(23, e.r, e.g, e.b),
      o.setXYZ(24, i.r, i.g, i.b),
      o.setXYZ(25, i.r, i.g, i.b),
      o.setXYZ(26, i.r, i.g, i.b),
      o.setXYZ(27, i.r, i.g, i.b),
      o.setXYZ(28, i.r, i.g, i.b),
      o.setXYZ(29, i.r, i.g, i.b),
      o.setXYZ(30, i.r, i.g, i.b),
      o.setXYZ(31, i.r, i.g, i.b),
      o.setXYZ(32, n.r, n.g, n.b),
      o.setXYZ(33, n.r, n.g, n.b),
      o.setXYZ(34, n.r, n.g, n.b),
      o.setXYZ(35, n.r, n.g, n.b),
      o.setXYZ(36, n.r, n.g, n.b),
      o.setXYZ(37, n.r, n.g, n.b),
      o.setXYZ(38, r.r, r.g, r.b),
      o.setXYZ(39, r.r, r.g, r.b),
      o.setXYZ(40, s.r, s.g, s.b),
      o.setXYZ(41, s.r, s.g, s.b),
      o.setXYZ(42, s.r, s.g, s.b),
      o.setXYZ(43, s.r, s.g, s.b),
      o.setXYZ(44, s.r, s.g, s.b),
      o.setXYZ(45, s.r, s.g, s.b),
      o.setXYZ(46, s.r, s.g, s.b),
      o.setXYZ(47, s.r, s.g, s.b),
      o.setXYZ(48, s.r, s.g, s.b),
      o.setXYZ(49, s.r, s.g, s.b),
      (o.needsUpdate = !0);
  }
  update() {
    const e = this.geometry,
      i = this.pointMap,
      n = 1,
      r = 1;
    ti.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),
      hi("c", i, e, ti, 0, 0, -1),
      hi("t", i, e, ti, 0, 0, 1),
      hi("n1", i, e, ti, -n, -r, -1),
      hi("n2", i, e, ti, n, -r, -1),
      hi("n3", i, e, ti, -n, r, -1),
      hi("n4", i, e, ti, n, r, -1),
      hi("f1", i, e, ti, -n, -r, 1),
      hi("f2", i, e, ti, n, -r, 1),
      hi("f3", i, e, ti, -n, r, 1),
      hi("f4", i, e, ti, n, r, 1),
      hi("u1", i, e, ti, n * 0.7, r * 1.1, -1),
      hi("u2", i, e, ti, -n * 0.7, r * 1.1, -1),
      hi("u3", i, e, ti, 0, r * 2, -1),
      hi("cf1", i, e, ti, -n, 0, 1),
      hi("cf2", i, e, ti, n, 0, 1),
      hi("cf3", i, e, ti, 0, -r, 1),
      hi("cf4", i, e, ti, 0, r, 1),
      hi("cn1", i, e, ti, -n, 0, -1),
      hi("cn2", i, e, ti, n, 0, -1),
      hi("cn3", i, e, ti, 0, -r, -1),
      hi("cn4", i, e, ti, 0, r, -1),
      (e.getAttribute("position").needsUpdate = !0);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function hi(t, e, i, n, r, s, a) {
  nc.set(r, s, a).unproject(n);
  const o = e[t];
  if (o !== void 0) {
    const l = i.getAttribute("position");
    for (let c = 0, d = o.length; c < d; c++) l.setXYZ(o[c], nc.x, nc.y, nc.z);
  }
}
class Wc extends xl {
  constructor(e, i = 16776960) {
    const n = new Uint16Array([
        0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7,
      ]),
      r = [
        1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1,
        1, -1, -1,
      ],
      s = new st();
    s.setIndex(new pt(n, 1)),
      s.setAttribute("position", new We(r, 3)),
      super(s, new Ks({ color: i, toneMapped: !1 })),
      (this.box = e),
      (this.type = "Box3Helper"),
      this.geometry.computeBoundingSphere();
  }
  updateMatrixWorld(e) {
    const i = this.box;
    i.isEmpty() ||
      (i.getCenter(this.position),
      i.getSize(this.scale),
      this.scale.multiplyScalar(0.5),
      super.updateMatrixWorld(e));
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class XA extends xl {
  constructor(e = 1) {
    const i = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e],
      n = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1],
      r = new st();
    r.setAttribute("position", new We(i, 3)),
      r.setAttribute("color", new We(n, 3));
    const s = new Ks({ vertexColors: !0, toneMapped: !1 });
    super(r, s), (this.type = "AxesHelper");
  }
  setColors(e, i, n) {
    const r = new tt(),
      s = this.geometry.attributes.color.array;
    return (
      r.set(e),
      r.toArray(s, 0),
      r.toArray(s, 3),
      r.set(i),
      r.toArray(s, 6),
      r.toArray(s, 9),
      r.set(n),
      r.toArray(s, 12),
      r.toArray(s, 15),
      (this.geometry.attributes.color.needsUpdate = !0),
      this
    );
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
typeof __THREE_DEVTOOLS__ < "u" &&
  __THREE_DEVTOOLS__.dispatchEvent(
    new CustomEvent("register", { detail: { revision: Bf } })
  );
typeof window < "u" &&
  (window.__THREE__
    ? console.warn("WARNING: Multiple instances of Three.js being imported.")
    : (window.__THREE__ = Bf));
const Zo = {
  name: "CopyShader",
  uniforms: { tDiffuse: { value: null }, opacity: { value: 1 } },
  vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
  fragmentShader: `

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );
			gl_FragColor = opacity * texel;


		}`,
};
class uo {
  constructor() {
    (this.isPass = !0),
      (this.enabled = !0),
      (this.needsSwap = !0),
      (this.clear = !1),
      (this.renderToScreen = !1);
  }
  setSize() {}
  render() {
    console.error("THREE.Pass: .render() must be implemented in derived pass.");
  }
  dispose() {}
}
const $A = new _h(-1, 1, 1, -1, 0, 1),
  ip = new st();
ip.setAttribute("position", new We([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3));
ip.setAttribute("uv", new We([0, 2, 0, 0, 2, 0], 2));
class np {
  constructor(e) {
    this._mesh = new Fn(ip, e);
  }
  dispose() {
    this._mesh.geometry.dispose();
  }
  render(e) {
    e.render(this._mesh, $A);
  }
  get material() {
    return this._mesh.material;
  }
  set material(e) {
    this._mesh.material = e;
  }
}
class Px extends uo {
  constructor(e, i) {
    super(),
      (this.textureID = i !== void 0 ? i : "tDiffuse"),
      e instanceof Ti
        ? ((this.uniforms = e.uniforms), (this.material = e))
        : e &&
          ((this.uniforms = un.clone(e.uniforms)),
          (this.material = new Ti({
            name: e.name !== void 0 ? e.name : "unspecified",
            defines: Object.assign({}, e.defines),
            uniforms: this.uniforms,
            vertexShader: e.vertexShader,
            fragmentShader: e.fragmentShader,
          }))),
      (this.fsQuad = new np(this.material));
  }
  render(e, i, n) {
    this.uniforms[this.textureID] &&
      (this.uniforms[this.textureID].value = n.texture),
      (this.fsQuad.material = this.material),
      this.renderToScreen
        ? (e.setRenderTarget(null), this.fsQuad.render(e))
        : (e.setRenderTarget(i),
          this.clear &&
            e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil),
          this.fsQuad.render(e));
  }
  dispose() {
    this.material.dispose(), this.fsQuad.dispose();
  }
}
class Hg extends uo {
  constructor(e, i) {
    super(),
      (this.scene = e),
      (this.camera = i),
      (this.clear = !0),
      (this.needsSwap = !1),
      (this.inverse = !1);
  }
  render(e, i, n) {
    const r = e.getContext(),
      s = e.state;
    s.buffers.color.setMask(!1),
      s.buffers.depth.setMask(!1),
      s.buffers.color.setLocked(!0),
      s.buffers.depth.setLocked(!0);
    let a, o;
    this.inverse ? ((a = 0), (o = 1)) : ((a = 1), (o = 0)),
      s.buffers.stencil.setTest(!0),
      s.buffers.stencil.setOp(r.REPLACE, r.REPLACE, r.REPLACE),
      s.buffers.stencil.setFunc(r.ALWAYS, a, 4294967295),
      s.buffers.stencil.setClear(o),
      s.buffers.stencil.setLocked(!0),
      e.setRenderTarget(n),
      this.clear && e.clear(),
      e.render(this.scene, this.camera),
      e.setRenderTarget(i),
      this.clear && e.clear(),
      e.render(this.scene, this.camera),
      s.buffers.color.setLocked(!1),
      s.buffers.depth.setLocked(!1),
      s.buffers.stencil.setLocked(!1),
      s.buffers.stencil.setFunc(r.EQUAL, 1, 4294967295),
      s.buffers.stencil.setOp(r.KEEP, r.KEEP, r.KEEP),
      s.buffers.stencil.setLocked(!0);
  }
}
class YA extends uo {
  constructor() {
    super(), (this.needsSwap = !1);
  }
  render(e) {
    e.state.buffers.stencil.setLocked(!1), e.state.buffers.stencil.setTest(!1);
  }
}
class ZA {
  constructor(e, i) {
    if (
      ((this.renderer = e),
      (this._pixelRatio = e.getPixelRatio()),
      i === void 0)
    ) {
      const n = e.getSize(new J());
      (this._width = n.width),
        (this._height = n.height),
        (i = new rn(
          this._width * this._pixelRatio,
          this._height * this._pixelRatio,
          { type: Mn }
        )),
        (i.texture.name = "EffectComposer.rt1");
    } else (this._width = i.width), (this._height = i.height);
    (this.renderTarget1 = i),
      (this.renderTarget2 = i.clone()),
      (this.renderTarget2.texture.name = "EffectComposer.rt2"),
      (this.writeBuffer = this.renderTarget1),
      (this.readBuffer = this.renderTarget2),
      (this.renderToScreen = !0),
      (this.passes = []),
      (this.copyPass = new Px(Zo)),
      (this.copyPass.material.blending = Pi),
      (this.clock = new HA());
  }
  swapBuffers() {
    const e = this.readBuffer;
    (this.readBuffer = this.writeBuffer), (this.writeBuffer = e);
  }
  addPass(e) {
    this.passes.push(e),
      e.setSize(
        this._width * this._pixelRatio,
        this._height * this._pixelRatio
      );
  }
  insertPass(e, i) {
    this.passes.splice(i, 0, e),
      e.setSize(
        this._width * this._pixelRatio,
        this._height * this._pixelRatio
      );
  }
  removePass(e) {
    const i = this.passes.indexOf(e);
    i !== -1 && this.passes.splice(i, 1);
  }
  isLastEnabledPass(e) {
    for (let i = e + 1; i < this.passes.length; i++)
      if (this.passes[i].enabled) return !1;
    return !0;
  }
  render(e) {
    e === void 0 && (e = this.clock.getDelta());
    const i = this.renderer.getRenderTarget();
    let n = !1;
    for (let r = 0, s = this.passes.length; r < s; r++) {
      const a = this.passes[r];
      if (a.enabled !== !1) {
        if (
          ((a.renderToScreen =
            this.renderToScreen && this.isLastEnabledPass(r)),
          a.render(this.renderer, this.writeBuffer, this.readBuffer, e, n),
          a.needsSwap)
        ) {
          if (n) {
            const o = this.renderer.getContext(),
              l = this.renderer.state.buffers.stencil;
            l.setFunc(o.NOTEQUAL, 1, 4294967295),
              this.copyPass.render(
                this.renderer,
                this.writeBuffer,
                this.readBuffer,
                e
              ),
              l.setFunc(o.EQUAL, 1, 4294967295);
          }
          this.swapBuffers();
        }
        Hg !== void 0 &&
          (a instanceof Hg ? (n = !0) : a instanceof YA && (n = !1));
      }
    }
    this.renderer.setRenderTarget(i);
  }
  reset(e) {
    if (e === void 0) {
      const i = this.renderer.getSize(new J());
      (this._pixelRatio = this.renderer.getPixelRatio()),
        (this._width = i.width),
        (this._height = i.height),
        (e = this.renderTarget1.clone()),
        e.setSize(
          this._width * this._pixelRatio,
          this._height * this._pixelRatio
        );
    }
    this.renderTarget1.dispose(),
      this.renderTarget2.dispose(),
      (this.renderTarget1 = e),
      (this.renderTarget2 = e.clone()),
      (this.writeBuffer = this.renderTarget1),
      (this.readBuffer = this.renderTarget2);
  }
  setSize(e, i) {
    (this._width = e), (this._height = i);
    const n = this._width * this._pixelRatio,
      r = this._height * this._pixelRatio;
    this.renderTarget1.setSize(n, r), this.renderTarget2.setSize(n, r);
    for (let s = 0; s < this.passes.length; s++) this.passes[s].setSize(n, r);
  }
  setPixelRatio(e) {
    (this._pixelRatio = e), this.setSize(this._width, this._height);
  }
  dispose() {
    this.renderTarget1.dispose(),
      this.renderTarget2.dispose(),
      this.copyPass.dispose();
  }
}
class KA {
  constructor(e = Math) {
    (this.grad3 = [
      [1, 1, 0],
      [-1, 1, 0],
      [1, -1, 0],
      [-1, -1, 0],
      [1, 0, 1],
      [-1, 0, 1],
      [1, 0, -1],
      [-1, 0, -1],
      [0, 1, 1],
      [0, -1, 1],
      [0, 1, -1],
      [0, -1, -1],
    ]),
      (this.grad4 = [
        [0, 1, 1, 1],
        [0, 1, 1, -1],
        [0, 1, -1, 1],
        [0, 1, -1, -1],
        [0, -1, 1, 1],
        [0, -1, 1, -1],
        [0, -1, -1, 1],
        [0, -1, -1, -1],
        [1, 0, 1, 1],
        [1, 0, 1, -1],
        [1, 0, -1, 1],
        [1, 0, -1, -1],
        [-1, 0, 1, 1],
        [-1, 0, 1, -1],
        [-1, 0, -1, 1],
        [-1, 0, -1, -1],
        [1, 1, 0, 1],
        [1, 1, 0, -1],
        [1, -1, 0, 1],
        [1, -1, 0, -1],
        [-1, 1, 0, 1],
        [-1, 1, 0, -1],
        [-1, -1, 0, 1],
        [-1, -1, 0, -1],
        [1, 1, 1, 0],
        [1, 1, -1, 0],
        [1, -1, 1, 0],
        [1, -1, -1, 0],
        [-1, 1, 1, 0],
        [-1, 1, -1, 0],
        [-1, -1, 1, 0],
        [-1, -1, -1, 0],
      ]),
      (this.p = []);
    for (let i = 0; i < 256; i++) this.p[i] = Math.floor(e.random() * 256);
    this.perm = [];
    for (let i = 0; i < 512; i++) this.perm[i] = this.p[i & 255];
    this.simplex = [
      [0, 1, 2, 3],
      [0, 1, 3, 2],
      [0, 0, 0, 0],
      [0, 2, 3, 1],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [1, 2, 3, 0],
      [0, 2, 1, 3],
      [0, 0, 0, 0],
      [0, 3, 1, 2],
      [0, 3, 2, 1],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [1, 3, 2, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [1, 2, 0, 3],
      [0, 0, 0, 0],
      [1, 3, 0, 2],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [2, 3, 0, 1],
      [2, 3, 1, 0],
      [1, 0, 2, 3],
      [1, 0, 3, 2],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [2, 0, 3, 1],
      [0, 0, 0, 0],
      [2, 1, 3, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [2, 0, 1, 3],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [3, 0, 1, 2],
      [3, 0, 2, 1],
      [0, 0, 0, 0],
      [3, 1, 2, 0],
      [2, 1, 0, 3],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [3, 1, 0, 2],
      [0, 0, 0, 0],
      [3, 2, 0, 1],
      [3, 2, 1, 0],
    ];
  }
  dot(e, i, n) {
    return e[0] * i + e[1] * n;
  }
  dot3(e, i, n, r) {
    return e[0] * i + e[1] * n + e[2] * r;
  }
  dot4(e, i, n, r, s) {
    return e[0] * i + e[1] * n + e[2] * r + e[3] * s;
  }
  noise(e, i) {
    let n, r, s;
    const a = 0.5 * (Math.sqrt(3) - 1),
      o = (e + i) * a,
      l = Math.floor(e + o),
      c = Math.floor(i + o),
      d = (3 - Math.sqrt(3)) / 6,
      h = (l + c) * d,
      u = l - h,
      f = c - h,
      p = e - u,
      v = i - f;
    let g, m;
    p > v ? ((g = 1), (m = 0)) : ((g = 0), (m = 1));
    const x = p - g + d,
      y = v - m + d,
      _ = p - 1 + 2 * d,
      M = v - 1 + 2 * d,
      b = l & 255,
      E = c & 255,
      T = this.perm[b + this.perm[E]] % 12,
      S = this.perm[b + g + this.perm[E + m]] % 12,
      w = this.perm[b + 1 + this.perm[E + 1]] % 12;
    let C = 0.5 - p * p - v * v;
    C < 0 ? (n = 0) : ((C *= C), (n = C * C * this.dot(this.grad3[T], p, v)));
    let L = 0.5 - x * x - y * y;
    L < 0 ? (r = 0) : ((L *= L), (r = L * L * this.dot(this.grad3[S], x, y)));
    let P = 0.5 - _ * _ - M * M;
    return (
      P < 0 ? (s = 0) : ((P *= P), (s = P * P * this.dot(this.grad3[w], _, M))),
      70 * (n + r + s)
    );
  }
  noise3d(e, i, n) {
    let r, s, a, o;
    const l = 0.3333333333333333,
      c = (e + i + n) * l,
      d = Math.floor(e + c),
      h = Math.floor(i + c),
      u = Math.floor(n + c),
      f = 1 / 6,
      p = (d + h + u) * f,
      v = d - p,
      g = h - p,
      m = u - p,
      x = e - v,
      y = i - g,
      _ = n - m;
    let M, b, E, T, S, w;
    x >= y
      ? y >= _
        ? ((M = 1), (b = 0), (E = 0), (T = 1), (S = 1), (w = 0))
        : x >= _
        ? ((M = 1), (b = 0), (E = 0), (T = 1), (S = 0), (w = 1))
        : ((M = 0), (b = 0), (E = 1), (T = 1), (S = 0), (w = 1))
      : y < _
      ? ((M = 0), (b = 0), (E = 1), (T = 0), (S = 1), (w = 1))
      : x < _
      ? ((M = 0), (b = 1), (E = 0), (T = 0), (S = 1), (w = 1))
      : ((M = 0), (b = 1), (E = 0), (T = 1), (S = 1), (w = 0));
    const C = x - M + f,
      L = y - b + f,
      P = _ - E + f,
      R = x - T + 2 * f,
      I = y - S + 2 * f,
      W = _ - w + 2 * f,
      N = x - 1 + 3 * f,
      U = y - 1 + 3 * f,
      G = _ - 1 + 3 * f,
      k = d & 255,
      B = h & 255,
      V = u & 255,
      X = this.perm[k + this.perm[B + this.perm[V]]] % 12,
      H = this.perm[k + M + this.perm[B + b + this.perm[V + E]]] % 12,
      j = this.perm[k + T + this.perm[B + S + this.perm[V + w]]] % 12,
      Y = this.perm[k + 1 + this.perm[B + 1 + this.perm[V + 1]]] % 12;
    let ee = 0.6 - x * x - y * y - _ * _;
    ee < 0
      ? (r = 0)
      : ((ee *= ee), (r = ee * ee * this.dot3(this.grad3[X], x, y, _)));
    let Z = 0.6 - C * C - L * L - P * P;
    Z < 0
      ? (s = 0)
      : ((Z *= Z), (s = Z * Z * this.dot3(this.grad3[H], C, L, P)));
    let K = 0.6 - R * R - I * I - W * W;
    K < 0
      ? (a = 0)
      : ((K *= K), (a = K * K * this.dot3(this.grad3[j], R, I, W)));
    let me = 0.6 - N * N - U * U - G * G;
    return (
      me < 0
        ? (o = 0)
        : ((me *= me), (o = me * me * this.dot3(this.grad3[Y], N, U, G))),
      32 * (r + s + a + o)
    );
  }
  noise4d(e, i, n, r) {
    const s = this.grad4,
      a = this.simplex,
      o = this.perm,
      l = (Math.sqrt(5) - 1) / 4,
      c = (5 - Math.sqrt(5)) / 20;
    let d, h, u, f, p;
    const v = (e + i + n + r) * l,
      g = Math.floor(e + v),
      m = Math.floor(i + v),
      x = Math.floor(n + v),
      y = Math.floor(r + v),
      _ = (g + m + x + y) * c,
      M = g - _,
      b = m - _,
      E = x - _,
      T = y - _,
      S = e - M,
      w = i - b,
      C = n - E,
      L = r - T,
      P = S > w ? 32 : 0,
      R = S > C ? 16 : 0,
      I = w > C ? 8 : 0,
      W = S > L ? 4 : 0,
      N = w > L ? 2 : 0,
      U = C > L ? 1 : 0,
      G = P + R + I + W + N + U,
      k = a[G][0] >= 3 ? 1 : 0,
      B = a[G][1] >= 3 ? 1 : 0,
      V = a[G][2] >= 3 ? 1 : 0,
      X = a[G][3] >= 3 ? 1 : 0,
      H = a[G][0] >= 2 ? 1 : 0,
      j = a[G][1] >= 2 ? 1 : 0,
      Y = a[G][2] >= 2 ? 1 : 0,
      ee = a[G][3] >= 2 ? 1 : 0,
      Z = a[G][0] >= 1 ? 1 : 0,
      K = a[G][1] >= 1 ? 1 : 0,
      me = a[G][2] >= 1 ? 1 : 0,
      re = a[G][3] >= 1 ? 1 : 0,
      F = S - k + c,
      Te = w - B + c,
      be = C - V + c,
      oe = L - X + c,
      Me = S - H + 2 * c,
      Ae = w - j + 2 * c,
      ye = C - Y + 2 * c,
      _e = L - ee + 2 * c,
      Ee = S - Z + 3 * c,
      Le = w - K + 3 * c,
      it = C - me + 3 * c,
      O = L - re + 3 * c,
      D = S - 1 + 4 * c,
      ne = w - 1 + 4 * c,
      pe = C - 1 + 4 * c,
      xe = L - 1 + 4 * c,
      we = g & 255,
      Fe = m & 255,
      Se = x & 255,
      le = y & 255,
      je = o[we + o[Fe + o[Se + o[le]]]] % 32,
      $e = o[we + k + o[Fe + B + o[Se + V + o[le + X]]]] % 32,
      Ye = o[we + H + o[Fe + j + o[Se + Y + o[le + ee]]]] % 32,
      He = o[we + Z + o[Fe + K + o[Se + me + o[le + re]]]] % 32,
      Ge = o[we + 1 + o[Fe + 1 + o[Se + 1 + o[le + 1]]]] % 32;
    let nt = 0.6 - S * S - w * w - C * C - L * L;
    nt < 0
      ? (d = 0)
      : ((nt *= nt), (d = nt * nt * this.dot4(s[je], S, w, C, L)));
    let wt = 0.6 - F * F - Te * Te - be * be - oe * oe;
    wt < 0
      ? (h = 0)
      : ((wt *= wt), (h = wt * wt * this.dot4(s[$e], F, Te, be, oe)));
    let q = 0.6 - Me * Me - Ae * Ae - ye * ye - _e * _e;
    q < 0
      ? (u = 0)
      : ((q *= q), (u = q * q * this.dot4(s[Ye], Me, Ae, ye, _e)));
    let De = 0.6 - Ee * Ee - Le * Le - it * it - O * O;
    De < 0
      ? (f = 0)
      : ((De *= De), (f = De * De * this.dot4(s[He], Ee, Le, it, O)));
    let se = 0.6 - D * D - ne * ne - pe * pe - xe * xe;
    return (
      se < 0
        ? (p = 0)
        : ((se *= se), (p = se * se * this.dot4(s[Ge], D, ne, pe, xe))),
      27 * (d + h + u + f + p)
    );
  }
}
const rc = {
    defines: { PERSPECTIVE_CAMERA: 1, KERNEL_SIZE: 32 },
    uniforms: {
      tDiffuse: { value: null },
      tNormal: { value: null },
      tDepth: { value: null },
      tNoise: { value: null },
      kernel: { value: null },
      cameraNear: { value: null },
      cameraFar: { value: null },
      resolution: { value: new J() },
      cameraProjectionMatrix: { value: new ze() },
      cameraInverseProjectionMatrix: { value: new ze() },
      kernelRadius: { value: 8 },
      minDistance: { value: 0.005 },
      maxDistance: { value: 0.05 },
    },
    vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
    fragmentShader: `

		uniform sampler2D tDiffuse;
		uniform sampler2D tNormal;
		uniform sampler2D tDepth;
		uniform sampler2D tNoise;

		uniform vec3 kernel[ KERNEL_SIZE ];

		uniform vec2 resolution;

		uniform float cameraNear;
		uniform float cameraFar;
		uniform mat4 cameraProjectionMatrix;
		uniform mat4 cameraInverseProjectionMatrix;

		uniform float kernelRadius;
		uniform float minDistance; // avoid artifacts caused by neighbour fragments with minimal depth difference
		uniform float maxDistance; // avoid the influence of fragments which are too far away

		varying vec2 vUv;

		#include <packing>

		float getDepth( const in vec2 screenPosition ) {

			return texture2D( tDepth, screenPosition ).x;

		}

		float getLinearDepth( const in vec2 screenPosition ) {

			#if PERSPECTIVE_CAMERA == 1

				float fragCoordZ = texture2D( tDepth, screenPosition ).x;
				float viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );
				return viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );

			#else

				return texture2D( tDepth, screenPosition ).x;

			#endif

		}

		float getViewZ( const in float depth ) {

			#if PERSPECTIVE_CAMERA == 1

				return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );

			#else

				return orthographicDepthToViewZ( depth, cameraNear, cameraFar );

			#endif

		}

		vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {

			float clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];

			vec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );

			clipPosition *= clipW; // unprojection.

			return ( cameraInverseProjectionMatrix * clipPosition ).xyz;

		}

		vec3 getViewNormal( const in vec2 screenPosition ) {

			return unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );

		}

		void main() {

			float depth = getDepth( vUv );
			float viewZ = getViewZ( depth );

			vec3 viewPosition = getViewPosition( vUv, depth, viewZ );
			vec3 viewNormal = getViewNormal( vUv );

			vec2 noiseScale = vec2( resolution.x / 4.0, resolution.y / 4.0 );
			vec3 random = vec3( texture2D( tNoise, vUv * noiseScale ).r );

			// compute matrix used to reorient a kernel vector

			vec3 tangent = normalize( random - viewNormal * dot( random, viewNormal ) );
			vec3 bitangent = cross( viewNormal, tangent );
			mat3 kernelMatrix = mat3( tangent, bitangent, viewNormal );

		 float occlusion = 0.0;

		 for ( int i = 0; i < KERNEL_SIZE; i ++ ) {

				vec3 sampleVector = kernelMatrix * kernel[ i ]; // reorient sample vector in view space
				vec3 samplePoint = viewPosition + ( sampleVector * kernelRadius ); // calculate sample point

				vec4 samplePointNDC = cameraProjectionMatrix * vec4( samplePoint, 1.0 ); // project point and calculate NDC
				samplePointNDC /= samplePointNDC.w;

				vec2 samplePointUv = samplePointNDC.xy * 0.5 + 0.5; // compute uv coordinates

				float realDepth = getLinearDepth( samplePointUv ); // get linear depth from depth texture
				float sampleDepth = viewZToOrthographicDepth( samplePoint.z, cameraNear, cameraFar ); // compute linear depth of the sample view Z value
				float delta = sampleDepth - realDepth;

				if ( delta > minDistance && delta < maxDistance ) { // if fragment is before sample point, increase occlusion

					occlusion += 1.0;

				}

			}

			occlusion = clamp( occlusion / float( KERNEL_SIZE ), 0.0, 1.0 );

			gl_FragColor = vec4( vec3( 1.0 - occlusion ), 1.0 );

		}`,
  },
  sc = {
    defines: { PERSPECTIVE_CAMERA: 1 },
    uniforms: {
      tDepth: { value: null },
      cameraNear: { value: null },
      cameraFar: { value: null },
    },
    vertexShader: `varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
    fragmentShader: `uniform sampler2D tDepth;

		uniform float cameraNear;
		uniform float cameraFar;

		varying vec2 vUv;

		#include <packing>

		float getLinearDepth( const in vec2 screenPosition ) {

			#if PERSPECTIVE_CAMERA == 1

				float fragCoordZ = texture2D( tDepth, screenPosition ).x;
				float viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );
				return viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );

			#else

				return texture2D( tDepth, screenPosition ).x;

			#endif

		}

		void main() {

			float depth = getLinearDepth( vUv );
			gl_FragColor = vec4( vec3( 1.0 - depth ), 1.0 );

		}`,
  },
  ac = {
    uniforms: { tDiffuse: { value: null }, resolution: { value: new J() } },
    vertexShader: `varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
    fragmentShader: `uniform sampler2D tDiffuse;

		uniform vec2 resolution;

		varying vec2 vUv;

		void main() {

			vec2 texelSize = ( 1.0 / resolution );
			float result = 0.0;

			for ( int i = - 2; i <= 2; i ++ ) {

				for ( int j = - 2; j <= 2; j ++ ) {

					vec2 offset = ( vec2( float( i ), float( j ) ) ) * texelSize;
					result += texture2D( tDiffuse, vUv + offset ).r;

				}

			}

			gl_FragColor = vec4( vec3( result / ( 5.0 * 5.0 ) ), 1.0 );

		}`,
  };
class Lr extends uo {
  constructor(e, i, n, r) {
    super(),
      (this.width = n !== void 0 ? n : 512),
      (this.height = r !== void 0 ? r : 512),
      (this.clear = !0),
      (this.camera = i),
      (this.scene = e),
      (this.kernelRadius = 8),
      (this.kernelSize = 32),
      (this.kernel = []),
      (this.noiseTexture = null),
      (this.output = 0),
      (this.minDistance = 0.005),
      (this.maxDistance = 0.1),
      (this._visibilityCache = new Map()),
      this.generateSampleKernel(),
      this.generateRandomKernelRotations();
    const s = new mx();
    (s.format = js),
      (s.type = ss),
      (this.beautyRenderTarget = new rn(this.width, this.height, { type: Mn })),
      (this.normalRenderTarget = new rn(this.width, this.height, {
        minFilter: vi,
        magFilter: vi,
        type: Mn,
        depthTexture: s,
      })),
      (this.ssaoRenderTarget = new rn(this.width, this.height, { type: Mn })),
      (this.blurRenderTarget = this.ssaoRenderTarget.clone()),
      (this.ssaoMaterial = new Ti({
        defines: Object.assign({}, rc.defines),
        uniforms: un.clone(rc.uniforms),
        vertexShader: rc.vertexShader,
        fragmentShader: rc.fragmentShader,
        blending: Pi,
      })),
      (this.ssaoMaterial.uniforms.tDiffuse.value =
        this.beautyRenderTarget.texture),
      (this.ssaoMaterial.uniforms.tNormal.value =
        this.normalRenderTarget.texture),
      (this.ssaoMaterial.uniforms.tDepth.value =
        this.normalRenderTarget.depthTexture),
      (this.ssaoMaterial.uniforms.tNoise.value = this.noiseTexture),
      (this.ssaoMaterial.uniforms.kernel.value = this.kernel),
      (this.ssaoMaterial.uniforms.cameraNear.value = this.camera.near),
      (this.ssaoMaterial.uniforms.cameraFar.value = this.camera.far),
      this.ssaoMaterial.uniforms.resolution.value.set(this.width, this.height),
      this.ssaoMaterial.uniforms.cameraProjectionMatrix.value.copy(
        this.camera.projectionMatrix
      ),
      this.ssaoMaterial.uniforms.cameraInverseProjectionMatrix.value.copy(
        this.camera.projectionMatrixInverse
      ),
      (this.normalMaterial = new RA()),
      (this.normalMaterial.blending = Pi),
      (this.blurMaterial = new Ti({
        defines: Object.assign({}, ac.defines),
        uniforms: un.clone(ac.uniforms),
        vertexShader: ac.vertexShader,
        fragmentShader: ac.fragmentShader,
      })),
      (this.blurMaterial.uniforms.tDiffuse.value =
        this.ssaoRenderTarget.texture),
      this.blurMaterial.uniforms.resolution.value.set(this.width, this.height),
      (this.depthRenderMaterial = new Ti({
        defines: Object.assign({}, sc.defines),
        uniforms: un.clone(sc.uniforms),
        vertexShader: sc.vertexShader,
        fragmentShader: sc.fragmentShader,
        blending: Pi,
      })),
      (this.depthRenderMaterial.uniforms.tDepth.value =
        this.normalRenderTarget.depthTexture),
      (this.depthRenderMaterial.uniforms.cameraNear.value = this.camera.near),
      (this.depthRenderMaterial.uniforms.cameraFar.value = this.camera.far),
      (this.copyMaterial = new Ti({
        uniforms: un.clone(Zo.uniforms),
        vertexShader: Zo.vertexShader,
        fragmentShader: Zo.fragmentShader,
        transparent: !0,
        depthTest: !1,
        depthWrite: !1,
        blendSrc: Gy,
        blendDst: dd,
        blendEquation: Xr,
        blendSrcAlpha: Hy,
        blendDstAlpha: dd,
        blendEquationAlpha: Xr,
      })),
      (this.fsQuad = new np(null)),
      (this.originalClearColor = new tt());
  }
  dispose() {
    this.beautyRenderTarget.dispose(),
      this.normalRenderTarget.dispose(),
      this.ssaoRenderTarget.dispose(),
      this.blurRenderTarget.dispose(),
      this.normalMaterial.dispose(),
      this.blurMaterial.dispose(),
      this.copyMaterial.dispose(),
      this.depthRenderMaterial.dispose(),
      this.fsQuad.dispose();
  }
  render(e, i) {
    switch (
      (e.capabilities.isWebGL2 === !1 && (this.noiseTexture.format = Yy),
      e.setRenderTarget(this.beautyRenderTarget),
      e.clear(),
      e.render(this.scene, this.camera),
      this.overrideVisibility(),
      this.renderOverride(
        e,
        this.normalMaterial,
        this.normalRenderTarget,
        7829503,
        1
      ),
      this.restoreVisibility(),
      (this.ssaoMaterial.uniforms.kernelRadius.value = this.kernelRadius),
      (this.ssaoMaterial.uniforms.minDistance.value = this.minDistance),
      (this.ssaoMaterial.uniforms.maxDistance.value = this.maxDistance),
      this.renderPass(e, this.ssaoMaterial, this.ssaoRenderTarget),
      this.renderPass(e, this.blurMaterial, this.blurRenderTarget),
      this.output)
    ) {
      case Lr.OUTPUT.SSAO:
        (this.copyMaterial.uniforms.tDiffuse.value =
          this.ssaoRenderTarget.texture),
          (this.copyMaterial.blending = Pi),
          this.renderPass(e, this.copyMaterial, this.renderToScreen ? null : i);
        break;
      case Lr.OUTPUT.Blur:
        (this.copyMaterial.uniforms.tDiffuse.value =
          this.blurRenderTarget.texture),
          (this.copyMaterial.blending = Pi),
          this.renderPass(e, this.copyMaterial, this.renderToScreen ? null : i);
        break;
      case Lr.OUTPUT.Beauty:
        (this.copyMaterial.uniforms.tDiffuse.value =
          this.beautyRenderTarget.texture),
          (this.copyMaterial.blending = Pi),
          this.renderPass(e, this.copyMaterial, this.renderToScreen ? null : i);
        break;
      case Lr.OUTPUT.Depth:
        this.renderPass(
          e,
          this.depthRenderMaterial,
          this.renderToScreen ? null : i
        );
        break;
      case Lr.OUTPUT.Normal:
        (this.copyMaterial.uniforms.tDiffuse.value =
          this.normalRenderTarget.texture),
          (this.copyMaterial.blending = Pi),
          this.renderPass(e, this.copyMaterial, this.renderToScreen ? null : i);
        break;
      case Lr.OUTPUT.Default:
        (this.copyMaterial.uniforms.tDiffuse.value =
          this.beautyRenderTarget.texture),
          (this.copyMaterial.blending = Pi),
          this.renderPass(e, this.copyMaterial, this.renderToScreen ? null : i),
          (this.copyMaterial.uniforms.tDiffuse.value =
            this.blurRenderTarget.texture),
          (this.copyMaterial.blending = Fy),
          this.renderPass(e, this.copyMaterial, this.renderToScreen ? null : i);
        break;
      default:
        console.warn("THREE.SSAOPass: Unknown output type.");
    }
  }
  renderPass(e, i, n, r, s) {
    e.getClearColor(this.originalClearColor);
    const a = e.getClearAlpha(),
      o = e.autoClear;
    e.setRenderTarget(n),
      (e.autoClear = !1),
      r != null && (e.setClearColor(r), e.setClearAlpha(s || 0), e.clear()),
      (this.fsQuad.material = i),
      this.fsQuad.render(e),
      (e.autoClear = o),
      e.setClearColor(this.originalClearColor),
      e.setClearAlpha(a);
  }
  renderOverride(e, i, n, r, s) {
    e.getClearColor(this.originalClearColor);
    const a = e.getClearAlpha(),
      o = e.autoClear;
    e.setRenderTarget(n),
      (e.autoClear = !1),
      (r = i.clearColor || r),
      (s = i.clearAlpha || s),
      r != null && (e.setClearColor(r), e.setClearAlpha(s || 0), e.clear()),
      (this.scene.overrideMaterial = i),
      e.render(this.scene, this.camera),
      (this.scene.overrideMaterial = null),
      (e.autoClear = o),
      e.setClearColor(this.originalClearColor),
      e.setClearAlpha(a);
  }
  setSize(e, i) {
    (this.width = e),
      (this.height = i),
      this.beautyRenderTarget.setSize(e, i),
      this.ssaoRenderTarget.setSize(e, i),
      this.normalRenderTarget.setSize(e, i),
      this.blurRenderTarget.setSize(e, i),
      this.ssaoMaterial.uniforms.resolution.value.set(e, i),
      this.ssaoMaterial.uniforms.cameraProjectionMatrix.value.copy(
        this.camera.projectionMatrix
      ),
      this.ssaoMaterial.uniforms.cameraInverseProjectionMatrix.value.copy(
        this.camera.projectionMatrixInverse
      ),
      this.blurMaterial.uniforms.resolution.value.set(e, i);
  }
  generateSampleKernel() {
    const e = this.kernelSize,
      i = this.kernel;
    for (let n = 0; n < e; n++) {
      const r = new A();
      (r.x = Math.random() * 2 - 1),
        (r.y = Math.random() * 2 - 1),
        (r.z = Math.random()),
        r.normalize();
      let s = n / e;
      (s = Jt.lerp(0.1, 1, s * s)), r.multiplyScalar(s), i.push(r);
    }
  }
  generateRandomKernelRotations() {
    const n = new KA(),
      r = 4 * 4,
      s = new Float32Array(r);
    for (let a = 0; a < r; a++) {
      const o = Math.random() * 2 - 1,
        l = Math.random() * 2 - 1,
        c = 0;
      s[a] = n.noise3d(o, l, c);
    }
    (this.noiseTexture = new yx(s, 4, 4, Zy, lr)),
      (this.noiseTexture.wrapS = nl),
      (this.noiseTexture.wrapT = nl),
      (this.noiseTexture.needsUpdate = !0);
  }
  overrideVisibility() {
    const e = this.scene,
      i = this._visibilityCache;
    e.traverse(function (n) {
      i.set(n, n.visible), (n.isPoints || n.isLine) && (n.visible = !1);
    });
  }
  restoreVisibility() {
    const e = this.scene,
      i = this._visibilityCache;
    e.traverse(function (n) {
      const r = i.get(n);
      n.visible = r;
    }),
      i.clear();
  }
}
Lr.OUTPUT = { Default: 0, SSAO: 1, Blur: 2, Beauty: 3, Depth: 4, Normal: 5 };
const JA = {
  name: "GammaCorrectionShader",
  uniforms: { tDiffuse: { value: null } },
  vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
  fragmentShader: `

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			vec4 tex = texture2D( tDiffuse, vUv );

			gl_FragColor = LinearTosRGB( tex );

		}`,
};
class QA extends uo {
  constructor(e, i, n, r, s) {
    super(),
      (this.scene = e),
      (this.camera = i),
      (this.overrideMaterial = n),
      (this.clearColor = r),
      (this.clearAlpha = s !== void 0 ? s : 0),
      (this.clear = !0),
      (this.clearDepth = !1),
      (this.needsSwap = !1),
      (this._oldClearColor = new tt());
  }
  render(e, i, n) {
    const r = e.autoClear;
    e.autoClear = !1;
    let s, a;
    this.overrideMaterial !== void 0 &&
      ((a = this.scene.overrideMaterial),
      (this.scene.overrideMaterial = this.overrideMaterial)),
      this.clearColor &&
        (e.getClearColor(this._oldClearColor),
        (s = e.getClearAlpha()),
        e.setClearColor(this.clearColor, this.clearAlpha)),
      this.clearDepth && e.clearDepth(),
      e.setRenderTarget(this.renderToScreen ? null : n),
      this.clear &&
        e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil),
      e.render(this.scene, this.camera),
      this.clearColor && e.setClearColor(this._oldClearColor, s),
      this.overrideMaterial !== void 0 && (this.scene.overrideMaterial = a),
      (e.autoClear = r);
  }
}
const eC = {
  shaderID: "luminosityHighPass",
  uniforms: {
    tDiffuse: { value: null },
    luminosityThreshold: { value: 1 },
    smoothWidth: { value: 1 },
    defaultColor: { value: new tt(0) },
    defaultOpacity: { value: 0 },
  },
  vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
  fragmentShader: `

		uniform sampler2D tDiffuse;
		uniform vec3 defaultColor;
		uniform float defaultOpacity;
		uniform float luminosityThreshold;
		uniform float smoothWidth;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );

			vec3 luma = vec3( 0.299, 0.587, 0.114 );

			float v = dot( texel.xyz, luma );

			vec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );

			float alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );

			gl_FragColor = mix( outputColor, texel, alpha );

		}`,
};
class Za extends uo {
  constructor(e, i, n, r) {
    super(),
      (this.strength = i !== void 0 ? i : 1),
      (this.radius = n),
      (this.threshold = r),
      (this.resolution = e !== void 0 ? new J(e.x, e.y) : new J(256, 256)),
      (this.clearColor = new tt(0, 0, 0)),
      (this.renderTargetsHorizontal = []),
      (this.renderTargetsVertical = []),
      (this.nMips = 5);
    let s = Math.round(this.resolution.x / 2),
      a = Math.round(this.resolution.y / 2);
    (this.renderTargetBright = new rn(s, a, { type: Mn })),
      (this.renderTargetBright.texture.name = "UnrealBloomPass.bright"),
      (this.renderTargetBright.texture.generateMipmaps = !1);
    for (let h = 0; h < this.nMips; h++) {
      const u = new rn(s, a, { type: Mn });
      (u.texture.name = "UnrealBloomPass.h" + h),
        (u.texture.generateMipmaps = !1),
        this.renderTargetsHorizontal.push(u);
      const f = new rn(s, a, { type: Mn });
      (f.texture.name = "UnrealBloomPass.v" + h),
        (f.texture.generateMipmaps = !1),
        this.renderTargetsVertical.push(f),
        (s = Math.round(s / 2)),
        (a = Math.round(a / 2));
    }
    const o = eC;
    (this.highPassUniforms = un.clone(o.uniforms)),
      (this.highPassUniforms.luminosityThreshold.value = r),
      (this.highPassUniforms.smoothWidth.value = 0.01),
      (this.materialHighPassFilter = new Ti({
        uniforms: this.highPassUniforms,
        vertexShader: o.vertexShader,
        fragmentShader: o.fragmentShader,
      })),
      (this.separableBlurMaterials = []);
    const l = [3, 5, 7, 9, 11];
    (s = Math.round(this.resolution.x / 2)),
      (a = Math.round(this.resolution.y / 2));
    for (let h = 0; h < this.nMips; h++)
      this.separableBlurMaterials.push(this.getSeperableBlurMaterial(l[h])),
        (this.separableBlurMaterials[h].uniforms.texSize.value = new J(s, a)),
        (s = Math.round(s / 2)),
        (a = Math.round(a / 2));
    (this.compositeMaterial = this.getCompositeMaterial(this.nMips)),
      (this.compositeMaterial.uniforms.blurTexture1.value =
        this.renderTargetsVertical[0].texture),
      (this.compositeMaterial.uniforms.blurTexture2.value =
        this.renderTargetsVertical[1].texture),
      (this.compositeMaterial.uniforms.blurTexture3.value =
        this.renderTargetsVertical[2].texture),
      (this.compositeMaterial.uniforms.blurTexture4.value =
        this.renderTargetsVertical[3].texture),
      (this.compositeMaterial.uniforms.blurTexture5.value =
        this.renderTargetsVertical[4].texture),
      (this.compositeMaterial.uniforms.bloomStrength.value = i),
      (this.compositeMaterial.uniforms.bloomRadius.value = 0.1);
    const c = [1, 0.8, 0.6, 0.4, 0.2];
    (this.compositeMaterial.uniforms.bloomFactors.value = c),
      (this.bloomTintColors = [
        new A(1, 1, 1),
        new A(1, 1, 1),
        new A(1, 1, 1),
        new A(1, 1, 1),
        new A(1, 1, 1),
      ]),
      (this.compositeMaterial.uniforms.bloomTintColors.value =
        this.bloomTintColors);
    const d = Zo;
    (this.copyUniforms = un.clone(d.uniforms)),
      (this.blendMaterial = new Ti({
        uniforms: this.copyUniforms,
        vertexShader: d.vertexShader,
        fragmentShader: d.fragmentShader,
        blending: ud,
        depthTest: !1,
        depthWrite: !1,
        transparent: !0,
      })),
      (this.enabled = !0),
      (this.needsSwap = !1),
      (this._oldClearColor = new tt()),
      (this.oldClearAlpha = 1),
      (this.basic = new co()),
      (this.fsQuad = new np(null));
  }
  dispose() {
    for (let e = 0; e < this.renderTargetsHorizontal.length; e++)
      this.renderTargetsHorizontal[e].dispose();
    for (let e = 0; e < this.renderTargetsVertical.length; e++)
      this.renderTargetsVertical[e].dispose();
    this.renderTargetBright.dispose();
    for (let e = 0; e < this.separableBlurMaterials.length; e++)
      this.separableBlurMaterials[e].dispose();
    this.compositeMaterial.dispose(),
      this.blendMaterial.dispose(),
      this.basic.dispose(),
      this.fsQuad.dispose();
  }
  setSize(e, i) {
    let n = Math.round(e / 2),
      r = Math.round(i / 2);
    this.renderTargetBright.setSize(n, r);
    for (let s = 0; s < this.nMips; s++)
      this.renderTargetsHorizontal[s].setSize(n, r),
        this.renderTargetsVertical[s].setSize(n, r),
        (this.separableBlurMaterials[s].uniforms.texSize.value = new J(n, r)),
        (n = Math.round(n / 2)),
        (r = Math.round(r / 2));
  }
  render(e, i, n, r, s) {
    e.getClearColor(this._oldClearColor),
      (this.oldClearAlpha = e.getClearAlpha());
    const a = e.autoClear;
    (e.autoClear = !1),
      e.setClearColor(this.clearColor, 0),
      s && e.state.buffers.stencil.setTest(!1),
      this.renderToScreen &&
        ((this.fsQuad.material = this.basic),
        (this.basic.map = n.texture),
        e.setRenderTarget(null),
        e.clear(),
        this.fsQuad.render(e)),
      (this.highPassUniforms.tDiffuse.value = n.texture),
      (this.highPassUniforms.luminosityThreshold.value = this.threshold),
      (this.fsQuad.material = this.materialHighPassFilter),
      e.setRenderTarget(this.renderTargetBright),
      e.clear(),
      this.fsQuad.render(e);
    let o = this.renderTargetBright;
    for (let l = 0; l < this.nMips; l++)
      (this.fsQuad.material = this.separableBlurMaterials[l]),
        (this.separableBlurMaterials[l].uniforms.colorTexture.value =
          o.texture),
        (this.separableBlurMaterials[l].uniforms.direction.value =
          Za.BlurDirectionX),
        e.setRenderTarget(this.renderTargetsHorizontal[l]),
        e.clear(),
        this.fsQuad.render(e),
        (this.separableBlurMaterials[l].uniforms.colorTexture.value =
          this.renderTargetsHorizontal[l].texture),
        (this.separableBlurMaterials[l].uniforms.direction.value =
          Za.BlurDirectionY),
        e.setRenderTarget(this.renderTargetsVertical[l]),
        e.clear(),
        this.fsQuad.render(e),
        (o = this.renderTargetsVertical[l]);
    (this.fsQuad.material = this.compositeMaterial),
      (this.compositeMaterial.uniforms.bloomStrength.value = this.strength),
      (this.compositeMaterial.uniforms.bloomRadius.value = this.radius),
      (this.compositeMaterial.uniforms.bloomTintColors.value =
        this.bloomTintColors),
      e.setRenderTarget(this.renderTargetsHorizontal[0]),
      e.clear(),
      this.fsQuad.render(e),
      (this.fsQuad.material = this.blendMaterial),
      (this.copyUniforms.tDiffuse.value =
        this.renderTargetsHorizontal[0].texture),
      s && e.state.buffers.stencil.setTest(!0),
      this.renderToScreen
        ? (e.setRenderTarget(null), this.fsQuad.render(e))
        : (e.setRenderTarget(n), this.fsQuad.render(e)),
      e.setClearColor(this._oldClearColor, this.oldClearAlpha),
      (e.autoClear = a);
  }
  getSeperableBlurMaterial(e) {
    return new Ti({
      defines: { KERNEL_RADIUS: e, SIGMA: e },
      uniforms: {
        colorTexture: { value: null },
        texSize: { value: new J(0.5, 0.5) },
        direction: { value: new J(0.5, 0.5) },
      },
      vertexShader: `varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,
      fragmentShader: `#include <common>
				varying vec2 vUv;
				uniform sampler2D colorTexture;
				uniform vec2 texSize;
				uniform vec2 direction;

				float gaussianPdf(in float x, in float sigma) {
					return 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;
				}
				void main() {
					vec2 invSize = 1.0 / texSize;
					float fSigma = float(SIGMA);
					float weightSum = gaussianPdf(0.0, fSigma);
					vec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;
					for( int i = 1; i < KERNEL_RADIUS; i ++ ) {
						float x = float(i);
						float w = gaussianPdf(x, fSigma);
						vec2 uvOffset = direction * invSize * x;
						vec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;
						vec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;
						diffuseSum += (sample1 + sample2) * w;
						weightSum += 2.0 * w;
					}
					gl_FragColor = vec4(diffuseSum/weightSum, 1.0);
				}`,
    });
  }
  getCompositeMaterial(e) {
    return new Ti({
      defines: { NUM_MIPS: e },
      uniforms: {
        blurTexture1: { value: null },
        blurTexture2: { value: null },
        blurTexture3: { value: null },
        blurTexture4: { value: null },
        blurTexture5: { value: null },
        bloomStrength: { value: 1 },
        bloomFactors: { value: null },
        bloomTintColors: { value: null },
        bloomRadius: { value: 0 },
      },
      vertexShader: `varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,
      fragmentShader: `varying vec2 vUv;
				uniform sampler2D blurTexture1;
				uniform sampler2D blurTexture2;
				uniform sampler2D blurTexture3;
				uniform sampler2D blurTexture4;
				uniform sampler2D blurTexture5;
				uniform float bloomStrength;
				uniform float bloomRadius;
				uniform float bloomFactors[NUM_MIPS];
				uniform vec3 bloomTintColors[NUM_MIPS];

				float lerpBloomFactor(const in float factor) {
					float mirrorFactor = 1.2 - factor;
					return mix(factor, mirrorFactor, bloomRadius);
				}

				void main() {
					gl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +
						lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +
						lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +
						lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +
						lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );
				}`,
    });
  }
}
Za.BlurDirectionX = new J(1, 0);
Za.BlurDirectionY = new J(0, 1);
function tC(t, e = !1) {
  const i = t[0].index !== null,
    n = new Set(Object.keys(t[0].attributes)),
    r = new Set(Object.keys(t[0].morphAttributes)),
    s = {},
    a = {},
    o = t[0].morphTargetsRelative,
    l = new st();
  let c = 0;
  for (let d = 0; d < t.length; ++d) {
    const h = t[d];
    let u = 0;
    if (i !== (h.index !== null))
      return (
        console.error(
          "THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " +
            d +
            ". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."
        ),
        null
      );
    for (const f in h.attributes) {
      if (!n.has(f))
        return (
          console.error(
            "THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " +
              d +
              '. All geometries must have compatible attributes; make sure "' +
              f +
              '" attribute exists among all geometries, or in none of them.'
          ),
          null
        );
      s[f] === void 0 && (s[f] = []), s[f].push(h.attributes[f]), u++;
    }
    if (u !== n.size)
      return (
        console.error(
          "THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " +
            d +
            ". Make sure all geometries have the same number of attributes."
        ),
        null
      );
    if (o !== h.morphTargetsRelative)
      return (
        console.error(
          "THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " +
            d +
            ". .morphTargetsRelative must be consistent throughout all geometries."
        ),
        null
      );
    for (const f in h.morphAttributes) {
      if (!r.has(f))
        return (
          console.error(
            "THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " +
              d +
              ".  .morphAttributes must be consistent throughout all geometries."
          ),
          null
        );
      a[f] === void 0 && (a[f] = []), a[f].push(h.morphAttributes[f]);
    }
    if (e) {
      let f;
      if (i) f = h.index.count;
      else if (h.attributes.position !== void 0)
        f = h.attributes.position.count;
      else
        return (
          console.error(
            "THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " +
              d +
              ". The geometry must have either an index or a position attribute"
          ),
          null
        );
      l.addGroup(c, f, d), (c += f);
    }
  }
  if (i) {
    let d = 0;
    const h = [];
    for (let u = 0; u < t.length; ++u) {
      const f = t[u].index;
      for (let p = 0; p < f.count; ++p) h.push(f.getX(p) + d);
      d += t[u].attributes.position.count;
    }
    l.setIndex(h);
  }
  for (const d in s) {
    const h = Gg(s[d]);
    if (!h)
      return (
        console.error(
          "THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the " +
            d +
            " attribute."
        ),
        null
      );
    l.setAttribute(d, h);
  }
  for (const d in a) {
    const h = a[d][0].length;
    if (h === 0) break;
    (l.morphAttributes = l.morphAttributes || {}), (l.morphAttributes[d] = []);
    for (let u = 0; u < h; ++u) {
      const f = [];
      for (let v = 0; v < a[d].length; ++v) f.push(a[d][v][u]);
      const p = Gg(f);
      if (!p)
        return (
          console.error(
            "THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the " +
              d +
              " morphAttribute."
          ),
          null
        );
      l.morphAttributes[d].push(p);
    }
  }
  return l;
}
function Gg(t) {
  let e,
    i,
    n,
    r = -1,
    s = 0;
  for (let c = 0; c < t.length; ++c) {
    const d = t[c];
    if (d.isInterleavedBufferAttribute)
      return (
        console.error(
          "THREE.BufferGeometryUtils: .mergeAttributes() failed. InterleavedBufferAttributes are not supported."
        ),
        null
      );
    if ((e === void 0 && (e = d.array.constructor), e !== d.array.constructor))
      return (
        console.error(
          "THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."
        ),
        null
      );
    if ((i === void 0 && (i = d.itemSize), i !== d.itemSize))
      return (
        console.error(
          "THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."
        ),
        null
      );
    if ((n === void 0 && (n = d.normalized), n !== d.normalized))
      return (
        console.error(
          "THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."
        ),
        null
      );
    if ((r === -1 && (r = d.gpuType), r !== d.gpuType))
      return (
        console.error(
          "THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes."
        ),
        null
      );
    s += d.array.length;
  }
  const a = new e(s);
  let o = 0;
  for (let c = 0; c < t.length; ++c)
    a.set(t[c].array, o), (o += t[c].array.length);
  const l = new pt(a, i, n);
  return r !== void 0 && (l.gpuType = r), l;
}
function Lx(t, e = !1) {
  return (
    console.warn(
      "THREE.BufferGeometryUtils: mergeBufferGeometries() has been renamed to mergeGeometries()."
    ),
    tC(t, e)
  );
}
const Pu = new WeakMap();
class iC extends _l {
  constructor(e) {
    super(e),
      (this.decoderPath = ""),
      (this.decoderConfig = {}),
      (this.decoderBinary = null),
      (this.decoderPending = null),
      (this.workerLimit = 4),
      (this.workerPool = []),
      (this.workerNextTaskID = 1),
      (this.workerSourceURL = ""),
      (this.defaultAttributeIDs = {
        position: "POSITION",
        normal: "NORMAL",
        color: "COLOR",
        uv: "TEX_COORD",
      }),
      (this.defaultAttributeTypes = {
        position: "Float32Array",
        normal: "Float32Array",
        color: "Float32Array",
        uv: "Float32Array",
      });
  }
  setDecoderPath(e) {
    return (this.decoderPath = e), this;
  }
  setDecoderConfig(e) {
    return (this.decoderConfig = e), this;
  }
  setWorkerLimit(e) {
    return (this.workerLimit = e), this;
  }
  load(e, i, n, r) {
    const s = new Gc(this.manager);
    s.setPath(this.path),
      s.setResponseType("arraybuffer"),
      s.setRequestHeader(this.requestHeader),
      s.setWithCredentials(this.withCredentials),
      s.load(
        e,
        (a) => {
          this.parse(a, i, r);
        },
        n,
        r
      );
  }
  parse(e, i, n) {
    this.decodeDracoFile(e, i, null, null, gt).catch(n);
  }
  decodeDracoFile(e, i, n, r, s = qn) {
    const a = {
      attributeIDs: n || this.defaultAttributeIDs,
      attributeTypes: r || this.defaultAttributeTypes,
      useUniqueIDs: !!n,
      vertexColorSpace: s,
    };
    return this.decodeGeometry(e, a).then(i);
  }
  decodeGeometry(e, i) {
    const n = JSON.stringify(i);
    if (Pu.has(e)) {
      const l = Pu.get(e);
      if (l.key === n) return l.promise;
      if (e.byteLength === 0)
        throw new Error(
          "THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred."
        );
    }
    let r;
    const s = this.workerNextTaskID++,
      a = e.byteLength,
      o = this._getWorker(s, a)
        .then(
          (l) => (
            (r = l),
            new Promise((c, d) => {
              (r._callbacks[s] = { resolve: c, reject: d }),
                r.postMessage(
                  { type: "decode", id: s, taskConfig: i, buffer: e },
                  [e]
                );
            })
          )
        )
        .then((l) => this._createGeometry(l.geometry));
    return (
      o
        .catch(() => !0)
        .then(() => {
          r && s && this._releaseTask(r, s);
        }),
      Pu.set(e, { key: n, promise: o }),
      o
    );
  }
  _createGeometry(e) {
    const i = new st();
    e.index && i.setIndex(new pt(e.index.array, 1));
    for (let n = 0; n < e.attributes.length; n++) {
      const r = e.attributes[n],
        s = r.name,
        a = r.array,
        o = r.itemSize,
        l = new pt(a, o);
      s === "color" &&
        (this._assignVertexColorSpace(l, r.vertexColorSpace),
        (l.normalized = !(a instanceof Float32Array))),
        i.setAttribute(s, l);
    }
    return i;
  }
  _assignVertexColorSpace(e, i) {
    if (i !== gt) return;
    const n = new tt();
    for (let r = 0, s = e.count; r < s; r++)
      n.fromBufferAttribute(e, r).convertSRGBToLinear(),
        e.setXYZ(r, n.r, n.g, n.b);
  }
  _loadLibrary(e, i) {
    const n = new Gc(this.manager);
    return (
      n.setPath(this.decoderPath),
      n.setResponseType(i),
      n.setWithCredentials(this.withCredentials),
      new Promise((r, s) => {
        n.load(e, r, void 0, s);
      })
    );
  }
  preload() {
    return this._initDecoder(), this;
  }
  _initDecoder() {
    if (this.decoderPending) return this.decoderPending;
    const e =
        typeof WebAssembly != "object" || this.decoderConfig.type === "js",
      i = [];
    return (
      e
        ? i.push(this._loadLibrary("draco_decoder.js", "text"))
        : (i.push(this._loadLibrary("draco_wasm_wrapper.js", "text")),
          i.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))),
      (this.decoderPending = Promise.all(i).then((n) => {
        const r = n[0];
        e || (this.decoderConfig.wasmBinary = n[1]);
        const s = nC.toString(),
          a = [
            "/* draco decoder */",
            r,
            "",
            "/* worker */",
            s.substring(s.indexOf("{") + 1, s.lastIndexOf("}")),
          ].join(`
`);
        this.workerSourceURL = URL.createObjectURL(new Blob([a]));
      })),
      this.decoderPending
    );
  }
  _getWorker(e, i) {
    return this._initDecoder().then(() => {
      if (this.workerPool.length < this.workerLimit) {
        const r = new Worker(this.workerSourceURL);
        (r._callbacks = {}),
          (r._taskCosts = {}),
          (r._taskLoad = 0),
          r.postMessage({ type: "init", decoderConfig: this.decoderConfig }),
          (r.onmessage = function (s) {
            const a = s.data;
            switch (a.type) {
              case "decode":
                r._callbacks[a.id].resolve(a);
                break;
              case "error":
                r._callbacks[a.id].reject(a);
                break;
              default:
                console.error(
                  'THREE.DRACOLoader: Unexpected message, "' + a.type + '"'
                );
            }
          }),
          this.workerPool.push(r);
      } else
        this.workerPool.sort(function (r, s) {
          return r._taskLoad > s._taskLoad ? -1 : 1;
        });
      const n = this.workerPool[this.workerPool.length - 1];
      return (n._taskCosts[e] = i), (n._taskLoad += i), n;
    });
  }
  _releaseTask(e, i) {
    (e._taskLoad -= e._taskCosts[i]),
      delete e._callbacks[i],
      delete e._taskCosts[i];
  }
  debug() {
    console.log(
      "Task load: ",
      this.workerPool.map((e) => e._taskLoad)
    );
  }
  dispose() {
    for (let e = 0; e < this.workerPool.length; ++e)
      this.workerPool[e].terminate();
    return (
      (this.workerPool.length = 0),
      this.workerSourceURL !== "" && URL.revokeObjectURL(this.workerSourceURL),
      this
    );
  }
}
function nC() {
  let t, e;
  onmessage = function (a) {
    const o = a.data;
    switch (o.type) {
      case "init":
        (t = o.decoderConfig),
          (e = new Promise(function (d) {
            (t.onModuleLoaded = function (h) {
              d({ draco: h });
            }),
              DracoDecoderModule(t);
          }));
        break;
      case "decode":
        const l = o.buffer,
          c = o.taskConfig;
        e.then((d) => {
          const h = d.draco,
            u = new h.Decoder();
          try {
            const f = i(h, u, new Int8Array(l), c),
              p = f.attributes.map((v) => v.array.buffer);
            f.index && p.push(f.index.array.buffer),
              self.postMessage({ type: "decode", id: o.id, geometry: f }, p);
          } catch (f) {
            console.error(f),
              self.postMessage({ type: "error", id: o.id, error: f.message });
          } finally {
            h.destroy(u);
          }
        });
        break;
    }
  };
  function i(a, o, l, c) {
    const d = c.attributeIDs,
      h = c.attributeTypes;
    let u, f;
    const p = o.GetEncodedGeometryType(l);
    if (p === a.TRIANGULAR_MESH)
      (u = new a.Mesh()), (f = o.DecodeArrayToMesh(l, l.byteLength, u));
    else if (p === a.POINT_CLOUD)
      (u = new a.PointCloud()),
        (f = o.DecodeArrayToPointCloud(l, l.byteLength, u));
    else throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
    if (!f.ok() || u.ptr === 0)
      throw new Error("THREE.DRACOLoader: Decoding failed: " + f.error_msg());
    const v = { index: null, attributes: [] };
    for (const g in d) {
      const m = self[h[g]];
      let x, y;
      if (c.useUniqueIDs) (y = d[g]), (x = o.GetAttributeByUniqueId(u, y));
      else {
        if (((y = o.GetAttributeId(u, a[d[g]])), y === -1)) continue;
        x = o.GetAttribute(u, y);
      }
      const _ = r(a, o, u, g, m, x);
      g === "color" && (_.vertexColorSpace = c.vertexColorSpace),
        v.attributes.push(_);
    }
    return p === a.TRIANGULAR_MESH && (v.index = n(a, o, u)), a.destroy(u), v;
  }
  function n(a, o, l) {
    const d = l.num_faces() * 3,
      h = d * 4,
      u = a._malloc(h);
    o.GetTrianglesUInt32Array(l, h, u);
    const f = new Uint32Array(a.HEAPF32.buffer, u, d).slice();
    return a._free(u), { array: f, itemSize: 1 };
  }
  function r(a, o, l, c, d, h) {
    const u = h.num_components(),
      p = l.num_points() * u,
      v = p * d.BYTES_PER_ELEMENT,
      g = s(a, d),
      m = a._malloc(v);
    o.GetAttributeDataArrayForAllPoints(l, h, g, v, m);
    const x = new d(a.HEAPF32.buffer, m, p).slice();
    return a._free(m), { name: c, array: x, itemSize: u };
  }
  function s(a, o) {
    switch (o) {
      case Float32Array:
        return a.DT_FLOAT32;
      case Int8Array:
        return a.DT_INT8;
      case Int16Array:
        return a.DT_INT16;
      case Int32Array:
        return a.DT_INT32;
      case Uint8Array:
        return a.DT_UINT8;
      case Uint16Array:
        return a.DT_UINT16;
      case Uint32Array:
        return a.DT_UINT32;
    }
  }
}
var rC = Object.create,
  rp = Object.defineProperty,
  sC = Object.getOwnPropertyDescriptor,
  aC = Object.getOwnPropertyNames,
  oC = Object.getPrototypeOf,
  lC = Object.prototype.hasOwnProperty,
  fo = (t, e) => () => (e || t((e = { exports: {} }).exports, e), e.exports),
  cC = (t, e) => {
    for (var i in e) rp(t, i, { get: e[i], enumerable: !0 });
  },
  hC = (t, e, i, n) => {
    if ((e && typeof e == "object") || typeof e == "function")
      for (let r of aC(e))
        !lC.call(t, r) &&
          r !== i &&
          rp(t, r, {
            get: () => e[r],
            enumerable: !(n = sC(e, r)) || n.enumerable,
          });
    return t;
  },
  wl = (t, e, i) => (
    (i = t != null ? rC(oC(t)) : {}),
    hC(
      e || !t || !t.__esModule
        ? rp(i, "default", { value: t, enumerable: !0 })
        : i,
      t
    )
  ),
  uC = fo((t, e) => {
    (function (i, n) {
      typeof t == "object"
        ? (e.exports = n())
        : typeof define == "function" && define.amd
        ? define(n)
        : (i.Alea = n());
    })(t, function () {
      return (
        (i.importState = function (r) {
          var s = new i();
          return s.importState(r), s;
        }),
        i
      );
      function i() {
        return (function (r) {
          var s = 0,
            a = 0,
            o = 0,
            l = 1;
          r.length == 0 && (r = [+new Date()]);
          var c = n();
          (s = c(" ")), (a = c(" ")), (o = c(" "));
          for (var d = 0; d < r.length; d++)
            (s -= c(r[d])),
              s < 0 && (s += 1),
              (a -= c(r[d])),
              a < 0 && (a += 1),
              (o -= c(r[d])),
              o < 0 && (o += 1);
          c = null;
          var h = function () {
            var u = 2091639 * s + l * 23283064365386963e-26;
            return (s = a), (a = o), (o = u - (l = u | 0));
          };
          return (
            (h.next = h),
            (h.uint32 = function () {
              return h() * 4294967296;
            }),
            (h.fract53 = function () {
              return h() + ((h() * 2097152) | 0) * 11102230246251565e-32;
            }),
            (h.version = "Alea 0.9"),
            (h.args = r),
            (h.exportState = function () {
              return [s, a, o, l];
            }),
            (h.importState = function (u) {
              (s = +u[0] || 0),
                (a = +u[1] || 0),
                (o = +u[2] || 0),
                (l = +u[3] || 0);
            }),
            h
          );
        })(Array.prototype.slice.call(arguments));
      }
      function n() {
        var r = 4022871197,
          s = function (a) {
            a = a.toString();
            for (var o = 0; o < a.length; o++) {
              r += a.charCodeAt(o);
              var l = 0.02519603282416938 * r;
              (r = l >>> 0),
                (l -= r),
                (l *= r),
                (r = l >>> 0),
                (l -= r),
                (r += l * 4294967296);
            }
            return (r >>> 0) * 23283064365386963e-26;
          };
        return (s.version = "Mash 0.9"), s;
      }
    });
  }),
  dC = fo((t, e) => {
    (function (i, n) {
      typeof t == "object" && typeof e < "u"
        ? n(t)
        : typeof define == "function" && define.amd
        ? define(["exports"], n)
        : n(
            ((i = typeof globalThis < "u" ? globalThis : i || self).SVDJS = {})
          );
    })(t, function (i) {
      (i.SVD = function (n, r, s, a, o) {
        if (
          ((r = r === void 0 || r),
          (s = s === void 0 || s),
          (o = 1e-64 / (a = a || Math.pow(2, -52))),
          !n)
        )
          throw new TypeError("Matrix a is not defined");
        var l,
          c,
          d,
          h,
          u,
          f,
          p,
          v,
          g,
          m,
          x,
          y,
          _ = n[0].length,
          M = n.length;
        if (M < _) throw new TypeError("Invalid matrix: m < n");
        for (
          var b = [], E = [], T = [], S = r === "f" ? M : _, w = (m = p = 0);
          w < M;
          w++
        )
          E[w] = new Array(S).fill(0);
        for (w = 0; w < _; w++) T[w] = new Array(_).fill(0);
        var C,
          L = new Array(_).fill(0);
        for (w = 0; w < M; w++) for (l = 0; l < _; l++) E[w][l] = n[w][l];
        for (w = 0; w < _; w++) {
          for (b[w] = p, g = 0, d = w + 1, l = w; l < M; l++)
            g += Math.pow(E[l][w], 2);
          if (g < o) p = 0;
          else
            for (
              v =
                (f = E[w][w]) * (p = f < 0 ? Math.sqrt(g) : -Math.sqrt(g)) - g,
                E[w][w] = f - p,
                l = d;
              l < _;
              l++
            ) {
              for (g = 0, c = w; c < M; c++) g += E[c][w] * E[c][l];
              for (f = g / v, c = w; c < M; c++)
                E[c][l] = E[c][l] + f * E[c][w];
            }
          for (L[w] = p, g = 0, l = d; l < _; l++) g += Math.pow(E[w][l], 2);
          if (g < o) p = 0;
          else {
            for (
              v =
                (f = E[w][w + 1]) * (p = f < 0 ? Math.sqrt(g) : -Math.sqrt(g)) -
                g,
                E[w][w + 1] = f - p,
                l = d;
              l < _;
              l++
            )
              b[l] = E[w][l] / v;
            for (l = d; l < M; l++) {
              for (g = 0, c = d; c < _; c++) g += E[l][c] * E[w][c];
              for (c = d; c < _; c++) E[l][c] = E[l][c] + g * b[c];
            }
          }
          m < (x = Math.abs(L[w]) + Math.abs(b[w])) && (m = x);
        }
        if (s)
          for (w = _ - 1; 0 <= w; w--) {
            if (p !== 0) {
              for (v = E[w][w + 1] * p, l = d; l < _; l++)
                T[l][w] = E[w][l] / v;
              for (l = d; l < _; l++) {
                for (g = 0, c = d; c < _; c++) g += E[w][c] * T[c][l];
                for (c = d; c < _; c++) T[c][l] = T[c][l] + g * T[c][w];
              }
            }
            for (l = d; l < _; l++) (T[w][l] = 0), (T[l][w] = 0);
            (T[w][w] = 1), (p = b[w]), (d = w);
          }
        if (r) {
          if (r === "f")
            for (w = _; w < M; w++) {
              for (l = _; l < M; l++) E[w][l] = 0;
              E[w][w] = 1;
            }
          for (w = _ - 1; 0 <= w; w--) {
            for (d = w + 1, p = L[w], l = d; l < S; l++) E[w][l] = 0;
            if (p !== 0) {
              for (v = E[w][w] * p, l = d; l < S; l++) {
                for (g = 0, c = d; c < M; c++) g += E[c][w] * E[c][l];
                for (f = g / v, c = w; c < M; c++)
                  E[c][l] = E[c][l] + f * E[c][w];
              }
              for (l = w; l < M; l++) E[l][w] = E[l][w] / p;
            } else for (l = w; l < M; l++) E[l][w] = 0;
            E[w][w] = E[w][w] + 1;
          }
        }
        for (a *= m, c = _ - 1; 0 <= c; c--)
          for (var P = 0; P < 50; P++) {
            for (C = !1, d = c; 0 <= d; d--) {
              if (Math.abs(b[d]) <= a) {
                C = !0;
                break;
              }
              if (Math.abs(L[d - 1]) <= a) break;
            }
            if (!C) {
              for (
                u = 0, h = d - (g = 1), w = d;
                w < c + 1 &&
                ((f = g * b[w]), (b[w] = u * b[w]), !(Math.abs(f) <= a));
                w++
              )
                if (
                  ((p = L[w]),
                  (L[w] = Math.sqrt(f * f + p * p)),
                  (u = p / (v = L[w])),
                  (g = -f / v),
                  r)
                )
                  for (l = 0; l < M; l++)
                    (x = E[l][h]),
                      (y = E[l][w]),
                      (E[l][h] = x * u + y * g),
                      (E[l][w] = -x * g + y * u);
            }
            if (((y = L[c]), d === c)) {
              if (y < 0 && ((L[c] = -y), s))
                for (l = 0; l < _; l++) T[l][c] = -T[l][c];
              break;
            }
            for (
              m = L[d],
                f =
                  (((x = L[c - 1]) - y) * (x + y) +
                    ((p = b[c - 1]) - (v = b[c])) * (p + v)) /
                  (2 * v * x),
                p = Math.sqrt(f * f + 1),
                f =
                  ((m - y) * (m + y) + v * (x / (f < 0 ? f - p : f + p) - v)) /
                  m,
                w = d + (g = u = 1);
              w < c + 1;
              w++
            ) {
              if (
                ((p = b[w]),
                (x = L[w]),
                (v = g * p),
                (p *= u),
                (y = Math.sqrt(f * f + v * v)),
                (f = m * (u = f / (b[w - 1] = y)) + p * (g = v / y)),
                (p = -m * g + p * u),
                (v = x * g),
                (x *= u),
                s)
              )
                for (l = 0; l < _; l++)
                  (m = T[l][w - 1]),
                    (y = T[l][w]),
                    (T[l][w - 1] = m * u + y * g),
                    (T[l][w] = -m * g + y * u);
              if (
                ((y = Math.sqrt(f * f + v * v)),
                (f = (u = f / (L[w - 1] = y)) * p + (g = v / y) * x),
                (m = -g * p + u * x),
                r)
              )
                for (l = 0; l < M; l++)
                  (x = E[l][w - 1]),
                    (y = E[l][w]),
                    (E[l][w - 1] = x * u + y * g),
                    (E[l][w] = -x * g + y * u);
            }
            (b[d] = 0), (b[c] = f), (L[c] = m);
          }
        for (w = 0; w < _; w++) L[w] < a && (L[w] = 0);
        return { u: E, q: L, v: T };
      }),
        (i.VERSION = "1.1.1"),
        Object.defineProperty(i, "__esModule", { value: !0 });
    });
  }),
  fC = fo((t, e) => {
    (function (i, n) {
      typeof t == "object" && typeof e < "u"
        ? (e.exports = n())
        : typeof define == "function" && define.amd
        ? define(n)
        : ((i = i || self), (i.TinyQueue = n()));
    })(t, function () {
      var i = function (r, s) {
        if (
          (r === void 0 && (r = []),
          s === void 0 && (s = n),
          (this.data = r),
          (this.length = this.data.length),
          (this.compare = s),
          this.length > 0)
        )
          for (var a = (this.length >> 1) - 1; a >= 0; a--) this._down(a);
      };
      (i.prototype.push = function (r) {
        this.data.push(r), this.length++, this._up(this.length - 1);
      }),
        (i.prototype.pop = function () {
          if (this.length !== 0) {
            var r = this.data[0],
              s = this.data.pop();
            return (
              this.length--,
              this.length > 0 && ((this.data[0] = s), this._down(0)),
              r
            );
          }
        }),
        (i.prototype.peek = function () {
          return this.data[0];
        }),
        (i.prototype._up = function (r) {
          for (var s = this, a = s.data, o = s.compare, l = a[r]; r > 0; ) {
            var c = (r - 1) >> 1,
              d = a[c];
            if (o(l, d) >= 0) break;
            (a[r] = d), (r = c);
          }
          a[r] = l;
        }),
        (i.prototype._down = function (r) {
          for (
            var s = this,
              a = s.data,
              o = s.compare,
              l = this.length >> 1,
              c = a[r];
            r < l;

          ) {
            var d = (r << 1) + 1,
              h = a[d],
              u = d + 1;
            if (
              (u < this.length && o(a[u], h) < 0 && ((d = u), (h = a[u])),
              o(h, c) >= 0)
            )
              break;
            (a[r] = h), (r = d);
          }
          a[r] = c;
        });
      function n(r, s) {
        return r < s ? -1 : r > s ? 1 : 0;
      }
      return i;
    });
  }),
  pC = fo((t, e) => {
    var i = fC();
    i.default && (i = i.default), (e.exports = n), (e.exports.default = n);
    function n(c, d, h) {
      d = d || 1;
      for (var u, f, p, v, g = 0; g < c[0].length; g++) {
        var m = c[0][g];
        (!g || m[0] < u) && (u = m[0]),
          (!g || m[1] < f) && (f = m[1]),
          (!g || m[0] > p) && (p = m[0]),
          (!g || m[1] > v) && (v = m[1]);
      }
      var x = p - u,
        y = v - f,
        _ = Math.min(x, y),
        M = _ / 2;
      if (_ === 0) {
        var b = [u, f];
        return (b.distance = 0), b;
      }
      for (var E = new i(void 0, r), T = u; T < p; T += _)
        for (var S = f; S < v; S += _) E.push(new s(T + M, S + M, M, c));
      var w = o(c),
        C = new s(u + x / 2, f + y / 2, 0, c);
      C.d > w.d && (w = C);
      for (var L = E.length; E.length; ) {
        var P = E.pop();
        P.d > w.d &&
          ((w = P),
          h &&
            console.log(
              "found best %d after %d probes",
              Math.round(1e4 * P.d) / 1e4,
              L
            )),
          !(P.max - w.d <= d) &&
            ((M = P.h / 2),
            E.push(new s(P.x - M, P.y - M, M, c)),
            E.push(new s(P.x + M, P.y - M, M, c)),
            E.push(new s(P.x - M, P.y + M, M, c)),
            E.push(new s(P.x + M, P.y + M, M, c)),
            (L += 4));
      }
      h &&
        (console.log("num probes: " + L), console.log("best distance: " + w.d));
      var R = [w.x, w.y];
      return (R.distance = w.d), R;
    }
    function r(c, d) {
      return d.max - c.max;
    }
    function s(c, d, h, u) {
      (this.x = c),
        (this.y = d),
        (this.h = h),
        (this.d = a(c, d, u)),
        (this.max = this.d + this.h * Math.SQRT2);
    }
    function a(c, d, h) {
      for (var u = !1, f = 1 / 0, p = 0; p < h.length; p++)
        for (var v = h[p], g = 0, m = v.length, x = m - 1; g < m; x = g++) {
          var y = v[g],
            _ = v[x];
          y[1] > d != _[1] > d &&
            c < ((_[0] - y[0]) * (d - y[1])) / (_[1] - y[1]) + y[0] &&
            (u = !u),
            (f = Math.min(f, l(c, d, y, _)));
        }
      return f === 0 ? 0 : (u ? 1 : -1) * Math.sqrt(f);
    }
    function o(c) {
      for (
        var d = 0, h = 0, u = 0, f = c[0], p = 0, v = f.length, g = v - 1;
        p < v;
        g = p++
      ) {
        var m = f[p],
          x = f[g],
          y = m[0] * x[1] - x[0] * m[1];
        (h += (m[0] + x[0]) * y), (u += (m[1] + x[1]) * y), (d += y * 3);
      }
      return d === 0
        ? new s(f[0][0], f[0][1], 0, c)
        : new s(h / d, u / d, 0, c);
    }
    function l(c, d, h, u) {
      var f = h[0],
        p = h[1],
        v = u[0] - f,
        g = u[1] - p;
      if (v !== 0 || g !== 0) {
        var m = ((c - f) * v + (d - p) * g) / (v * v + g * g);
        m > 1
          ? ((f = u[0]), (p = u[1]))
          : m > 0 && ((f += v * m), (p += g * m));
      }
      return (v = c - f), (g = d - p), v * v + g * g;
    }
  }),
  mC = fo((t) => {
    (function () {
      var e = function () {
        this.init();
      };
      e.prototype = {
        init: function () {
          var h = this || i;
          return (
            (h._counter = 1e3),
            (h._html5AudioPool = []),
            (h.html5PoolSize = 10),
            (h._codecs = {}),
            (h._howls = []),
            (h._muted = !1),
            (h._volume = 1),
            (h._canPlayEvent = "canplaythrough"),
            (h._navigator =
              typeof window < "u" && window.navigator
                ? window.navigator
                : null),
            (h.masterGain = null),
            (h.noAudio = !1),
            (h.usingWebAudio = !0),
            (h.autoSuspend = !0),
            (h.ctx = null),
            (h.autoUnlock = !0),
            h._setup(),
            h
          );
        },
        volume: function (h) {
          var u = this || i;
          if (
            ((h = parseFloat(h)),
            u.ctx || d(),
            typeof h < "u" && h >= 0 && h <= 1)
          ) {
            if (((u._volume = h), u._muted)) return u;
            u.usingWebAudio &&
              u.masterGain.gain.setValueAtTime(h, i.ctx.currentTime);
            for (var f = 0; f < u._howls.length; f++)
              if (!u._howls[f]._webAudio)
                for (
                  var p = u._howls[f]._getSoundIds(), v = 0;
                  v < p.length;
                  v++
                ) {
                  var g = u._howls[f]._soundById(p[v]);
                  g && g._node && (g._node.volume = g._volume * h);
                }
            return u;
          }
          return u._volume;
        },
        mute: function (h) {
          var u = this || i;
          u.ctx || d(),
            (u._muted = h),
            u.usingWebAudio &&
              u.masterGain.gain.setValueAtTime(
                h ? 0 : u._volume,
                i.ctx.currentTime
              );
          for (var f = 0; f < u._howls.length; f++)
            if (!u._howls[f]._webAudio)
              for (
                var p = u._howls[f]._getSoundIds(), v = 0;
                v < p.length;
                v++
              ) {
                var g = u._howls[f]._soundById(p[v]);
                g && g._node && (g._node.muted = h ? !0 : g._muted);
              }
          return u;
        },
        stop: function () {
          for (var h = this || i, u = 0; u < h._howls.length; u++)
            h._howls[u].stop();
          return h;
        },
        unload: function () {
          for (var h = this || i, u = h._howls.length - 1; u >= 0; u--)
            h._howls[u].unload();
          return (
            h.usingWebAudio &&
              h.ctx &&
              typeof h.ctx.close < "u" &&
              (h.ctx.close(), (h.ctx = null), d()),
            h
          );
        },
        codecs: function (h) {
          return (this || i)._codecs[h.replace(/^x-/, "")];
        },
        _setup: function () {
          var h = this || i;
          if (
            ((h.state = (h.ctx && h.ctx.state) || "suspended"),
            h._autoSuspend(),
            !h.usingWebAudio)
          )
            if (typeof Audio < "u")
              try {
                var u = new Audio();
                typeof u.oncanplaythrough > "u" &&
                  (h._canPlayEvent = "canplay");
              } catch {
                h.noAudio = !0;
              }
            else h.noAudio = !0;
          try {
            var u = new Audio();
            u.muted && (h.noAudio = !0);
          } catch {}
          return h.noAudio || h._setupCodecs(), h;
        },
        _setupCodecs: function () {
          var h = this || i,
            u = null;
          try {
            u = typeof Audio < "u" ? new Audio() : null;
          } catch {
            return h;
          }
          if (!u || typeof u.canPlayType != "function") return h;
          var f = u.canPlayType("audio/mpeg;").replace(/^no$/, ""),
            p = h._navigator ? h._navigator.userAgent : "",
            v = p.match(/OPR\/([0-6].)/g),
            g = v && parseInt(v[0].split("/")[1], 10) < 33,
            m = p.indexOf("Safari") !== -1 && p.indexOf("Chrome") === -1,
            x = p.match(/Version\/(.*?) /),
            y = m && x && parseInt(x[1], 10) < 15;
          return (
            (h._codecs = {
              mp3: !!(
                !g &&
                (f || u.canPlayType("audio/mp3;").replace(/^no$/, ""))
              ),
              mpeg: !!f,
              opus: !!u
                .canPlayType('audio/ogg; codecs="opus"')
                .replace(/^no$/, ""),
              ogg: !!u
                .canPlayType('audio/ogg; codecs="vorbis"')
                .replace(/^no$/, ""),
              oga: !!u
                .canPlayType('audio/ogg; codecs="vorbis"')
                .replace(/^no$/, ""),
              wav: !!(
                u.canPlayType('audio/wav; codecs="1"') ||
                u.canPlayType("audio/wav")
              ).replace(/^no$/, ""),
              aac: !!u.canPlayType("audio/aac;").replace(/^no$/, ""),
              caf: !!u.canPlayType("audio/x-caf;").replace(/^no$/, ""),
              m4a: !!(
                u.canPlayType("audio/x-m4a;") ||
                u.canPlayType("audio/m4a;") ||
                u.canPlayType("audio/aac;")
              ).replace(/^no$/, ""),
              m4b: !!(
                u.canPlayType("audio/x-m4b;") ||
                u.canPlayType("audio/m4b;") ||
                u.canPlayType("audio/aac;")
              ).replace(/^no$/, ""),
              mp4: !!(
                u.canPlayType("audio/x-mp4;") ||
                u.canPlayType("audio/mp4;") ||
                u.canPlayType("audio/aac;")
              ).replace(/^no$/, ""),
              weba: !!(
                !y &&
                u.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")
              ),
              webm: !!(
                !y &&
                u.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")
              ),
              dolby: !!u
                .canPlayType('audio/mp4; codecs="ec-3"')
                .replace(/^no$/, ""),
              flac: !!(
                u.canPlayType("audio/x-flac;") || u.canPlayType("audio/flac;")
              ).replace(/^no$/, ""),
            }),
            h
          );
        },
        _unlockAudio: function () {
          var h = this || i;
          if (!(h._audioUnlocked || !h.ctx)) {
            (h._audioUnlocked = !1),
              (h.autoUnlock = !1),
              !h._mobileUnloaded &&
                h.ctx.sampleRate !== 44100 &&
                ((h._mobileUnloaded = !0), h.unload()),
              (h._scratchBuffer = h.ctx.createBuffer(1, 1, 22050));
            var u = function (f) {
              for (; h._html5AudioPool.length < h.html5PoolSize; )
                try {
                  var p = new Audio();
                  (p._unlocked = !0), h._releaseHtml5Audio(p);
                } catch {
                  h.noAudio = !0;
                  break;
                }
              for (var v = 0; v < h._howls.length; v++)
                if (!h._howls[v]._webAudio)
                  for (
                    var g = h._howls[v]._getSoundIds(), m = 0;
                    m < g.length;
                    m++
                  ) {
                    var x = h._howls[v]._soundById(g[m]);
                    x &&
                      x._node &&
                      !x._node._unlocked &&
                      ((x._node._unlocked = !0), x._node.load());
                  }
              h._autoResume();
              var y = h.ctx.createBufferSource();
              (y.buffer = h._scratchBuffer),
                y.connect(h.ctx.destination),
                typeof y.start > "u" ? y.noteOn(0) : y.start(0),
                typeof h.ctx.resume == "function" && h.ctx.resume(),
                (y.onended = function () {
                  y.disconnect(0),
                    (h._audioUnlocked = !0),
                    document.removeEventListener("touchstart", u, !0),
                    document.removeEventListener("touchend", u, !0),
                    document.removeEventListener("click", u, !0),
                    document.removeEventListener("keydown", u, !0);
                  for (var _ = 0; _ < h._howls.length; _++)
                    h._howls[_]._emit("unlock");
                });
            };
            return (
              document.addEventListener("touchstart", u, !0),
              document.addEventListener("touchend", u, !0),
              document.addEventListener("click", u, !0),
              document.addEventListener("keydown", u, !0),
              h
            );
          }
        },
        _obtainHtml5Audio: function () {
          var h = this || i;
          if (h._html5AudioPool.length) return h._html5AudioPool.pop();
          var u = new Audio().play();
          return (
            u &&
              typeof Promise < "u" &&
              (u instanceof Promise || typeof u.then == "function") &&
              u.catch(function () {
                console.warn(
                  "HTML5 Audio pool exhausted, returning potentially locked audio object."
                );
              }),
            new Audio()
          );
        },
        _releaseHtml5Audio: function (h) {
          var u = this || i;
          return h._unlocked && u._html5AudioPool.push(h), u;
        },
        _autoSuspend: function () {
          var h = this;
          if (
            !(
              !h.autoSuspend ||
              !h.ctx ||
              typeof h.ctx.suspend > "u" ||
              !i.usingWebAudio
            )
          ) {
            for (var u = 0; u < h._howls.length; u++)
              if (h._howls[u]._webAudio) {
                for (var f = 0; f < h._howls[u]._sounds.length; f++)
                  if (!h._howls[u]._sounds[f]._paused) return h;
              }
            return (
              h._suspendTimer && clearTimeout(h._suspendTimer),
              (h._suspendTimer = setTimeout(function () {
                if (h.autoSuspend) {
                  (h._suspendTimer = null), (h.state = "suspending");
                  var p = function () {
                    (h.state = "suspended"),
                      h._resumeAfterSuspend &&
                        (delete h._resumeAfterSuspend, h._autoResume());
                  };
                  h.ctx.suspend().then(p, p);
                }
              }, 3e4)),
              h
            );
          }
        },
        _autoResume: function () {
          var h = this;
          if (!(!h.ctx || typeof h.ctx.resume > "u" || !i.usingWebAudio))
            return (
              h.state === "running" &&
              h.ctx.state !== "interrupted" &&
              h._suspendTimer
                ? (clearTimeout(h._suspendTimer), (h._suspendTimer = null))
                : h.state === "suspended" ||
                  (h.state === "running" && h.ctx.state === "interrupted")
                ? (h.ctx.resume().then(function () {
                    h.state = "running";
                    for (var u = 0; u < h._howls.length; u++)
                      h._howls[u]._emit("resume");
                  }),
                  h._suspendTimer &&
                    (clearTimeout(h._suspendTimer), (h._suspendTimer = null)))
                : h.state === "suspending" && (h._resumeAfterSuspend = !0),
              h
            );
        },
      };
      var i = new e(),
        n = function (h) {
          var u = this;
          if (!h.src || h.src.length === 0) {
            console.error(
              "An array of source files must be passed with any new Howl."
            );
            return;
          }
          u.init(h);
        };
      n.prototype = {
        init: function (h) {
          var u = this;
          return (
            i.ctx || d(),
            (u._autoplay = h.autoplay || !1),
            (u._format = typeof h.format != "string" ? h.format : [h.format]),
            (u._html5 = h.html5 || !1),
            (u._muted = h.mute || !1),
            (u._loop = h.loop || !1),
            (u._pool = h.pool || 5),
            (u._preload =
              typeof h.preload == "boolean" || h.preload === "metadata"
                ? h.preload
                : !0),
            (u._rate = h.rate || 1),
            (u._sprite = h.sprite || {}),
            (u._src = typeof h.src != "string" ? h.src : [h.src]),
            (u._volume = h.volume !== void 0 ? h.volume : 1),
            (u._xhr = {
              method: h.xhr && h.xhr.method ? h.xhr.method : "GET",
              headers: h.xhr && h.xhr.headers ? h.xhr.headers : null,
              withCredentials:
                h.xhr && h.xhr.withCredentials ? h.xhr.withCredentials : !1,
            }),
            (u._duration = 0),
            (u._state = "unloaded"),
            (u._sounds = []),
            (u._endTimers = {}),
            (u._queue = []),
            (u._playLock = !1),
            (u._onend = h.onend ? [{ fn: h.onend }] : []),
            (u._onfade = h.onfade ? [{ fn: h.onfade }] : []),
            (u._onload = h.onload ? [{ fn: h.onload }] : []),
            (u._onloaderror = h.onloaderror ? [{ fn: h.onloaderror }] : []),
            (u._onplayerror = h.onplayerror ? [{ fn: h.onplayerror }] : []),
            (u._onpause = h.onpause ? [{ fn: h.onpause }] : []),
            (u._onplay = h.onplay ? [{ fn: h.onplay }] : []),
            (u._onstop = h.onstop ? [{ fn: h.onstop }] : []),
            (u._onmute = h.onmute ? [{ fn: h.onmute }] : []),
            (u._onvolume = h.onvolume ? [{ fn: h.onvolume }] : []),
            (u._onrate = h.onrate ? [{ fn: h.onrate }] : []),
            (u._onseek = h.onseek ? [{ fn: h.onseek }] : []),
            (u._onunlock = h.onunlock ? [{ fn: h.onunlock }] : []),
            (u._onresume = []),
            (u._webAudio = i.usingWebAudio && !u._html5),
            typeof i.ctx < "u" && i.ctx && i.autoUnlock && i._unlockAudio(),
            i._howls.push(u),
            u._autoplay &&
              u._queue.push({
                event: "play",
                action: function () {
                  u.play();
                },
              }),
            u._preload && u._preload !== "none" && u.load(),
            u
          );
        },
        load: function () {
          var h = this,
            u = null;
          if (i.noAudio) {
            h._emit("loaderror", null, "No audio support.");
            return;
          }
          typeof h._src == "string" && (h._src = [h._src]);
          for (var f = 0; f < h._src.length; f++) {
            var p, v;
            if (h._format && h._format[f]) p = h._format[f];
            else {
              if (((v = h._src[f]), typeof v != "string")) {
                h._emit(
                  "loaderror",
                  null,
                  "Non-string found in selected audio sources - ignoring."
                );
                continue;
              }
              (p = /^data:audio\/([^;,]+);/i.exec(v)),
                p || (p = /\.([^.]+)$/.exec(v.split("?", 1)[0])),
                p && (p = p[1].toLowerCase());
            }
            if (
              (p ||
                console.warn(
                  'No file extension was found. Consider using the "format" property or specify an extension.'
                ),
              p && i.codecs(p))
            ) {
              u = h._src[f];
              break;
            }
          }
          if (!u) {
            h._emit(
              "loaderror",
              null,
              "No codec support for selected audio sources."
            );
            return;
          }
          return (
            (h._src = u),
            (h._state = "loading"),
            window.location.protocol === "https:" &&
              u.slice(0, 5) === "http:" &&
              ((h._html5 = !0), (h._webAudio = !1)),
            new r(h),
            h._webAudio && a(h),
            h
          );
        },
        play: function (h, u) {
          var f = this,
            p = null;
          if (typeof h == "number") (p = h), (h = null);
          else {
            if (typeof h == "string" && f._state === "loaded" && !f._sprite[h])
              return null;
            if (typeof h > "u" && ((h = "__default"), !f._playLock)) {
              for (var v = 0, g = 0; g < f._sounds.length; g++)
                f._sounds[g]._paused &&
                  !f._sounds[g]._ended &&
                  (v++, (p = f._sounds[g]._id));
              v === 1 ? (h = null) : (p = null);
            }
          }
          var m = p ? f._soundById(p) : f._inactiveSound();
          if (!m) return null;
          if (
            (p && !h && (h = m._sprite || "__default"), f._state !== "loaded")
          ) {
            (m._sprite = h), (m._ended = !1);
            var x = m._id;
            return (
              f._queue.push({
                event: "play",
                action: function () {
                  f.play(x);
                },
              }),
              x
            );
          }
          if (p && !m._paused) return u || f._loadQueue("play"), m._id;
          f._webAudio && i._autoResume();
          var y = Math.max(0, m._seek > 0 ? m._seek : f._sprite[h][0] / 1e3),
            _ = Math.max(0, (f._sprite[h][0] + f._sprite[h][1]) / 1e3 - y),
            M = (_ * 1e3) / Math.abs(m._rate),
            b = f._sprite[h][0] / 1e3,
            E = (f._sprite[h][0] + f._sprite[h][1]) / 1e3;
          (m._sprite = h), (m._ended = !1);
          var T = function () {
            (m._paused = !1),
              (m._seek = y),
              (m._start = b),
              (m._stop = E),
              (m._loop = !!(m._loop || f._sprite[h][2]));
          };
          if (y >= E) {
            f._ended(m);
            return;
          }
          var S = m._node;
          if (f._webAudio) {
            var w = function () {
              (f._playLock = !1), T(), f._refreshBuffer(m);
              var R = m._muted || f._muted ? 0 : m._volume;
              S.gain.setValueAtTime(R, i.ctx.currentTime),
                (m._playStart = i.ctx.currentTime),
                typeof S.bufferSource.start > "u"
                  ? m._loop
                    ? S.bufferSource.noteGrainOn(0, y, 86400)
                    : S.bufferSource.noteGrainOn(0, y, _)
                  : m._loop
                  ? S.bufferSource.start(0, y, 86400)
                  : S.bufferSource.start(0, y, _),
                M !== 1 / 0 &&
                  (f._endTimers[m._id] = setTimeout(f._ended.bind(f, m), M)),
                u ||
                  setTimeout(function () {
                    f._emit("play", m._id), f._loadQueue();
                  }, 0);
            };
            i.state === "running" && i.ctx.state !== "interrupted"
              ? w()
              : ((f._playLock = !0), f.once("resume", w), f._clearTimer(m._id));
          } else {
            var C = function () {
              (S.currentTime = y),
                (S.muted = m._muted || f._muted || i._muted || S.muted),
                (S.volume = m._volume * i.volume()),
                (S.playbackRate = m._rate);
              try {
                var R = S.play();
                if (
                  (R &&
                  typeof Promise < "u" &&
                  (R instanceof Promise || typeof R.then == "function")
                    ? ((f._playLock = !0),
                      T(),
                      R.then(function () {
                        (f._playLock = !1),
                          (S._unlocked = !0),
                          u ? f._loadQueue() : f._emit("play", m._id);
                      }).catch(function () {
                        (f._playLock = !1),
                          f._emit(
                            "playerror",
                            m._id,
                            "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction."
                          ),
                          (m._ended = !0),
                          (m._paused = !0);
                      }))
                    : u || ((f._playLock = !1), T(), f._emit("play", m._id)),
                  (S.playbackRate = m._rate),
                  S.paused)
                ) {
                  f._emit(
                    "playerror",
                    m._id,
                    "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction."
                  );
                  return;
                }
                h !== "__default" || m._loop
                  ? (f._endTimers[m._id] = setTimeout(f._ended.bind(f, m), M))
                  : ((f._endTimers[m._id] = function () {
                      f._ended(m),
                        S.removeEventListener("ended", f._endTimers[m._id], !1);
                    }),
                    S.addEventListener("ended", f._endTimers[m._id], !1));
              } catch (I) {
                f._emit("playerror", m._id, I);
              }
            };
            S.src ===
              "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA" &&
              ((S.src = f._src), S.load());
            var L =
              (window && window.ejecta) ||
              (!S.readyState && i._navigator.isCocoonJS);
            if (S.readyState >= 3 || L) C();
            else {
              (f._playLock = !0), (f._state = "loading");
              var P = function () {
                (f._state = "loaded"),
                  C(),
                  S.removeEventListener(i._canPlayEvent, P, !1);
              };
              S.addEventListener(i._canPlayEvent, P, !1), f._clearTimer(m._id);
            }
          }
          return m._id;
        },
        pause: function (h) {
          var u = this;
          if (u._state !== "loaded" || u._playLock)
            return (
              u._queue.push({
                event: "pause",
                action: function () {
                  u.pause(h);
                },
              }),
              u
            );
          for (var f = u._getSoundIds(h), p = 0; p < f.length; p++) {
            u._clearTimer(f[p]);
            var v = u._soundById(f[p]);
            if (
              v &&
              !v._paused &&
              ((v._seek = u.seek(f[p])),
              (v._rateSeek = 0),
              (v._paused = !0),
              u._stopFade(f[p]),
              v._node)
            )
              if (u._webAudio) {
                if (!v._node.bufferSource) continue;
                typeof v._node.bufferSource.stop > "u"
                  ? v._node.bufferSource.noteOff(0)
                  : v._node.bufferSource.stop(0),
                  u._cleanBuffer(v._node);
              } else
                (!isNaN(v._node.duration) || v._node.duration === 1 / 0) &&
                  v._node.pause();
            arguments[1] || u._emit("pause", v ? v._id : null);
          }
          return u;
        },
        stop: function (h, u) {
          var f = this;
          if (f._state !== "loaded" || f._playLock)
            return (
              f._queue.push({
                event: "stop",
                action: function () {
                  f.stop(h);
                },
              }),
              f
            );
          for (var p = f._getSoundIds(h), v = 0; v < p.length; v++) {
            f._clearTimer(p[v]);
            var g = f._soundById(p[v]);
            g &&
              ((g._seek = g._start || 0),
              (g._rateSeek = 0),
              (g._paused = !0),
              (g._ended = !0),
              f._stopFade(p[v]),
              g._node &&
                (f._webAudio
                  ? g._node.bufferSource &&
                    (typeof g._node.bufferSource.stop > "u"
                      ? g._node.bufferSource.noteOff(0)
                      : g._node.bufferSource.stop(0),
                    f._cleanBuffer(g._node))
                  : (!isNaN(g._node.duration) || g._node.duration === 1 / 0) &&
                    ((g._node.currentTime = g._start || 0),
                    g._node.pause(),
                    g._node.duration === 1 / 0 && f._clearSound(g._node))),
              u || f._emit("stop", g._id));
          }
          return f;
        },
        mute: function (h, u) {
          var f = this;
          if (f._state !== "loaded" || f._playLock)
            return (
              f._queue.push({
                event: "mute",
                action: function () {
                  f.mute(h, u);
                },
              }),
              f
            );
          if (typeof u > "u")
            if (typeof h == "boolean") f._muted = h;
            else return f._muted;
          for (var p = f._getSoundIds(u), v = 0; v < p.length; v++) {
            var g = f._soundById(p[v]);
            g &&
              ((g._muted = h),
              g._interval && f._stopFade(g._id),
              f._webAudio && g._node
                ? g._node.gain.setValueAtTime(
                    h ? 0 : g._volume,
                    i.ctx.currentTime
                  )
                : g._node && (g._node.muted = i._muted ? !0 : h),
              f._emit("mute", g._id));
          }
          return f;
        },
        volume: function () {
          var h = this,
            u = arguments,
            f,
            p;
          if (u.length === 0) return h._volume;
          if (u.length === 1 || (u.length === 2 && typeof u[1] > "u")) {
            var v = h._getSoundIds(),
              g = v.indexOf(u[0]);
            g >= 0 ? (p = parseInt(u[0], 10)) : (f = parseFloat(u[0]));
          } else
            u.length >= 2 && ((f = parseFloat(u[0])), (p = parseInt(u[1], 10)));
          var m;
          if (typeof f < "u" && f >= 0 && f <= 1) {
            if (h._state !== "loaded" || h._playLock)
              return (
                h._queue.push({
                  event: "volume",
                  action: function () {
                    h.volume.apply(h, u);
                  },
                }),
                h
              );
            typeof p > "u" && (h._volume = f), (p = h._getSoundIds(p));
            for (var x = 0; x < p.length; x++)
              (m = h._soundById(p[x])),
                m &&
                  ((m._volume = f),
                  u[2] || h._stopFade(p[x]),
                  h._webAudio && m._node && !m._muted
                    ? m._node.gain.setValueAtTime(f, i.ctx.currentTime)
                    : m._node && !m._muted && (m._node.volume = f * i.volume()),
                  h._emit("volume", m._id));
          } else
            return (m = p ? h._soundById(p) : h._sounds[0]), m ? m._volume : 0;
          return h;
        },
        fade: function (h, u, f, p) {
          var v = this;
          if (v._state !== "loaded" || v._playLock)
            return (
              v._queue.push({
                event: "fade",
                action: function () {
                  v.fade(h, u, f, p);
                },
              }),
              v
            );
          (h = Math.min(Math.max(0, parseFloat(h)), 1)),
            (u = Math.min(Math.max(0, parseFloat(u)), 1)),
            (f = parseFloat(f)),
            v.volume(h, p);
          for (var g = v._getSoundIds(p), m = 0; m < g.length; m++) {
            var x = v._soundById(g[m]);
            if (x) {
              if ((p || v._stopFade(g[m]), v._webAudio && !x._muted)) {
                var y = i.ctx.currentTime,
                  _ = y + f / 1e3;
                (x._volume = h),
                  x._node.gain.setValueAtTime(h, y),
                  x._node.gain.linearRampToValueAtTime(u, _);
              }
              v._startFadeInterval(x, h, u, f, g[m], typeof p > "u");
            }
          }
          return v;
        },
        _startFadeInterval: function (h, u, f, p, v, g) {
          var m = this,
            x = u,
            y = f - u,
            _ = Math.abs(y / 0.01),
            M = Math.max(4, _ > 0 ? p / _ : p),
            b = Date.now();
          (h._fadeTo = f),
            (h._interval = setInterval(function () {
              var E = (Date.now() - b) / p;
              (b = Date.now()),
                (x += y * E),
                (x = Math.round(x * 100) / 100),
                y < 0 ? (x = Math.max(f, x)) : (x = Math.min(f, x)),
                m._webAudio ? (h._volume = x) : m.volume(x, h._id, !0),
                g && (m._volume = x),
                ((f < u && x <= f) || (f > u && x >= f)) &&
                  (clearInterval(h._interval),
                  (h._interval = null),
                  (h._fadeTo = null),
                  m.volume(f, h._id),
                  m._emit("fade", h._id));
            }, M));
        },
        _stopFade: function (h) {
          var u = this,
            f = u._soundById(h);
          return (
            f &&
              f._interval &&
              (u._webAudio &&
                f._node.gain.cancelScheduledValues(i.ctx.currentTime),
              clearInterval(f._interval),
              (f._interval = null),
              u.volume(f._fadeTo, h),
              (f._fadeTo = null),
              u._emit("fade", h)),
            u
          );
        },
        loop: function () {
          var h = this,
            u = arguments,
            f,
            p,
            v;
          if (u.length === 0) return h._loop;
          if (u.length === 1)
            if (typeof u[0] == "boolean") (f = u[0]), (h._loop = f);
            else
              return (v = h._soundById(parseInt(u[0], 10))), v ? v._loop : !1;
          else u.length === 2 && ((f = u[0]), (p = parseInt(u[1], 10)));
          for (var g = h._getSoundIds(p), m = 0; m < g.length; m++)
            (v = h._soundById(g[m])),
              v &&
                ((v._loop = f),
                h._webAudio &&
                  v._node &&
                  v._node.bufferSource &&
                  ((v._node.bufferSource.loop = f),
                  f &&
                    ((v._node.bufferSource.loopStart = v._start || 0),
                    (v._node.bufferSource.loopEnd = v._stop),
                    h.playing(g[m]) && (h.pause(g[m], !0), h.play(g[m], !0)))));
          return h;
        },
        rate: function () {
          var h = this,
            u = arguments,
            f,
            p;
          if (u.length === 0) p = h._sounds[0]._id;
          else if (u.length === 1) {
            var v = h._getSoundIds(),
              g = v.indexOf(u[0]);
            g >= 0 ? (p = parseInt(u[0], 10)) : (f = parseFloat(u[0]));
          } else
            u.length === 2 &&
              ((f = parseFloat(u[0])), (p = parseInt(u[1], 10)));
          var m;
          if (typeof f == "number") {
            if (h._state !== "loaded" || h._playLock)
              return (
                h._queue.push({
                  event: "rate",
                  action: function () {
                    h.rate.apply(h, u);
                  },
                }),
                h
              );
            typeof p > "u" && (h._rate = f), (p = h._getSoundIds(p));
            for (var x = 0; x < p.length; x++)
              if (((m = h._soundById(p[x])), m)) {
                h.playing(p[x]) &&
                  ((m._rateSeek = h.seek(p[x])),
                  (m._playStart = h._webAudio
                    ? i.ctx.currentTime
                    : m._playStart)),
                  (m._rate = f),
                  h._webAudio && m._node && m._node.bufferSource
                    ? m._node.bufferSource.playbackRate.setValueAtTime(
                        f,
                        i.ctx.currentTime
                      )
                    : m._node && (m._node.playbackRate = f);
                var y = h.seek(p[x]),
                  _ =
                    (h._sprite[m._sprite][0] + h._sprite[m._sprite][1]) / 1e3 -
                    y,
                  M = (_ * 1e3) / Math.abs(m._rate);
                (h._endTimers[p[x]] || !m._paused) &&
                  (h._clearTimer(p[x]),
                  (h._endTimers[p[x]] = setTimeout(h._ended.bind(h, m), M))),
                  h._emit("rate", m._id);
              }
          } else return (m = h._soundById(p)), m ? m._rate : h._rate;
          return h;
        },
        seek: function () {
          var h = this,
            u = arguments,
            f,
            p;
          if (u.length === 0) h._sounds.length && (p = h._sounds[0]._id);
          else if (u.length === 1) {
            var v = h._getSoundIds(),
              g = v.indexOf(u[0]);
            g >= 0
              ? (p = parseInt(u[0], 10))
              : h._sounds.length &&
                ((p = h._sounds[0]._id), (f = parseFloat(u[0])));
          } else
            u.length === 2 &&
              ((f = parseFloat(u[0])), (p = parseInt(u[1], 10)));
          if (typeof p > "u") return 0;
          if (typeof f == "number" && (h._state !== "loaded" || h._playLock))
            return (
              h._queue.push({
                event: "seek",
                action: function () {
                  h.seek.apply(h, u);
                },
              }),
              h
            );
          var m = h._soundById(p);
          if (m)
            if (typeof f == "number" && f >= 0) {
              var x = h.playing(p);
              x && h.pause(p, !0),
                (m._seek = f),
                (m._ended = !1),
                h._clearTimer(p),
                !h._webAudio &&
                  m._node &&
                  !isNaN(m._node.duration) &&
                  (m._node.currentTime = f);
              var y = function () {
                x && h.play(p, !0), h._emit("seek", p);
              };
              if (x && !h._webAudio) {
                var _ = function () {
                  h._playLock ? setTimeout(_, 0) : y();
                };
                setTimeout(_, 0);
              } else y();
            } else if (h._webAudio) {
              var M = h.playing(p) ? i.ctx.currentTime - m._playStart : 0,
                b = m._rateSeek ? m._rateSeek - m._seek : 0;
              return m._seek + (b + M * Math.abs(m._rate));
            } else return m._node.currentTime;
          return h;
        },
        playing: function (h) {
          var u = this;
          if (typeof h == "number") {
            var f = u._soundById(h);
            return f ? !f._paused : !1;
          }
          for (var p = 0; p < u._sounds.length; p++)
            if (!u._sounds[p]._paused) return !0;
          return !1;
        },
        duration: function (h) {
          var u = this,
            f = u._duration,
            p = u._soundById(h);
          return p && (f = u._sprite[p._sprite][1] / 1e3), f;
        },
        state: function () {
          return this._state;
        },
        unload: function () {
          for (var h = this, u = h._sounds, f = 0; f < u.length; f++)
            u[f]._paused || h.stop(u[f]._id),
              h._webAudio ||
                (h._clearSound(u[f]._node),
                u[f]._node.removeEventListener("error", u[f]._errorFn, !1),
                u[f]._node.removeEventListener(
                  i._canPlayEvent,
                  u[f]._loadFn,
                  !1
                ),
                u[f]._node.removeEventListener("ended", u[f]._endFn, !1),
                i._releaseHtml5Audio(u[f]._node)),
              delete u[f]._node,
              h._clearTimer(u[f]._id);
          var p = i._howls.indexOf(h);
          p >= 0 && i._howls.splice(p, 1);
          var v = !0;
          for (f = 0; f < i._howls.length; f++)
            if (
              i._howls[f]._src === h._src ||
              h._src.indexOf(i._howls[f]._src) >= 0
            ) {
              v = !1;
              break;
            }
          return (
            s && v && delete s[h._src],
            (i.noAudio = !1),
            (h._state = "unloaded"),
            (h._sounds = []),
            (h = null),
            null
          );
        },
        on: function (h, u, f, p) {
          var v = this,
            g = v["_on" + h];
          return (
            typeof u == "function" &&
              g.push(p ? { id: f, fn: u, once: p } : { id: f, fn: u }),
            v
          );
        },
        off: function (h, u, f) {
          var p = this,
            v = p["_on" + h],
            g = 0;
          if ((typeof u == "number" && ((f = u), (u = null)), u || f))
            for (g = 0; g < v.length; g++) {
              var m = f === v[g].id;
              if ((u === v[g].fn && m) || (!u && m)) {
                v.splice(g, 1);
                break;
              }
            }
          else if (h) p["_on" + h] = [];
          else {
            var x = Object.keys(p);
            for (g = 0; g < x.length; g++)
              x[g].indexOf("_on") === 0 &&
                Array.isArray(p[x[g]]) &&
                (p[x[g]] = []);
          }
          return p;
        },
        once: function (h, u, f) {
          var p = this;
          return p.on(h, u, f, 1), p;
        },
        _emit: function (h, u, f) {
          for (var p = this, v = p["_on" + h], g = v.length - 1; g >= 0; g--)
            (!v[g].id || v[g].id === u || h === "load") &&
              (setTimeout(
                function (m) {
                  m.call(this, u, f);
                }.bind(p, v[g].fn),
                0
              ),
              v[g].once && p.off(h, v[g].fn, v[g].id));
          return p._loadQueue(h), p;
        },
        _loadQueue: function (h) {
          var u = this;
          if (u._queue.length > 0) {
            var f = u._queue[0];
            f.event === h && (u._queue.shift(), u._loadQueue()),
              h || f.action();
          }
          return u;
        },
        _ended: function (h) {
          var u = this,
            f = h._sprite;
          if (
            !u._webAudio &&
            h._node &&
            !h._node.paused &&
            !h._node.ended &&
            h._node.currentTime < h._stop
          )
            return setTimeout(u._ended.bind(u, h), 100), u;
          var p = !!(h._loop || u._sprite[f][2]);
          if (
            (u._emit("end", h._id),
            !u._webAudio && p && u.stop(h._id, !0).play(h._id),
            u._webAudio && p)
          ) {
            u._emit("play", h._id),
              (h._seek = h._start || 0),
              (h._rateSeek = 0),
              (h._playStart = i.ctx.currentTime);
            var v = ((h._stop - h._start) * 1e3) / Math.abs(h._rate);
            u._endTimers[h._id] = setTimeout(u._ended.bind(u, h), v);
          }
          return (
            u._webAudio &&
              !p &&
              ((h._paused = !0),
              (h._ended = !0),
              (h._seek = h._start || 0),
              (h._rateSeek = 0),
              u._clearTimer(h._id),
              u._cleanBuffer(h._node),
              i._autoSuspend()),
            !u._webAudio && !p && u.stop(h._id, !0),
            u
          );
        },
        _clearTimer: function (h) {
          var u = this;
          if (u._endTimers[h]) {
            if (typeof u._endTimers[h] != "function")
              clearTimeout(u._endTimers[h]);
            else {
              var f = u._soundById(h);
              f &&
                f._node &&
                f._node.removeEventListener("ended", u._endTimers[h], !1);
            }
            delete u._endTimers[h];
          }
          return u;
        },
        _soundById: function (h) {
          for (var u = this, f = 0; f < u._sounds.length; f++)
            if (h === u._sounds[f]._id) return u._sounds[f];
          return null;
        },
        _inactiveSound: function () {
          var h = this;
          h._drain();
          for (var u = 0; u < h._sounds.length; u++)
            if (h._sounds[u]._ended) return h._sounds[u].reset();
          return new r(h);
        },
        _drain: function () {
          var h = this,
            u = h._pool,
            f = 0,
            p = 0;
          if (!(h._sounds.length < u)) {
            for (p = 0; p < h._sounds.length; p++) h._sounds[p]._ended && f++;
            for (p = h._sounds.length - 1; p >= 0; p--) {
              if (f <= u) return;
              h._sounds[p]._ended &&
                (h._webAudio &&
                  h._sounds[p]._node &&
                  h._sounds[p]._node.disconnect(0),
                h._sounds.splice(p, 1),
                f--);
            }
          }
        },
        _getSoundIds: function (h) {
          var u = this;
          if (typeof h > "u") {
            for (var f = [], p = 0; p < u._sounds.length; p++)
              f.push(u._sounds[p]._id);
            return f;
          } else return [h];
        },
        _refreshBuffer: function (h) {
          var u = this;
          return (
            (h._node.bufferSource = i.ctx.createBufferSource()),
            (h._node.bufferSource.buffer = s[u._src]),
            h._panner
              ? h._node.bufferSource.connect(h._panner)
              : h._node.bufferSource.connect(h._node),
            (h._node.bufferSource.loop = h._loop),
            h._loop &&
              ((h._node.bufferSource.loopStart = h._start || 0),
              (h._node.bufferSource.loopEnd = h._stop || 0)),
            h._node.bufferSource.playbackRate.setValueAtTime(
              h._rate,
              i.ctx.currentTime
            ),
            u
          );
        },
        _cleanBuffer: function (h) {
          var u = this,
            f = i._navigator && i._navigator.vendor.indexOf("Apple") >= 0;
          if (
            i._scratchBuffer &&
            h.bufferSource &&
            ((h.bufferSource.onended = null), h.bufferSource.disconnect(0), f)
          )
            try {
              h.bufferSource.buffer = i._scratchBuffer;
            } catch {}
          return (h.bufferSource = null), u;
        },
        _clearSound: function (h) {
          var u = /MSIE |Trident\//.test(
            i._navigator && i._navigator.userAgent
          );
          u ||
            (h.src =
              "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA");
        },
      };
      var r = function (h) {
        (this._parent = h), this.init();
      };
      r.prototype = {
        init: function () {
          var h = this,
            u = h._parent;
          return (
            (h._muted = u._muted),
            (h._loop = u._loop),
            (h._volume = u._volume),
            (h._rate = u._rate),
            (h._seek = 0),
            (h._paused = !0),
            (h._ended = !0),
            (h._sprite = "__default"),
            (h._id = ++i._counter),
            u._sounds.push(h),
            h.create(),
            h
          );
        },
        create: function () {
          var h = this,
            u = h._parent,
            f = i._muted || h._muted || h._parent._muted ? 0 : h._volume;
          return (
            u._webAudio
              ? ((h._node =
                  typeof i.ctx.createGain > "u"
                    ? i.ctx.createGainNode()
                    : i.ctx.createGain()),
                h._node.gain.setValueAtTime(f, i.ctx.currentTime),
                (h._node.paused = !0),
                h._node.connect(i.masterGain))
              : i.noAudio ||
                ((h._node = i._obtainHtml5Audio()),
                (h._errorFn = h._errorListener.bind(h)),
                h._node.addEventListener("error", h._errorFn, !1),
                (h._loadFn = h._loadListener.bind(h)),
                h._node.addEventListener(i._canPlayEvent, h._loadFn, !1),
                (h._endFn = h._endListener.bind(h)),
                h._node.addEventListener("ended", h._endFn, !1),
                (h._node.src = u._src),
                (h._node.preload = u._preload === !0 ? "auto" : u._preload),
                (h._node.volume = f * i.volume()),
                h._node.load()),
            h
          );
        },
        reset: function () {
          var h = this,
            u = h._parent;
          return (
            (h._muted = u._muted),
            (h._loop = u._loop),
            (h._volume = u._volume),
            (h._rate = u._rate),
            (h._seek = 0),
            (h._rateSeek = 0),
            (h._paused = !0),
            (h._ended = !0),
            (h._sprite = "__default"),
            (h._id = ++i._counter),
            h
          );
        },
        _errorListener: function () {
          var h = this;
          h._parent._emit(
            "loaderror",
            h._id,
            h._node.error ? h._node.error.code : 0
          ),
            h._node.removeEventListener("error", h._errorFn, !1);
        },
        _loadListener: function () {
          var h = this,
            u = h._parent;
          (u._duration = Math.ceil(h._node.duration * 10) / 10),
            Object.keys(u._sprite).length === 0 &&
              (u._sprite = { __default: [0, u._duration * 1e3] }),
            u._state !== "loaded" &&
              ((u._state = "loaded"), u._emit("load"), u._loadQueue()),
            h._node.removeEventListener(i._canPlayEvent, h._loadFn, !1);
        },
        _endListener: function () {
          var h = this,
            u = h._parent;
          u._duration === 1 / 0 &&
            ((u._duration = Math.ceil(h._node.duration * 10) / 10),
            u._sprite.__default[1] === 1 / 0 &&
              (u._sprite.__default[1] = u._duration * 1e3),
            u._ended(h)),
            h._node.removeEventListener("ended", h._endFn, !1);
        },
      };
      var s = {},
        a = function (h) {
          var u = h._src;
          if (s[u]) {
            (h._duration = s[u].duration), c(h);
            return;
          }
          if (/^data:[^;]+;base64,/.test(u)) {
            for (
              var f = atob(u.split(",")[1]),
                p = new Uint8Array(f.length),
                v = 0;
              v < f.length;
              ++v
            )
              p[v] = f.charCodeAt(v);
            l(p.buffer, h);
          } else {
            var g = new XMLHttpRequest();
            g.open(h._xhr.method, u, !0),
              (g.withCredentials = h._xhr.withCredentials),
              (g.responseType = "arraybuffer"),
              h._xhr.headers &&
                Object.keys(h._xhr.headers).forEach(function (m) {
                  g.setRequestHeader(m, h._xhr.headers[m]);
                }),
              (g.onload = function () {
                var m = (g.status + "")[0];
                if (m !== "0" && m !== "2" && m !== "3") {
                  h._emit(
                    "loaderror",
                    null,
                    "Failed loading audio file with status: " + g.status + "."
                  );
                  return;
                }
                l(g.response, h);
              }),
              (g.onerror = function () {
                h._webAudio &&
                  ((h._html5 = !0),
                  (h._webAudio = !1),
                  (h._sounds = []),
                  delete s[u],
                  h.load());
              }),
              o(g);
          }
        },
        o = function (h) {
          try {
            h.send();
          } catch {
            h.onerror();
          }
        },
        l = function (h, u) {
          var f = function () {
              u._emit("loaderror", null, "Decoding audio data failed.");
            },
            p = function (v) {
              v && u._sounds.length > 0 ? ((s[u._src] = v), c(u, v)) : f();
            };
          typeof Promise < "u" && i.ctx.decodeAudioData.length === 1
            ? i.ctx.decodeAudioData(h).then(p).catch(f)
            : i.ctx.decodeAudioData(h, p, f);
        },
        c = function (h, u) {
          u && !h._duration && (h._duration = u.duration),
            Object.keys(h._sprite).length === 0 &&
              (h._sprite = { __default: [0, h._duration * 1e3] }),
            h._state !== "loaded" &&
              ((h._state = "loaded"), h._emit("load"), h._loadQueue());
        },
        d = function () {
          if (i.usingWebAudio) {
            try {
              typeof AudioContext < "u"
                ? (i.ctx = new AudioContext())
                : typeof webkitAudioContext < "u"
                ? (i.ctx = new webkitAudioContext())
                : (i.usingWebAudio = !1);
            } catch {
              i.usingWebAudio = !1;
            }
            i.ctx || (i.usingWebAudio = !1);
            var h = /iP(hone|od|ad)/.test(
                i._navigator && i._navigator.platform
              ),
              u =
                i._navigator &&
                i._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/),
              f = u ? parseInt(u[1], 10) : null;
            if (h && f && f < 9) {
              var p = /safari/.test(
                i._navigator && i._navigator.userAgent.toLowerCase()
              );
              i._navigator && !p && (i.usingWebAudio = !1);
            }
            i.usingWebAudio &&
              ((i.masterGain =
                typeof i.ctx.createGain > "u"
                  ? i.ctx.createGainNode()
                  : i.ctx.createGain()),
              i.masterGain.gain.setValueAtTime(
                i._muted ? 0 : i._volume,
                i.ctx.currentTime
              ),
              i.masterGain.connect(i.ctx.destination)),
              i._setup();
          }
        };
      typeof define == "function" &&
        define.amd &&
        define([], function () {
          return { Howler: i, Howl: n };
        }),
        typeof t < "u" && ((t.Howler = i), (t.Howl = n)),
        typeof global < "u"
          ? ((global.HowlerGlobal = e),
            (global.Howler = i),
            (global.Howl = n),
            (global.Sound = r))
          : typeof window < "u" &&
            ((window.HowlerGlobal = e),
            (window.Howler = i),
            (window.Howl = n),
            (window.Sound = r));
    })(),
      (function () {
        (HowlerGlobal.prototype._pos = [0, 0, 0]),
          (HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0]),
          (HowlerGlobal.prototype.stereo = function (i) {
            var n = this;
            if (!n.ctx || !n.ctx.listener) return n;
            for (var r = n._howls.length - 1; r >= 0; r--)
              n._howls[r].stereo(i);
            return n;
          }),
          (HowlerGlobal.prototype.pos = function (i, n, r) {
            var s = this;
            if (!s.ctx || !s.ctx.listener) return s;
            if (
              ((n = typeof n != "number" ? s._pos[1] : n),
              (r = typeof r != "number" ? s._pos[2] : r),
              typeof i == "number")
            )
              (s._pos = [i, n, r]),
                typeof s.ctx.listener.positionX < "u"
                  ? (s.ctx.listener.positionX.setTargetAtTime(
                      s._pos[0],
                      Howler.ctx.currentTime,
                      0.1
                    ),
                    s.ctx.listener.positionY.setTargetAtTime(
                      s._pos[1],
                      Howler.ctx.currentTime,
                      0.1
                    ),
                    s.ctx.listener.positionZ.setTargetAtTime(
                      s._pos[2],
                      Howler.ctx.currentTime,
                      0.1
                    ))
                  : s.ctx.listener.setPosition(s._pos[0], s._pos[1], s._pos[2]);
            else return s._pos;
            return s;
          }),
          (HowlerGlobal.prototype.orientation = function (i, n, r, s, a, o) {
            var l = this;
            if (!l.ctx || !l.ctx.listener) return l;
            var c = l._orientation;
            if (
              ((n = typeof n != "number" ? c[1] : n),
              (r = typeof r != "number" ? c[2] : r),
              (s = typeof s != "number" ? c[3] : s),
              (a = typeof a != "number" ? c[4] : a),
              (o = typeof o != "number" ? c[5] : o),
              typeof i == "number")
            )
              (l._orientation = [i, n, r, s, a, o]),
                typeof l.ctx.listener.forwardX < "u"
                  ? (l.ctx.listener.forwardX.setTargetAtTime(
                      i,
                      Howler.ctx.currentTime,
                      0.1
                    ),
                    l.ctx.listener.forwardY.setTargetAtTime(
                      n,
                      Howler.ctx.currentTime,
                      0.1
                    ),
                    l.ctx.listener.forwardZ.setTargetAtTime(
                      r,
                      Howler.ctx.currentTime,
                      0.1
                    ),
                    l.ctx.listener.upX.setTargetAtTime(
                      s,
                      Howler.ctx.currentTime,
                      0.1
                    ),
                    l.ctx.listener.upY.setTargetAtTime(
                      a,
                      Howler.ctx.currentTime,
                      0.1
                    ),
                    l.ctx.listener.upZ.setTargetAtTime(
                      o,
                      Howler.ctx.currentTime,
                      0.1
                    ))
                  : l.ctx.listener.setOrientation(i, n, r, s, a, o);
            else return c;
            return l;
          }),
          (Howl.prototype.init = (function (i) {
            return function (n) {
              var r = this;
              return (
                (r._orientation = n.orientation || [1, 0, 0]),
                (r._stereo = n.stereo || null),
                (r._pos = n.pos || null),
                (r._pannerAttr = {
                  coneInnerAngle:
                    typeof n.coneInnerAngle < "u" ? n.coneInnerAngle : 360,
                  coneOuterAngle:
                    typeof n.coneOuterAngle < "u" ? n.coneOuterAngle : 360,
                  coneOuterGain:
                    typeof n.coneOuterGain < "u" ? n.coneOuterGain : 0,
                  distanceModel:
                    typeof n.distanceModel < "u" ? n.distanceModel : "inverse",
                  maxDistance: typeof n.maxDistance < "u" ? n.maxDistance : 1e4,
                  panningModel:
                    typeof n.panningModel < "u" ? n.panningModel : "HRTF",
                  refDistance: typeof n.refDistance < "u" ? n.refDistance : 1,
                  rolloffFactor:
                    typeof n.rolloffFactor < "u" ? n.rolloffFactor : 1,
                }),
                (r._onstereo = n.onstereo ? [{ fn: n.onstereo }] : []),
                (r._onpos = n.onpos ? [{ fn: n.onpos }] : []),
                (r._onorientation = n.onorientation
                  ? [{ fn: n.onorientation }]
                  : []),
                i.call(this, n)
              );
            };
          })(Howl.prototype.init)),
          (Howl.prototype.stereo = function (i, n) {
            var r = this;
            if (!r._webAudio) return r;
            if (r._state !== "loaded")
              return (
                r._queue.push({
                  event: "stereo",
                  action: function () {
                    r.stereo(i, n);
                  },
                }),
                r
              );
            var s =
              typeof Howler.ctx.createStereoPanner > "u" ? "spatial" : "stereo";
            if (typeof n > "u")
              if (typeof i == "number") (r._stereo = i), (r._pos = [i, 0, 0]);
              else return r._stereo;
            for (var a = r._getSoundIds(n), o = 0; o < a.length; o++) {
              var l = r._soundById(a[o]);
              if (l)
                if (typeof i == "number")
                  (l._stereo = i),
                    (l._pos = [i, 0, 0]),
                    l._node &&
                      ((l._pannerAttr.panningModel = "equalpower"),
                      (!l._panner || !l._panner.pan) && e(l, s),
                      s === "spatial"
                        ? typeof l._panner.positionX < "u"
                          ? (l._panner.positionX.setValueAtTime(
                              i,
                              Howler.ctx.currentTime
                            ),
                            l._panner.positionY.setValueAtTime(
                              0,
                              Howler.ctx.currentTime
                            ),
                            l._panner.positionZ.setValueAtTime(
                              0,
                              Howler.ctx.currentTime
                            ))
                          : l._panner.setPosition(i, 0, 0)
                        : l._panner.pan.setValueAtTime(
                            i,
                            Howler.ctx.currentTime
                          )),
                    r._emit("stereo", l._id);
                else return l._stereo;
            }
            return r;
          }),
          (Howl.prototype.pos = function (i, n, r, s) {
            var a = this;
            if (!a._webAudio) return a;
            if (a._state !== "loaded")
              return (
                a._queue.push({
                  event: "pos",
                  action: function () {
                    a.pos(i, n, r, s);
                  },
                }),
                a
              );
            if (
              ((n = typeof n != "number" ? 0 : n),
              (r = typeof r != "number" ? -0.5 : r),
              typeof s > "u")
            )
              if (typeof i == "number") a._pos = [i, n, r];
              else return a._pos;
            for (var o = a._getSoundIds(s), l = 0; l < o.length; l++) {
              var c = a._soundById(o[l]);
              if (c)
                if (typeof i == "number")
                  (c._pos = [i, n, r]),
                    c._node &&
                      ((!c._panner || c._panner.pan) && e(c, "spatial"),
                      typeof c._panner.positionX < "u"
                        ? (c._panner.positionX.setValueAtTime(
                            i,
                            Howler.ctx.currentTime
                          ),
                          c._panner.positionY.setValueAtTime(
                            n,
                            Howler.ctx.currentTime
                          ),
                          c._panner.positionZ.setValueAtTime(
                            r,
                            Howler.ctx.currentTime
                          ))
                        : c._panner.setPosition(i, n, r)),
                    a._emit("pos", c._id);
                else return c._pos;
            }
            return a;
          }),
          (Howl.prototype.orientation = function (i, n, r, s) {
            var a = this;
            if (!a._webAudio) return a;
            if (a._state !== "loaded")
              return (
                a._queue.push({
                  event: "orientation",
                  action: function () {
                    a.orientation(i, n, r, s);
                  },
                }),
                a
              );
            if (
              ((n = typeof n != "number" ? a._orientation[1] : n),
              (r = typeof r != "number" ? a._orientation[2] : r),
              typeof s > "u")
            )
              if (typeof i == "number") a._orientation = [i, n, r];
              else return a._orientation;
            for (var o = a._getSoundIds(s), l = 0; l < o.length; l++) {
              var c = a._soundById(o[l]);
              if (c)
                if (typeof i == "number")
                  (c._orientation = [i, n, r]),
                    c._node &&
                      (c._panner ||
                        (c._pos || (c._pos = a._pos || [0, 0, -0.5]),
                        e(c, "spatial")),
                      typeof c._panner.orientationX < "u"
                        ? (c._panner.orientationX.setValueAtTime(
                            i,
                            Howler.ctx.currentTime
                          ),
                          c._panner.orientationY.setValueAtTime(
                            n,
                            Howler.ctx.currentTime
                          ),
                          c._panner.orientationZ.setValueAtTime(
                            r,
                            Howler.ctx.currentTime
                          ))
                        : c._panner.setOrientation(i, n, r)),
                    a._emit("orientation", c._id);
                else return c._orientation;
            }
            return a;
          }),
          (Howl.prototype.pannerAttr = function () {
            var i = this,
              n = arguments,
              r,
              s,
              a;
            if (!i._webAudio) return i;
            if (n.length === 0) return i._pannerAttr;
            if (n.length === 1)
              if (typeof n[0] == "object")
                (r = n[0]),
                  typeof s > "u" &&
                    (r.pannerAttr ||
                      (r.pannerAttr = {
                        coneInnerAngle: r.coneInnerAngle,
                        coneOuterAngle: r.coneOuterAngle,
                        coneOuterGain: r.coneOuterGain,
                        distanceModel: r.distanceModel,
                        maxDistance: r.maxDistance,
                        refDistance: r.refDistance,
                        rolloffFactor: r.rolloffFactor,
                        panningModel: r.panningModel,
                      }),
                    (i._pannerAttr = {
                      coneInnerAngle:
                        typeof r.pannerAttr.coneInnerAngle < "u"
                          ? r.pannerAttr.coneInnerAngle
                          : i._coneInnerAngle,
                      coneOuterAngle:
                        typeof r.pannerAttr.coneOuterAngle < "u"
                          ? r.pannerAttr.coneOuterAngle
                          : i._coneOuterAngle,
                      coneOuterGain:
                        typeof r.pannerAttr.coneOuterGain < "u"
                          ? r.pannerAttr.coneOuterGain
                          : i._coneOuterGain,
                      distanceModel:
                        typeof r.pannerAttr.distanceModel < "u"
                          ? r.pannerAttr.distanceModel
                          : i._distanceModel,
                      maxDistance:
                        typeof r.pannerAttr.maxDistance < "u"
                          ? r.pannerAttr.maxDistance
                          : i._maxDistance,
                      refDistance:
                        typeof r.pannerAttr.refDistance < "u"
                          ? r.pannerAttr.refDistance
                          : i._refDistance,
                      rolloffFactor:
                        typeof r.pannerAttr.rolloffFactor < "u"
                          ? r.pannerAttr.rolloffFactor
                          : i._rolloffFactor,
                      panningModel:
                        typeof r.pannerAttr.panningModel < "u"
                          ? r.pannerAttr.panningModel
                          : i._panningModel,
                    }));
              else
                return (
                  (a = i._soundById(parseInt(n[0], 10))),
                  a ? a._pannerAttr : i._pannerAttr
                );
            else n.length === 2 && ((r = n[0]), (s = parseInt(n[1], 10)));
            for (var o = i._getSoundIds(s), l = 0; l < o.length; l++)
              if (((a = i._soundById(o[l])), a)) {
                var c = a._pannerAttr;
                c = {
                  coneInnerAngle:
                    typeof r.coneInnerAngle < "u"
                      ? r.coneInnerAngle
                      : c.coneInnerAngle,
                  coneOuterAngle:
                    typeof r.coneOuterAngle < "u"
                      ? r.coneOuterAngle
                      : c.coneOuterAngle,
                  coneOuterGain:
                    typeof r.coneOuterGain < "u"
                      ? r.coneOuterGain
                      : c.coneOuterGain,
                  distanceModel:
                    typeof r.distanceModel < "u"
                      ? r.distanceModel
                      : c.distanceModel,
                  maxDistance:
                    typeof r.maxDistance < "u" ? r.maxDistance : c.maxDistance,
                  refDistance:
                    typeof r.refDistance < "u" ? r.refDistance : c.refDistance,
                  rolloffFactor:
                    typeof r.rolloffFactor < "u"
                      ? r.rolloffFactor
                      : c.rolloffFactor,
                  panningModel:
                    typeof r.panningModel < "u"
                      ? r.panningModel
                      : c.panningModel,
                };
                var d = a._panner;
                d
                  ? ((d.coneInnerAngle = c.coneInnerAngle),
                    (d.coneOuterAngle = c.coneOuterAngle),
                    (d.coneOuterGain = c.coneOuterGain),
                    (d.distanceModel = c.distanceModel),
                    (d.maxDistance = c.maxDistance),
                    (d.refDistance = c.refDistance),
                    (d.rolloffFactor = c.rolloffFactor),
                    (d.panningModel = c.panningModel))
                  : (a._pos || (a._pos = i._pos || [0, 0, -0.5]),
                    e(a, "spatial"));
              }
            return i;
          }),
          (Sound.prototype.init = (function (i) {
            return function () {
              var n = this,
                r = n._parent;
              (n._orientation = r._orientation),
                (n._stereo = r._stereo),
                (n._pos = r._pos),
                (n._pannerAttr = r._pannerAttr),
                i.call(this),
                n._stereo
                  ? r.stereo(n._stereo)
                  : n._pos && r.pos(n._pos[0], n._pos[1], n._pos[2], n._id);
            };
          })(Sound.prototype.init)),
          (Sound.prototype.reset = (function (i) {
            return function () {
              var n = this,
                r = n._parent;
              return (
                (n._orientation = r._orientation),
                (n._stereo = r._stereo),
                (n._pos = r._pos),
                (n._pannerAttr = r._pannerAttr),
                n._stereo
                  ? r.stereo(n._stereo)
                  : n._pos
                  ? r.pos(n._pos[0], n._pos[1], n._pos[2], n._id)
                  : n._panner &&
                    (n._panner.disconnect(0),
                    (n._panner = void 0),
                    r._refreshBuffer(n)),
                i.call(this)
              );
            };
          })(Sound.prototype.reset));
        var e = function (i, n) {
          (n = n || "spatial"),
            n === "spatial"
              ? ((i._panner = Howler.ctx.createPanner()),
                (i._panner.coneInnerAngle = i._pannerAttr.coneInnerAngle),
                (i._panner.coneOuterAngle = i._pannerAttr.coneOuterAngle),
                (i._panner.coneOuterGain = i._pannerAttr.coneOuterGain),
                (i._panner.distanceModel = i._pannerAttr.distanceModel),
                (i._panner.maxDistance = i._pannerAttr.maxDistance),
                (i._panner.refDistance = i._pannerAttr.refDistance),
                (i._panner.rolloffFactor = i._pannerAttr.rolloffFactor),
                (i._panner.panningModel = i._pannerAttr.panningModel),
                typeof i._panner.positionX < "u"
                  ? (i._panner.positionX.setValueAtTime(
                      i._pos[0],
                      Howler.ctx.currentTime
                    ),
                    i._panner.positionY.setValueAtTime(
                      i._pos[1],
                      Howler.ctx.currentTime
                    ),
                    i._panner.positionZ.setValueAtTime(
                      i._pos[2],
                      Howler.ctx.currentTime
                    ))
                  : i._panner.setPosition(i._pos[0], i._pos[1], i._pos[2]),
                typeof i._panner.orientationX < "u"
                  ? (i._panner.orientationX.setValueAtTime(
                      i._orientation[0],
                      Howler.ctx.currentTime
                    ),
                    i._panner.orientationY.setValueAtTime(
                      i._orientation[1],
                      Howler.ctx.currentTime
                    ),
                    i._panner.orientationZ.setValueAtTime(
                      i._orientation[2],
                      Howler.ctx.currentTime
                    ))
                  : i._panner.setOrientation(
                      i._orientation[0],
                      i._orientation[1],
                      i._orientation[2]
                    ))
              : ((i._panner = Howler.ctx.createStereoPanner()),
                i._panner.pan.setValueAtTime(
                  i._stereo,
                  Howler.ctx.currentTime
                )),
            i._panner.connect(i._node),
            i._paused || i._parent.pause(i._id, !0).play(i._id, !0);
        };
      })();
  }),
  gC = fo((t, e) => {
    e.exports = function (i, n) {
      for (var r = i.split("."), s = n.split("."), a = 0; a < 3; a++) {
        var o = Number(r[a]),
          l = Number(s[a]);
        if (o > l) return 1;
        if (l > o) return -1;
        if (!isNaN(o) && isNaN(l)) return 1;
        if (isNaN(o) && !isNaN(l)) return -1;
      }
      return 0;
    };
  });
function vC(t) {
  for (let e of Object.keys(t)) t[e] === void 0 && delete t[e];
  return t;
}
function qs(t, e) {
  return Object.setPrototypeOf(t, e), t;
}
function Dx(t) {
  return Array.isArray(t) ? t : [t];
}
function yC(t, e) {
  let i = 0;
  for (; i < t.length && i < e.length; ) {
    if (t[i] < e[i]) return -1;
    if (t[i] > e[i]) return 1;
    i += 1;
  }
  return i !== e.length ? -1 : i !== t.length ? 1 : 0;
}
var xC =
    typeof global == "object" && global && global.Object === Object && global,
  Rx = xC,
  _C = typeof self == "object" && self && self.Object === Object && self,
  bC = Rx || _C || Function("return this")(),
  pr = bC,
  wC = pr.Symbol,
  En = wC,
  Ox = Object.prototype,
  SC = Ox.hasOwnProperty,
  MC = Ox.toString,
  Ao = En ? En.toStringTag : void 0;
function EC(t) {
  var e = SC.call(t, Ao),
    i = t[Ao];
  try {
    t[Ao] = void 0;
    var n = !0;
  } catch {}
  var r = MC.call(t);
  return n && (e ? (t[Ao] = i) : delete t[Ao]), r;
}
var TC = EC,
  AC = Object.prototype,
  CC = AC.toString;
function PC(t) {
  return CC.call(t);
}
var LC = PC,
  DC = "[object Null]",
  RC = "[object Undefined]",
  jg = En ? En.toStringTag : void 0;
function OC(t) {
  return t == null
    ? t === void 0
      ? RC
      : DC
    : jg && jg in Object(t)
    ? TC(t)
    : LC(t);
}
var Js = OC;
function IC(t) {
  return t != null && typeof t == "object";
}
var Fr = IC,
  UC = "[object Symbol]";
function NC(t) {
  return typeof t == "symbol" || (Fr(t) && Js(t) == UC);
}
var sp = NC;
function zC(t, e) {
  for (var i = -1, n = t == null ? 0 : t.length, r = Array(n); ++i < n; )
    r[i] = e(t[i], i, t);
  return r;
}
var Ix = zC,
  BC = Array.isArray,
  Yn = BC,
  FC = 1 / 0,
  Wg = En ? En.prototype : void 0,
  qg = Wg ? Wg.toString : void 0;
function Ux(t) {
  if (typeof t == "string") return t;
  if (Yn(t)) return Ix(t, Ux) + "";
  if (sp(t)) return qg ? qg.call(t) : "";
  var e = t + "";
  return e == "0" && 1 / t == -FC ? "-0" : e;
}
var kC = Ux;
function VC(t) {
  var e = typeof t;
  return t != null && (e == "object" || e == "function");
}
var Xs = VC;
function HC(t) {
  return t;
}
var GC = HC,
  jC = "[object AsyncFunction]",
  WC = "[object Function]",
  qC = "[object GeneratorFunction]",
  XC = "[object Proxy]";
function $C(t) {
  if (!Xs(t)) return !1;
  var e = Js(t);
  return e == WC || e == qC || e == jC || e == XC;
}
var Nx = $C,
  YC = pr["__core-js_shared__"],
  Lu = YC,
  Xg = (function () {
    var t = /[^.]+$/.exec((Lu && Lu.keys && Lu.keys.IE_PROTO) || "");
    return t ? "Symbol(src)_1." + t : "";
  })();
function ZC(t) {
  return !!Xg && Xg in t;
}
var KC = ZC,
  JC = Function.prototype,
  QC = JC.toString;
function e3(t) {
  if (t != null) {
    try {
      return QC.call(t);
    } catch {}
    try {
      return t + "";
    } catch {}
  }
  return "";
}
var Qs = e3,
  t3 = /[\\^$.*+?()[\]{}|]/g,
  i3 = /^\[object .+?Constructor\]$/,
  n3 = Function.prototype,
  r3 = Object.prototype,
  s3 = n3.toString,
  a3 = r3.hasOwnProperty,
  o3 = RegExp(
    "^" +
      s3
        .call(a3)
        .replace(t3, "\\$&")
        .replace(
          /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
          "$1.*?"
        ) +
      "$"
  );
function l3(t) {
  if (!Xs(t) || KC(t)) return !1;
  var e = Nx(t) ? o3 : i3;
  return e.test(Qs(t));
}
var c3 = l3;
function h3(t, e) {
  return t == null ? void 0 : t[e];
}
var u3 = h3;
function d3(t, e) {
  var i = u3(t, e);
  return c3(i) ? i : void 0;
}
var ea = d3,
  f3 = ea(pr, "WeakMap"),
  Ed = f3,
  $g = Object.create,
  p3 = (function () {
    function t() {}
    return function (e) {
      if (!Xs(e)) return {};
      if ($g) return $g(e);
      t.prototype = e;
      var i = new t();
      return (t.prototype = void 0), i;
    };
  })(),
  m3 = p3;
function g3(t, e, i) {
  switch (i.length) {
    case 0:
      return t.call(e);
    case 1:
      return t.call(e, i[0]);
    case 2:
      return t.call(e, i[0], i[1]);
    case 3:
      return t.call(e, i[0], i[1], i[2]);
  }
  return t.apply(e, i);
}
var v3 = g3;
function y3(t, e) {
  var i = -1,
    n = t.length;
  for (e || (e = Array(n)); ++i < n; ) e[i] = t[i];
  return e;
}
var x3 = y3,
  _3 = 800,
  b3 = 16,
  w3 = Date.now;
function S3(t) {
  var e = 0,
    i = 0;
  return function () {
    var n = w3(),
      r = b3 - (n - i);
    if (((i = n), r > 0)) {
      if (++e >= _3) return arguments[0];
    } else e = 0;
    return t.apply(void 0, arguments);
  };
}
var M3 = S3;
function E3(t) {
  return function () {
    return t;
  };
}
var T3 = E3,
  A3 = (function () {
    try {
      var t = ea(Object, "defineProperty");
      return t({}, "", {}), t;
    } catch {}
  })(),
  qc = A3,
  C3 = qc
    ? function (t, e) {
        return qc(t, "toString", {
          configurable: !0,
          enumerable: !1,
          value: T3(e),
          writable: !0,
        });
      }
    : GC,
  P3 = C3,
  L3 = M3(P3),
  D3 = L3;
function R3(t, e) {
  for (
    var i = -1, n = t == null ? 0 : t.length;
    ++i < n && e(t[i], i, t) !== !1;

  );
  return t;
}
var O3 = R3,
  I3 = 9007199254740991,
  U3 = /^(?:0|[1-9]\d*)$/;
function N3(t, e) {
  var i = typeof t;
  return (
    (e = e ?? I3),
    !!e &&
      (i == "number" || (i != "symbol" && U3.test(t))) &&
      t > -1 &&
      t % 1 == 0 &&
      t < e
  );
}
var ap = N3;
function z3(t, e, i) {
  e == "__proto__" && qc
    ? qc(t, e, { configurable: !0, enumerable: !0, value: i, writable: !0 })
    : (t[e] = i);
}
var zx = z3;
function B3(t, e) {
  return t === e || (t !== t && e !== e);
}
var op = B3,
  F3 = Object.prototype,
  k3 = F3.hasOwnProperty;
function V3(t, e, i) {
  var n = t[e];
  (!(k3.call(t, e) && op(n, i)) || (i === void 0 && !(e in t))) && zx(t, e, i);
}
var lp = V3;
function H3(t, e, i, n) {
  var r = !i;
  i || (i = {});
  for (var s = -1, a = e.length; ++s < a; ) {
    var o = e[s],
      l = n ? n(i[o], t[o], o, i, t) : void 0;
    l === void 0 && (l = t[o]), r ? zx(i, o, l) : lp(i, o, l);
  }
  return i;
}
var Sl = H3,
  Yg = Math.max;
function G3(t, e, i) {
  return (
    (e = Yg(e === void 0 ? t.length - 1 : e, 0)),
    function () {
      for (
        var n = arguments, r = -1, s = Yg(n.length - e, 0), a = Array(s);
        ++r < s;

      )
        a[r] = n[e + r];
      r = -1;
      for (var o = Array(e + 1); ++r < e; ) o[r] = n[r];
      return (o[e] = i(a)), v3(t, this, o);
    }
  );
}
var j3 = G3,
  W3 = 9007199254740991;
function q3(t) {
  return typeof t == "number" && t > -1 && t % 1 == 0 && t <= W3;
}
var cp = q3;
function X3(t) {
  return t != null && cp(t.length) && !Nx(t);
}
var Bx = X3,
  $3 = Object.prototype;
function Y3(t) {
  var e = t && t.constructor,
    i = (typeof e == "function" && e.prototype) || $3;
  return t === i;
}
var hp = Y3;
function Z3(t, e) {
  for (var i = -1, n = Array(t); ++i < t; ) n[i] = e(i);
  return n;
}
var K3 = Z3,
  J3 = "[object Arguments]";
function Q3(t) {
  return Fr(t) && Js(t) == J3;
}
var Zg = Q3,
  Fx = Object.prototype,
  eP = Fx.hasOwnProperty,
  tP = Fx.propertyIsEnumerable,
  iP = Zg(
    (function () {
      return arguments;
    })()
  )
    ? Zg
    : function (t) {
        return Fr(t) && eP.call(t, "callee") && !tP.call(t, "callee");
      },
  up = iP;
function nP() {
  return !1;
}
var rP = nP,
  kx = typeof exports == "object" && exports && !exports.nodeType && exports,
  Kg = kx && typeof module == "object" && module && !module.nodeType && module,
  sP = Kg && Kg.exports === kx,
  Jg = sP ? pr.Buffer : void 0,
  aP = Jg ? Jg.isBuffer : void 0,
  oP = aP || rP,
  Xc = oP,
  lP = "[object Arguments]",
  cP = "[object Array]",
  hP = "[object Boolean]",
  uP = "[object Date]",
  dP = "[object Error]",
  fP = "[object Function]",
  pP = "[object Map]",
  mP = "[object Number]",
  gP = "[object Object]",
  vP = "[object RegExp]",
  yP = "[object Set]",
  xP = "[object String]",
  _P = "[object WeakMap]",
  bP = "[object ArrayBuffer]",
  wP = "[object DataView]",
  SP = "[object Float32Array]",
  MP = "[object Float64Array]",
  EP = "[object Int8Array]",
  TP = "[object Int16Array]",
  AP = "[object Int32Array]",
  CP = "[object Uint8Array]",
  PP = "[object Uint8ClampedArray]",
  LP = "[object Uint16Array]",
  DP = "[object Uint32Array]",
  $t = {};
$t[SP] =
  $t[MP] =
  $t[EP] =
  $t[TP] =
  $t[AP] =
  $t[CP] =
  $t[PP] =
  $t[LP] =
  $t[DP] =
    !0;
$t[lP] =
  $t[cP] =
  $t[bP] =
  $t[hP] =
  $t[wP] =
  $t[uP] =
  $t[dP] =
  $t[fP] =
  $t[pP] =
  $t[mP] =
  $t[gP] =
  $t[vP] =
  $t[yP] =
  $t[xP] =
  $t[_P] =
    !1;
function RP(t) {
  return Fr(t) && cp(t.length) && !!$t[Js(t)];
}
var OP = RP;
function IP(t) {
  return function (e) {
    return t(e);
  };
}
var dp = IP,
  Vx = typeof exports == "object" && exports && !exports.nodeType && exports,
  Ko = Vx && typeof module == "object" && module && !module.nodeType && module,
  UP = Ko && Ko.exports === Vx,
  Du = UP && Rx.process,
  NP = (function () {
    try {
      var t = Ko && Ko.require && Ko.require("util").types;
      return t || (Du && Du.binding && Du.binding("util"));
    } catch {}
  })(),
  Ka = NP,
  Qg = Ka && Ka.isTypedArray,
  zP = Qg ? dp(Qg) : OP,
  Hx = zP,
  BP = Object.prototype,
  FP = BP.hasOwnProperty;
function kP(t, e) {
  var i = Yn(t),
    n = !i && up(t),
    r = !i && !n && Xc(t),
    s = !i && !n && !r && Hx(t),
    a = i || n || r || s,
    o = a ? K3(t.length, String) : [],
    l = o.length;
  for (var c in t)
    (e || FP.call(t, c)) &&
      !(
        a &&
        (c == "length" ||
          (r && (c == "offset" || c == "parent")) ||
          (s && (c == "buffer" || c == "byteLength" || c == "byteOffset")) ||
          ap(c, l))
      ) &&
      o.push(c);
  return o;
}
var Gx = kP;
function VP(t, e) {
  return function (i) {
    return t(e(i));
  };
}
var jx = VP,
  HP = jx(Object.keys, Object),
  GP = HP,
  jP = Object.prototype,
  WP = jP.hasOwnProperty;
function qP(t) {
  if (!hp(t)) return GP(t);
  var e = [];
  for (var i in Object(t)) WP.call(t, i) && i != "constructor" && e.push(i);
  return e;
}
var XP = qP;
function $P(t) {
  return Bx(t) ? Gx(t) : XP(t);
}
var fp = $P;
function YP(t) {
  var e = [];
  if (t != null) for (var i in Object(t)) e.push(i);
  return e;
}
var ZP = YP,
  KP = Object.prototype,
  JP = KP.hasOwnProperty;
function QP(t) {
  if (!Xs(t)) return ZP(t);
  var e = hp(t),
    i = [];
  for (var n in t) (n == "constructor" && (e || !JP.call(t, n))) || i.push(n);
  return i;
}
var eL = QP;
function tL(t) {
  return Bx(t) ? Gx(t, !0) : eL(t);
}
var pp = tL,
  iL = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
  nL = /^\w*$/;
function rL(t, e) {
  if (Yn(t)) return !1;
  var i = typeof t;
  return i == "number" || i == "symbol" || i == "boolean" || t == null || sp(t)
    ? !0
    : nL.test(t) || !iL.test(t) || (e != null && t in Object(e));
}
var sL = rL,
  aL = ea(Object, "create"),
  cl = aL;
function oL() {
  (this.__data__ = cl ? cl(null) : {}), (this.size = 0);
}
var lL = oL;
function cL(t) {
  var e = this.has(t) && delete this.__data__[t];
  return (this.size -= e ? 1 : 0), e;
}
var hL = cL,
  uL = "__lodash_hash_undefined__",
  dL = Object.prototype,
  fL = dL.hasOwnProperty;
function pL(t) {
  var e = this.__data__;
  if (cl) {
    var i = e[t];
    return i === uL ? void 0 : i;
  }
  return fL.call(e, t) ? e[t] : void 0;
}
var mL = pL,
  gL = Object.prototype,
  vL = gL.hasOwnProperty;
function yL(t) {
  var e = this.__data__;
  return cl ? e[t] !== void 0 : vL.call(e, t);
}
var xL = yL,
  _L = "__lodash_hash_undefined__";
function bL(t, e) {
  var i = this.__data__;
  return (
    (this.size += this.has(t) ? 0 : 1),
    (i[t] = cl && e === void 0 ? _L : e),
    this
  );
}
var wL = bL;
function po(t) {
  var e = -1,
    i = t == null ? 0 : t.length;
  for (this.clear(); ++e < i; ) {
    var n = t[e];
    this.set(n[0], n[1]);
  }
}
po.prototype.clear = lL;
po.prototype.delete = hL;
po.prototype.get = mL;
po.prototype.has = xL;
po.prototype.set = wL;
var e0 = po;
function SL() {
  (this.__data__ = []), (this.size = 0);
}
var ML = SL;
function EL(t, e) {
  for (var i = t.length; i--; ) if (op(t[i][0], e)) return i;
  return -1;
}
var Ch = EL,
  TL = Array.prototype,
  AL = TL.splice;
function CL(t) {
  var e = this.__data__,
    i = Ch(e, t);
  if (i < 0) return !1;
  var n = e.length - 1;
  return i == n ? e.pop() : AL.call(e, i, 1), --this.size, !0;
}
var PL = CL;
function LL(t) {
  var e = this.__data__,
    i = Ch(e, t);
  return i < 0 ? void 0 : e[i][1];
}
var DL = LL;
function RL(t) {
  return Ch(this.__data__, t) > -1;
}
var OL = RL;
function IL(t, e) {
  var i = this.__data__,
    n = Ch(i, t);
  return n < 0 ? (++this.size, i.push([t, e])) : (i[n][1] = e), this;
}
var UL = IL;
function mo(t) {
  var e = -1,
    i = t == null ? 0 : t.length;
  for (this.clear(); ++e < i; ) {
    var n = t[e];
    this.set(n[0], n[1]);
  }
}
mo.prototype.clear = ML;
mo.prototype.delete = PL;
mo.prototype.get = DL;
mo.prototype.has = OL;
mo.prototype.set = UL;
var Ph = mo,
  NL = ea(pr, "Map"),
  hl = NL;
function zL() {
  (this.size = 0),
    (this.__data__ = {
      hash: new e0(),
      map: new (hl || Ph)(),
      string: new e0(),
    });
}
var BL = zL;
function FL(t) {
  var e = typeof t;
  return e == "string" || e == "number" || e == "symbol" || e == "boolean"
    ? t !== "__proto__"
    : t === null;
}
var kL = FL;
function VL(t, e) {
  var i = t.__data__;
  return kL(e) ? i[typeof e == "string" ? "string" : "hash"] : i.map;
}
var Lh = VL;
function HL(t) {
  var e = Lh(this, t).delete(t);
  return (this.size -= e ? 1 : 0), e;
}
var GL = HL;
function jL(t) {
  return Lh(this, t).get(t);
}
var WL = jL;
function qL(t) {
  return Lh(this, t).has(t);
}
var XL = qL;
function $L(t, e) {
  var i = Lh(this, t),
    n = i.size;
  return i.set(t, e), (this.size += i.size == n ? 0 : 1), this;
}
var YL = $L;
function go(t) {
  var e = -1,
    i = t == null ? 0 : t.length;
  for (this.clear(); ++e < i; ) {
    var n = t[e];
    this.set(n[0], n[1]);
  }
}
go.prototype.clear = BL;
go.prototype.delete = GL;
go.prototype.get = WL;
go.prototype.has = XL;
go.prototype.set = YL;
var Dh = go,
  ZL = "Expected a function";
function mp(t, e) {
  if (typeof t != "function" || (e != null && typeof e != "function"))
    throw new TypeError(ZL);
  var i = function () {
    var n = arguments,
      r = e ? e.apply(this, n) : n[0],
      s = i.cache;
    if (s.has(r)) return s.get(r);
    var a = t.apply(this, n);
    return (i.cache = s.set(r, a) || s), a;
  };
  return (i.cache = new (mp.Cache || Dh)()), i;
}
mp.Cache = Dh;
var KL = mp,
  JL = 500;
function QL(t) {
  var e = KL(t, function (n) {
      return i.size === JL && i.clear(), n;
    }),
    i = e.cache;
  return e;
}
var eD = QL,
  tD =
    /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
  iD = /\\(\\)?/g,
  nD = eD(function (t) {
    var e = [];
    return (
      t.charCodeAt(0) === 46 && e.push(""),
      t.replace(tD, function (i, n, r, s) {
        e.push(r ? s.replace(iD, "$1") : n || i);
      }),
      e
    );
  }),
  rD = nD;
function sD(t) {
  return t == null ? "" : kC(t);
}
var aD = sD;
function oD(t, e) {
  return Yn(t) ? t : sL(t, e) ? [t] : rD(aD(t));
}
var vo = oD,
  lD = 1 / 0;
function cD(t) {
  if (typeof t == "string" || sp(t)) return t;
  var e = t + "";
  return e == "0" && 1 / t == -lD ? "-0" : e;
}
var Rh = cD;
function hD(t, e) {
  e = vo(e, t);
  for (var i = 0, n = e.length; t != null && i < n; ) t = t[Rh(e[i++])];
  return i && i == n ? t : void 0;
}
var Wx = hD;
function uD(t, e) {
  for (var i = -1, n = e.length, r = t.length; ++i < n; ) t[r + i] = e[i];
  return t;
}
var gp = uD,
  t0 = En ? En.isConcatSpreadable : void 0;
function dD(t) {
  return Yn(t) || up(t) || !!(t0 && t && t[t0]);
}
var fD = dD;
function qx(t, e, i, n, r) {
  var s = -1,
    a = t.length;
  for (i || (i = fD), r || (r = []); ++s < a; ) {
    var o = t[s];
    e > 0 && i(o)
      ? e > 1
        ? qx(o, e - 1, i, n, r)
        : gp(r, o)
      : n || (r[r.length] = o);
  }
  return r;
}
var pD = qx;
function mD(t) {
  var e = t == null ? 0 : t.length;
  return e ? pD(t, 1) : [];
}
var gD = mD;
function vD(t) {
  return D3(j3(t, void 0, gD), t + "");
}
var Xx = vD,
  yD = jx(Object.getPrototypeOf, Object),
  vp = yD,
  xD = "[object Object]",
  _D = Function.prototype,
  bD = Object.prototype,
  $x = _D.toString,
  wD = bD.hasOwnProperty,
  SD = $x.call(Object);
function MD(t) {
  if (!Fr(t) || Js(t) != xD) return !1;
  var e = vp(t);
  if (e === null) return !0;
  var i = wD.call(e, "constructor") && e.constructor;
  return typeof i == "function" && i instanceof i && $x.call(i) == SD;
}
var ED = MD;
function TD(t, e, i) {
  var n = -1,
    r = t.length;
  e < 0 && (e = -e > r ? 0 : r + e),
    (i = i > r ? r : i),
    i < 0 && (i += r),
    (r = e > i ? 0 : (i - e) >>> 0),
    (e >>>= 0);
  for (var s = Array(r); ++n < r; ) s[n] = t[n + e];
  return s;
}
var AD = TD;
function CD() {
  (this.__data__ = new Ph()), (this.size = 0);
}
var PD = CD;
function LD(t) {
  var e = this.__data__,
    i = e.delete(t);
  return (this.size = e.size), i;
}
var DD = LD;
function RD(t) {
  return this.__data__.get(t);
}
var OD = RD;
function ID(t) {
  return this.__data__.has(t);
}
var UD = ID,
  ND = 200;
function zD(t, e) {
  var i = this.__data__;
  if (i instanceof Ph) {
    var n = i.__data__;
    if (!hl || n.length < ND - 1)
      return n.push([t, e]), (this.size = ++i.size), this;
    i = this.__data__ = new Dh(n);
  }
  return i.set(t, e), (this.size = i.size), this;
}
var BD = zD;
function yo(t) {
  var e = (this.__data__ = new Ph(t));
  this.size = e.size;
}
yo.prototype.clear = PD;
yo.prototype.delete = DD;
yo.prototype.get = OD;
yo.prototype.has = UD;
yo.prototype.set = BD;
var Rc = yo;
function FD(t, e) {
  return t && Sl(e, fp(e), t);
}
var kD = FD;
function VD(t, e) {
  return t && Sl(e, pp(e), t);
}
var HD = VD,
  Yx = typeof exports == "object" && exports && !exports.nodeType && exports,
  i0 = Yx && typeof module == "object" && module && !module.nodeType && module,
  GD = i0 && i0.exports === Yx,
  n0 = GD ? pr.Buffer : void 0,
  r0 = n0 ? n0.allocUnsafe : void 0;
function jD(t, e) {
  if (e) return t.slice();
  var i = t.length,
    n = r0 ? r0(i) : new t.constructor(i);
  return t.copy(n), n;
}
var WD = jD;
function qD(t, e) {
  for (var i = -1, n = t == null ? 0 : t.length, r = 0, s = []; ++i < n; ) {
    var a = t[i];
    e(a, i, t) && (s[r++] = a);
  }
  return s;
}
var XD = qD;
function $D() {
  return [];
}
var Zx = $D,
  YD = Object.prototype,
  ZD = YD.propertyIsEnumerable,
  s0 = Object.getOwnPropertySymbols,
  KD = s0
    ? function (t) {
        return t == null
          ? []
          : ((t = Object(t)),
            XD(s0(t), function (e) {
              return ZD.call(t, e);
            }));
      }
    : Zx,
  yp = KD;
function JD(t, e) {
  return Sl(t, yp(t), e);
}
var QD = JD,
  eR = Object.getOwnPropertySymbols,
  tR = eR
    ? function (t) {
        for (var e = []; t; ) gp(e, yp(t)), (t = vp(t));
        return e;
      }
    : Zx,
  Kx = tR;
function iR(t, e) {
  return Sl(t, Kx(t), e);
}
var nR = iR;
function rR(t, e, i) {
  var n = e(t);
  return Yn(t) ? n : gp(n, i(t));
}
var Jx = rR;
function sR(t) {
  return Jx(t, fp, yp);
}
var Td = sR;
function aR(t) {
  return Jx(t, pp, Kx);
}
var Qx = aR,
  oR = ea(pr, "DataView"),
  Ad = oR,
  lR = ea(pr, "Promise"),
  Cd = lR,
  cR = ea(pr, "Set"),
  Pd = cR,
  a0 = "[object Map]",
  hR = "[object Object]",
  o0 = "[object Promise]",
  l0 = "[object Set]",
  c0 = "[object WeakMap]",
  h0 = "[object DataView]",
  uR = Qs(Ad),
  dR = Qs(hl),
  fR = Qs(Cd),
  pR = Qs(Pd),
  mR = Qs(Ed),
  Ps = Js;
((Ad && Ps(new Ad(new ArrayBuffer(1))) != h0) ||
  (hl && Ps(new hl()) != a0) ||
  (Cd && Ps(Cd.resolve()) != o0) ||
  (Pd && Ps(new Pd()) != l0) ||
  (Ed && Ps(new Ed()) != c0)) &&
  (Ps = function (t) {
    var e = Js(t),
      i = e == hR ? t.constructor : void 0,
      n = i ? Qs(i) : "";
    if (n)
      switch (n) {
        case uR:
          return h0;
        case dR:
          return a0;
        case fR:
          return o0;
        case pR:
          return l0;
        case mR:
          return c0;
      }
    return e;
  });
var ul = Ps,
  gR = Object.prototype,
  vR = gR.hasOwnProperty;
function yR(t) {
  var e = t.length,
    i = new t.constructor(e);
  return (
    e &&
      typeof t[0] == "string" &&
      vR.call(t, "index") &&
      ((i.index = t.index), (i.input = t.input)),
    i
  );
}
var xR = yR,
  _R = pr.Uint8Array,
  $c = _R;
function bR(t) {
  var e = new t.constructor(t.byteLength);
  return new $c(e).set(new $c(t)), e;
}
var xp = bR;
function wR(t, e) {
  var i = e ? xp(t.buffer) : t.buffer;
  return new t.constructor(i, t.byteOffset, t.byteLength);
}
var SR = wR,
  MR = /\w*$/;
function ER(t) {
  var e = new t.constructor(t.source, MR.exec(t));
  return (e.lastIndex = t.lastIndex), e;
}
var TR = ER,
  u0 = En ? En.prototype : void 0,
  d0 = u0 ? u0.valueOf : void 0;
function AR(t) {
  return d0 ? Object(d0.call(t)) : {};
}
var CR = AR;
function PR(t, e) {
  var i = e ? xp(t.buffer) : t.buffer;
  return new t.constructor(i, t.byteOffset, t.length);
}
var LR = PR,
  DR = "[object Boolean]",
  RR = "[object Date]",
  OR = "[object Map]",
  IR = "[object Number]",
  UR = "[object RegExp]",
  NR = "[object Set]",
  zR = "[object String]",
  BR = "[object Symbol]",
  FR = "[object ArrayBuffer]",
  kR = "[object DataView]",
  VR = "[object Float32Array]",
  HR = "[object Float64Array]",
  GR = "[object Int8Array]",
  jR = "[object Int16Array]",
  WR = "[object Int32Array]",
  qR = "[object Uint8Array]",
  XR = "[object Uint8ClampedArray]",
  $R = "[object Uint16Array]",
  YR = "[object Uint32Array]";
function ZR(t, e, i) {
  var n = t.constructor;
  switch (e) {
    case FR:
      return xp(t);
    case DR:
    case RR:
      return new n(+t);
    case kR:
      return SR(t, i);
    case VR:
    case HR:
    case GR:
    case jR:
    case WR:
    case qR:
    case XR:
    case $R:
    case YR:
      return LR(t, i);
    case OR:
      return new n();
    case IR:
    case zR:
      return new n(t);
    case UR:
      return TR(t);
    case NR:
      return new n();
    case BR:
      return CR(t);
  }
}
var KR = ZR;
function JR(t) {
  return typeof t.constructor == "function" && !hp(t) ? m3(vp(t)) : {};
}
var QR = JR,
  eO = "[object Map]";
function tO(t) {
  return Fr(t) && ul(t) == eO;
}
var iO = tO,
  f0 = Ka && Ka.isMap,
  nO = f0 ? dp(f0) : iO,
  rO = nO,
  sO = "[object Set]";
function aO(t) {
  return Fr(t) && ul(t) == sO;
}
var oO = aO,
  p0 = Ka && Ka.isSet,
  lO = p0 ? dp(p0) : oO,
  cO = lO,
  hO = 1,
  uO = 2,
  dO = 4,
  e_ = "[object Arguments]",
  fO = "[object Array]",
  pO = "[object Boolean]",
  mO = "[object Date]",
  gO = "[object Error]",
  t_ = "[object Function]",
  vO = "[object GeneratorFunction]",
  yO = "[object Map]",
  xO = "[object Number]",
  i_ = "[object Object]",
  _O = "[object RegExp]",
  bO = "[object Set]",
  wO = "[object String]",
  SO = "[object Symbol]",
  MO = "[object WeakMap]",
  EO = "[object ArrayBuffer]",
  TO = "[object DataView]",
  AO = "[object Float32Array]",
  CO = "[object Float64Array]",
  PO = "[object Int8Array]",
  LO = "[object Int16Array]",
  DO = "[object Int32Array]",
  RO = "[object Uint8Array]",
  OO = "[object Uint8ClampedArray]",
  IO = "[object Uint16Array]",
  UO = "[object Uint32Array]",
  qt = {};
qt[e_] =
  qt[fO] =
  qt[EO] =
  qt[TO] =
  qt[pO] =
  qt[mO] =
  qt[AO] =
  qt[CO] =
  qt[PO] =
  qt[LO] =
  qt[DO] =
  qt[yO] =
  qt[xO] =
  qt[i_] =
  qt[_O] =
  qt[bO] =
  qt[wO] =
  qt[SO] =
  qt[RO] =
  qt[OO] =
  qt[IO] =
  qt[UO] =
    !0;
qt[gO] = qt[t_] = qt[MO] = !1;
function Oc(t, e, i, n, r, s) {
  var a,
    o = e & hO,
    l = e & uO,
    c = e & dO;
  if ((i && (a = r ? i(t, n, r, s) : i(t)), a !== void 0)) return a;
  if (!Xs(t)) return t;
  var d = Yn(t);
  if (d) {
    if (((a = xR(t)), !o)) return x3(t, a);
  } else {
    var h = ul(t),
      u = h == t_ || h == vO;
    if (Xc(t)) return WD(t, o);
    if (h == i_ || h == e_ || (u && !r)) {
      if (((a = l || u ? {} : QR(t)), !o))
        return l ? nR(t, HD(a, t)) : QD(t, kD(a, t));
    } else {
      if (!qt[h]) return r ? t : {};
      a = KR(t, h, o);
    }
  }
  s || (s = new Rc());
  var f = s.get(t);
  if (f) return f;
  s.set(t, a),
    cO(t)
      ? t.forEach(function (g) {
          a.add(Oc(g, e, i, g, t, s));
        })
      : rO(t) &&
        t.forEach(function (g, m) {
          a.set(m, Oc(g, e, i, m, t, s));
        });
  var p = c ? (l ? Qx : Td) : l ? pp : fp,
    v = d ? void 0 : p(t);
  return (
    O3(v || t, function (g, m) {
      v && ((m = g), (g = t[m])), lp(a, m, Oc(g, e, i, m, t, s));
    }),
    a
  );
}
var n_ = Oc,
  NO = 1,
  zO = 4;
function BO(t) {
  return n_(t, NO | zO);
}
var Oh = BO,
  FO = "__lodash_hash_undefined__";
function kO(t) {
  return this.__data__.set(t, FO), this;
}
var VO = kO;
function HO(t) {
  return this.__data__.has(t);
}
var GO = HO;
function Yc(t) {
  var e = -1,
    i = t == null ? 0 : t.length;
  for (this.__data__ = new Dh(); ++e < i; ) this.add(t[e]);
}
Yc.prototype.add = Yc.prototype.push = VO;
Yc.prototype.has = GO;
var jO = Yc;
function WO(t, e) {
  for (var i = -1, n = t == null ? 0 : t.length; ++i < n; )
    if (e(t[i], i, t)) return !0;
  return !1;
}
var qO = WO;
function XO(t, e) {
  return t.has(e);
}
var $O = XO,
  YO = 1,
  ZO = 2;
function KO(t, e, i, n, r, s) {
  var a = i & YO,
    o = t.length,
    l = e.length;
  if (o != l && !(a && l > o)) return !1;
  var c = s.get(t),
    d = s.get(e);
  if (c && d) return c == e && d == t;
  var h = -1,
    u = !0,
    f = i & ZO ? new jO() : void 0;
  for (s.set(t, e), s.set(e, t); ++h < o; ) {
    var p = t[h],
      v = e[h];
    if (n) var g = a ? n(v, p, h, e, t, s) : n(p, v, h, t, e, s);
    if (g !== void 0) {
      if (g) continue;
      u = !1;
      break;
    }
    if (f) {
      if (
        !qO(e, function (m, x) {
          if (!$O(f, x) && (p === m || r(p, m, i, n, s))) return f.push(x);
        })
      ) {
        u = !1;
        break;
      }
    } else if (!(p === v || r(p, v, i, n, s))) {
      u = !1;
      break;
    }
  }
  return s.delete(t), s.delete(e), u;
}
var r_ = KO;
function JO(t) {
  var e = -1,
    i = Array(t.size);
  return (
    t.forEach(function (n, r) {
      i[++e] = [r, n];
    }),
    i
  );
}
var QO = JO;
function eI(t) {
  var e = -1,
    i = Array(t.size);
  return (
    t.forEach(function (n) {
      i[++e] = n;
    }),
    i
  );
}
var tI = eI,
  iI = 1,
  nI = 2,
  rI = "[object Boolean]",
  sI = "[object Date]",
  aI = "[object Error]",
  oI = "[object Map]",
  lI = "[object Number]",
  cI = "[object RegExp]",
  hI = "[object Set]",
  uI = "[object String]",
  dI = "[object Symbol]",
  fI = "[object ArrayBuffer]",
  pI = "[object DataView]",
  m0 = En ? En.prototype : void 0,
  Ru = m0 ? m0.valueOf : void 0;
function mI(t, e, i, n, r, s, a) {
  switch (i) {
    case pI:
      if (t.byteLength != e.byteLength || t.byteOffset != e.byteOffset)
        return !1;
      (t = t.buffer), (e = e.buffer);
    case fI:
      return !(t.byteLength != e.byteLength || !s(new $c(t), new $c(e)));
    case rI:
    case sI:
    case lI:
      return op(+t, +e);
    case aI:
      return t.name == e.name && t.message == e.message;
    case cI:
    case uI:
      return t == e + "";
    case oI:
      var o = QO;
    case hI:
      var l = n & iI;
      if ((o || (o = tI), t.size != e.size && !l)) return !1;
      var c = a.get(t);
      if (c) return c == e;
      (n |= nI), a.set(t, e);
      var d = r_(o(t), o(e), n, r, s, a);
      return a.delete(t), d;
    case dI:
      if (Ru) return Ru.call(t) == Ru.call(e);
  }
  return !1;
}
var gI = mI,
  vI = 1,
  yI = Object.prototype,
  xI = yI.hasOwnProperty;
function _I(t, e, i, n, r, s) {
  var a = i & vI,
    o = Td(t),
    l = o.length,
    c = Td(e),
    d = c.length;
  if (l != d && !a) return !1;
  for (var h = l; h--; ) {
    var u = o[h];
    if (!(a ? u in e : xI.call(e, u))) return !1;
  }
  var f = s.get(t),
    p = s.get(e);
  if (f && p) return f == e && p == t;
  var v = !0;
  s.set(t, e), s.set(e, t);
  for (var g = a; ++h < l; ) {
    u = o[h];
    var m = t[u],
      x = e[u];
    if (n) var y = a ? n(x, m, u, e, t, s) : n(m, x, u, t, e, s);
    if (!(y === void 0 ? m === x || r(m, x, i, n, s) : y)) {
      v = !1;
      break;
    }
    g || (g = u == "constructor");
  }
  if (v && !g) {
    var _ = t.constructor,
      M = e.constructor;
    _ != M &&
      "constructor" in t &&
      "constructor" in e &&
      !(
        typeof _ == "function" &&
        _ instanceof _ &&
        typeof M == "function" &&
        M instanceof M
      ) &&
      (v = !1);
  }
  return s.delete(t), s.delete(e), v;
}
var bI = _I,
  wI = 1,
  g0 = "[object Arguments]",
  v0 = "[object Array]",
  oc = "[object Object]",
  SI = Object.prototype,
  y0 = SI.hasOwnProperty;
function MI(t, e, i, n, r, s) {
  var a = Yn(t),
    o = Yn(e),
    l = a ? v0 : ul(t),
    c = o ? v0 : ul(e);
  (l = l == g0 ? oc : l), (c = c == g0 ? oc : c);
  var d = l == oc,
    h = c == oc,
    u = l == c;
  if (u && Xc(t)) {
    if (!Xc(e)) return !1;
    (a = !0), (d = !1);
  }
  if (u && !d)
    return (
      s || (s = new Rc()),
      a || Hx(t) ? r_(t, e, i, n, r, s) : gI(t, e, l, i, n, r, s)
    );
  if (!(i & wI)) {
    var f = d && y0.call(t, "__wrapped__"),
      p = h && y0.call(e, "__wrapped__");
    if (f || p) {
      var v = f ? t.value() : t,
        g = p ? e.value() : e;
      return s || (s = new Rc()), r(v, g, i, n, s);
    }
  }
  return u ? (s || (s = new Rc()), bI(t, e, i, n, r, s)) : !1;
}
var EI = MI;
function s_(t, e, i, n, r) {
  return t === e
    ? !0
    : t == null || e == null || (!Fr(t) && !Fr(e))
    ? t !== t && e !== e
    : EI(t, e, i, n, s_, r);
}
var TI = s_;
function AI(t, e) {
  return t != null && e in Object(t);
}
var CI = AI;
function PI(t, e, i) {
  e = vo(e, t);
  for (var n = -1, r = e.length, s = !1; ++n < r; ) {
    var a = Rh(e[n]);
    if (!(s = t != null && i(t, a))) break;
    t = t[a];
  }
  return s || ++n != r
    ? s
    : ((r = t == null ? 0 : t.length),
      !!r && cp(r) && ap(a, r) && (Yn(t) || up(t)));
}
var LI = PI;
function DI(t, e) {
  return t != null && LI(t, e, CI);
}
var RI = DI;
function OI(t) {
  var e = t == null ? 0 : t.length;
  return e ? t[e - 1] : void 0;
}
var II = OI;
function UI(t, e) {
  return e.length < 2 ? t : Wx(t, AD(e, 0, -1));
}
var NI = UI;
function zI(t, e) {
  return TI(t, e);
}
var a_ = zI;
function BI(t, e) {
  return (e = vo(e, t)), (t = NI(t, e)), t == null || delete t[Rh(II(e))];
}
var FI = BI;
function kI(t) {
  return ED(t) ? void 0 : t;
}
var VI = kI,
  HI = 1,
  GI = 2,
  jI = 4,
  WI = Xx(function (t, e) {
    var i = {};
    if (t == null) return i;
    var n = !1;
    (e = Ix(e, function (s) {
      return (s = vo(s, t)), n || (n = s.length > 1), s;
    })),
      Sl(t, Qx(t), i),
      n && (i = n_(i, HI | GI | jI, VI));
    for (var r = e.length; r--; ) FI(i, e[r]);
    return i;
  }),
  Ld = WI;
function qI(t, e, i, n) {
  if (!Xs(t)) return t;
  e = vo(e, t);
  for (var r = -1, s = e.length, a = s - 1, o = t; o != null && ++r < s; ) {
    var l = Rh(e[r]),
      c = i;
    if (l === "__proto__" || l === "constructor" || l === "prototype") return t;
    if (r != a) {
      var d = o[l];
      (c = n ? n(d, l, o) : void 0),
        c === void 0 && (c = Xs(d) ? d : ap(e[r + 1]) ? [] : {});
    }
    lp(o, l, c), (o = o[l]);
  }
  return t;
}
var XI = qI;
function $I(t, e, i) {
  for (var n = -1, r = e.length, s = {}; ++n < r; ) {
    var a = e[n],
      o = Wx(t, a);
    i(o, a) && XI(s, vo(a, t), o);
  }
  return s;
}
var YI = $I;
function ZI(t, e) {
  return YI(t, e, function (i, n) {
    return RI(t, n);
  });
}
var KI = ZI,
  JI = Xx(function (t, e) {
    return t == null ? {} : KI(t, e);
  }),
  os = JI,
  pi = class {
    modifyById(t, e) {
      let i = this;
      if (i[t] === void 0) throw new Error("not expected");
      {
        let n = { ...i, [t]: e };
        return Object.setPrototypeOf(n, pi.prototype), n;
      }
    }
    add(t, e) {
      var i;
      return (
        ((i = this.runOp({ type: 1, id: t, data: e })) == null
          ? void 0
          : i.data) ?? this
      );
    }
    runOp(t) {
      let e = this;
      if (t.type === 1) {
        let i = e[t.id],
          n;
        i === void 0
          ? (n = { type: 2, id: t.id })
          : (n = { type: 1, id: t.id, data: i });
        let { id: r, data: s } = t,
          a = { ...e, [r]: s };
        return (
          Object.setPrototypeOf(a, pi.prototype),
          { data: a, actual: t, reverse: n }
        );
      } else if (t.type === 2) {
        let { id: i } = t,
          n = e[i];
        if (n === void 0) return null;
        {
          let r = { ...e };
          return (
            Object.setPrototypeOf(r, pi.prototype),
            delete r[i],
            { data: r, actual: t, reverse: { type: 1, id: i, data: n } }
          );
        }
      }
      return null;
    }
  };
function _p(t) {
  if (t.deepFreeze !== void 0) {
    t.deepFreeze(t);
    return;
  }
  let e = Object.getOwnPropertyNames(t);
  for (let i of e) {
    let n = t[i];
    n && typeof n == "object" && _p(n);
  }
  return Object.freeze(t);
}
function QI(t, e) {
  let i = 0;
  for (; i < t.length && i < e.length; ) {
    if (t[i] < e[i]) return -1;
    if (t[i] > e[i]) return 1;
    i += 1;
  }
  return i !== e.length ? -1 : i !== t.length ? 1 : 0;
}
var o_ = class extends Error {};
function Ou(t) {
  let e = { ...t };
  return Object.setPrototypeOf(e, Object.getPrototypeOf(t)), e;
}
function Kr(t, e, i) {
  if (
    (t === void 0
      ? e === void 0
        ? ((t = 0), (e = 10))
        : (t = e - 10)
      : e === void 0 && (e = t + 10),
    t > e)
  ) {
    let s = t;
    (t = e), (e = s);
  }
  let n = [],
    r = 1 / (i + 1);
  for (let s = 0; s < i; s++) {
    let a = t + (e - t) * (s + 0.75 + Math.random() * 0.5) * r;
    n.push(a);
  }
  return n;
}
function bp(t) {
  return (
    t instanceof Uint8Array ||
    t instanceof Uint16Array ||
    t instanceof Uint32Array ||
    t instanceof Int8Array ||
    t instanceof Int16Array ||
    t instanceof Int32Array ||
    t instanceof Float32Array ||
    t instanceof Float64Array
  );
}
function eU() {
  return typeof process < "u";
}
function l_(t, e) {
  for (let i of t) e(i.id, i.data) !== !0 && l_(i.children, e);
}
function c_(t, e) {
  if (e(t.id, t.data) !== !0) for (let i of t.children) c_(i, e);
}
var sn = class extends Array {
    constructor(...t) {
      super(...t), Object.setPrototypeOf(this, sn.prototype);
    }
    deepFreeze() {
      let t = 0;
      for (; t < this.length; ) _p(this[t]), t++;
    }
    fillCaches0(t, e) {
      this.objCaches.set(t.id, t), this.parentCaches.set(t.id, e);
      for (let i of t.children) this.fillCaches0(i, t.id);
    }
    fillCaches() {
      if (this.objCaches === void 0) {
        (this.objCaches = new Map()), (this.parentCaches = new Map());
        for (let t of this) this.fillCaches0(t, null);
      }
    }
    randomId() {
      this.fillCaches();
      let t = Array.from(this.objCaches.keys());
      if (t.length !== 0)
        return t[Math.max(0, Math.floor(Math.random() * t.length) - 1)];
    }
    nonExistOrDescendantOf(t, e) {
      if (!this.has(t)) return !0;
      for (; t; ) {
        let i = this.parent(t);
        if (i === e) return !0;
        t = i;
      }
      return !1;
    }
    rootAcestor(t) {
      for (; t; ) {
        let e = this.parent(t);
        if (e) t = e;
        else return t;
      }
      return t;
    }
    isDescendantOf(t, e) {
      for (; t; ) {
        let i = this.parent(t);
        if (i === e) return !0;
        t = i;
      }
      return !1;
    }
    data(t) {
      var e;
      return (e = this.get(t)) == null ? void 0 : e.data;
    }
    has(t) {
      return this.childrenOf(t) !== void 0;
    }
    get(t) {
      return this.fillCaches(), this.objCaches.get(t);
    }
    childrenOf(t) {
      var e;
      return t === null
        ? this
        : (e = this.get(t)) == null
        ? void 0
        : e.children;
    }
    traverseFrom(t, e) {
      if (t === null) this.traverse(e);
      else {
        let i = this.get(t);
        i && c_(i, e);
      }
    }
    traverse(t) {
      l_(this, t);
    }
    totalSize() {
      return this.fillCaches(), this.objCaches.size;
    }
    parent(t) {
      return this.fillCaches(), this.parentCaches.get(t);
    }
    childrenArray(t) {
      return t === null ? this : this.get(t).children;
    }
    modifyById(t, e) {
      if (this.get(t) === void 0) throw new Error("not expected");
      {
        let i = this.parent(t),
          n = this.childrenArray(i),
          r = n.findIndex((a) => a.id === t);
        if (r < 0) throw new Error("not expected");
        let s = n[r];
        return (
          (n = [...n]), (n[r] = { ...s, data: e }), this.modifyArrayBy(i, n)
        );
      }
    }
    modifyArrayBy(t, e) {
      let i = t,
        n = e;
      for (; i !== null; ) {
        let s = n,
          a = i;
        if (((i = this.parent(i)), i === void 0)) throw new Error();
        n = this.childrenArray(i);
        let o = n.findIndex((l) => l.id === a);
        if (o < 0) throw new Error();
        (n = [...n]), (n[o] = { ...n[o], children: s });
      }
      Object.setPrototypeOf(n, sn.prototype);
      let r = n;
      return r.fillCaches(), r;
    }
    runOp(t) {
      switch (t.type) {
        case 7:
          return this.addOp(t);
        case 8:
          return this.deleteOp(t);
        case 9:
          return this.moveOp(t);
      }
      return null;
    }
    checkDuplicatedIdRec({ id: t, children: e }) {
      if (this.get(t) !== void 0) return !0;
      for (let i of e) if (this.checkDuplicatedIdRec(i)) return !0;
      return !1;
    }
    addOp(t) {
      let { parent: e, fi: i, id: n, data: r, children: s } = t;
      if (
        (e !== null && this.get(e) === void 0) ||
        this.checkDuplicatedIdRec(t)
      )
        return null;
      {
        let a = e,
          o = this.childrenArray(a),
          l = { fi: i, id: n, data: r, children: s };
        return (
          (o = [...o, l]),
          o.sort((c, d) => c.fi - d.fi),
          (t.localIndex = o.indexOf(l)),
          {
            data: this.modifyArrayBy(a, o),
            actual: t,
            reverse: { type: 8, id: n },
          }
        );
      }
    }
    deleteOp(t) {
      let { id: e } = t;
      if (this.get(e) === null) return null;
      {
        let i = this.parent(e);
        if (i === void 0) return null;
        let n = this.childrenArray(i),
          r = n.findIndex((a) => a.id === e);
        (t.localIndex = r), (n = [...n]);
        let s = n.splice(r, 1)[0];
        return {
          data: this.modifyArrayBy(i, n),
          actual: t,
          reverse: { type: 7, ...s, parent: i },
        };
      }
    }
    moveOp(t) {
      let { parent: e, fi: i, id: n } = t;
      if (e !== null && this.get(e) === void 0)
        return this.deleteOp({ type: 8, id: n });
      if (e !== null) {
        let h = e;
        for (; h !== null; ) {
          if (h === void 0) throw new Error();
          if (h === n) throw new o_("cyclic tree");
          h = this.parent(h);
        }
      }
      let r = this.parent(n);
      if (r === void 0) return null;
      let s = r,
        a = this.childrenArray(r),
        o = a.findIndex((h) => h.id === n);
      a = [...a];
      let l = a.splice(o, 1)[0],
        c = this.modifyArrayBy(r, a);
      (r = e), (a = c.childrenArray(r));
      let d = l.fi;
      return (
        (l = { ...l, fi: i }),
        (a = [...a, l]),
        a.sort((h, u) => h.fi - u.fi),
        (t.localIndex = a.indexOf(l)),
        (c = c.modifyArrayBy(r, a)),
        { data: c, actual: t, reverse: { type: 9, parent: s, fi: d, id: n } }
      );
    }
    previous(t, e) {
      if (e === null) {
        let n = this.childrenArray(t);
        return n.length === 0 ? null : n[n.length - 1].id;
      }
      let i = null;
      for (let n of this.childrenArray(t)) {
        if (n.id === e) return i;
        i = n.id;
      }
      return null;
    }
    traverseSortNext(t) {
      let e = this.parent(t);
      if (e !== void 0) {
        let i = this.childrenArray(e),
          n = i.findIndex((r) => r.id === t) + 1;
        if (n < i.length) return i[n].id;
        if (e) return this.traverseSortNext(e);
      }
    }
    sortNext(t) {
      let e = this.childrenArray(t);
      return e.length > 0 ? e[0].id : this.traverseSortNext(t);
    }
    traverseSortPrevious(t) {
      let e = this.childrenArray(t);
      return e.length > 0 ? this.traverseSortPrevious(e[e.length - 1].id) : t;
    }
    sortPrevious(t) {
      let e = this.parent(t);
      if (e !== void 0) {
        let i = this.childrenArray(e),
          n = i.findIndex((r) => r.id === t) - 1;
        return n >= 0 ? this.traverseSortPrevious(i[n].id) : e;
      }
    }
    getAllSorted(t) {
      let e = [];
      for (let i of t) {
        let n = this.getWithSortKey(i.id);
        n !== void 0 && e.push({ ...i, ...n });
      }
      e.sort((i, n) => QI(i.sortKey, n.sortKey));
      for (let i of e) delete i.sortKey;
      return e;
    }
    getWithSortKey(t) {
      var e = t;
      let i = [],
        n = this.get(e),
        r = n;
      if (n !== void 0) {
        for (; e; )
          i.splice(0, 0, n.fi),
            (e = this.parent(e)),
            e !== null && (n = this.get(e));
        return { ...r, sortKey: i };
      }
    }
    insertBeforeHelper(t, e, i) {
      return this.insertAfterHelper(t, this.previous(t, e), i);
    }
    insertAfterHelper(t, e, i) {
      let n = this.childrenArray(t);
      if (e === null) {
        if (n.length === 0) return Kr(0, i, i);
        {
          let r = n[0].fi;
          return Kr(r - i, r, i);
        }
      } else {
        let r = this.get(e);
        if (r === void 0 || this.parent(e) !== t)
          throw new Error("illegal args");
        let s = n.find((a) => a.fi > r.fi);
        if (s === void 0) {
          let a = n[n.length - 1].fi;
          return Kr(a, a + i, i);
        } else return Kr(r.fi, s.fi, i);
      }
    }
  },
  Zc;
((t) => {
  function e(i, n) {
    if (n.type !== 0) return null;
    if (Array.isArray(i)) {
      let r = n.props,
        s = {},
        a = [...i],
        o = !1;
      if (r)
        for (let l of Object.keys(r)) {
          let c = parseInt(l);
          if (isNaN(c)) throw new Error("wrong index");
          (s[l] = a[c]), (a[c] = r[l]), (o = !0);
        }
      return o ? { data: a, actual: n, reverse: { type: 0, props: s } } : null;
    } else {
      let r = n.props,
        s = {},
        a = { ...i },
        o = !1;
      if (r)
        for (let l of Object.keys(r)) {
          s[l] = a[l];
          let c = r[l];
          c === void 0 ? delete a[l] : (a[l] = c), (o = !0);
        }
      return o ? { data: a, actual: n, reverse: { type: 0, props: s } } : null;
    }
  }
  t.runOp = e;
})(Zc || (Zc = {}));
var Ot = class extends Array {
  constructor(...t) {
    super(...t), Object.setPrototypeOf(this, Ot.prototype);
  }
  deepFreeze() {
    let t = 0;
    for (; t < this.length; ) _p(this[t]), t++;
  }
  fillCaches0(t) {
    this.objCaches.set(t.id, t);
  }
  fillCaches() {
    if (this.objCaches === void 0) {
      (this.objCaches = new Map()),
        (Object.getOwnPropertyDescriptor(this, "objCaches").enumerable = !1);
      for (let t of this) this.fillCaches0(t);
    }
  }
  randomId() {
    this.fillCaches();
    let t = Array.from(this.objCaches.keys());
    if (t.length !== 0)
      return t[Math.max(0, Math.floor(Math.random() * t.length) - 1)];
  }
  data(t) {
    var e;
    return (e = this.get(t)) == null ? void 0 : e.data;
  }
  get(t) {
    return this.fillCaches(), this.objCaches.get(t);
  }
  modifyById(t, e) {
    if (this.get(t) === void 0) throw new Error("not expected");
    {
      let i = this,
        n = i.findIndex((s) => s.id === t);
      if (n < 0) throw new Error("not expected");
      let r = i[n];
      return (i = [...i]), (i[n] = { ...r, data: e }), this.modifyArrayBy(i);
    }
  }
  modifyArrayBy(t) {
    Object.setPrototypeOf(t, Ot.prototype);
    let e = t;
    return eU() || e.fillCaches(), e;
  }
  runOp(t) {
    switch (t.type) {
      case 4:
        return this.addOp(t);
      case 5:
        return this.deleteOp(t);
      case 6:
        return this.moveOp(t);
    }
    return null;
  }
  addOp(t) {
    let { fi: e, id: i, data: n } = t,
      r = this,
      s = { fi: e, id: i, data: n };
    return (
      (r = [...r, s]),
      r.sort((a, o) => a.fi - o.fi),
      (t.localIndex = r.indexOf(s)),
      { data: this.modifyArrayBy(r), actual: t, reverse: { type: 5, id: i } }
    );
  }
  deleteOp(t) {
    let { id: e } = t,
      i = this,
      n = i.findIndex((s) => s.id === e);
    if (n === -1) return null;
    (t.localIndex = n), (i = [...i]);
    let r = i.splice(n, 1)[0];
    return {
      data: this.modifyArrayBy(i),
      actual: t,
      reverse: { type: 4, ...r },
    };
  }
  moveOp(t) {
    let { fi: e, id: i } = t,
      n = this;
    n = [...n];
    let r = n.findIndex((o) => o.id === i);
    if (r === -1) return null;
    let s = n[r].fi,
      a = { ...n[r], fi: e };
    return (
      (n[r] = a),
      n.sort((o, l) => o.fi - l.fi),
      (t.localIndex = n.indexOf(a)),
      {
        data: this.modifyArrayBy(n),
        actual: t,
        reverse: { type: 6, fi: s, id: i },
      }
    );
  }
  previous(t) {
    if (t === null) return this.length === 0 ? null : this[this.length - 1].id;
    let e = null;
    for (let i of this) {
      if (i.id === t) return e;
      e = i.id;
    }
    return null;
  }
  insertBeforeHelper(t, e) {
    return this.insertAfterHelper(this.previous(t), e);
  }
  insertAfterHelper(t, e) {
    let i = this;
    if (t === null) {
      if (i.length === 0) return Kr(0, e, e);
      {
        let n = i[0].fi;
        return Kr(n - e, n, e);
      }
    } else {
      let n = this.get(t);
      if (n === void 0) throw new Error("illegal args");
      let r = i.find((s) => s.fi > n.fi);
      if (r === void 0) {
        let s = i[i.length - 1].fi;
        return Kr(s, s + e, e);
      } else return Kr(n.fi, r.fi, e);
    }
  }
};
function Ja(t) {
  return t && typeof t == "object" && t instanceof xi;
}
var xi = class {
    unusedFunOverridesTable(t) {}
    runOp(t) {
      let e = [],
        i = this,
        n = 0,
        r = {};
      for (; n < t.path.length; ) {
        if (
          (e.push(i),
          (i = i === void 0 ? void 0 : i[t.path[n]]),
          i !== void 0 && !Ja(i))
        )
          return null;
        n += 1;
      }
      i = i ? Ou(i) : new xi();
      for (let [o, l] of Object.entries(t.props)) {
        let c = i[o];
        (r[o] = c), l === void 0 ? delete i[o] : (i[o] = l);
      }
      for (; n > 0; ) {
        if (Object.keys(i).length === 0) {
          let o = e[n - 1];
          o && ((i = Ou(o)), delete i[t.path[n - 1]]);
        } else {
          let o = e[n - 1];
          if (o) {
            let l = Ou(o);
            (l[t.path[n - 1]] = i), (i = l);
          } else {
            let l = new xi();
            (l[t.path[n - 1]] = i), (i = l);
          }
        }
        n -= 1;
      }
      let s = Object.setPrototypeOf(i, xi.prototype),
        a = { ...t, props: r };
      return { data: s, actual: t, reverse: a };
    }
  },
  ls;
((t) => {
  function e(r, s) {
    return dl(r, s) ?? r;
  }
  t.apply = e;
  function i(r, s) {
    return Sp(r, s);
  }
  t.merge = i;
  function n(r, s) {
    let a = 0,
      o = s.path,
      l = r;
    for (; a < o.length && l !== void 0; ) {
      if (((l = hr.zoomOnce(l, o[a])), l === void 0)) return s;
      if (!Ja(l)) return;
      a += 1;
    }
    if (l === void 0) return s;
    if (Ja(l))
      if (s.type === 0) {
        let c = { ...s.props };
        for (let d of Object.keys(l)) delete c[d];
        return { ...s, props: c };
      } else if (s.type === 1 || s.type === 4 || s.type === 7) {
        let c = wp([s], l);
        return c ? (console.log(c), c) : s;
      } else return s;
  }
  t.filterOp = n;
})(ls || (ls = {}));
function wp(t, e) {
  if (e === void 0) return;
  let i = !1,
    n = t.map((r) => {
      let s = r.id,
        a = dl(r.data, e[s]);
      if (((i = i || a !== void 0), a === void 0 && (a = r.data), r.children)) {
        let o = wp(r.children, e);
        return (
          o !== void 0 ? (i = !0) : (o = r.children),
          { ...r, id: s, data: a, children: o }
        );
      } else return { ...r, id: s, data: a };
    });
  if (i) return n;
}
function tU(t, e) {
  if (e === void 0) return;
  let i = !1,
    n = t.map((r) => {
      let s = r.id,
        a = dl(r.data, e[s]);
      return (
        (i = i || a !== void 0),
        a === void 0 && (a = r.data),
        { ...r, id: s, data: a }
      );
    });
  if (i) return Object.setPrototypeOf(n, Object.getPrototypeOf(t)), n;
}
function dl(t, e) {
  if (!Ja(e)) return e;
  if (t instanceof sn) {
    let i = wp(t, e);
    return (
      i !== void 0 && Object.setPrototypeOf(i, Object.getPrototypeOf(t)), i
    );
  } else {
    if (t instanceof Ot) return tU(t, e);
    if (Array.isArray(t)) {
      let i = !1,
        n = t.map((r, s) => {
          let a = dl(r, e[s]);
          return (i = i || a !== void 0), a === void 0 && (a = r), a;
        });
      return i
        ? (Object.setPrototypeOf(n, Object.getPrototypeOf(t)), n)
        : void 0;
    } else {
      if (t instanceof xi) return Sp(t, e);
      if (t && typeof t == "object") {
        let i = {},
          n = !1;
        for (let [r, s] of Object.entries(t)) {
          let a = dl(s, e[r]);
          (n = n || a !== void 0), a === void 0 && (a = s), (i[r] = a);
        }
        return n
          ? (Object.setPrototypeOf(i, Object.getPrototypeOf(t)), i)
          : void 0;
      }
    }
  }
}
function Sp(t, e) {
  if (t === void 0) return e;
  if (e === void 0) return t;
  if (!Ja(e)) return e;
  if (!Ja(t)) return ls.apply(t, e);
  let i = new Set();
  for (let r of Object.keys(t)) i.add(r);
  for (let r of Object.keys(e)) i.add(r);
  let n = new xi();
  for (let r of i) {
    let s = Sp(t === void 0 ? void 0 : t[r], e === void 0 ? void 0 : e[r]);
    n[r] = s;
  }
  return n;
}
function iU(t, e) {
  let i = { cur: [], result: [], len: 0 };
  return (t = fl(t, e, i) ?? t), [t, i.result];
}
function Kc(t, e) {
  return t === null ? null : ((t.cur[t.len] = e), (t.len += 1), t);
}
function Jc(t) {
  t && (t.len -= 1);
}
function nU(t) {
  if (t === null) return null;
  t.result.push(t.cur.slice(0, t.len));
}
function h_(t, e, i) {
  let n = !1,
    r = t.map((s) => {
      let a = s.id,
        o = e[a];
      if (
        o !== void 0 &&
        typeof o == "string" &&
        ((n = !0), (a = o), i !== null)
      )
        throw new Error("not supported");
      let l = fl(s.data, e, Kc(i, a));
      Jc(i), (n = n || l !== void 0), l === void 0 && (l = s.data);
      let c = h_(s.children, e, i);
      return (
        c !== void 0 ? (n = !0) : (c = s.children),
        { ...s, id: a, data: l, children: c }
      );
    });
  if (n) return r;
}
function rU(t, e, i) {
  let n = !1,
    r = t.map((s) => {
      let a = s.id,
        o = e[a];
      if (
        o !== void 0 &&
        typeof o == "string" &&
        ((n = !0), (a = o), i !== null)
      )
        throw new Error("not supported");
      let l = fl(s.data, e, Kc(i, a));
      return (
        Jc(i),
        (n = n || l !== void 0),
        l === void 0 && (l = s.data),
        { ...s, id: a, data: l }
      );
    });
  if (n) return Object.setPrototypeOf(r, Object.getPrototypeOf(t)), r;
}
function fl(t, e, i) {
  if (t instanceof sn) {
    let n = h_(t, e, i);
    return (
      n !== void 0 && Object.setPrototypeOf(n, Object.getPrototypeOf(t)), n
    );
  } else {
    if (t instanceof Ot) return rU(t, e, i);
    if (Array.isArray(t)) {
      let n = !1,
        r = t.map((s, a) => {
          let o = fl(s, e, Kc(i, a));
          return Jc(i), (n = n || o !== void 0), o === void 0 && (o = s), o;
        });
      return n
        ? (Object.setPrototypeOf(r, Object.getPrototypeOf(t)), r)
        : void 0;
    } else if (t && typeof t == "object" && !bp(t)) {
      let n = {},
        r = !1;
      for (let [s, a] of Object.entries(t))
        if (s !== "name" && s !== "text") {
          let o = e[s];
          if (typeof o == "string") {
            if (i !== null) throw new Error("not supported");
            (r = !0), (s = o);
          }
          let l = fl(a, e, Kc(i, s));
          Jc(i), (r = r || l !== void 0), l === void 0 && (l = a), (n[s] = l);
        } else n[s] = a;
      return r
        ? (Object.setPrototypeOf(n, Object.getPrototypeOf(t)), n)
        : void 0;
    } else if (typeof t == "string") {
      let n = e[t];
      if (n !== void 0) {
        if (t.length !== 36)
          throw new Error(
            "for now you should only call this method when the key is a uuid"
          );
        nU(i);
      }
      return n;
    } else return;
  }
}
var Dd;
((t) => {
  function e(i, n) {
    let r = hr.zoom(n, i.path);
    if (typeof r == "object") {
      let s = {};
      for (let a of Object.keys(i.props)) s[a] = r[a];
      return { ...i, props: s };
    } else return { ...i, props: {} };
  }
  t.replaceProps = e;
})(Dd || (Dd = {}));
var dn;
((t) => {
  function e(l, c) {
    return { ...l, path: l.path.slice(c) };
  }
  t.drop = e;
  function i(l, c) {
    var d;
    return ((d = n(l, c)) == null ? void 0 : d.data) ?? l;
  }
  t.applySimple = i;
  function n(l, c) {
    var u, f;
    let d = c.path;
    for (var h = []; ; ) {
      let p;
      if (
        (l instanceof xi &&
          c.type === 0 &&
          ((p = l.runOp({ ...c, path: d.slice(h.length) })),
          p === null && (p = void 0)),
        p === void 0 &&
          h.length === d.length &&
          (l instanceof sn || l instanceof Ot || l instanceof pi
            ? (p = l.runOp(c))
            : (p = Zc.runOp(l, c))),
        p !== void 0)
      )
        if (p !== null) {
          let m = p.data;
          for (let x = h.length - 1; x >= 0; x--) {
            let y = d[x],
              _ = h[x];
            if (_ instanceof sn) {
              if (typeof y == "number") throw new Error("illegal arg");
              m = _.modifyById(y, m);
            } else if (_ instanceof Ot) {
              if (typeof y == "number") throw new Error("illegal arg");
              m = _.modifyById(y, m);
            } else if (_ instanceof pi) {
              if (typeof y == "number") throw new Error("illegal arg");
              m = _.modifyById(y, m);
            } else if (_ instanceof xi) {
              let M = { ..._, [y]: m };
              m = Object.setPrototypeOf(M, xi.prototype);
            } else if (typeof _ == "object")
              if (Array.isArray(_)) {
                if (typeof y == "string" && ((y = parseInt(y)), isNaN(y)))
                  throw new Error("Invalid path");
                let M = m;
                (m = [..._]), (m[y] = M);
              } else m = { ..._, [y]: m };
            else return null;
          }
          return {
            data: m,
            actual: { ...p.actual, path: d },
            reverse: { ...p.reverse, path: d },
          };
        } else return null;
      let v = d[h.length],
        g;
      if (l instanceof sn) {
        if (typeof v == "number") throw new Error("");
        g = (u = l.get(v)) == null ? void 0 : u.data;
      } else if (l instanceof Ot) {
        if (typeof v == "number") throw new Error("");
        g = (f = l.get(v)) == null ? void 0 : f.data;
      } else l !== null && (g = l[v]);
      if (g !== void 0) h.push(l), (l = g);
      else return null;
    }
  }
  t.apply = n;
  function r(l, c) {
    for (let d = 0; d < l.length && d < c.length; d++)
      if (l[d] !== c[d]) return !0;
    return !1;
  }
  t.pathDisjoint = r;
  function s(l, c) {
    if (l.length !== c.length) return !1;
    for (let d = 0; d < l.length; d++) if (l[d] !== c[d]) return !1;
    return !0;
  }
  t.pathEq = s;
  function a(l, c) {
    return r(l.path, c.path);
  }
  t.commutative = a;
  function o(l, c) {
    return l.type === 0 && c.type === 0 && s(l.path, c.path)
      ? Object.keys(l.props).every((d) => c.props[d] !== void 0)
      : !1;
  }
  t.subsumed = o;
})(dn || (dn = {}));
var x0;
((t) => {
  function e() {
    return [];
  }
  t.empty = e;
  function i(c, d) {
    let h = [];
    for (let u of c) {
      let [f, ...p] = u.path;
      f === d && h.push({ ...u, path: p });
    }
    return h;
  }
  t.removePrefix = i;
  function n(c, d) {
    return c.map((h) => ({ ...h, path: [d, ...h.path] }));
  }
  t.addPrefix = n;
  function r(c, d) {
    return [...c, ...d];
  }
  t.concat = r;
  function s(c, d) {
    return [...c.filter((h) => !d.some((u) => dn.subsumed(h, u))), ...d];
  }
  t.compress = s;
  function a(c, d) {
    return c.every((h) => d.every((u) => dn.commutative(h, u)));
  }
  t.commutative = a;
  function o(c, d) {
    for (let h of d) {
      let u = l(c, h);
      u !== null && (c = u.data);
    }
    return c;
  }
  t.applyAll = o;
  function l(c, d) {
    var h = c;
    let u = [],
      f = [];
    for (let p of d)
      try {
        if (p.type === 3) {
          let v = hr.zoom(h, [...p.path, p.id]),
            g = dn.apply(h, { ...p, type: 2 });
          if (g !== null) {
            h = g.data;
            let [m, x] = iU(h, { [p.id]: v });
            h = m;
            for (let y of x) {
              let _ = y[y.length - 1];
              y.splice(y.length - 1, 1),
                u.push({ type: 0, path: y, props: { [_]: v } }),
                f.push({ type: 0, path: y, props: { [_]: p.id } });
            }
            f.push(g.reverse), u.push(g.actual);
          }
        } else {
          let v = dn.apply(h, p);
          v !== null && (u.push(v.actual), (h = v.data), f.push(v.reverse));
        }
      } catch (v) {
        if (v instanceof o_) return null;
        throw v;
      }
    return { data: h, actual: u, reverse: f.reverse() };
  }
  t.apply = l;
})(x0 || (x0 = {}));
var u_ = Symbol(),
  sU = Symbol(),
  Ih = Symbol(),
  Ml = class {
    reportOp(t, e, i = []) {
      let n = this;
      if (e === null) return;
      n._current = e.data;
      let r = i;
      for (; !(n instanceof f_); ) {
        let s = n._path,
          a = n._current;
        if ((s !== "" && r.splice(0, 0, s), (n = n._parent), n === null))
          return;
        n.update(s, a);
      }
      n.push(r, t, e.actual, e.reverse);
    }
    deleteChildren(t) {
      if (this._children) {
        let e = this._children[t];
        if (e) {
          let i = e[Ih];
          i && i(), delete this._children[t];
        }
      }
    }
  },
  aU = class extends Ml {
    constructor(t, e, i) {
      super(), (this._parent = t), (this._path = e), (this._current = i);
    }
    update(t, e) {
      if (Array.isArray(this._current)) {
        if (typeof t == "string" && ((t = parseInt(t)), isNaN(t)))
          throw new Error("Invalid path");
        (this._current = [...this._current]), (this._current[t] = e);
      } else this._current = { ...this._current, [t]: e };
    }
    runOp(t) {
      this.reportOp(t, Zc.runOp(this._current, t), t.path);
    }
  },
  oU = class extends Ml {
    constructor(t, e, i) {
      super(), (this._parent = t), (this._path = e), (this._current = i);
    }
    update(t, e) {
      (this._current = { ...this._current, [t]: e }),
        Object.setPrototypeOf(this._current, pi.prototype);
    }
    runOp(t) {
      this.reportOp(t, this._current.runOp(t));
    }
  },
  d_ = {
    get(t, e) {
      if (e === Ih)
        return () => {
          t._parent = null;
        };
      if (e === u_) return t._current;
      if (e === sU) return t;
      let { _current: i, _children: n } = t;
      if (e === "push" && Array.isArray(i))
        throw new Error("not supported to expand array");
      let r = n === void 0 ? void 0 : n[e];
      if (r !== void 0) return r;
      let s = i[e],
        a = Uh(t, e, s);
      return a !== s
        ? (n === void 0 && ((n = {}), (t._children = n)), (n[e] = a), a)
        : s;
    },
    has(t, e) {
      return e in t._current;
    },
    ownKeys(t) {
      return Reflect.ownKeys(t._current);
    },
    defineProperty() {
      throw Error("not supported");
    },
    getPrototypeOf(t) {
      return Object.getPrototypeOf(t._current);
    },
    setPrototypeOf() {
      throw Error("not supported");
    },
    getOwnPropertyDescriptor(t, e) {
      let i = t._current,
        n = Reflect.getOwnPropertyDescriptor(i, e);
      return (
        n && {
          writable: !0,
          configurable: !0,
          enumerable: n.enumerable,
          value: i[e],
        }
      );
    },
  },
  lU = {
    ...d_,
    set(t, e, i) {
      let n = { type: 0, props: { [e]: Ai(i) ?? i } };
      return t.deleteChildren(e), t.runOp(n), !0;
    },
    deleteProperty(t, e) {
      let i = { type: 0, props: { [e]: void 0 } };
      return t.deleteChildren(e), t.runOp(i), !0;
    },
  },
  cU = {
    ...d_,
    set(t, e, i) {
      return (
        i === void 0
          ? this.deleteProperty(t, e)
          : (t.deleteChildren(e), t.runOp({ type: 1, id: e, data: i })),
        !0
      );
    },
    deleteProperty(t, e) {
      return t.runOp({ type: 2, id: e }), !0;
    },
  },
  Mp = class extends Ml {
    constructor(t, e, i) {
      super(),
        (this._children = {}),
        (this._parent = t),
        (this._path = e),
        (this._current = i),
        (this[Ih] = () => {
          this._parent = null;
        });
    }
    unproxy() {
      return this._current;
    }
    update(t, e) {
      this._current = this._current.modifyById(t, e);
    }
    runOp(t) {
      this.reportOp(t, this._current.runOp(t));
    }
    randomId() {
      return this._current.randomId();
    }
    isDescendantOf(t, e) {
      return this._current.isDescendantOf(t, e);
    }
    childrenOf(t) {
      return this._current.childrenOf(t);
    }
    traverse(t) {
      return this._current.traverse(t);
    }
    get(t) {
      return this._current.get(t);
    }
    parent(t) {
      return this._current.parent(t);
    }
    traverse(t) {
      this._current.traverse((e, i) => {
        t(e, this.data(e));
      });
    }
    data(t) {
      var a;
      let { _current: e, _children: i } = this,
        n = i === void 0 ? void 0 : i[t];
      if (n !== void 0) return n;
      let r = (a = e.get(t)) == null ? void 0 : a.data,
        s = Uh(this, t, r);
      return s !== r
        ? (i === void 0 && ((i = {}), (this._children = i)), (i[t] = s), s)
        : r;
    }
    add(t, e, i, n, r) {
      this.runOp({ type: 7, parent: t, fi: e, id: i, data: n, children: r });
    }
    move(t, e, i) {
      this.runOp({ type: 9, parent: t, fi: e, id: i });
    }
    insertAfter(t, e, i) {
      let n = this._current.insertAfterHelper(t, e, i.length);
      for (let r = 0; r < i.length; r++) {
        let s = i[r];
        this.add(t, n[r], s.id, s.data, s.children);
      }
    }
    insertBefore(t, e, i) {
      let n = this._current.insertBeforeHelper(t, e, i.length);
      for (let r = 0; r < i.length; r++) {
        let s = i[r];
        this.add(t, n[r], s.id, s.data, s.children);
      }
    }
    moveAfter(t, e, i) {
      let n = this._current.insertAfterHelper(t, e, i.length);
      for (let r = 0; r < i.length; r++) {
        let s = i[r];
        this.move(t, n[r], s);
      }
    }
    moveBefore(t, e, i) {
      let n = this._current.insertBeforeHelper(t, e, i.length);
      for (let r = 0; r < i.length; r++) {
        let s = i[r];
        this.move(t, n[r], s);
      }
    }
    delete(t) {
      this.deleteChildren(t), this.runOp({ type: 8, id: t });
    }
    sortNext(t) {
      return this._current.sortNext(t);
    }
    sortPrevious(t) {
      return this._current.sortPrevious(t);
    }
    getAllSorted(t) {
      return this._current.getAllSorted(t);
    }
  },
  Ep = class extends Ml {
    constructor(t, e, i) {
      super(),
        (this._children = {}),
        (this._parent = t),
        (this._path = e),
        (this._current = i),
        (this[Ih] = () => {
          this._parent = null;
        });
    }
    unproxy() {
      return this._current;
    }
    get length() {
      return this._current.length;
    }
    forEach(t) {
      let e = this.length;
      for (let i = 0; i < e; i++) {
        let n = this._current[i].id,
          r = this._current[i].fi;
        t(this.data(this._current[i].id), n, r);
      }
    }
    find(t) {
      let e = this.length;
      for (let i = 0; i < e; i++) {
        let n = this._current[i].id;
        if (t(this.data(n), n)) return this.get(n);
      }
    }
    update(t, e) {
      this._current = this._current.modifyById(t, e);
    }
    randomId() {
      return this._current.randomId();
    }
    get(t) {
      return { ...this._current.get(t), data: this.data(t) };
    }
    data(t) {
      var a;
      let { _current: e, _children: i } = this,
        n = i === void 0 ? void 0 : i[t];
      if (n !== void 0) return n;
      let r = (a = e.get(t)) == null ? void 0 : a.data,
        s = Uh(this, t, r);
      return s !== r
        ? (i === void 0 && ((i = {}), (this._children = i)), (i[t] = s), s)
        : r;
    }
    runOp(t) {
      this.reportOp(t, this._current.runOp(t));
    }
    add(t, e, i) {
      this.runOp({ type: 4, fi: t, id: e, data: i });
    }
    move(t, e) {
      this.runOp({ type: 6, fi: t, id: e });
    }
    insertAfter(t, e) {
      let i = this._current.insertAfterHelper(t, e.length);
      for (let n = 0; n < e.length; n++) {
        let r = e[n];
        this.add(i[n], r.id, r.data);
      }
    }
    insertBefore(t, e) {
      let i = this._current.insertBeforeHelper(t, e.length);
      for (let n = 0; n < e.length; n++) {
        let r = e[n];
        this.add(i[n], r.id, r.data);
      }
    }
    moveAfter(t, e) {
      let i = this._current.insertAfterHelper(t, e.length);
      for (let n = 0; n < e.length; n++) {
        let r = e[n];
        this.move(i[n], r);
      }
    }
    moveBefore(t, e) {
      let i = this._current.insertBeforeHelper(t, e.length);
      for (let n = 0; n < e.length; n++) {
        let r = e[n];
        this.move(i[n], r);
      }
    }
    delete(t) {
      this.deleteChildren(t), this.runOp({ type: 5, id: t });
    }
  };
function Iu(t, e, i) {
  if (t.length > 0) {
    let n = t[t.length - 1];
    if (n.type === 0 && e.type === 0 && hr.equal(n.path, i)) {
      Object.assign(n.props, e.props);
      return;
    }
  }
  t.push({ ...e, path: i });
}
var f_ = class extends Ml {
  constructor(t) {
    super(),
      (this.ts = []),
      (this.actual = []),
      (this.reverse = []),
      (this._current = t);
  }
  update(t, e) {
    if (t !== "") throw new Error("");
    this._current = e;
  }
  push(t, e, i, n) {
    Iu(this.ts, e, t), Iu(this.actual, i, t), Iu(this.reverse, n, t);
  }
  result() {
    return {
      data: this._current,
      ts: this.ts,
      actual: this.actual,
      reverse: this.reverse.reverse(),
    };
  }
};
function Uh(t, e, i) {
  return i instanceof sn
    ? new Mp(t, e, i)
    : i instanceof Ot
    ? new Ep(t, e, i)
    : i instanceof pi
    ? new Proxy(new oU(t, e, i), cU)
    : i !== null && typeof i == "object"
    ? bp(i)
      ? i
      : new Proxy(new aU(t, e, i), lU)
    : i;
}
function p_(t) {
  let e = new f_(t);
  return [Uh(e, "", t), e];
}
function Qc(t, e) {
  let [i, n] = p_(t);
  return e(i), n.result();
}
function Ai(t) {
  return t instanceof Mp || t instanceof Ep
    ? t._current
    : t !== null && typeof t == "object"
    ? t[u_]
    : t;
}
var hr;
((t) => {
  function e(s, a) {
    if (a.length === s.length)
      for (var o = 0; o < s.length; ) {
        if (s[o] !== a[o]) return !1;
        o += 1;
      }
    else return !1;
    return !0;
  }
  t.equal = e;
  function i(s, a, o) {
    let l = r(o, s);
    if (l !== void 0 && typeof l == "object" && l !== null) {
      let c = { ...a };
      return (
        Object.keys(l).forEach((d) => {
          delete c[d];
        }),
        c
      );
    } else return a;
  }
  t.removeOverridden = i;
  function n(s, a) {
    if (
      ((s instanceof sn || s instanceof Mp) && typeof a == "string") ||
      ((s instanceof Ot || s instanceof Ep) && typeof a == "string")
    )
      return s.data(a);
    if (
      (typeof a == "number" && Array.isArray(s)) ||
      (typeof a == "string" && typeof s == "object" && s !== null)
    )
      return s[a];
  }
  t.zoomOnce = n;
  function r(s, a, o = 0) {
    for (; o < a.length && s !== void 0; ) (s = n(s, a[o])), (o += 1);
    return s;
  }
  t.zoom = r;
})(hr || (hr = {}));
function hU(t, e) {
  let i = [];
  if (e.length === t.length)
    for (var n = 0; n < t.length; ) {
      if (e[n] === "*") i.push(t[n]);
      else if (t[n] !== e[n]) return null;
      n += 1;
    }
  else return null;
  return i;
}
function Sn(t, e) {
  let i = [];
  if (e.length <= t.length)
    for (var n = 0; n < e.length; ) {
      if (e[n] === "*") i.push(t[n]);
      else if (t[n] !== e[n]) return null;
      n += 1;
    }
  else return null;
  return i;
}
var m_ = class {},
  _0 = class extends m_ {
    constructor(t) {
      super(), (this.id = t);
    }
  },
  b0 = class extends m_ {
    constructor(t) {
      super(), (this.data = t);
    }
  },
  Rd;
try {
  Rd = new TextDecoder();
} catch {}
var Ve,
  cs,
  ie = 0,
  Qi = {},
  Rt,
  Jr,
  xn = 0,
  sr = 0,
  hn,
  Br,
  $i = [],
  zt,
  w0 = { useRecords: !1, mapsAsObjects: !0 },
  g_ = class {},
  v_ = new g_();
v_.name = "MessagePack 0xC1";
var Qa = !1,
  eh = class {
    constructor(t) {
      t &&
        (t.useRecords === !1 &&
          t.mapsAsObjects === void 0 &&
          (t.mapsAsObjects = !0),
        t.structures
          ? (t.structures.sharedLength = t.structures.length)
          : t.getStructures &&
            (((t.structures = []).uninitialized = !0),
            (t.structures.sharedLength = 0))),
        Object.assign(this, t);
    }
    unpack(t, e) {
      if (Ve)
        return S_(
          () => (
            Id(), this ? this.unpack(t, e) : eh.prototype.unpack.call(w0, t, e)
          )
        );
      (cs = e > -1 ? e : t.length),
        (ie = 0),
        (sr = 0),
        (Jr = null),
        (hn = null),
        (Ve = t);
      try {
        zt =
          t.dataView ||
          (t.dataView = new DataView(t.buffer, t.byteOffset, t.byteLength));
      } catch (i) {
        throw (
          ((Ve = null),
          t instanceof Uint8Array
            ? i
            : new Error(
                "Source must be a Uint8Array or Buffer but was a " +
                  (t && typeof t == "object" ? t.constructor.name : typeof t)
              ))
        );
      }
      if (this instanceof eh) {
        if (((Qi = this), this.structures)) return (Rt = this.structures), lc();
        (!Rt || Rt.length > 0) && (Rt = []);
      } else (Qi = w0), (!Rt || Rt.length > 0) && (Rt = []);
      return lc();
    }
    unpackMultiple(t, e) {
      let i,
        n = 0;
      try {
        Qa = !0;
        let r = t.length,
          s = this ? this.unpack(t, r) : zh.unpack(t, r);
        if (e) {
          for (e(s); ie < r; ) if (((n = ie), e(lc()) === !1)) return;
        } else {
          for (i = [s]; ie < r; ) (n = ie), i.push(lc());
          return i;
        }
      } catch (r) {
        throw ((r.lastPosition = n), (r.values = i), r);
      } finally {
        (Qa = !1), Id();
      }
    }
    _mergeStructures(t, e) {
      t = t || [];
      for (let i = 0, n = t.length; i < n; i++) {
        let r = t[i];
        r && ((r.isShared = !0), i >= 32 && (r.highByte = (i - 32) >> 5));
      }
      t.sharedLength = t.length;
      for (let i in e || [])
        if (i >= 0) {
          let n = t[i],
            r = e[i];
          r &&
            (n && ((t.restoreStructures || (t.restoreStructures = []))[i] = n),
            (t[i] = r));
        }
      return (this.structures = t);
    }
    decode(t, e) {
      return this.unpack(t, e);
    }
  };
function lc() {
  try {
    if (!Qi.trusted && !Qa) {
      let e = Rt.sharedLength || 0;
      e < Rt.length && (Rt.length = e);
    }
    let t = ri();
    if (ie == cs)
      Rt.restoreStructures && S0(), (Rt = null), (Ve = null), Br && (Br = null);
    else if (ie > cs) {
      let e = new Error("Unexpected end of MessagePack data");
      throw ((e.incomplete = !0), e);
    } else if (!Qa) throw new Error("Data read, but end of buffer not reached");
    return t;
  } catch (t) {
    throw (
      (Rt.restoreStructures && S0(),
      Id(),
      (t instanceof RangeError ||
        t.message.startsWith("Unexpected end of buffer")) &&
        (t.incomplete = !0),
      t)
    );
  }
}
function S0() {
  for (let t in Rt.restoreStructures) Rt[t] = Rt.restoreStructures[t];
  Rt.restoreStructures = null;
}
function ri() {
  let t = Ve[ie++];
  if (t < 160)
    if (t < 128) {
      if (t < 64) return t;
      {
        let e = Rt[t & 63] || (Qi.getStructures && y_()[t & 63]);
        return e ? (e.read || (e.read = Tp(e, t & 63)), e.read()) : t;
      }
    } else if (t < 144)
      if (((t -= 128), Qi.mapsAsObjects)) {
        let e = {};
        for (let i = 0; i < t; i++) e[__()] = ri();
        return e;
      } else {
        let e = new Map();
        for (let i = 0; i < t; i++) e.set(ri(), ri());
        return e;
      }
    else {
      t -= 144;
      let e = new Array(t);
      for (let i = 0; i < t; i++) e[i] = ri();
      return e;
    }
  else if (t < 192) {
    let e = t - 160;
    if (sr >= ie) return Jr.slice(ie - xn, (ie += e) - xn);
    if (sr == 0 && cs < 140) {
      let i = e < 16 ? Ap(e) : x_(e);
      if (i != null) return i;
    }
    return Od(e);
  } else {
    let e;
    switch (t) {
      case 192:
        return null;
      case 193:
        return hn
          ? ((e = ri()),
            e > 0
              ? hn[1].slice(hn.position1, (hn.position1 += e))
              : hn[0].slice(hn.position0, (hn.position0 -= e)))
          : v_;
      case 194:
        return !1;
      case 195:
        return !0;
      case 196:
        return Uu(Ve[ie++]);
      case 197:
        return (e = zt.getUint16(ie)), (ie += 2), Uu(e);
      case 198:
        return (e = zt.getUint32(ie)), (ie += 4), Uu(e);
      case 199:
        return Ts(Ve[ie++]);
      case 200:
        return (e = zt.getUint16(ie)), (ie += 2), Ts(e);
      case 201:
        return (e = zt.getUint32(ie)), (ie += 4), Ts(e);
      case 202:
        if (((e = zt.getFloat32(ie)), Qi.useFloat32 > 2)) {
          let i = Cp[((Ve[ie] & 127) << 1) | (Ve[ie + 1] >> 7)];
          return (ie += 4), ((i * e + (e > 0 ? 0.5 : -0.5)) >> 0) / i;
        }
        return (ie += 4), e;
      case 203:
        return (e = zt.getFloat64(ie)), (ie += 8), e;
      case 204:
        return Ve[ie++];
      case 205:
        return (e = zt.getUint16(ie)), (ie += 2), e;
      case 206:
        return (e = zt.getUint32(ie)), (ie += 4), e;
      case 207:
        return (
          Qi.int64AsNumber
            ? ((e = zt.getUint32(ie) * 4294967296), (e += zt.getUint32(ie + 4)))
            : (e = zt.getBigUint64(ie)),
          (ie += 8),
          e
        );
      case 208:
        return zt.getInt8(ie++);
      case 209:
        return (e = zt.getInt16(ie)), (ie += 2), e;
      case 210:
        return (e = zt.getInt32(ie)), (ie += 4), e;
      case 211:
        return (
          Qi.int64AsNumber
            ? ((e = zt.getInt32(ie) * 4294967296), (e += zt.getUint32(ie + 4)))
            : (e = zt.getBigInt64(ie)),
          (ie += 8),
          e
        );
      case 212:
        if (((e = Ve[ie++]), e == 114)) return C0(Ve[ie++] & 63);
        {
          let i = $i[e];
          if (i)
            return i.read
              ? (ie++, i.read(ri()))
              : i.noBuffer
              ? (ie++, i())
              : i(Ve.subarray(ie, ++ie));
          throw new Error("Unknown extension " + e);
        }
      case 213:
        return (
          (e = Ve[ie]), e == 114 ? (ie++, C0(Ve[ie++] & 63, Ve[ie++])) : Ts(2)
        );
      case 214:
        return Ts(4);
      case 215:
        return Ts(8);
      case 216:
        return Ts(16);
      case 217:
        return (
          (e = Ve[ie++]), sr >= ie ? Jr.slice(ie - xn, (ie += e) - xn) : dU(e)
        );
      case 218:
        return (
          (e = zt.getUint16(ie)),
          (ie += 2),
          sr >= ie ? Jr.slice(ie - xn, (ie += e) - xn) : fU(e)
        );
      case 219:
        return (
          (e = zt.getUint32(ie)),
          (ie += 4),
          sr >= ie ? Jr.slice(ie - xn, (ie += e) - xn) : pU(e)
        );
      case 220:
        return (e = zt.getUint16(ie)), (ie += 2), E0(e);
      case 221:
        return (e = zt.getUint32(ie)), (ie += 4), E0(e);
      case 222:
        return (e = zt.getUint16(ie)), (ie += 2), T0(e);
      case 223:
        return (e = zt.getUint32(ie)), (ie += 4), T0(e);
      default:
        if (t >= 224) return t - 256;
        if (t === void 0) {
          let i = new Error("Unexpected end of MessagePack data");
          throw ((i.incomplete = !0), i);
        }
        throw new Error("Unknown MessagePack token " + t);
    }
  }
}
var uU = /^[a-zA-Z_$][a-zA-Z\d_$]*$/;
function Tp(t, e) {
  function i() {
    if (i.count++ > 2) {
      let r = (t.read = new Function(
        "r",
        "return function(){return {" +
          t
            .map((s) =>
              uU.test(s) ? s + ":r()" : "[" + JSON.stringify(s) + "]:r()"
            )
            .join(",") +
          "}}"
      )(ri));
      return t.highByte === 0 && (t.read = M0(e, t.read)), r();
    }
    let n = {};
    for (let r = 0, s = t.length; r < s; r++) {
      let a = t[r];
      n[a] = ri();
    }
    return n;
  }
  return (i.count = 0), t.highByte === 0 ? M0(e, i) : i;
}
var M0 = (t, e) =>
  function () {
    let i = Ve[ie++];
    if (i === 0) return e();
    let n = t < 32 ? -(t + (i << 5)) : t + (i << 5),
      r = Rt[n] || y_()[n];
    if (!r) throw new Error("Record id is not defined for " + n);
    return r.read || (r.read = Tp(r, t)), r.read();
  };
function y_() {
  let t = S_(() => ((Ve = null), Qi.getStructures()));
  return (Rt = Qi._mergeStructures(t, Rt));
}
var Od = Nh,
  dU = Nh,
  fU = Nh,
  pU = Nh;
function Nh(t) {
  let e;
  if (t < 16 && (e = Ap(t))) return e;
  if (t > 64 && Rd) return Rd.decode(Ve.subarray(ie, (ie += t)));
  let i = ie + t,
    n = [];
  for (e = ""; ie < i; ) {
    let r = Ve[ie++];
    if (!(r & 128)) n.push(r);
    else if ((r & 224) === 192) {
      let s = Ve[ie++] & 63;
      n.push(((r & 31) << 6) | s);
    } else if ((r & 240) === 224) {
      let s = Ve[ie++] & 63,
        a = Ve[ie++] & 63;
      n.push(((r & 31) << 12) | (s << 6) | a);
    } else if ((r & 248) === 240) {
      let s = Ve[ie++] & 63,
        a = Ve[ie++] & 63,
        o = Ve[ie++] & 63,
        l = ((r & 7) << 18) | (s << 12) | (a << 6) | o;
      l > 65535 &&
        ((l -= 65536),
        n.push(((l >>> 10) & 1023) | 55296),
        (l = 56320 | (l & 1023))),
        n.push(l);
    } else n.push(r);
    n.length >= 4096 && ((e += Mi.apply(String, n)), (n.length = 0));
  }
  return n.length > 0 && (e += Mi.apply(String, n)), e;
}
function E0(t) {
  let e = new Array(t);
  for (let i = 0; i < t; i++) e[i] = ri();
  return e;
}
function T0(t) {
  if (Qi.mapsAsObjects) {
    let e = {};
    for (let i = 0; i < t; i++) e[__()] = ri();
    return e;
  } else {
    let e = new Map();
    for (let i = 0; i < t; i++) e.set(ri(), ri());
    return e;
  }
}
var Mi = String.fromCharCode;
function x_(t) {
  let e = ie,
    i = new Array(t);
  for (let n = 0; n < t; n++) {
    let r = Ve[ie++];
    if ((r & 128) > 0) {
      ie = e;
      return;
    }
    i[n] = r;
  }
  return Mi.apply(String, i);
}
function Ap(t) {
  if (t < 4)
    if (t < 2) {
      if (t === 0) return "";
      {
        let e = Ve[ie++];
        if ((e & 128) > 1) {
          ie -= 1;
          return;
        }
        return Mi(e);
      }
    } else {
      let e = Ve[ie++],
        i = Ve[ie++];
      if ((e & 128) > 0 || (i & 128) > 0) {
        ie -= 2;
        return;
      }
      if (t < 3) return Mi(e, i);
      let n = Ve[ie++];
      if ((n & 128) > 0) {
        ie -= 3;
        return;
      }
      return Mi(e, i, n);
    }
  else {
    let e = Ve[ie++],
      i = Ve[ie++],
      n = Ve[ie++],
      r = Ve[ie++];
    if ((e & 128) > 0 || (i & 128) > 0 || (n & 128) > 0 || (r & 128) > 0) {
      ie -= 4;
      return;
    }
    if (t < 6) {
      if (t === 4) return Mi(e, i, n, r);
      {
        let s = Ve[ie++];
        if ((s & 128) > 0) {
          ie -= 5;
          return;
        }
        return Mi(e, i, n, r, s);
      }
    } else if (t < 8) {
      let s = Ve[ie++],
        a = Ve[ie++];
      if ((s & 128) > 0 || (a & 128) > 0) {
        ie -= 6;
        return;
      }
      if (t < 7) return Mi(e, i, n, r, s, a);
      let o = Ve[ie++];
      if ((o & 128) > 0) {
        ie -= 7;
        return;
      }
      return Mi(e, i, n, r, s, a, o);
    } else {
      let s = Ve[ie++],
        a = Ve[ie++],
        o = Ve[ie++],
        l = Ve[ie++];
      if ((s & 128) > 0 || (a & 128) > 0 || (o & 128) > 0 || (l & 128) > 0) {
        ie -= 8;
        return;
      }
      if (t < 10) {
        if (t === 8) return Mi(e, i, n, r, s, a, o, l);
        {
          let c = Ve[ie++];
          if ((c & 128) > 0) {
            ie -= 9;
            return;
          }
          return Mi(e, i, n, r, s, a, o, l, c);
        }
      } else if (t < 12) {
        let c = Ve[ie++],
          d = Ve[ie++];
        if ((c & 128) > 0 || (d & 128) > 0) {
          ie -= 10;
          return;
        }
        if (t < 11) return Mi(e, i, n, r, s, a, o, l, c, d);
        let h = Ve[ie++];
        if ((h & 128) > 0) {
          ie -= 11;
          return;
        }
        return Mi(e, i, n, r, s, a, o, l, c, d, h);
      } else {
        let c = Ve[ie++],
          d = Ve[ie++],
          h = Ve[ie++],
          u = Ve[ie++];
        if ((c & 128) > 0 || (d & 128) > 0 || (h & 128) > 0 || (u & 128) > 0) {
          ie -= 12;
          return;
        }
        if (t < 14) {
          if (t === 12) return Mi(e, i, n, r, s, a, o, l, c, d, h, u);
          {
            let f = Ve[ie++];
            if ((f & 128) > 0) {
              ie -= 13;
              return;
            }
            return Mi(e, i, n, r, s, a, o, l, c, d, h, u, f);
          }
        } else {
          let f = Ve[ie++],
            p = Ve[ie++];
          if ((f & 128) > 0 || (p & 128) > 0) {
            ie -= 14;
            return;
          }
          if (t < 15) return Mi(e, i, n, r, s, a, o, l, c, d, h, u, f, p);
          let v = Ve[ie++];
          if ((v & 128) > 0) {
            ie -= 15;
            return;
          }
          return Mi(e, i, n, r, s, a, o, l, c, d, h, u, f, p, v);
        }
      }
    }
  }
}
function Uu(t) {
  return Qi.copyBuffers
    ? Uint8Array.prototype.slice.call(Ve, ie, (ie += t))
    : Ve.subarray(ie, (ie += t));
}
function Ts(t) {
  let e = Ve[ie++];
  if ($i[e]) return $i[e](Ve.subarray(ie, (ie += t)));
  throw new Error("Unknown extension type " + e);
}
var A0 = new Array(4096);
function __() {
  let t = Ve[ie++];
  if (t >= 160 && t < 192) {
    if (((t = t - 160), sr >= ie)) return Jr.slice(ie - xn, (ie += t) - xn);
    if (!(sr == 0 && cs < 180)) return Od(t);
  } else return ie--, ri();
  let e = ((t << 5) ^ (t > 1 ? zt.getUint16(ie) : t > 0 ? Ve[ie] : 0)) & 4095,
    i = A0[e],
    n = ie,
    r = ie + t - 3,
    s,
    a = 0;
  if (i && i.bytes == t) {
    for (; n < r; ) {
      if (((s = zt.getUint32(n)), s != i[a++])) {
        n = 1879048192;
        break;
      }
      n += 4;
    }
    for (r += 3; n < r; )
      if (((s = Ve[n++]), s != i[a++])) {
        n = 1879048192;
        break;
      }
    if (n === r) return (ie = n), i.string;
    (r -= 3), (n = ie);
  }
  for (i = [], A0[e] = i, i.bytes = t; n < r; )
    (s = zt.getUint32(n)), i.push(s), (n += 4);
  for (r += 3; n < r; ) (s = Ve[n++]), i.push(s);
  let o = t < 16 ? Ap(t) : x_(t);
  return o != null ? (i.string = o) : (i.string = Od(t));
}
var C0 = (t, e) => {
    var i = ri();
    let n = t;
    e !== void 0 &&
      ((t = t < 32 ? -((e << 5) + t) : (e << 5) + t), (i.highByte = e));
    let r = Rt[t];
    return (
      r &&
        r.isShared &&
        ((Rt.restoreStructures || (Rt.restoreStructures = []))[t] = r),
      (Rt[t] = i),
      (i.read = Tp(i, n)),
      i.read()
    );
  },
  b_ = typeof self == "object" ? self : global;
$i[0] = () => {};
$i[0].noBuffer = !0;
$i[101] = () => {
  let t = ri();
  return (b_[t[0]] || Error)(t[1]);
};
$i[105] = (t) => {
  let e = zt.getUint32(ie - 4);
  Br || (Br = new Map());
  let i = Ve[ie],
    n;
  (i >= 144 && i < 160) || i == 220 || i == 221 ? (n = []) : (n = {});
  let r = { target: n };
  Br.set(e, r);
  let s = ri();
  return r.used ? Object.assign(n, s) : ((r.target = s), s);
};
$i[112] = (t) => {
  let e = zt.getUint32(ie - 4),
    i = Br.get(e);
  return (i.used = !0), i.target;
};
$i[115] = () => new Set(ri());
var w_ = [
  "Int8",
  "Uint8",
  "Uint8Clamped",
  "Int16",
  "Uint16",
  "Int32",
  "Uint32",
  "Float32",
  "Float64",
  "BigInt64",
  "BigUint64",
].map((t) => t + "Array");
$i[116] = (t) => {
  let e = t[0],
    i = w_[e];
  if (!i) throw new Error("Could not find typed array for code " + e);
  return new b_[i](Uint8Array.prototype.slice.call(t, 1).buffer);
};
$i[120] = () => {
  let t = ri();
  return new RegExp(t[0], t[1]);
};
$i[98] = (t) => {
  let e = (t[0] << 24) + (t[1] << 16) + (t[2] << 8) + t[3],
    i = ie;
  (ie += e - 4), (hn = [ri(), ri()]), (hn.position0 = 0), (hn.position1 = 0);
  let n = ie;
  ie = i;
  try {
    return ri();
  } finally {
    ie = n;
  }
};
$i[255] = (t) =>
  t.length == 4
    ? new Date((t[0] * 16777216 + (t[1] << 16) + (t[2] << 8) + t[3]) * 1e3)
    : t.length == 8
    ? new Date(
        ((t[0] << 22) + (t[1] << 14) + (t[2] << 6) + (t[3] >> 2)) / 1e6 +
          ((t[3] & 3) * 4294967296 +
            t[4] * 16777216 +
            (t[5] << 16) +
            (t[6] << 8) +
            t[7]) *
            1e3
      )
    : t.length == 12
    ? new Date(
        ((t[0] << 24) + (t[1] << 16) + (t[2] << 8) + t[3]) / 1e6 +
          ((t[4] & 128 ? -281474976710656 : 0) +
            t[6] * 1099511627776 +
            t[7] * 4294967296 +
            t[8] * 16777216 +
            (t[9] << 16) +
            (t[10] << 8) +
            t[11]) *
            1e3
      )
    : new Date("invalid");
function S_(t) {
  let e = cs,
    i = ie,
    n = xn,
    r = sr,
    s = Jr,
    a = Br,
    o = hn,
    l = new Uint8Array(Ve.slice(0, cs)),
    c = Rt,
    d = Rt.slice(0, Rt.length),
    h = Qi,
    u = Qa,
    f = t();
  return (
    (cs = e),
    (ie = i),
    (xn = n),
    (sr = r),
    (Jr = s),
    (Br = a),
    (hn = o),
    (Ve = l),
    (Qa = u),
    (Rt = c),
    Rt.splice(0, Rt.length, ...d),
    (Qi = h),
    (zt = new DataView(Ve.buffer, Ve.byteOffset, Ve.byteLength)),
    f
  );
}
function Id() {
  (Ve = null), (Br = null), (Rt = null);
}
function mU(t) {
  t.unpack ? ($i[t.type] = t.unpack) : ($i[t.type] = t);
}
var Cp = new Array(147);
for (let t = 0; t < 256; t++) Cp[t] = +("1e" + Math.floor(45.15 - t * 0.30103));
var zh = new eh({ useRecords: !1 });
zh.unpack;
zh.unpackMultiple;
zh.unpack;
var gU = new Float32Array(1);
new Uint8Array(gU.buffer, 0, 4);
var Ic;
try {
  Ic = new TextEncoder();
} catch {}
var th,
  Pp,
  Bh = typeof Buffer < "u",
  Nu = Bh ? Buffer.allocUnsafeSlow : Uint8Array,
  M_ = Bh ? Buffer : Uint8Array,
  P0 = Bh ? 4294967296 : 2144337920,
  ve,
  ui,
  ce = 0,
  Jn,
  Qn = null,
  vU = /[\u0080-\uFFFF]/,
  Co = Symbol("record-id"),
  E_ = class extends eh {
    constructor(t) {
      super(t), (this.offset = 0);
      let e,
        i,
        n,
        r,
        s,
        a = 0,
        o = M_.prototype.utf8Write
          ? function (b, E, T) {
              return ve.utf8Write(b, E, T);
            }
          : Ic && Ic.encodeInto
          ? function (b, E) {
              return Ic.encodeInto(b, ve.subarray(E)).written;
            }
          : !1,
        l = this;
      t || (t = {});
      let c = t && t.sequential,
        d = t.structures || t.saveStructures,
        h = t.maxSharedStructures;
      if ((h == null && (h = d ? 32 : 0), h > 8160))
        throw new Error("Maximum maxSharedStructure is 8160");
      let u = t.maxOwnStructures;
      u == null && (u = d ? 32 : 64),
        c && !t.saveStructures && (this.structures = []);
      let f = h > 32 || u + h > 64,
        p = h + 64,
        v = h + u + 64;
      if (v > 8256)
        throw new Error("Maximum maxSharedStructure + maxOwnStructure is 8192");
      let g = [],
        m = 0,
        x = 0;
      this.pack = this.encode = function (b, E) {
        if (
          (ve ||
            ((ve = new Nu(8192)),
            (ui = new DataView(ve.buffer, 0, 8192)),
            (ce = 0)),
          (Jn = ve.length - 10),
          Jn - ce < 2048
            ? ((ve = new Nu(ve.length)),
              (ui = new DataView(ve.buffer, 0, ve.length)),
              (Jn = ve.length - 10),
              (ce = 0))
            : (ce = (ce + 7) & 2147483640),
          (e = ce),
          (s = l.structuredClone ? new Map() : null),
          l.bundleStrings
            ? ((Qn = ["", ""]),
              (ve[ce++] = 214),
              (ve[ce++] = 98),
              (Qn.position = ce - e),
              (ce += 4))
            : (Qn = null),
          (i = l.structures),
          i)
        ) {
          i.uninitialized && (i = l._mergeStructures(l.getStructures()));
          let T = i.sharedLength || 0;
          if (T > h)
            throw new Error(
              "Shared structures is larger than maximum shared structures, try increasing maxSharedStructures to " +
                i.sharedLength
            );
          if (!i.transitions) {
            i.transitions = Object.create(null);
            for (let S = 0; S < T; S++) {
              let w = i[S];
              if (!w) continue;
              let C,
                L = i.transitions;
              for (let P = 0, R = w.length; P < R; P++) {
                let I = w[P];
                (C = L[I]), C || (C = L[I] = Object.create(null)), (L = C);
              }
              L[Co] = S + 64;
            }
            a = T;
          }
          c || (i.nextId = T + 64);
        }
        n && (n = !1), (r = i || []);
        try {
          if ((y(b), Qn)) {
            ui.setUint32(Qn.position + e, ce - Qn.position - e);
            let T = Qn;
            (Qn = null), y(T[0]), y(T[1]);
          }
          if (((l.offset = ce), s && s.idsToInsert)) {
            (ce += s.idsToInsert.length * 6), ce > Jn && M(ce), (l.offset = ce);
            let T = xU(ve.subarray(e, ce), s.idsToInsert);
            return (s = null), T;
          }
          return E & _U
            ? ((ve.start = e), (ve.end = ce), ve)
            : ve.subarray(e, ce);
        } finally {
          if (i) {
            if ((x < 10 && x++, m > 1e4))
              (i.transitions = null),
                (x = 0),
                (m = 0),
                g.length > 0 && (g = []);
            else if (g.length > 0 && !c) {
              for (let T = 0, S = g.length; T < S; T++) g[T][Co] = 0;
              g = [];
            }
            if (n && l.saveStructures) {
              let T = i.sharedLength || h;
              i.length > T && (i = i.slice(0, T));
              let S = ve.subarray(e, ce);
              return l.saveStructures(i, a) === !1
                ? (l._mergeStructures(l.getStructures()), l.pack(b))
                : ((a = T), S);
            }
          }
          E & bU && (ce = e);
        }
      };
      let y = (b) => {
          ce > Jn && (ve = M(ce));
          var E = typeof b,
            T;
          if (E === "string") {
            let S = b.length;
            if (Qn && S >= 8 && S < 4096) {
              let L = vU.test(b);
              (Qn[L ? 0 : 1] += b), (ve[ce++] = 193), y(L ? -S : S);
              return;
            }
            let w;
            S < 32
              ? (w = 1)
              : S < 256
              ? (w = 2)
              : S < 65536
              ? (w = 3)
              : (w = 5);
            let C = S * 3;
            if ((ce + C > Jn && (ve = M(ce + C)), S < 64 || !o)) {
              let L,
                P,
                R,
                I = ce + w;
              for (L = 0; L < S; L++)
                (P = b.charCodeAt(L)),
                  P < 128
                    ? (ve[I++] = P)
                    : P < 2048
                    ? ((ve[I++] = (P >> 6) | 192), (ve[I++] = (P & 63) | 128))
                    : (P & 64512) === 55296 &&
                      ((R = b.charCodeAt(L + 1)) & 64512) === 56320
                    ? ((P = 65536 + ((P & 1023) << 10) + (R & 1023)),
                      L++,
                      (ve[I++] = (P >> 18) | 240),
                      (ve[I++] = ((P >> 12) & 63) | 128),
                      (ve[I++] = ((P >> 6) & 63) | 128),
                      (ve[I++] = (P & 63) | 128))
                    : ((ve[I++] = (P >> 12) | 224),
                      (ve[I++] = ((P >> 6) & 63) | 128),
                      (ve[I++] = (P & 63) | 128));
              T = I - ce - w;
            } else T = o(b, ce + w, C);
            T < 32
              ? (ve[ce++] = 160 | T)
              : T < 256
              ? (w < 2 && ve.copyWithin(ce + 2, ce + 1, ce + 1 + T),
                (ve[ce++] = 217),
                (ve[ce++] = T))
              : T < 65536
              ? (w < 3 && ve.copyWithin(ce + 3, ce + 2, ce + 2 + T),
                (ve[ce++] = 218),
                (ve[ce++] = T >> 8),
                (ve[ce++] = T & 255))
              : (w < 5 && ve.copyWithin(ce + 5, ce + 3, ce + 3 + T),
                (ve[ce++] = 219),
                ui.setUint32(ce, T),
                (ce += 4)),
              (ce += T);
          } else if (E === "number")
            if (b >>> 0 === b)
              b < 64
                ? (ve[ce++] = b)
                : b < 256
                ? ((ve[ce++] = 204), (ve[ce++] = b))
                : b < 65536
                ? ((ve[ce++] = 205), (ve[ce++] = b >> 8), (ve[ce++] = b & 255))
                : ((ve[ce++] = 206), ui.setUint32(ce, b), (ce += 4));
            else if (b >> 0 === b)
              b >= -32
                ? (ve[ce++] = 256 + b)
                : b >= -128
                ? ((ve[ce++] = 208), (ve[ce++] = b + 256))
                : b >= -32768
                ? ((ve[ce++] = 209), ui.setInt16(ce, b), (ce += 2))
                : ((ve[ce++] = 210), ui.setInt32(ce, b), (ce += 4));
            else {
              let S;
              if (
                (S = this.useFloat32) > 0 &&
                b < 4294967296 &&
                b >= -2147483648
              ) {
                (ve[ce++] = 202), ui.setFloat32(ce, b);
                let w;
                if (
                  S < 4 ||
                  (w = b * Cp[((ve[ce] & 127) << 1) | (ve[ce + 1] >> 7)]) >>
                    0 ===
                    w
                ) {
                  ce += 4;
                  return;
                } else ce--;
              }
              (ve[ce++] = 203), ui.setFloat64(ce, b), (ce += 8);
            }
          else if (E === "object")
            if (!b) ve[ce++] = 192;
            else {
              if (s) {
                let w = s.get(b);
                if (w) {
                  if (!w.id) {
                    let C = s.idsToInsert || (s.idsToInsert = []);
                    w.id = C.push(w);
                  }
                  (ve[ce++] = 214),
                    (ve[ce++] = 112),
                    ui.setUint32(ce, w.id),
                    (ce += 4);
                  return;
                } else s.set(b, { offset: ce - e });
              }
              let S = b.constructor;
              if (S === Object) _(b, !0);
              else if (S === Array) {
                (T = b.length),
                  T < 16
                    ? (ve[ce++] = 144 | T)
                    : T < 65536
                    ? ((ve[ce++] = 220),
                      (ve[ce++] = T >> 8),
                      (ve[ce++] = T & 255))
                    : ((ve[ce++] = 221), ui.setUint32(ce, T), (ce += 4));
                for (let w = 0; w < T; w++) y(b[w]);
              } else if (S === Map) {
                (T = b.size),
                  T < 16
                    ? (ve[ce++] = 128 | T)
                    : T < 65536
                    ? ((ve[ce++] = 222),
                      (ve[ce++] = T >> 8),
                      (ve[ce++] = T & 255))
                    : ((ve[ce++] = 223), ui.setUint32(ce, T), (ce += 4));
                for (let [w, C] of b) y(w), y(C);
              } else {
                for (let w = 0, C = th.length; w < C; w++) {
                  let L = Pp[w];
                  if (b instanceof L) {
                    let P = th[w];
                    if (P.write) {
                      P.type &&
                        ((ve[ce++] = 212), (ve[ce++] = P.type), (ve[ce++] = 0)),
                        y(P.write.call(this, b));
                      return;
                    }
                    let R = ve,
                      I = ui,
                      W = ce;
                    ve = null;
                    let N;
                    try {
                      N = P.pack.call(
                        this,
                        b,
                        (U) => (
                          (ve = R),
                          (R = null),
                          (ce += U),
                          ce > Jn && M(ce),
                          { target: ve, targetView: ui, position: ce - U }
                        ),
                        y
                      );
                    } finally {
                      R &&
                        ((ve = R), (ui = I), (ce = W), (Jn = ve.length - 10));
                    }
                    N &&
                      (N.length + ce > Jn && M(N.length + ce),
                      (ce = yU(N, ve, ce, P.type)));
                    return;
                  }
                }
                _(b, !b.hasOwnProperty);
              }
            }
          else if (E === "boolean") ve[ce++] = b ? 195 : 194;
          else if (E === "bigint") {
            if (b < BigInt(1) << BigInt(63) && b >= -(BigInt(1) << BigInt(63)))
              (ve[ce++] = 211), ui.setBigInt64(ce, b);
            else if (b < BigInt(1) << BigInt(64) && b > 0)
              (ve[ce++] = 207), ui.setBigUint64(ce, b);
            else if (this.largeBigIntToFloat)
              (ve[ce++] = 203), ui.setFloat64(ce, Number(b));
            else
              throw new RangeError(
                b +
                  " was too large to fit in MessagePack 64-bit integer format, set largeBigIntToFloat to convert to float-64"
              );
            ce += 8;
          } else if (E === "undefined")
            this.encodeUndefinedAsNil
              ? (ve[ce++] = 192)
              : ((ve[ce++] = 212), (ve[ce++] = 0), (ve[ce++] = 0));
          else if (E === "function")
            y(this.writeFunction && this.writeFunction());
          else throw new Error("Unknown type: " + E);
        },
        _ =
          this.useRecords === !1
            ? this.variableMapSize
              ? (b) => {
                  let E = Object.keys(b),
                    T = E.length;
                  T < 16
                    ? (ve[ce++] = 128 | T)
                    : T < 65536
                    ? ((ve[ce++] = 222),
                      (ve[ce++] = T >> 8),
                      (ve[ce++] = T & 255))
                    : ((ve[ce++] = 223), ui.setUint32(ce, T), (ce += 4));
                  let S;
                  for (let w = 0; w < T; w++) y((S = E[w])), y(b[S]);
                }
              : (b, E) => {
                  ve[ce++] = 222;
                  let T = ce - e;
                  ce += 2;
                  let S = 0;
                  for (let w in b)
                    (E || b.hasOwnProperty(w)) && (y(w), y(b[w]), S++);
                  (ve[T++ + e] = S >> 8), (ve[T + e] = S & 255);
                }
            : (b) => {
                let E = Object.keys(b),
                  T,
                  S = r.transitions || (r.transitions = Object.create(null)),
                  w = 0;
                for (let L = 0, P = E.length; L < P; L++) {
                  let R = E[L];
                  (T = S[R]),
                    T || ((T = S[R] = Object.create(null)), w++),
                    (S = T);
                }
                let C = S[Co];
                if (C)
                  C >= 96 && f
                    ? ((ve[ce++] = ((C -= 96) & 31) + 96), (ve[ce++] = C >> 5))
                    : (ve[ce++] = C);
                else {
                  (C = r.nextId),
                    C || (C = 64),
                    C < p &&
                    this.shouldShareStructure &&
                    !this.shouldShareStructure(E)
                      ? ((C = r.nextOwnId),
                        C < v || (C = p),
                        (r.nextOwnId = C + 1))
                      : (C >= v && (C = p), (r.nextId = C + 1));
                  let L = (E.highByte = C >= 96 && f ? (C - 96) >> 5 : -1);
                  (S[Co] = C),
                    (r[C - 64] = E),
                    C < p
                      ? ((E.isShared = !0),
                        (r.sharedLength = C - 63),
                        (n = !0),
                        L >= 0
                          ? ((ve[ce++] = (C & 31) + 96), (ve[ce++] = L))
                          : (ve[ce++] = C))
                      : (L >= 0
                          ? ((ve[ce++] = 213),
                            (ve[ce++] = 114),
                            (ve[ce++] = (C & 31) + 96),
                            (ve[ce++] = L))
                          : ((ve[ce++] = 212),
                            (ve[ce++] = 114),
                            (ve[ce++] = C)),
                        w && (m += x * w),
                        g.length >= u && (g.shift()[Co] = 0),
                        g.push(S),
                        y(E));
                }
                for (let L = 0, P = E.length; L < P; L++) y(b[E[L]]);
              },
        M = (b) => {
          let E;
          if (b > 16777216) {
            if (b - e > P0)
              throw new Error(
                "Packed buffer would be larger than maximum buffer size"
              );
            E = Math.min(
              P0,
              Math.round(
                Math.max((b - e) * (b > 67108864 ? 1.25 : 2), 4194304) / 4096
              ) * 4096
            );
          } else E = ((Math.max((b - e) << 2, ve.length - 1) >> 12) + 1) << 12;
          let T = new Nu(E);
          return (
            (ui = new DataView(T.buffer, 0, E)),
            ve.copy ? ve.copy(T, 0, e, b) : T.set(ve.slice(e, b)),
            (ce -= e),
            (e = 0),
            (Jn = T.length - 10),
            (ve = T)
          );
        };
    }
    useBuffer(t) {
      (ve = t),
        (ui = new DataView(ve.buffer, ve.byteOffset, ve.byteLength)),
        (ce = 0);
    }
  };
Pp = [
  Date,
  Set,
  Error,
  RegExp,
  ArrayBuffer,
  Object.getPrototypeOf(Uint8Array.prototype).constructor,
  g_,
];
th = [
  {
    pack(t, e, i) {
      let n = t.getTime() / 1e3;
      if (
        (this.useTimestamp32 || t.getMilliseconds() === 0) &&
        n >= 0 &&
        n < 4294967296
      ) {
        let { target: r, targetView: s, position: a } = e(6);
        (r[a++] = 214), (r[a++] = 255), s.setUint32(a, n);
      } else if (n > 0 && n < 17179869184) {
        let { target: r, targetView: s, position: a } = e(10);
        (r[a++] = 215),
          (r[a++] = 255),
          s.setUint32(
            a,
            t.getMilliseconds() * 4e6 + ((n / 1e3 / 4294967296) >> 0)
          ),
          s.setUint32(a + 4, n);
      } else if (isNaN(n)) {
        if (this.onInvalidDate) return e(0), i(this.onInvalidDate());
        let { target: r, targetView: s, position: a } = e(3);
        (r[a++] = 212), (r[a++] = 255), (r[a++] = 255);
      } else {
        let { target: r, targetView: s, position: a } = e(15);
        (r[a++] = 199),
          (r[a++] = 12),
          (r[a++] = 255),
          s.setUint32(a, t.getMilliseconds() * 1e6),
          s.setBigInt64(a + 4, BigInt(Math.floor(n)));
      }
    },
  },
  {
    pack(t, e, i) {
      let n = Array.from(t),
        { target: r, position: s } = e(this.structuredClone ? 3 : 0);
      this.structuredClone && ((r[s++] = 212), (r[s++] = 115), (r[s++] = 0)),
        i(n);
    },
  },
  {
    pack(t, e, i) {
      let { target: n, position: r } = e(this.structuredClone ? 3 : 0);
      this.structuredClone && ((n[r++] = 212), (n[r++] = 101), (n[r++] = 0)),
        i([t.name, t.message]);
    },
  },
  {
    pack(t, e, i) {
      let { target: n, position: r } = e(this.structuredClone ? 3 : 0);
      this.structuredClone && ((n[r++] = 212), (n[r++] = 120), (n[r++] = 0)),
        i([t.source, t.flags]);
    },
  },
  {
    pack(t, e) {
      this.structuredClone
        ? L0(t, 16, e)
        : D0(Bh ? Buffer.from(t) : new Uint8Array(t), e);
    },
  },
  {
    pack(t, e) {
      let i = t.constructor;
      i !== M_ && this.structuredClone
        ? L0(t, w_.indexOf(i.name), e)
        : D0(t, e);
    },
  },
  {
    pack(t, e) {
      let { target: i, position: n } = e(1);
      i[n] = 193;
    },
  },
];
function L0(t, e, i, n) {
  let r = t.byteLength;
  if (r + 1 < 256) {
    var { target: s, position: a } = i(4 + r);
    (s[a++] = 199), (s[a++] = r + 1);
  } else if (r + 1 < 65536) {
    var { target: s, position: a } = i(5 + r);
    (s[a++] = 200), (s[a++] = (r + 1) >> 8), (s[a++] = (r + 1) & 255);
  } else {
    var { target: s, position: a, targetView: o } = i(7 + r);
    (s[a++] = 201), o.setUint32(a, r + 1), (a += 4);
  }
  (s[a++] = 116),
    (s[a++] = e),
    s.set(new Uint8Array(t.buffer, t.byteOffset, t.byteLength), a);
}
function D0(t, e) {
  let i = t.byteLength;
  var n, r;
  if (i < 256) {
    var { target: n, position: r } = e(i + 2);
    (n[r++] = 196), (n[r++] = i);
  } else if (i < 65536) {
    var { target: n, position: r } = e(i + 3);
    (n[r++] = 197), (n[r++] = i >> 8), (n[r++] = i & 255);
  } else {
    var { target: n, position: r, targetView: s } = e(i + 5);
    (n[r++] = 198), s.setUint32(r, i), (r += 4);
  }
  n.set(t, r);
}
function yU(t, e, i, n) {
  let r = t.length;
  switch (r) {
    case 1:
      e[i++] = 212;
      break;
    case 2:
      e[i++] = 213;
      break;
    case 4:
      e[i++] = 214;
      break;
    case 8:
      e[i++] = 215;
      break;
    case 16:
      e[i++] = 216;
      break;
    default:
      r < 256
        ? ((e[i++] = 199), (e[i++] = r))
        : r < 65536
        ? ((e[i++] = 200), (e[i++] = r >> 8), (e[i++] = r & 255))
        : ((e[i++] = 201),
          (e[i++] = r >> 24),
          (e[i++] = (r >> 16) & 255),
          (e[i++] = (r >> 8) & 255),
          (e[i++] = r & 255));
  }
  return (e[i++] = n), e.set(t, i), (i += r), i;
}
function xU(t, e) {
  let i,
    n = e.length * 6,
    r = t.length - n;
  for (e.sort((s, a) => (s.offset > a.offset ? 1 : -1)); (i = e.pop()); ) {
    let s = i.offset,
      a = i.id;
    t.copyWithin(s + n, s, r), (n -= 6);
    let o = s + n;
    (t[o++] = 214),
      (t[o++] = 105),
      (t[o++] = a >> 24),
      (t[o++] = (a >> 16) & 255),
      (t[o++] = (a >> 8) & 255),
      (t[o++] = a & 255),
      (r = s);
  }
  return t;
}
function xo(t) {
  if (t.Class) {
    if (!t.pack && !t.write)
      throw new Error("Extension has no pack or write function");
    if (t.pack && !t.type)
      throw new Error(
        "Extension has no type (numeric code to identify the extension)"
      );
    Pp.unshift(t.Class), th.unshift(t);
  }
  mU(t);
}
var T_ = new E_({ useRecords: !1 });
T_.pack;
T_.pack;
var _U = 512,
  bU = 1024,
  R0 = new E_({ structuredClone: !0 });
xo({
  Class: pi.prototype.constructor,
  type: 1,
  write(t) {
    return { ...t };
  },
  read(t) {
    return Object.setPrototypeOf(t, pi.prototype), t;
  },
});
xo({
  Class: Ot.prototype.constructor,
  type: 2,
  write(t) {
    return [...t];
  },
  read(t) {
    return Object.setPrototypeOf(t, Ot.prototype), t;
  },
});
xo({
  Class: sn.prototype.constructor,
  type: 3,
  write(t) {
    return [...t];
  },
  read(t) {
    return Object.setPrototypeOf(t, sn.prototype), t;
  },
});
xo({
  Class: _0.prototype.constructor,
  type: 4,
  write(t) {
    return t.id;
  },
  read(t) {
    return new _0(t);
  },
});
xo({
  Class: b0.prototype.constructor,
  type: 5,
  write(t) {
    return t.data;
  },
  read(t) {
    return new b0(t);
  },
});
xo({
  Class: xi.prototype.constructor,
  type: 6,
  write(t) {
    return { ...t };
  },
  read(t) {
    return Object.setPrototypeOf(t, xi.prototype), t;
  },
});
function wU(t) {
  var e = 0;
  if (t.length === 0) return e;
  for (let i = 0; i < t.length; i++) {
    let n = t[i];
    (e = (e << 5) - e + n), (e = e & e);
  }
  return e;
}
function Ud(t) {
  if (bp(t)) return t;
  if (Array.isArray(t)) return t.map(Ud);
  if (typeof t == "object" && t !== null) {
    let e = {};
    for (let i of Object.keys(t).sort()) e[i] = Ud(t[i]);
    return Object.setPrototypeOf(e, Object.getPrototypeOf(t)), e;
  } else return t;
}
var Nd;
((t) => {
  function e(r) {
    return R0.pack(r);
  }
  t.serialize = e;
  function i(r) {
    return R0.unpack(r);
  }
  t.deserialize = i;
  function n(r) {
    return wU(e(Ud(r))).toString();
  }
  t.checksum = n;
})(Nd || (Nd = {}));
var Fh = "personal camera",
  Jo = "a218fcc3-276b-49b9-b485-49037fd14f5f",
  SU = 2960946,
  Tn = 5526619,
  O0;
((t) => {
  function e(n, r) {
    return n[0] === r[0] && n[1] === r[1];
  }
  t.isEqual = e;
  function i(n, r, s) {
    return [n[0] + (r[0] - n[0]) * s, n[1] + (r[1] - n[1]) * s];
  }
  t.lerp = i;
})(O0 || (O0 = {}));
var Ba;
((t) => {
  function e(l, c) {
    return l[0] === c[0] && l[1] === c[1] && l[2] === c[2];
  }
  t.isEqual = e;
  function i(l, c) {
    return [l[0] + c[0], l[1] + c[1], l[2] + c[2]];
  }
  t.add = i;
  function n(l, c) {
    return [l[0] - c[0], l[1] - c[1], l[2] - c[2]];
  }
  t.sub = n;
  function r(l, c) {
    return [l[0] / c[0], l[1] / c[1], l[2] / c[2]];
  }
  t.div = r;
  function s(l, c) {
    return [l[0] * c[0], l[1] * c[1], l[2] * c[2]];
  }
  t.mul = s;
  function a(l, c) {
    return Math.hypot(l[0] - c[0], l[1] - c[1], l[2] - c[2]);
  }
  t.dist = a;
  function o(l, c, d) {
    return [
      l[0] + (c[0] - l[0]) * d,
      l[1] + (c[1] - l[1]) * d,
      l[2] + (c[2] - l[2]) * d,
    ];
  }
  t.lerp = o;
})(Ba || (Ba = {}));
var I0;
((t) => {
  function e(n, r) {
    return n[0] === r[0] && n[1] === r[1] && n[2] === r[2] && n[3] === r[3];
  }
  t.isEqual = e;
  function i(n, r, s) {
    return [
      n[0] + (r[0] - n[0]) * s,
      n[1] + (r[1] - n[1]) * s,
      n[2] + (r[2] - n[2]) * s,
      n[3] + (r[3] - n[3]) * s,
    ];
  }
  t.lerp = i;
})(I0 || (I0 = {}));
var eo;
((t) => {
  t.identity = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
  function e(r, s) {
    for (let a = 0; a < 16; a++) if (r[a] !== s[a]) return !1;
    return !0;
  }
  t.isEqual = e;
  function i(r) {
    return r ?? t.identity;
  }
  t.simplify = i;
  function n(r, s) {
    let a = s.slice(0);
    for (var o = 0, l = s.length; o < l; o += 3) {
      let c = r[3] * s[o] + r[7] * s[o + 1] + r[11] * s[o + 2] + r[15];
      (a[o] = (r[0] * s[o] + r[4] * s[o + 1] + r[8] * s[o + 2] + r[12]) / c),
        (a[o + 1] =
          (r[1] * s[o] + r[5] * s[o + 1] + r[9] * s[o + 2] + r[13]) / c),
        (a[o + 2] =
          (r[2] * s[o] + r[6] * s[o + 1] + r[10] * s[o + 2] + r[14]) / c);
    }
    return a;
  }
  t.applyMatrix4 = n;
})(eo || (eo = {}));
var Hi;
((t) => {
  function e(l) {
    return (
      typeof l == "object" &&
      typeof l.r == "number" &&
      typeof l.g == "number" &&
      typeof l.b == "number"
    );
  }
  (t.isRGB = e),
    (t.white = { r: 1, g: 1, b: 1 }),
    (t.red = { r: 1, g: 0, b: 0 }),
    (t.black = { r: 0, g: 0, b: 0 });
  function i(l) {
    return {
      r: Math.round(l.r * 255),
      g: Math.round(l.g * 255),
      b: Math.round(l.b * 255),
      a: 1,
    };
  }
  t.toRgb255a1 = i;
  function n(l) {
    return { r: l.r, g: l.g, b: l.b };
  }
  t.clone = n;
  function r(l) {
    return (
      (l = Math.floor(l)),
      {
        r: ((l >> 16) & 255) / 255,
        g: ((l >> 8) & 255) / 255,
        b: (l & 255) / 255,
      }
    );
  }
  t.fromHex = r;
  function s(l) {
    return (
      Math.round(l.r * 255) * 65536 +
      Math.round(l.g * 255) * 256 +
      Math.round(l.b * 255)
    );
  }
  t.toHex = s;
  function a(l, c) {
    return l.r === c.r && l.g === c.g && l.b === c.b;
  }
  t.equals = a;
  function o(l, c, d) {
    return {
      r: l.r + (c.r - l.r) * d,
      g: l.g + (c.g - l.g) * d,
      b: l.b + (c.b - l.b) * d,
    };
  }
  t.lerp = o;
})(Hi || (Hi = {}));
var Vn;
((t) => {
  (t.white = { ...Hi.white, a: 1 }), (t.transparent = { ...Hi.white, a: 0 });
  function e(a) {
    return { r: a[0], g: a[1], b: a[2], a: a[3] };
  }
  t.from0to1 = e;
  function i(a, o) {
    return { ...Hi.fromHex(a), a: o };
  }
  t.fromHexAndA = i;
  function n(a) {
    return {
      r: Math.round(a.r * 255),
      g: Math.round(a.g * 255),
      b: Math.round(a.b * 255),
      a: a.a,
    };
  }
  t.toRgb255a1 = n;
  function r(a, o) {
    return Hi.equals(a, o) && a.a === o.a;
  }
  t.equals = r;
  function s(a, o, l) {
    return {
      r: a.r + (o.r - a.r) * l,
      g: a.g + (o.g - a.g) * l,
      b: a.b + (o.b - a.b) * l,
      a: a.a + (o.a - a.a) * l,
    };
  }
  t.lerp = s;
})(Vn || (Vn = {}));
var zd;
((t) =>
  (t.identity = {
    position: [0, 0, 0],
    rotation: [0, 0, 0],
    scale: [1, 1, 1],
  }))(zd || (zd = {}));
var U0;
((t) => (t.defaultData = { mass: 1, stiffness: 80, damping: 10, velocity: 0 }))(
  U0 || (U0 = {})
);
var N0;
((t) => (t.defaultData = { control1: [0.5, 0], control2: [0.5, 1] }))(
  N0 || (N0 = {})
);
var z0;
((t) => (
  (t.linear = [0, 0, 1, 1]),
  (t.ease = [0.25, 0.1, 0.25, 1]),
  (t.easeIn = [0.42, 0, 1, 1]),
  (t.easeOut = [0, 0, 0.58, 1]),
  (t.easeInOut = [0.42, 0, 0.58, 1])
))(z0 || (z0 = {}));
var $s;
((t) => {
  t.all = ["PerspectiveCamera", "OrthographicCamera"];
  function e(i) {
    return t.all.includes(i);
  }
  t.is = e;
})($s || ($s = {}));
var to;
((t) => {
  (t.DefaultUp = [0, 1, 0]),
    (t.DefaultTargetOffset = 1e3),
    (t.defaultData = {
      far: 1e5,
      type: "OrthographicCamera",
      perspective: { near: 70, fov: 45, zoom: 1 },
      orthographic: { near: -1e5, zoom: 1 },
      up: t.DefaultUp,
      isUpVectorFlipped: !1,
      targetOffset: t.DefaultTargetOffset,
    });
  function e(i) {
    return i.type === "PerspectiveCamera"
      ? i.perspective.zoom
      : i.orthographic.zoom;
  }
  t.getZoom = e;
})(to || (to = {}));
var Qr;
((t) => {
  function e(n, r = 0.1) {
    return {
      disabled: !1,
      type: "linear",
      hideBase: !1,
      count: 3,
      radial: {
        radius: Math.max(n[0], n[1]) * 2,
        start: 0,
        end: 360,
        alignment: !1,
        axis: "y",
        scale: [1, 1, 1],
        rotation: [0, 0, 0],
        position: [0, 0, 0],
      },
      toObject: {
        object: "",
        spreadType: "random",
        scale: [0, 0, 0],
        rotation: [0, 0, 0],
        position: [0, 0, 0],
        axis: "x",
        seed: 0,
        count: 99,
        align: "normal",
      },
      linear: {
        scale: [1, 1, 1],
        rotation: [0, 0, 0],
        position: [n[0] + n[0] * r, 0, 0],
      },
      grid: {
        count: [2, 2, 2],
        size: n.map((s) => s * (1 + r)),
        useCenter: !0,
      },
      randomness: !1,
      randomnessObject: {
        strength: 100,
        scale: [0, 0, 0],
        rotation: [0, 0, 0],
        position: [0, 0, 0],
        movement: 1,
        seed: 0,
        freqScale: 10,
        noiseType: "perlin",
      },
    };
  }
  t.defaultData = e;
  function i(n, r) {
    let s = { ...n };
    if (
      (MU.forEach((a) => {
        Object.assign(s, { [a]: r[a] ?? n[a] });
      }),
      (s.radial = { ...n.radial }),
      r.radial)
    ) {
      let a = n.radial,
        o = r.radial;
      EU.forEach((l) => {
        Object.assign(s.radial, { [l]: o[l] ?? a[l] });
      });
    }
    if (((s.linear = { ...n.linear }), r.linear)) {
      let a = n.linear,
        o = r.linear;
      TU.forEach((l) => {
        Object.assign(s.linear, { [l]: o[l] ?? a[l] });
      });
    }
    if (((s.grid = { ...n.grid }), r.grid)) {
      let a = n.grid,
        o = r.grid;
      AU.forEach((l) => {
        Object.assign(s.grid, { [l]: o[l] ?? a[l] });
      });
    }
    if (((s.toObject = { ...n.toObject }), r.toObject)) {
      let a = n.toObject,
        o = r.toObject;
      CU.forEach((l) => {
        Object.assign(s.toObject, { [l]: o[l] ?? a[l] });
      });
    }
    if (
      ((s.randomnessObject = { ...n.randomnessObject }), r.randomnessObject)
    ) {
      let a = n.randomnessObject,
        o = r.randomnessObject;
      PU.forEach((l) => {
        Object.assign(s.randomnessObject, { [l]: o[l] ?? a[l] });
      });
    }
    return s;
  }
  t.merge = i;
})(Qr || (Qr = {}));
var Bd;
((t) => {
  t.defaultData = {
    radial: {},
    linear: {},
    grid: {},
    toObject: {},
    randomnessObject: {},
  };
  let e = ["radial", "linear", "grid", "toObject", "randomnessObject"];
  function i(n, r) {
    let s = [];
    n.count !== void 0 &&
      s.push({ type: 0, path: r, props: { count: n.count } });
    for (let a of e) {
      let o = n[a];
      o &&
        Object.keys(o).length > 0 &&
        s.push({ type: 0, path: [...r, a], props: o });
    }
    return s;
  }
  t.toOps = i;
})(Bd || (Bd = {}));
var MU = ["count"],
  EU = ["radius", "start", "end", "position", "scale", "rotation"],
  TU = ["position", "scale", "rotation"],
  AU = ["count", "size"],
  CU = ["count", "position", "scale", "rotation"],
  PU = [
    "strength",
    "scale",
    "rotation",
    "position",
    "movement",
    "seed",
    "freqScale",
  ],
  Fd;
((t) => {
  t.all = ["PointLight", "SpotLight", "DirectionalLight", "HemisphereLight"];
  function e(i) {
    return t.all.includes(i);
  }
  t.is = e;
})(Fd || (Fd = {}));
var kd;
((t) => {
  function e(n) {
    return i(n);
  }
  t.defaultData = e;
  function i(n) {
    if (n === "PointLight")
      return {
        type: n,
        color: Vn.white,
        intensity: 1,
        distance: 2e3,
        decay: 1,
        shadows: !0,
        shadowResolution: 1024,
        shadowRadius: 1,
        penumbraSize: 0.5,
        depth: 1e5,
      };
    if (n === "SpotLight")
      return {
        type: n,
        color: Vn.white,
        intensity: 1,
        distance: 2e3,
        decay: 1,
        shadows: !0,
        penumbra: 0,
        angle: (30 / 180) * Math.PI,
        depth: 1e5,
        penumbraSize: 0.5,
        shadowResolution: 1024,
        shadowRadius: 1,
      };
    if (n === "DirectionalLight")
      return {
        type: n,
        color: Vn.white,
        intensity: 1,
        shadows: !0,
        size: 2e3,
        depth: 1e5,
        penumbraSize: 0.5,
        shadowResolution: 1024,
        shadowRadius: 1,
      };
    throw new Error("not implemented");
  }
})(kd || (kd = {}));
var io;
((t) =>
  (t.defaultData = {
    enabled: "visibility",
    fusedBody: !0,
    rigidBody: "positioned",
    density: 1,
    pointMass: 0,
    gravityScale: 1,
    friction: 0.5,
    damping: 0,
    restitution: 0.2,
    colliderType: "convex",
    enabledRotation: [!0, !0, !0],
    enabledTranslation: [!0, !0, !0],
  }))(io || (io = {}));
var Vd;
((t) => {
  t.defaultData = { castShadow: !0, receiveShadow: !0 };
  function e(i, n) {
    return i.castShadow === n.castShadow && i.receiveShadow === n.receiveShadow;
  }
  t.equals = e;
})(Vd || (Vd = {}));
var Hd;
((t) => {
  t.defaultData = { flatShading: !1, wireframe: !1, side: 0 };
  function e(i, n) {
    return (
      i.flatShading === n.flatShading &&
      i.side === n.side &&
      i.wireframe === n.wireframe
    );
  }
  t.equals = e;
})(Hd || (Hd = {}));
var Gd;
((t) => (t.defaultData = { ...Hd.defaultData, ...Vd.defaultData }))(
  Gd || (Gd = {})
);
var ih;
((t) => (
  (t.defaultVideo = {
    data: "",
    thumb: "/_assets/_videos/catThumb.png",
    type: "video",
    name: "Cat video",
  }),
  (t.maxSize = 3e7)
))(ih || (ih = {}));
var B0;
((t) => {
  function e(i) {
    return (
      i === "texture" ||
      i === "video" ||
      i === "color" ||
      i === "depth" ||
      i === "normal" ||
      i === "gradient" ||
      i === "noise" ||
      i === "fresnel" ||
      i === "rainbow" ||
      i === "toon" ||
      i === "outline" ||
      i === "transmission" ||
      i === "matcap" ||
      i === "displace" ||
      i === "pattern" ||
      i === "light"
    );
  }
  t.is = e;
})(B0 || (B0 = {}));
function LU(t) {
  return t.type !== "displace";
}
var F0;
((t) => {
  function e(i) {
    return i === "phong" || i === "toon" || i === "lambert" || i === "physical";
  }
  t.is = e;
})(F0 || (F0 = {}));
var DU = [
    "mode",
    "gradientType",
    "noiseType",
    "displacementType",
    "projection",
    "cnormal",
    "crop",
    "axis",
    "side",
  ],
  RU = ["wrapping", "image", "video", "name"],
  _n;
((t) => {
  function e(s, a) {
    let { texture: o, ...l } = a;
    if ((Object.assign(s, l), o)) {
      let c = s.texture;
      c && Object.assign(c, o);
    }
  }
  t.patch = e;
  function i(s, a) {
    return s === "light" && a ? n(a) : r(s);
  }
  t.defaultData = i;
  function n(s) {
    let a = {
      mode: 0,
      isMask: !1,
      visible: !0,
      bumpMap: void 0,
      bumpMapIntensity: 5,
      roughnessMap: void 0,
      alphaOverride: 1,
    };
    switch (s) {
      case "phong":
        return {
          ...a,
          category: "phong",
          specular: { r: 0.2, g: 0.2, b: 0.2 },
          shininess: 5,
          type: "light",
          visible: !0,
          mode: 0,
          occlusion: !0,
          alpha: 0.6,
        };
      case "toon":
        return {
          ...a,
          category: "toon",
          specular: { r: 0.2, g: 0.2, b: 0.2 },
          shininess: 10,
          type: "light",
          alpha: 1,
        };
      case "lambert":
        return {
          ...a,
          category: "lambert",
          emissive: { r: 0, g: 0, b: 0 },
          type: "light",
          alpha: 1,
          visible: !0,
          mode: 0,
          occlusion: !0,
        };
      case "physical":
        return {
          ...a,
          category: "physical",
          roughness: 0.2,
          metalness: 0.2,
          reflectivity: 0.2,
          type: "light",
          alpha: 1,
          visible: !0,
          mode: 0,
          occlusion: !0,
        };
    }
  }
  function r(s) {
    let a = { alpha: 1, mode: 0, isMask: !1, visible: !0 };
    switch (s) {
      case "texture":
        return {
          ...a,
          type: "texture",
          size: [128, 128],
          blending: 0,
          axis: "x",
          side: 2,
          projection: 0,
          texture: {
            image: "image_0",
            wrapping: 1e3,
            repeat: [1, 1],
            offset: [0, 0],
          },
          crop: !1,
        };
      case "video":
        return {
          ...a,
          type: "video",
          size: [128, 128],
          blending: 0,
          axis: "x",
          side: 2,
          projection: 0,
          texture: {
            video: ih.defaultVideo,
            wrapping: 1001,
            repeat: [1, 1],
            offset: [0, 0],
          },
          crop: !1,
        };
      case "color":
        return { ...a, type: "color", color: Hi.fromHex(Tn) };
      case "depth":
        return {
          ...a,
          type: "depth",
          gradientType: 1,
          smooth: !1,
          isVector: !0,
          isWorldSpace: !1,
          origin: [0, 0, 0],
          direction: [1, 0, 0],
          colors: [
            [1, 1, 1, 1],
            [0, 0, 0, 1],
          ],
          steps: [0, 1],
          near: 50,
          far: 200,
        };
      case "normal":
        return { ...a, type: "normal", cnormal: [1, 1, 1] };
      case "gradient":
        return {
          ...a,
          type: "gradient",
          gradientType: 0,
          smooth: !1,
          colors: [
            [0, 0, 0, 1],
            [1, 1, 1, 1],
            [1, 1, 1, 1],
            [1, 1, 1, 1],
            [1, 1, 1, 1],
            [1, 1, 1, 1],
            [1, 1, 1, 1],
            [1, 1, 1, 1],
            [1, 1, 1, 1],
            [1, 1, 1, 1],
          ],
          steps: [0, 1, 1, 1, 1, 1, 1, 1, 1, 1],
          num: 2,
          angle: 0,
          offset: [0, 0],
          morph: [0, 0],
        };
      case "noise":
        return {
          ...a,
          type: "noise",
          size: [100, 100, 100],
          noiseType: 0,
          scale: 1,
          move: 1,
          colorA: { ...Hi.fromHex(6710886), a: 1 },
          colorB: { ...Hi.fromHex(6710886), a: 1 },
          colorC: { ...Hi.fromHex(16777215), a: 1 },
          colorD: { ...Hi.fromHex(16777215), a: 1 },
          distortion: [1, 1],
          fA: [1.7, 9.2],
          fB: [8.3, 2.8],
          voronoiStyle: 0,
          highCut: 1,
          lowCut: 0,
          smoothness: 0.3,
          seed: 0,
          quality: 1,
        };
      case "fresnel":
        return {
          ...a,
          type: "fresnel",
          color: Vn.fromHexAndA(16777215, 1),
          bias: 0.1,
          scale: 1,
          intensity: 2,
          factor: 1,
        };
      case "rainbow":
        return {
          ...a,
          type: "rainbow",
          filmThickness: 30,
          movement: 0,
          wavelengths: [0, 0, 0],
          noiseStrength: 0,
          noiseScale: 1,
          offset: [0, 0, 0],
        };
      case "toon":
        return {
          ...a,
          type: "toon",
          positioning: 2,
          colors: [
            [0, 0, 0, 1],
            [0.5, 0.5, 0.5, 1],
            [0.5, 0.5, 0.5, 1],
            [1, 1, 1, 1],
            [1, 1, 1, 1],
            [1, 1, 1, 1],
            [1, 1, 1, 1],
            [1, 1, 1, 1],
            [1, 1, 1, 1],
            [1, 1, 1, 1],
          ],
          steps: [0, 0.475, 0.525, 1, 1, 1, 1, 1, 1, 1],
          num: 4,
          source: [0, 1e3, 0],
          isWorldSpace: !0,
          noiseStrength: 0,
          noiseScale: 1,
          shadowColor: Vn.fromHexAndA(0, 0),
          offset: [0, 0, 0],
        };
      case "outline":
        return {
          ...a,
          type: "outline",
          outlineColor: Vn.fromHexAndA(0, 1),
          contourColor: Vn.fromHexAndA(0, 1),
          outlineWidth: 2,
          contourWidth: 5,
          outlineThreshold: 0.4,
          contourThreshold: 0,
          outlineSmoothing: 0,
          contourFrequency: 10,
          contourDirection: [0, 1, 0],
          positionalLines: !1,
          compensation: !0,
        };
      case "matcap":
        return {
          ...a,
          type: "matcap",
          texture: {
            image: "matcap_0",
            wrapping: 1001,
            repeat: [1, 1],
            offset: [0, 0],
          },
        };
      case "transmission":
        return {
          ...a,
          type: "transmission",
          thickness: 10,
          ior: 1.5,
          roughness: 1,
        };
      case "displace":
        return {
          visible: !0,
          type: "displace",
          displacementType: "noise",
          noiseType: 0,
          scale: 10,
          movement: 1,
          offset: [0, 0, 0],
          intensity: 8,
          voronoiStyle: 0,
          smoothness: 0.3,
          seed: 0,
          highCut: 1,
          lowCut: 0,
          quality: 1,
        };
      case "pattern":
        return {
          ...a,
          type: "pattern",
          style: 0,
          projection: 0,
          axis: "y",
          blending: 0,
          offset: [0, 0],
          colorA: { ...Hi.fromHex(0), a: 1 },
          colorB: { ...Hi.fromHex(16777215), a: 1 },
          frequency: [10, 10],
          size: 0.5,
          variation: 0,
          smoothness: 0.5,
          zigzag: 0,
          rotation: 0,
          vertical: [0, 1],
          horizontal: [0, 1],
          sides: 6,
        };
    }
  }
})(_n || (_n = {}));
var fn;
((t) => {
  function e(c) {
    return !c.layers.some(
      (d) =>
        (d.data.type === "texture" && d.data.projection !== 0) ||
        (d.data.type === "depth" && !d.data.isWorldSpace) ||
        d.data.type === "noise" ||
        d.data.type === "displace"
    );
  }
  t.isMergable = e;
  function i(c) {
    let d = "";
    return (
      c.layers.forEach((h) => {
        Object.entries(h.data).forEach(([u, f]) => {
          (d += `${u}${f}`),
            Array.isArray(f)
              ? f.forEach((p) => (d += `${p}`))
              : typeof f == "object"
              ? Object.values(f).forEach((p) => {
                  typeof p == "number"
                    ? (d += `${p.toFixed(4)}`)
                    : (d += `${p}`);
                })
              : (d += `${f}`);
        });
      }),
      d
    );
  }
  t.getHash = i;
  function n() {
    return { layers: new Ot() };
  }
  t.defaultEmptyData = n;
  function r(c = "layer1", d = "layer2") {
    return a("phong", c, d);
  }
  t.defaultData = r;
  function s(c, d) {
    return { ...c, name: d };
  }
  t.withName = s;
  function a(c, d = "layer1", h = "layer2") {
    let u = new Ot();
    return (
      u.push({ fi: 0, data: _n.defaultData("light", c), id: d }),
      u.push({ fi: 1, data: _n.defaultData("color"), id: h }),
      { layers: u }
    );
  }
  t.defaultTwoLayerData = a;
  function o(c, d = "phong", h = "layer1", u = "layer2") {
    let f = _n.defaultData("texture");
    Object.assign(f.texture, { image: c });
    let p = new Ot();
    return (
      p.push({ fi: 0, data: f, id: h }),
      p.push({ fi: 1, data: _n.defaultData("light", d), id: u }),
      { layers: p }
    );
  }
  t.defaultTwoLayerTextureData = o;
  function l(c, d = "phong", h = "layer1", u = "layer2") {
    let f = _n.defaultData("video");
    Object.assign(f.texture, { video: c });
    let p = new Ot();
    return (
      p.push({ fi: 0, data: f, id: h }),
      p.push({ fi: 1, data: _n.defaultData("light", d), id: u }),
      { layers: p }
    );
  }
  t.defaultTwoLayerVideoTextureData = l;
})(fn || (fn = {}));
var nh;
((t) => {
  function e() {
    return { points: new Ot(), roundness: 0, shapeHoles: [], isClosed: !1 };
  }
  t.defaultData = e;
})(nh || (nh = {}));
var rh;
((t) => {
  function e() {
    return {
      points: new Ot(),
      lastInsertionPlane: null,
      subdivisions: 12,
      isClosed: !1,
    };
  }
  t.defaultData = e;
})(rh || (rh = {}));
var A_ = {
    type: "Ellipse",
    width: 100,
    height: 100,
    spikes: 16,
    angle: 360,
    innerRadius: 0,
  },
  jd;
((t) => {
  function e(i, n) {
    let r = { ...i };
    return (
      OU.forEach((s) => {
        Object.assign(r, { [s]: n[s] ?? i[s] });
      }),
      r
    );
  }
  t.merge = e;
})(jd || (jd = {}));
var C_ = {
    shape: A_,
    depth: 1,
    offset: 0,
    bevel: 50,
    bevelSides: 6,
    angle: 0,
    twist: 0,
    startScale: 1,
    endScale: 1,
    capType: "flat",
  },
  OU = ["depth", "offset", "angle", "twist", "startScale", "endScale"],
  sh;
((t) => {
  function e(n) {
    return (
      n === "PolygonGeometry" ||
      n === "RectangleGeometry" ||
      n === "StarGeometry" ||
      n === "TriangleGeometry" ||
      n === "EllipseGeometry"
    );
  }
  t.is2DParametricMesh = e;
  function i(n) {
    return (
      n === "PolygonGeometry" ||
      n === "PolygonGeometry" ||
      n === "RectangleGeometry" ||
      n === "StarGeometry" ||
      n === "TriangleGeometry" ||
      n === "EllipseGeometry" ||
      n === "PathGeometry" ||
      n === "VectorGeometry" ||
      n === "ConeGeometry" ||
      n === "CubeGeometry" ||
      n === "CylinderGeometry" ||
      n === "DodecahedronGeometry" ||
      n === "HelixGeometry" ||
      n === "IcosahedronGeometry" ||
      n === "LatheGeometry" ||
      n === "PyramidGeometry" ||
      n === "SphereGeometry" ||
      n === "PlaneGeometry" ||
      n === "BackdropGeometry" ||
      n === "TorusGeometry" ||
      n === "TorusKnotGeometry" ||
      n === "BooleanGeometry" ||
      n === "TextGeometry"
    );
  }
  t.isParametricMesh = i;
})(sh || (sh = {}));
var Wd;
((t) => {
  function e(i, n) {
    let r = { ...i };
    return (
      Object.assign(r, n),
      r.type === "PathGeometry" &&
        "extrusion" in n &&
        n.extrusion &&
        ((r.extrusion = { ...i.extrusion }),
        Object.assign(r.extrusion, jd.merge(r.extrusion, n.extrusion))),
      r
    );
  }
  t.merge = e;
})(Wd || (Wd = {}));
var Fa;
((t) => {
  function e(i) {
    if (i === "RectangleGeometry")
      return {
        width: 320,
        height: 320,
        type: i,
        cornerRadius: [0, 0, 0, 0],
        cornerType: 0,
        depth: 0,
        extrudeBevelSize: 0,
        extrudeBevelSegments: 1,
      };
    if (i === "PathGeometry")
      return {
        type: i,
        width: 1,
        height: 1,
        depth: 1,
        path: rh.defaultData(),
        extrusion: C_,
      };
    if (i === "VectorGeometry")
      return {
        width: 1,
        height: 1,
        type: i,
        subdivisions: 12,
        shape: nh.defaultData(),
        depth: 0,
        extrudeBevelSize: 0,
        extrudeBevelSegments: 1,
      };
    if (i === "BooleanGeometry")
      return {
        type: i,
        operation: 2,
        width: 0,
        height: 0,
        depth: 0,
        phongAngle: 35,
      };
    if (i === "TextGeometry")
      return {
        type: i,
        width: 100,
        height: 100,
        depth: 0,
        horizontalAlign: 1,
        verticalAlign: 1,
        fontSize: 16,
        lineHeight: 1.2,
        letterSpacing: 0,
        text: "",
        textTransform: 1,
        font: "Roboto_regular",
        extrudeBevelSize: 0,
        extrudeBevelSegments: 1,
      };
    if (i === "SphereGeometry")
      return {
        type: "SphereGeometry",
        width: 100,
        height: 100,
        depth: 100,
        widthSegments: 64,
        heightSegments: 64,
        phiStart: 0,
        phiLength: 2 * Math.PI,
        thetaStart: 0,
        thetaLength: Math.PI,
      };
    throw new Error("not implemented");
  }
  t.defaultData = e;
})(Fa || (Fa = {}));
var qd;
((t) =>
  (t.defaultData = {
    enabled: !1,
    useBackgroundColor: !1,
    color: Hi.white,
    near: 0.1,
    far: 2e3,
  }))(qd || (qd = {}));
var Xd;
((t) => {
  let e = { opacity: 1, blendFunction: 13, enabled: !1 };
  t.defaultData = {
    enabled: !1,
    pixelation: { ...e, blendFunction: 16, granularity: 15 },
    bloom: {
      ...e,
      blendFunction: 16,
      intensity: 1,
      blurScale: 1,
      luminanceThreshold: 0.25,
      luminanceSmoothing: 0.025,
      kernelSize: 3,
    },
    chromaticAberration: { ...e, offset: [2, 2] },
    vignette: { ...e, darkness: 1, offset: 0 },
    hueSaturation: { ...e, hue: 3, saturation: 0 },
    brightnessContrast: { ...e, brightness: 0.25, contrast: 0 },
    depthOfField: { ...e, focalLength: 2, focusDistance: 2, bokehScale: 2 },
    noise: { ...e, blendFunction: 16 },
  };
})(Xd || (Xd = {}));
var $d;
((t) => (t.defaultData = { softShadowQuality: "low" }))($d || ($d = {}));
var Yd;
((t) =>
  (t.defaultData = {
    enabled: !0,
    color: {
      r: 0.8274509803921568,
      g: 0.8274509803921568,
      b: 0.8274509803921568,
    },
    intensity: 0.75,
  }))(Yd || (Yd = {}));
var Zd;
((t) =>
  (t.defaultData = {
    occlusion: !1,
    aoFullRes: !1,
    radius: 256,
    bias: 0.5,
    aoColor: {
      r: 0.19607843137254902,
      g: 0.19607843137254902,
      b: 0.19607843137254902,
    },
  }))(Zd || (Zd = {}));
var ah;
((t) => (t.defaultData = { usePhysics: !1, gravity: -10 }))(ah || (ah = {}));
var Kd;
((t) => (t.defaultData = { playCamera: Fh, gameControlObject: null }))(
  Kd || (Kd = {})
);
var Jd;
((t) =>
  (t.defaultData = {
    backgroundColor: Vn.fromHexAndA(SU, 1),
    postprocessing: Xd.defaultData,
    fog: qd.defaultData,
    globalPhysics: ah.defaultData,
    ambient: Yd.defaultData,
    ao: Zd.defaultData,
    shadow: $d.defaultData,
    publish: Kd.defaultData,
  }))(Jd || (Jd = {}));
var k0;
((t) => {
  function e(n) {
    return n === "Component" || n === "Instance";
  }
  t.isComponentRelated = e;
  function i(n) {
    return n === "Empty" || n === "Instance";
  }
  t.isEmptyOrComponent = i;
})(k0 || (k0 = {}));
var no;
((t) => {
  t.identity = { ...zd.identity, hiddenMatrix: eo.identity };
  function e(r) {
    return {
      position: r.position,
      rotation: r.rotation,
      scale: r.scale,
      hiddenMatrix: r.hiddenMatrix,
    };
  }
  t.fromObject = e;
  function i(r, s) {
    return {
      position: (s == null ? void 0 : s.position) || r.position,
      rotation: (s == null ? void 0 : s.rotation) || r.rotation,
      scale: (s == null ? void 0 : s.scale) || r.scale,
      hiddenMatrix: (s == null ? void 0 : s.hiddenMatrix) || r.hiddenMatrix,
    };
  }
  t.merge = i;
  function n(r, s) {
    return vC({
      position: Ba.isEqual(r.position, s.position) ? void 0 : s.position,
      rotation: Ba.isEqual(r.rotation, s.rotation) ? void 0 : s.rotation,
      scale: Ba.isEqual(r.scale, s.scale) ? null : s.scale,
      hiddenMatrix: eo.isEqual(r.hiddenMatrix, s.hiddenMatrix)
        ? void 0
        : s.hiddenMatrix,
    });
  }
  t.diff = n;
})(no || (no = {}));
var Xi;
((t) =>
  (t.defaultData = {
    states: new Ot(),
    events: new Ot(),
    visible: !0,
    raycastLock: !1,
    physics: io.defaultData,
    pathSnapping: {
      pathId: null,
      slide: 0,
      offset: 0,
      orientation: "tangential",
    },
    ...no.identity,
    cloner: null,
  }))(Xi || (Xi = {}));
var V0;
((t) => (t.defaultData = { type: "Empty", ...Xi.defaultData }))(
  V0 || (V0 = {})
);
var H0;
((t) => (t.defaultData = { type: "Component", ...Xi.defaultData }))(
  H0 || (H0 = {})
);
var ka;
((t) =>
  (t.defaultData = { type: "Mesh", ...Xi.defaultData, ...Gd.defaultData }))(
  ka || (ka = {})
);
var pl;
((t) =>
  (t.defaultData = {
    ...Xi.defaultData,
    ...no.identity,
    position: [0, 0, to.DefaultTargetOffset],
    ...to.defaultData,
  }))(pl || (pl = {}));
var Qd;
((t) => {
  function e(i) {
    return { ...Xi.defaultData, ...kd.defaultData(i) };
  }
  (t.defaultData = e),
    (t.defaultDirectionalLightData = {
      ...t.defaultData("DirectionalLight"),
      position: [200, 300, 300],
      name: "Directional Light",
      intensity: 0.7,
    });
})(Qd || (Qd = {}));
var oh;
((t) => {
  function e(n, r, s = 0) {
    for (; s < r.length; ) {
      let a = n ? n[r[s]] : void 0;
      if (r.length === s + 1) return a;
      if (a) (n = a.descendants), (s += 1);
      else return;
    }
  }
  t.resolveWithDes = e;
  function i(n, r, s = 0) {
    let a = e(n, r, s);
    if (a) {
      let o = Object.keys(a);
      if (o.length === 1 && o[0] === "descendants") return;
    }
    return a;
  }
  t.resolve = i;
})(oh || (oh = {}));
var es;
((t) => {
  (t.rootOverrideProps = ["physics", "events"]),
    (t.compositeNonOptionalOverrideProps = ["geometry"]),
    (t.compositeEntireOverrideOverrideProps = ["material"]);
  function e(n, r) {
    return {
      ...Xi.defaultData,
      ...r,
      component: n,
      overrides: new xi(),
      physics: void 0,
      events: void 0,
      type: "Instance",
    };
  }
  t.ofComponent = e;
  function i(n) {
    let r = no.fromObject(n.data);
    return e(n.id, r);
  }
  t.fromComponentData = i;
})(es || (es = {}));
var ro;
((t) =>
  (t.defaultData = {
    type: "Page",
    ...Xi.defaultData,
    physics: { ...io.defaultData, fusedBody: !1 },
    ...Jd.defaultData,
    camera: pl.defaultData,
  }))(ro || (ro = {}));
var ef;
((t) => (
  (t.defaultCamera = {
    position: [0, 0, 1e3],
    scale: [1, 1, 1],
    rotation: [0, 0, 0],
    hiddenMatrix: eo.identity,
    name: "Play Camera",
    visible: !0,
    raycastLock: !1,
    physics: io.defaultData,
    states: new Ot(),
    events: new Ot(),
    cloner: null,
    pathSnapping: {
      pathId: null,
      orientation: "tangential",
      slide: 0,
      offset: 0,
    },
    ...to.defaultData,
  }),
  (t.KeysByResetCategory = {
    States: ["states"],
    Events: ["events"],
    Material: ["material", "materials"],
    Geometry: ["geometry"],
    Position: ["position"],
    Rotation: ["rotation"],
    Scale: ["scale"],
    Transform: ["position", "scale", "rotation", "hiddenMatrix"],
    Name: ["name"],
    Visibility: ["visible", "raycastLock", "flatShading", "wireframe", "side"],
    Shadows: ["castShadow", "receiveShadow"],
    Cloner: ["cloner"],
    Physics: ["physics"],
  }),
  (t.defaultMeshObject = {
    name: "Rectangle",
    ...Xi.defaultData,
    ...ka.defaultData,
    geometry: Fa.defaultData("RectangleGeometry"),
    material: fn.defaultTwoLayerData("phong", "layer1", "layer2"),
  }),
  (t.defaultBooleanObject = {
    name: "Boolean",
    ...Xi.defaultData,
    ...ka.defaultData,
    geometry: Fa.defaultData("BooleanGeometry"),
    material: fn.defaultTwoLayerData("phong", "layer1", "layer2"),
  }),
  (t.defaultTextObject = {
    name: "Text",
    ...Xi.defaultData,
    ...ka.defaultData,
    geometry: Fa.defaultData("TextGeometry"),
    material: fn.defaultTwoLayerData("phong", "layer1", "layer2"),
  })
))(ef || (ef = {}));
var Oa;
((t) => {
  function e(s, a) {
    let o = { name: a };
    return (
      s.type === "Mesh"
        ? ((o.geometry = {}),
          "material" in s && (o.material = { layers: new xi() }),
          "materials" in s &&
            (o.materials = s.materials.map((l) => ({ layers: new xi() }))))
        : $s.is(s.type) && ((o.perspective = {}), (o.orthographic = {})),
      o
    );
  }
  t.newEmpty = e;
  function i(s, a) {
    if (a === void 0) return s;
    let o = { ...s };
    return (
      "material" in o &&
        "material" in a &&
        a.material &&
        (o.material = Qc(o.material, (l) => {
          if (typeof l != "string")
            for (let [c, d] of Object.entries(a.material.layers)) {
              let h = l.layers.data(c);
              h && _n.patch(h, d);
            }
        }).data),
      o.materials &&
        a.materials &&
        (o.materials = Qc(o.materials, (l) => {
          var c, d;
          for (let h = 0; h < o.materials.length; h++) {
            let u = a.materials[h];
            if (typeof u != "string")
              for (let [f, p] of Object.entries(u.layers)) {
                let v =
                  (d = (c = l[h]) == null ? void 0 : c.layers) == null
                    ? void 0
                    : d.data(f);
                v && _n.patch(v, p);
              }
          }
        }).data),
      o
    );
  }
  function n(s, a) {
    let o,
      l = [],
      c = { orthographic: 0, perspective: 0, geometry: 0 };
    function d(h, u) {
      for (let [f, p] of Object.entries(u.layers)) {
        let { texture: v, ...g } = p;
        if (v !== void 0 && Object.keys(v).length > 0) {
          let m = { path: [...h, "layers", f, "texture"], props: v, type: 0 };
          l.push(m);
        }
        if (Object.keys(g).length > 0) {
          let m = { path: [...h, "layers", f], props: g, type: 0 };
          l.push(m);
        }
      }
    }
    for (let [h, u] of Object.entries(a))
      if (h !== "name")
        if (h === "cloner") l.push(...Bd.toOps(u, ["cloner"]));
        else if (h === "pathSnapping")
          l.push({
            path: [h],
            props: { slide: u.slide, offset: u.offset },
            type: 0,
          });
        else if (h === "material") d(["material"], u);
        else if (h === "materials")
          for (let [f, p] of Object.entries(u)) d(["materials", f], p);
        else if (c[h] === 0) {
          if (h === "geometry" && u.extrusion !== void 0) {
            let f = { path: [h, "extrusion"], props: u.extrusion, type: 0 };
            l.push(f), (u = { ...u }), delete u.extrusion;
          }
          if (Object.keys(u).length > 0) {
            let f = { path: [h], props: u, type: 0 };
            l.push(f);
          }
        } else
          o === void 0 && ((o = { path: [], props: {}, type: 0 }), l.push(o)),
            (o.props[h] = u);
    return l;
  }
  t.toOps = n;
  function r(s, a) {
    var l, c, d, h, u, f;
    if (a === void 0) return s;
    let o = { ...s };
    if (
      (Object.assign(o, no.merge(o, a)),
      Object.assign(o, {
        pathSnapping: Object.assign({}, o.pathSnapping, {
          slide:
            ((l = a.pathSnapping) == null ? void 0 : l.slide) ??
            ((c = o.pathSnapping) == null ? void 0 : c.slide) ??
            0,
          offset:
            ((d = a.pathSnapping) == null ? void 0 : d.offset) ??
            ((h = o.pathSnapping) == null ? void 0 : h.offset) ??
            0,
        }),
      }),
      $s.is(s.type))
    ) {
      (o.orthographic = { ...o.orthographic }),
        (o.perspective = { ...o.perspective });
      let p = a;
      ((u = p.orthographic) == null ? void 0 : u.zoom) !== void 0 &&
        (o.orthographic.zoom = p.orthographic.zoom),
        ((f = p.perspective) == null ? void 0 : f.zoom) !== void 0 &&
          (o.perspective.zoom = p.perspective.zoom),
        p.isUpVectorFlipped !== void 0 &&
          (o.isUpVectorFlipped = p.isUpVectorFlipped),
        p.targetOffset !== void 0 && (o.targetOffset = p.targetOffset);
    } else if (s.type === "Mesh")
      "geometry" in a &&
        Object.assign(o, { geometry: Wd.merge(o.geometry, a.geometry) }),
        (a.material || a.materials) && (o = i(o, a)),
        o.cloner &&
          "cloner" in a &&
          Object.assign(o, { cloner: Qr.merge(o.cloner, a.cloner) });
    else if (s.type === "Empty")
      o.cloner &&
        "cloner" in a &&
        Object.assign(o, { cloner: Qr.merge(o.cloner, a.cloner) });
    else if (Fd.is(s.type)) {
      let p = a;
      p.intensity !== void 0 && (o.intensity = p.intensity),
        p.color !== void 0 &&
          (typeof p.color == "string"
            ? (o.color = p.color)
            : (o.color = Hi.clone(p.color)));
    }
    return o;
  }
  t.patch = r;
})(Oa || (Oa = {}));
var lh;
((t) =>
  (t.defaultData = {
    enablePan: !0,
    enableZoom: !0,
    enableRotate: !0,
    enableDamping: !0,
    rotationLimitsMode: 0,
    rotationVerticalOffset: { min: Math.PI / 4, max: Math.PI / 4 },
    rotationHorizontalOffset: { min: Math.PI / 4, max: Math.PI / 4 },
    rotationSoftLimit: 2,
    panLimitsMode: 0,
    panVerticalOffset: { min: 250, max: 250 },
    panHorizontalOffset: { min: 250, max: 250 },
    panSoftLimit: 2,
    zoomLimitsEnabled: !1,
    zoomLimits: { min: 0.1, max: 2 },
    autoRotate: !1,
    autoRotateSpeed: 2,
    autoRotateClockwise: !0,
    hoverRotatePanMode: 0,
    hoverRotatePanStrength: 20,
    isTouchZoom: !0,
    orbitTouches: 2,
    panTouches: 3,
    resetHoverEffectOnPointerLeave: !0,
  }))(lh || (lh = {}));
var Fs;
((t) =>
  (t.defaultData = {
    orbitControls: lh.defaultData,
    playPage: Jo,
    withBackground: !0,
    preventScroll: !1,
    preventTouchScroll: !1,
    hideCursor: !1,
    mouseEventTarget: "canvas",
    joystickSizeAndXYOffset: Array(12)
      .fill(0)
      .map((e, i) => {
        let n = 0,
          r = 0;
        return (
          i < 5 ? (r = -30) : i < 10 && (r = 30),
          i === 0 || i === 10 || i === 5
            ? (n = 30)
            : (i === 4 || i === 11 || i === 9) && (n = -30),
          [120, [n, r], "show"]
        );
      }),
    settings: {
      image: { format: "jpg", ratio: 1 },
      video: {
        format: "mp4",
        imageFormat: "jpg",
        fps: 30,
        mbps: 80,
        ratio: Math.max(
          1,
          typeof window < "u" ? Math.floor(window.devicePixelRatio) : 1
        ),
        stopMode: "manual",
        duration: 5e3,
      },
      web: { logo: !0, compress: !0, preset: 1, preload: !0, hint: !1 },
    },
    stopRaycast: !0,
    hdTransmission: !1,
  }))(Fs || (Fs = {}));
var tf;
((t) =>
  (t.defaultData = { id: "basic", label: "Basic", style: "None", prompt: "" }))(
  tf || (tf = {})
);
var nf;
((t) =>
  (t.defaultData = {
    weather: 0,
    shadows: 0,
    lightOrigin: 0,
    temperature: 0,
    sun: 0,
    camera: 0,
    environment: 0,
    particles: 0,
    nature: 0,
    floor: 0,
  }))(nf || (nf = {}));
var Va;
((t) => (
  (t.defaultData = () => ({
    mode: "line-art-both",
    prompt: "",
    negativePrompt: "",
    style: { ...tf.defaultData },
    isRandomSeed: !0,
    seed: t.generateSeed(),
    guessMode: !1,
    advanced: !1,
    steps: 20,
    guidanceScale: 7.5,
    controlNetScale: 1,
    modifiers: nf.defaultData,
  })),
  (t.generateSeed = () => Math.round(Math.random() * 1e5))
))(Va || (Va = {}));
var G0;
((t) => {
  function e(n) {
    return (
      n.find(
        (r) => r.data.type === "Page" && r.data.globalPhysics.usePhysics
      ) !== void 0
    );
  }
  t.physicsEnabled = e;
  function i(n, r, s) {
    n.traverseFrom(r, (a, o) => {
      if (o.type === "Instance") {
        let l = n.data(o.component);
        l && s(a, o, l.events);
      } else s(a, o, o.events);
    });
  }
  t.traverseModuleInstances = i;
})(G0 || (G0 = {}));
var rf;
((t) => {
  t.TRASH_CAN_ID = "830a2708-8ed9-49cf-a68e-085299892222";
  function e(r = { withLight: !0, withSquare: !0 }) {
    let s = [],
      a = ef.defaultMeshObject;
    r.withLight === !0 &&
      s.push({
        fi: -1,
        data: Qd.defaultDirectionalLightData,
        id: "830a2708-8ed9-49cf-a68e-085299899103",
        children: [],
      }),
      r.withSquare === !0 &&
        s.push({
          fi: 1,
          id: "7ba78968-2a55-48f2-b14c-5191da3e075e",
          data: a,
          children: [],
        });
    let o = new sn();
    return (
      o.push({
        fi: 1,
        id: Jo,
        data: { ...ro.defaultData, name: "Scene 1" },
        children: s,
      }),
      o
    );
  }
  (t.defaultData = {
    objects: e(),
    publish: Fs.defaultData,
    styles: Va.defaultData(),
  }),
    (t.emptyDataWithoutPage = function () {
      return {
        objects: new sn(),
        publish: Fs.defaultData,
        styles: Va.defaultData(),
      };
    }),
    (t.emptyDataWithPage = function (r) {
      return {
        objects: e(r),
        publish: Fs.defaultData,
        styles: Va.defaultData(),
      };
    });
  function i(r) {
    return { ...t.defaultData, objects: qs(r, sn.prototype) };
  }
  t.withObjs = i;
  function n(r, s) {
    return i([{ id: r, data: s, children: [], fi: 0 }]);
  }
  t.withObj = n;
})(rf || (rf = {}));
var ch;
((t) =>
  (t.emptyImage = {
    data: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVQYV2NgYAAAAAMAAWgmWQ0AAAAASUVORK5CYII=",
    name: "empty",
  }))(ch || (ch = {}));
var sf;
((t) => {
  function e() {
    let r = {};
    return (
      (r["89b10010-844c-11ec-a8a3-0242ac120002"] = {
        r: 0.5,
        g: 0.5,
        b: 0.5,
        a: 1,
        name: "Default Color",
      }),
      qs(r, pi.prototype)
    );
  }
  t.defaultColors = e;
  function i(r) {
    let s = {};
    return (
      r != null &&
        r.withAITexture &&
        (s["a1b10010-844c-a8a3-11ec-0242ac2011ec"] = {
          ...ch.emptyImage,
          name: "AI generated image",
        }),
      qs(s, pi.prototype)
    );
  }
  t.defaultImages = i;
  function n() {
    return {
      materials: new pi(),
      images: new pi(),
      videos: new pi(),
      colors: new pi(),
      audios: new pi(),
      fonts: new pi(),
    };
  }
  t.emptyData = n;
})(sf || (sf = {}));
var af;
((t) => (t.list = ["idle", "move", "jump", "run"]))(af || (af = {}));
var of;
((t) => (
  (t.defaultColliderData = {
    type: "capsule",
    height: 200,
    radius: 50,
    position: [0, 0, 0],
    rotation: [0, 0, 0],
  }),
  (t.defaultDataThirdPerson = {
    moveMode: "walk",
    forwardDirection: "+z",
    speedTranslate: 1e3,
    speedRotate: 100,
    runMultiplier: 2,
    rotationMode: "normal",
    rotBy: "keys",
    rotByTouch: "drag",
    delayPos: [0.3, 0.3],
    delayRot: [0.3, 0.3],
    keyAssignments: [
      ["moveNegZ", "W"],
      ["moveNegX", "A"],
      ["movePosZ", "S"],
      ["movePosX", "D"],
      ["rotPosX", "▲"],
      ["rotPosY", "◀"],
      ["rotNegX", "▼"],
      ["rotNegY", "▶"],
      ["jump", "Space"],
      ["run", "⇧"],
      ["none", "Ctrl"],
    ],
    touchControl: !0,
    joystickPosLoc: 5,
    joystickRotLoc: 11,
    jumpTouchButtonLoc: 9,
    collider: t.defaultColliderData,
    colliderHelperVisible: !0,
    collisionEnabled: !0,
    jumpPower: 100,
    resetYPosition: 3e3,
    alignToGround: !1,
    autoOrientMove: !0,
    orientWith: "camera",
    orientMode: "radial",
    delayPosCamera: 0.3,
    delayRotCamera: 0.3,
    camera: "",
    cameraXAxis: "Limit",
    cameraYAxis: "Free",
    cameraRotXLimits: [0, Math.PI / 2],
    cameraRotYLimits: [-Math.PI / 2, Math.PI / 2],
    gameActions: {
      idle: new Ot(),
      move: new Ot(),
      jump: new Ot(),
      run: new Ot(),
    },
    navmesh: {
      enabled: !1,
      ch: 6,
      cs: 6,
      walkableClimb: 5,
      walkableHeight: 1,
      walkableRadius: 0,
      zones: "all",
      objects: [],
      helperVisible: !0,
      destinationHelperRadius: 0,
      destinationHelperColor: Vn.fromHexAndA(3728051, 1),
    },
  })
))(of || (of = {}));
function j0(t) {
  t.layers.forEach((e) => {
    if (e.type === "depth" && e.colorA !== void 0) {
      let i = e.colorA,
        n = e.colorB,
        r = [
          [i.r, i.g, i.b, i.a],
          [n.r, n.g, n.b, n.a],
        ],
        s = [0, 1];
      for (let o = 2; o < 10; o++) r.push(r[1]), s.push(1);
      let a = {
        ...os(
          Ai(e),
          "type",
          "visible",
          "isVector",
          "isWorldSpace",
          "origin",
          "alpha",
          "mode"
        ),
        near: Math.max(0, e.near),
        far: Math.max(0, e.far),
        colors: r,
        steps: s,
        num: 2,
        direction: [1, 0, 0],
        smooth: !1,
        gradientType: 1,
      };
      Object.assign(e, a);
    } else if (
      e.type === "depth" &&
      e.gradientType === 1 &&
      (e.near < 0 || e.far < 0)
    ) {
      let i = { ...Ai(e), near: Math.max(e.near, 0), far: Math.max(e.far, 0) };
      Object.assign(e, i);
    }
  });
}
function $r(t, e) {
  Object.values(t.shared.materials).forEach((i) => e(i));
}
function Yr(t, e) {
  t.scene.objects.traverse((i, n) => {
    "materials" in n
      ? n.materials.forEach((r, s) => {
          r === void 0 &&
            ((n.materials[s] = fn.defaultData()), (r = n.materials[s])),
            typeof r != "string" && e(r);
        })
      : "material" in n
      ? typeof n.material != "string" &&
        (n.material === void 0 && (n.material = fn.defaultData()),
        e(n.material))
      : n.type === "Mesh" &&
        (n.material === void 0 && (n.material = fn.defaultData()),
        e(n.material)),
      "overrides" in n &&
        Object.values(n.overrides).forEach((r) => {
          r.material && typeof r.material != "string" && e(r.material);
        });
  });
}
function IU(t) {
  Object.assign(t.scene.publish, {
    orbitControls: { ...lh.defaultData, ...Ai(t.scene.publish.orbitControls) },
  });
}
function UU(t) {
  Object.assign(t.scene.publish.settings, {
    video: {
      ...Fs.defaultData.settings.video,
      ...Ai(t.scene.publish.settings.video),
    },
  });
}
function NU(t) {
  function e(i) {
    if (i.layers) {
      for (let n of Object.values(i.layers))
        if (n) {
          for (let [r, s] of Object.entries(n))
            if (
              ((DU.includes(r) || typeof s == "boolean") && delete n[r],
              r === "texture")
            )
              for (let [a, o] of Object.entries(s))
                (RU.includes(a) || typeof o == "boolean") && delete s[a];
        }
    }
  }
  t.scene.objects.traverse((i, n) => {
    n.states.forEach((r) => {
      let s = r;
      s.material
        ? e(s.material)
        : s.materials &&
          s.materials.forEach((a) => {
            e(a);
          });
    });
  });
}
function zU(t) {
  t.scene.publish.withBackground = !0;
}
function BU(t) {
  t.scene.publish.settings.web = {
    compress: !0,
    preload: !0,
    preset: 1,
    logo: !0,
    hint: !1,
  };
}
function FU(t) {
  t.scene.objects.traverse((e, i) => {
    let n = i.cloner;
    n &&
      ((n.radial.scale = n.radial.scale.map((r) => r + 1)),
      (n.linear.scale = n.linear.scale.map((r) => r + 1)));
  });
}
function kU(t) {
  t.scene.objects.traverse((e, i) => {
    let n = i.geometry;
    n &&
      (n.type === "DodecahedronGeometry" || n.type === "IcosahedronGeometry") &&
      (n.detail = Math.round(n.detail));
  });
}
function VU(t) {
  t.scene.objects.traverse((e, i) => {
    let n = t.scene.objects.unproxy().parent(e);
    if (n) {
      let r = Ai(t.scene.objects.data(n));
      r &&
        r.type === "Mesh" &&
        r.geometry.type === "BooleanGeometry" &&
        i.type === "Mesh" &&
        (i.visible = Ai(i).booleanExclude !== !0);
    }
  });
}
function HU(t) {
  t.scene.objects.traverse((e, i) => {
    if (i.type === "Mesh") {
      let n = i;
      i.geometry.type === "NonParametricGeometry"
        ? n.material !== void 0 && delete n.material
        : n.materials !== void 0 && delete n.materials;
    }
  });
}
function GU(t) {
  function e(n) {
    Object.setPrototypeOf(n, xi.prototype),
      n.texture && Object.setPrototypeOf(n.texture, xi.prototype);
  }
  function i(n) {
    Object.setPrototypeOf(n, xi.prototype);
    for (let r in n) e(n[r]);
  }
  t.scene.objects.traverse((n, r) => {
    r.states.forEach((s) => {
      let a = s;
      if (a.material) {
        let o = Ai(a.material).layers;
        i(o), (a.material.layers = o);
      }
      if (a.materials)
        for (let o = 0; o < a.materials.length; o++) {
          let l = a.materials[o],
            c = Ai(l).layers;
          i(c), (l.layers = c);
        }
    });
  });
}
function W0(t) {
  t.layers === void 0 && Object.assign(t, fn.defaultTwoLayerData("lambert"));
}
function zu(t) {
  !t.layers ||
    t.layers.forEach((e) => {
      if (e.type === "depth" && e.colors.length === 10) {
        let i = [...e.colors];
        i.push(e.colors[9]);
        let n = [...e.steps];
        n.push(e.steps[9]);
        let r = { ...Ai(e), colors: i, steps: n };
        Object.assign(e, r);
      }
    });
}
function jU(t) {
  t.scene.objects.traverse((e, i) => {
    i.type === "Mesh" &&
      (i.geometry.type === "BooleanGeometry" ||
        i.geometry.type === "SubdivGeometry") &&
      (i.geometry.phongAngle = 35);
  });
}
function q0(t) {
  t.scene.objects.traverse((e, i) => {
    "materials" in i
      ? i.materials.forEach((n) => {
          typeof n != "string" && zu(n);
        })
      : "material" in i && typeof i.material != "string" && zu(i.material);
  }),
    Object.values(t.shared.materials).forEach((e) => zu(e));
}
function WU(t) {
  (t.scene.environment.ambientLight.softShadows = !1),
    (t.scene.environment.ambientLight.softShadowQuality = "low"),
    t.scene.objects.traverse((e, i) => {
      (i.type === "DirectionalLight" || i.type === "SpotLight") &&
        ((i.shadowResolution = 1024), (i.shadowRadius = 1), (i.depth = 1e5));
    }),
    (t.shared.penumbraSize = new Array(5).fill(0.5));
}
function qU(t) {
  t.shared.audios = qs({}, pi.prototype);
}
function XU(t) {
  t.shared.videos = qs({}, pi.prototype);
}
function $U(t) {
  let e = t.shared.materials;
  Object.entries(e).forEach(([i, n]) => {
    if (!n.layers) {
      let r = {
        name: "Untitled Material",
        layers: [
          {
            fi: 0,
            data: {
              type: "light",
              category: "phong",
              alpha: 0.6,
              visible: !0,
              mode: 0,
              specular: { r: 0.2, g: 0.2, b: 0.2 },
              shininess: 5,
            },
            id: "layer1",
          },
          {
            fi: 1,
            data: {
              type: "color",
              alpha: 1,
              visible: !0,
              mode: 0,
              color: {
                r: 0.2823529411764706,
                g: 0.2823529411764706,
                b: 0.30196078431372547,
              },
            },
            id: "layer2",
          },
        ],
      };
      Object.assign(e, { [i]: r });
    }
  });
}
function YU(t) {
  Object.entries(Ai(t.shared.images))
    .filter((e) => e[1].asset === !1)
    .map((e) => e[0])
    .forEach((e) => {
      delete t.shared.images[e];
    }),
    Object.entries(Ai(t.shared.audios))
      .filter((e) => e[1].asset === !1)
      .map((e) => e[0])
      .forEach((e) => {
        delete t.shared.audios[e];
      });
}
function ZU(t) {
  t.scene.publish.settings.web.preload = !1;
}
function X0(t) {
  t.layers &&
    t.layers.forEach((e) => {
      e.type === "depth" &&
        e.num !== void 0 &&
        ((e.colors = e.colors.slice(0, e.num)),
        (e.steps = e.steps.slice(0, e.num)),
        delete e.num);
    });
}
function $0(t) {
  t.layers &&
    t.layers.forEach((e) => {
      LU(e) && e.isMask === void 0 && (e.isMask = !1),
        (e.type === "texture" || e.type === "video") &&
          e.blending === void 0 &&
          (e.blending = 0),
        (e.type === "noise" ||
          (e.type === "displace" && e.displacementType === "noise")) &&
          (e.voronoiStyle === void 0 && (e.voronoiStyle = 0),
          e.highCut === void 0 && (e.highCut = 1),
          e.lowCut === void 0 && (e.lowCut = 0),
          e.smoothness === void 0 && (e.smoothness = 0.3),
          e.seed === void 0 && (e.seed = 0),
          e.quality === void 0 && (e.quality = 1));
    });
}
function KU(t) {
  t.shared.fonts = qs({}, pi.prototype);
}
function JU(t) {
  return t
    .replace(".typeface", "")
    .replace(/optimer/gi, "open sans")
    .replace("space_mono", "space mono")
    .replace(/alma_mono/gi, "varela round")
    .replace(/droid_sans_mono/gi, "noto sans mono")
    .replace(
      /droid_sans|gentilis|gnomon_(simple|foreground)|helvetiker/gi,
      "roboto"
    )
    .replace(/droid_serif/gi, "roboto slab")
    .replace("_sans", " sans")
    .replace("crimson_text", "crimson text")
    .replace("medium_medium", "medium")
    .replace("fatface_fatface", "fatface")
    .replace("100hairline", "thin")
    .replace("200thin", "extralight")
    .replace("300light", "light")
    .replace("500medium", "medium")
    .replace("600semi", "semibold")
    .replace("800heavy", "extrabold")
    .replace("900black", "black")
    .replace(/bodoni_(11|16|24|36|48|72|96)([^_])/gi, "bodoni_$1_$2")
    .replace(/bodoni_(11|16|24|36|48|72|96)/gi, "bodoni moda")
    .replace(/(thin|hairline)(_regular)?/gi, "100")
    .replace(/(extra|ultra)light(_regular)?/gi, "200")
    .replace(/light(_regular)?/gi, "300")
    .replace(/_book|_normal|_roman/gi, "_regular")
    .replace(/medium(_regular)?/gi, "500")
    .replace(/(semi|demi)bold(_regular)?/gi, "600")
    .replace(/(extra|ultra)bold(_regular)?/gi, "800")
    .replace(/bold(_regular)?/gi, "700")
    .replace(/(black|heavy|fatface)(_regular)?/gi, "900")
    .replace(/([1-9]00)_italic/gi, "$1italic")
    .replace(/regularitalic/gi, "italic")
    .replace(/regularitalic/gi, "italic")
    .split(" ")
    .map((e) => e.charAt(0).toUpperCase() + e.slice(1))
    .join(" ");
}
function QU(t) {
  let e = [];
  t.scene.objects.traverse((i, n) => {
    let r = n;
    if (r.type === "TextFrame") {
      let s = fn.defaultTwoLayerData("phong"),
        a = typeof r.color == "string" ? t.shared.colors[r.color] : r.color;
      (s.layers[1].data.color = { r: a.r, g: a.g, b: a.b }),
        (s.layers[1].data.alpha = r.alpha);
      let o = JU(r.font);
      t.shared.fonts[o] === void 0 && (t.shared.fonts[o] = { name: o });
      let l = {
          name: r.name,
          ...Xi.defaultData,
          ...ka.defaultData,
          flatShading: !1,
          wireframe: !1,
          geometry: {
            ...Fa.defaultData("TextGeometry"),
            width: r.width,
            height: r.height,
            font: o,
            depth: 0,
            horizontalAlign: r.horizontalAlign,
            verticalAlign: r.verticalAlign,
            fontSize: r.fontSize * 1.40625,
            lineHeight: r.lineHeight / 1.40625,
            letterSpacing: r.letterSpacing - 1,
            text: r.text,
            textTransform: r.textTransform,
            extrudeBevelSize: 0,
            extrudeBevelSegments: 1,
          },
          material: s,
          states: Ai(r.states),
          events: Ai(r.events),
          visible: r.visible,
          raycastLock: r.raycastLock,
          position: r.position,
          rotation: r.rotation,
          scale: r.scale,
          hiddenMatrix: r.hiddenMatrix,
        },
        c = Ai(t.scene.objects).parent(i);
      t.scene.objects.insertAfter(c ?? null, i, [
        { id: i + "new", data: l, children: [] },
      ]),
        e.push(i);
    }
  }),
    e.forEach((i) => {
      t.scene.objects.delete(i);
    });
}
function eN(t) {
  let e = {
    0: "MouseDown",
    1: "MouseUp",
    2: "MouseHover",
    5: "KeyDown",
    6: "KeyUp",
    7: "Start",
    9: "LookAt",
    10: "Follow",
    11: "Scroll",
    12: "Audio",
    13: "GameControl",
  };
  t.scene.objects.traverse((i, n) => {
    n.events.forEach((r) => {
      if (e[Number(r.type)])
        if (
          (Object.assign(r, { type: e[Number(r.type)] }),
          r.type === "Audio" &&
            "audioEvent" in r &&
            (Object.assign(r, { playAudio: r.audioEvent }),
            delete r.audioEvent),
          r.type === "GameControl")
        )
          Object.assign(r, {
            gameActions: { idle: new Ot(), move: new Ot(), jump: new Ot() },
          });
        else {
          let s = new Ot();
          Object.assign(r, { actions: s }),
            (r.type === "MouseDown" ||
              r.type === "MouseUp" ||
              r.type === "KeyDown" ||
              r.type === "KeyUp") &&
              "url" in r &&
              s.push({
                fi: 0,
                id: Jt.generateUUID(),
                data: { type: "Link", url: r.url, delay: 0 },
              }),
            "targets" in r &&
              (r.targets.forEach((a, o, l) => {
                let c = {
                    state: void 0,
                    repeat: 0,
                    delay: 0,
                    delayDirection: void 0,
                    direction: "normal",
                    duration: 0,
                    easing: 4,
                  },
                  d = { easing: a.easing, duration: a.duration };
                a.easing === 6
                  ? Object.assign(
                      d,
                      os(a, "mass", "stiffness", "damping", "velocity")
                    )
                  : a.easing === 5 &&
                    Object.assign(d, {
                      control1: { ...a.control1 },
                      control2: { ...a.control2 },
                    });
                let h = {
                    repeat: a.repeat ? -1 : 0,
                    delay: a.delay,
                    delayDirection: a.delayDirection,
                    direction:
                      a.cycle && a.rewind
                        ? "pingpong-rewind"
                        : a.cycle
                        ? "pingpong"
                        : "normal",
                  },
                  u = { state: a.state, ...h, ...d },
                  f = {
                    allowSlerp: !0,
                    type: "Transition",
                    object: a.object,
                    repeat: 0,
                    delay: 0,
                    delayDirection: void 0,
                    direction: "normal",
                    tweens: new Ot(
                      { fi: 0, id: Jt.generateUUID(), data: c },
                      { fi: 1, id: Jt.generateUUID(), data: u }
                    ),
                  };
                s.push({ fi: l, id: o, data: f });
              }),
              delete r.targets);
        }
    });
  });
}
function tN(t) {
  t.scene.objects.traverse((e, i) => {
    function n(r, s) {
      var l;
      let a = new Ot(),
        o = [];
      if (
        (i.events.forEach((c, d, h) => {
          if (c.type === "Audio" && c.trigger === s) {
            let u;
            o.push(d),
              c.interaction === "play"
                ? (u = {
                    ...os(c, "interaction", "audio", "delay", "volume", "loop"),
                    triggerAfter: "after" in c ? c.after : void 0,
                    toggle: "after" in c ? c.toggle : void 0,
                    type: "Audio",
                  })
                : (c.interaction === "pause" || c.interaction === "stop") &&
                  (u = {
                    ...os(c, "interaction", "delay", "object", "playAudio"),
                    type: "Audio",
                  }),
              u && a.push({ fi: h, id: d, data: u });
          }
        }),
        o.forEach((c) => i.events.delete(c)),
        a.length)
      ) {
        let c =
          (l = i.events.find((d) => d.type === r)) == null ? void 0 : l.data;
        c
          ? "actions" in c && c.actions.insertBefore(null, a)
          : i.events.insertBefore(null, [
              { id: Jt.generateUUID(), data: { type: r, actions: a } },
            ]);
      }
    }
    n("Start", "start"),
      n("MouseDown", "mouseDown"),
      n("MouseUp", "mouseUp"),
      n("KeyDown", "keyDown"),
      n("KeyUp", "keyUp");
  });
}
function Y0(t) {
  var i;
  let e =
    (i = t.layers.find((n) => n.type === "light")) == null ? void 0 : i.data;
  if ((e == null ? void 0 : e.category) === "basic") {
    let n = _n.defaultData("light", "phong"),
      r = e;
    Object.assign(r, n), (r.visible = !1);
  }
}
function Z0(t) {
  $r(t, Y0), Yr(t, Y0);
}
function iN(t) {
  t.scene.objects.traverse((e, i) => {
    i.type === "Mesh" &&
      i.geometry.type === "SubdivGeometry" &&
      (i.geometry.scaleBaked || (i.geometry.scaleBaked = [1, 1, 1]));
  });
}
function nN(t) {
  t.scene.objects.traverse((e, i) => {
    (i.type === "Empty" || i.type === "Mesh") &&
      i.cloner &&
      !i.cloner.randomnessObject &&
      !i.cloner.toObject &&
      !i.cloner.randomness &&
      (i.cloner = {
        ...i.cloner,
        toObject: {
          object: "",
          spreadType: "random",
          scale: [0, 0, 0],
          rotation: [0, 0, 0],
          position: [0, 0, 0],
          axis: "x",
          seed: 0,
          count: 99,
          align: "normal",
        },
        randomness: !1,
        randomnessObject: {
          strength: 100,
          scale: [0, 0, 0],
          rotation: [0, 0, 0],
          position: [0, 0, 0],
          movement: 1,
          seed: 0,
          freqScale: 10,
          noiseType: "perlin",
        },
      });
  });
}
function rN(t) {
  t.scene.objects.traverse((e, i) => {
    i.type === "Mesh" &&
      i.geometry.type === "NonParametricGeometry" &&
      !("material" in i) &&
      !("materials" in i) &&
      (i.material = fn.defaultTwoLayerData("phong"));
  });
}
function sN(t) {
  t.scene.publish.orbitControls.autoZoom === void 0 &&
    (t.scene.publish.orbitControls.autoZoom = !1),
    t.scene.objects.traverse((e, i) => {
      (i.type === "OrthographicCamera" || i.type === "PerspectiveCamera") &&
        (i.orthographic.autoZoom === void 0 && (i.orthographic.autoZoom = !1),
        i.orthographic.autoZoomFrustumSize === void 0 &&
          (i.orthographic.autoZoomFrustumSize = 790));
    });
}
function aN(t) {
  t.scene.objects.traverse((e, i) => {
    i.pathSnapping === void 0 &&
      (i.pathSnapping = {
        pathId: null,
        slide: 0,
        offset: 0,
        orientation: "tangential",
      }),
      i.pathSnapping.offset === void 0 && (i.pathSnapping.offset = 0);
  });
}
function oN(t) {
  t.scene.publish.mouseEventTarget === void 0 &&
    (t.scene.publish.mouseEventTarget = "canvas"),
    t.scene.publish.settings.web.hint === void 0 &&
      (t.scene.publish.settings.web.hint = !1);
}
function lN(t) {
  let { video: e } = t.scene.publish.settings;
  e.format === "gif" && e.fps > 48 && (e.fps = 15);
}
function cN(t) {
  t.scene.objects.traverse((e, i) => {
    i.events.forEach((n) => {
      n.type === "GameControl" &&
        (n.resetYPosition = Math.abs(n.resetYPosition - i.position[1]));
    });
  });
}
function hN(t) {
  let e = t.scene.environment.usePhysics;
  t.scene.objects.traverse((i, n) => {
    e && n.physics === null ? (n.collision = !1) : (n.collision = "visibility");
  });
}
function uN(t) {
  t.scene.objects.traverse((e, i) => {
    i.events.forEach((n) => {
      n.type === "GameControl" &&
        (n.navmesh = of.defaultDataThirdPerson.navmesh);
    });
  });
}
function dN(t) {
  t.scene.styles || (t.scene.styles = Va.defaultData());
}
function K0(t) {
  t.layers.forEach((e) => {
    e.type === "light" &&
      e.category !== "toon" &&
      e.occlusion === void 0 &&
      (e.occlusion = !0);
  });
}
function fN(t) {
  t.scene.environment.ambientLight.occlusion === void 0 &&
    (t.scene.environment.ambientLight.occlusion = !1),
    t.scene.environment.ambientLight.aoFullRes === void 0 &&
      (t.scene.environment.ambientLight.aoFullRes = !1),
    t.scene.environment.ambientLight.radius === void 0 &&
      (t.scene.environment.ambientLight.radius = 256),
    t.scene.environment.ambientLight.bias === void 0 &&
      (t.scene.environment.ambientLight.bias = 0.5),
    t.scene.environment.ambientLight.aoColor === void 0 &&
      (t.scene.environment.ambientLight.aoColor = {
        r: 0.19607843137254902,
        g: 0.19607843137254902,
        b: 0.19607843137254902,
      }),
    Yr(t, K0),
    $r(t, K0);
}
function pN(t) {
  t.scene.objects.traverse((e, i) => {
    i.events.forEach((n) => {
      n.type === "GameControl" &&
        Object.assign(n.gameActions, { run: new Ot() });
    });
  });
}
function mN(t) {
  t.scene.objects.traverse((e, i) => {
    i.events.forEach((n) => {
      n.type === "GameControl" &&
        (n.keyAssignments = [
          ...n.keyAssignments,
          ["run", "⇧"],
          ["none", "Ctrl"],
        ]);
    });
  });
}
function J0(t) {
  t.layers &&
    t.layers.forEach((e) => {
      e.type === "light" &&
        e.bumpMapIntensity === void 0 &&
        (e.bumpMapIntensity = 5);
    });
}
function gN(t, e) {
  if (
    (e < 1 && (Yr(t, j0), $r(t, j0), (t.schema = 1)),
    e < 2 && (IU(t), (t.schema = 2)),
    e < 3 && (NU(t), (t.schema = 3)),
    e < 4 && (zU(t), (t.schema = 4)),
    e < 5 && (BU(t), (t.schema = 5)),
    e < 6 && (FU(t), (t.schema = 6)),
    e < 7 && (kU(t), (t.schema = 7)),
    e < 8 && (t.schema = 8),
    e < 9 && (q0(t), (t.schema = 9)),
    e < 10 && (jU(t), (t.schema = 10)),
    e < 11 && (WU(t), (t.schema = 11)),
    e < 12 && (q0(t), (t.schema = 12)),
    e < 13 && (qU(t), (t.schema = 13)),
    e < 14 && ($U(t), (t.schema = 14)),
    e < 15 && (YU(t), (t.schema = 15)),
    e < 16 && (ZU(t), (t.schema = 16)),
    e < 17 && (Yr(t, X0), $r(t, X0), (t.schema = 17)),
    e < 18 && (Yr(t, W0), $r(t, W0), (t.schema = 18)),
    e < 19 && (UU(t), (t.schema = 19)),
    e < 20 && (KU(t), QU(t), (t.schema = 20)),
    e < 21 && (eN(t), tN(t), (t.schema = 21)),
    e < 22 && (Z0(t), (t.schema = 22)),
    e < 23 && (iN(t), (t.schema = 23)),
    e < 24 && (nN(t), (t.schema = 24)),
    (e < 25 || t.shared.videos === void 0) &&
      (XU(t), e < 25 && (t.schema = 25)),
    e < 26 && (VU(t), (t.schema = 26)),
    e < 27 && (HU(t), (t.schema = 27)),
    e < 28 && (Z0(t), (t.schema = 28)),
    e < 29 && (GU(t), (t.schema = 29)),
    e < 30 && (rN(t), (t.schema = 30)),
    e < 31 && (sN(t), (t.schema = 31)),
    e < 33 && (aN(t), (t.schema = 33)),
    e < 34 && (oN(t), (t.schema = 34)),
    e < 35 && (lN(t), (t.schema = 35)),
    e < 36 && (cN(t), (t.schema = 36)),
    e < 37 && (hN(t), (t.schema = 37)),
    e < 38 && (Yr(t, $0), $r(t, $0), (t.schema = 38)),
    e < 39 && (uN(t), (t.schema = 39)),
    e < 40 && (dN(t), (t.schema = 40)),
    e < 41 && (fN(t), (t.schema = 41)),
    e < 42 && (pN(t), (t.schema = 42)),
    e < 43 && (mN(t), (t.schema = 43)),
    e < 99)
  ) {
    Yr(t, J0),
      $r(t, J0),
      t.scene.publish.playCamera === null && (t.scene.publish.playCamera = Fh);
    let i = Ai(t.scene.objects),
      n = t.scene.objects;
    (t.scene.publish.playPage = Jo),
      n.insertBefore(null, null, [
        {
          id: Jo,
          data: {
            ...ro.defaultData,
            backgroundColor: t.scene.backgroundColor,
            fog: t.scene.fog,
            postprocessing: t.scene.postprocessing,
            ao: os(
              t.scene.environment.ambientLight,
              "occlusion",
              "aoFullRes",
              "radius",
              "bias",
              "aoColor"
            ),
            publish: {
              playCamera: t.scene.publish.playCamera,
              gameControlObject: t.scene.publish.gameControlObject,
            },
            shadow: os(t.scene.environment.ambientLight, "softShadowQuality"),
            globalPhysics: {
              ...ah.defaultData,
              ...os(t.scene.environment, "usePhysics", "gravity"),
            },
            camera: Ai(t.scene.ownerCamera) ?? ro.defaultData.camera,
            name: "Scene",
          },
          children: [],
        },
      ]);
    for (let a of i) a.id !== rf.TRASH_CAN_ID && n.move(Jo, a.fi, a.id);
    let r = 0,
      s = 0;
    t.shared.penumbraSize &&
      t.scene.objects.traverse((a, o) => {
        o.type === "DirectionalLight"
          ? ((o.penumbraSize = t.shared.penumbraSize[Math.min(r, 2)]), (r += 1))
          : o.type === "SpotLight" &&
            ((o.penumbraSize = t.shared.penumbraSize[3 + Math.min(s, 1)]),
            (s += 1)),
          (o.physics === void 0 || o.physics === null) &&
            o.type !== "Instance" &&
            ((o.physics = {}), Object.assign(o.physics, io.defaultData)),
          o.physics !== void 0 &&
            ((o.physics.enabled = o.collision ?? "visibility"),
            delete o.collision);
      }),
      (t.schema = 99);
  }
}
function Q0(t) {
  t.layers &&
    t.layers.forEach((e) => {
      e.type === "light" && e.alphaOverride === void 0 && (e.alphaOverride = 1);
    });
}
function vN(t) {
  t.scene.objects.traverse((e, i) => {
    let n = i.geometry;
    n &&
      n.type === "PathGeometry" &&
      ((n.extrusion.capType = "flat"),
      (n.extrusion.bevel = 50),
      (n.extrusion.bevelSides = 6),
      n.extrusion.shape.type === "Custom" &&
        (n.extrusion.shape.shapeQuality = "low"));
  });
}
var ev = 102;
function yN(t) {
  let e = t.schema ?? 0;
  e !== ev &&
    (console.warn("updating from ", e, "to ", ev),
    gN(t, e),
    e < 100 &&
      (t.scene.publish.joystickSizeAndXYOffset === void 0 &&
        (t.scene.publish.joystickSizeAndXYOffset =
          Fs.defaultData.joystickSizeAndXYOffset),
      (t.schema = 100)),
    e < 101 && (Yr(t, Q0), $r(t, Q0), (t.schema = 101)),
    e < 102 && (vN(t), (t.schema = 102)));
}
var Po = wl(uC()),
  xN = 0.5 * (Math.sqrt(3) - 1),
  Lo = (3 - Math.sqrt(3)) / 6,
  _N = 1 / 3,
  er = 1 / 6,
  Qo = (t) => Math.floor(t) | 0,
  tv = new Float64Array([
    1, 1, -1, 1, 1, -1, -1, -1, 1, 0, -1, 0, 1, 0, -1, 0, 0, 1, 0, -1, 0, 1, 0,
    -1,
  ]),
  Bu = new Float64Array([
    1, 1, 0, -1, 1, 0, 1, -1, 0, -1, -1, 0, 1, 0, 1, -1, 0, 1, 1, 0, -1, -1, 0,
    -1, 0, 1, 1, 0, -1, 1, 0, 1, -1, 0, -1, -1,
  ]);
function Fu(t = Math.random) {
  let e = P_(t),
    i = new Float64Array(e).map((r) => tv[(r % 12) * 2]),
    n = new Float64Array(e).map((r) => tv[(r % 12) * 2 + 1]);
  return function (r, s) {
    let a = 0,
      o = 0,
      l = 0,
      c = (r + s) * xN,
      d = Qo(r + c),
      h = Qo(s + c),
      u = (d + h) * Lo,
      f = d - u,
      p = h - u,
      v = r - f,
      g = s - p,
      m,
      x;
    v > g ? ((m = 1), (x = 0)) : ((m = 0), (x = 1));
    let y = v - m + Lo,
      _ = g - x + Lo,
      M = v - 1 + 2 * Lo,
      b = g - 1 + 2 * Lo,
      E = d & 255,
      T = h & 255,
      S = 0.5 - v * v - g * g;
    if (S >= 0) {
      let L = E + e[T],
        P = i[L],
        R = n[L];
      (S *= S), (a = S * S * (P * v + R * g));
    }
    let w = 0.5 - y * y - _ * _;
    if (w >= 0) {
      let L = E + m + e[T + x],
        P = i[L],
        R = n[L];
      (w *= w), (o = w * w * (P * y + R * _));
    }
    let C = 0.5 - M * M - b * b;
    if (C >= 0) {
      let L = E + 1 + e[T + 1],
        P = i[L],
        R = n[L];
      (C *= C), (l = C * C * (P * M + R * b));
    }
    return 70 * (a + o + l);
  };
}
function bN(t = Math.random) {
  let e = P_(t),
    i = new Float64Array(e).map((s) => Bu[(s % 12) * 3]),
    n = new Float64Array(e).map((s) => Bu[(s % 12) * 3 + 1]),
    r = new Float64Array(e).map((s) => Bu[(s % 12) * 3 + 2]);
  return function (s, a, o) {
    let l,
      c,
      d,
      h,
      u = (s + a + o) * _N,
      f = Qo(s + u),
      p = Qo(a + u),
      v = Qo(o + u),
      g = (f + p + v) * er,
      m = f - g,
      x = p - g,
      y = v - g,
      _ = s - m,
      M = a - x,
      b = o - y,
      E,
      T,
      S,
      w,
      C,
      L;
    _ >= M
      ? M >= b
        ? ((E = 1), (T = 0), (S = 0), (w = 1), (C = 1), (L = 0))
        : _ >= b
        ? ((E = 1), (T = 0), (S = 0), (w = 1), (C = 0), (L = 1))
        : ((E = 0), (T = 0), (S = 1), (w = 1), (C = 0), (L = 1))
      : M < b
      ? ((E = 0), (T = 0), (S = 1), (w = 0), (C = 1), (L = 1))
      : _ < b
      ? ((E = 0), (T = 1), (S = 0), (w = 0), (C = 1), (L = 1))
      : ((E = 0), (T = 1), (S = 0), (w = 1), (C = 1), (L = 0));
    let P = _ - E + er,
      R = M - T + er,
      I = b - S + er,
      W = _ - w + 2 * er,
      N = M - C + 2 * er,
      U = b - L + 2 * er,
      G = _ - 1 + 3 * er,
      k = M - 1 + 3 * er,
      B = b - 1 + 3 * er,
      V = f & 255,
      X = p & 255,
      H = v & 255,
      j = 0.6 - _ * _ - M * M - b * b;
    if (j < 0) l = 0;
    else {
      let K = V + e[X + e[H]];
      (j *= j), (l = j * j * (i[K] * _ + n[K] * M + r[K] * b));
    }
    let Y = 0.6 - P * P - R * R - I * I;
    if (Y < 0) c = 0;
    else {
      let K = V + E + e[X + T + e[H + S]];
      (Y *= Y), (c = Y * Y * (i[K] * P + n[K] * R + r[K] * I));
    }
    let ee = 0.6 - W * W - N * N - U * U;
    if (ee < 0) d = 0;
    else {
      let K = V + w + e[X + C + e[H + L]];
      (ee *= ee), (d = ee * ee * (i[K] * W + n[K] * N + r[K] * U));
    }
    let Z = 0.6 - G * G - k * k - B * B;
    if (Z < 0) h = 0;
    else {
      let K = V + 1 + e[X + 1 + e[H + 1]];
      (Z *= Z), (h = Z * Z * (i[K] * G + n[K] * k + r[K] * B));
    }
    return 32 * (l + c + d + h);
  };
}
function P_(t) {
  let e = new Uint8Array(512);
  for (let i = 0; i < 512 / 2; i++) e[i] = i;
  for (let i = 0; i < 512 / 2 - 1; i++) {
    let n = i + ~~(t() * (256 - i)),
      r = e[i];
    (e[i] = e[n]), (e[n] = r);
  }
  for (let i = 256; i < 512; i++) e[i] = e[i - 256];
  return e;
}
var In = new Ki(),
  wN = class {
    constructor(t) {
      this.weightAttribute = null;
      let e = t.geometry;
      if (!e.isBufferGeometry || e.attributes.position.itemSize !== 3)
        throw new Error(
          "THREE.MeshSurfaceSampler: Requires BufferGeometry triangle mesh."
        );
      e.index && (e = e.toNonIndexed()),
        (this.geometry = e),
        (this.randomFunction = Math.random),
        (this.positionAttribute = this.geometry.getAttribute("position")),
        (this.distribution = null);
    }
    build() {
      let t = this.positionAttribute,
        e = new Float32Array(t.count / 3);
      for (let n = 0; n < t.count; n += 3) {
        let r = 1;
        In.a.fromBufferAttribute(t, n),
          In.b.fromBufferAttribute(t, n + 1),
          In.c.fromBufferAttribute(t, n + 2),
          (r *= In.getArea()),
          (e[n / 3] = r);
      }
      this.distribution = new Float32Array(t.count / 3);
      let i = 0;
      for (let n = 0; n < e.length; n++)
        (i += e[n]), (this.distribution[n] = i);
      return this;
    }
    setRandomGenerator(t) {
      return (this.randomFunction = t), this;
    }
    sample(t, e) {
      if (this.distribution) {
        let i = this.distribution[this.distribution.length - 1],
          n = this.binarySearch(this.randomFunction() * i);
        return this.sampleFace(n, t, e);
      }
    }
    binarySearch(t) {
      if (!this.distribution) return 0;
      let e = this.distribution,
        i = 0,
        n = e.length - 1,
        r = -1;
      for (; i <= n; ) {
        let s = Math.ceil((i + n) / 2);
        if (s === 0 || (e[s - 1] <= t && e[s] > t)) {
          r = s;
          break;
        } else t < e[s] ? (n = s - 1) : (i = s + 1);
      }
      return r;
    }
    sampleFace(t, e, i) {
      let n = this.randomFunction(),
        r = this.randomFunction();
      return (
        n + r > 1 && ((n = 1 - n), (r = 1 - r)),
        In.a.fromBufferAttribute(this.positionAttribute, t * 3),
        In.b.fromBufferAttribute(this.positionAttribute, t * 3 + 1),
        In.c.fromBufferAttribute(this.positionAttribute, t * 3 + 2),
        e
          .set(0, 0, 0)
          .addScaledVector(In.a, n)
          .addScaledVector(In.b, r)
          .addScaledVector(In.c, 1 - (n + r)),
        In.getNormal(i),
        this
      );
    }
  },
  SN = wl(dC()),
  MN = new ze(),
  EN = new ze(),
  TN = new ze(),
  ml;
((t) => {
  function e(i) {
    return i && i.__isSPEObject;
  }
  t.is = e;
})(ml || (ml = {}));
var Lp = (t) =>
    class extends t {
      constructor() {
        super(...arguments),
          (this.previousModelViewMatrix = new ze()),
          (this.copyPreviousMatrix = !0),
          (this.hiddenMatrix = new ze()),
          (this.matrixWorldRigid = new ze()),
          (this.shearScale = new ze()),
          (this.shearScaleInv = new ze());
      }
      get __isSPEObject() {
        return !0;
      }
      isDescendantOf(e) {
        e instanceof Ht && (e = e.uuid);
        let i = this;
        for (; i.parent; ) {
          if (i.parent.uuid === e) return !0;
          i = i.parent;
        }
        return !1;
      }
      updateMatrixWorld(e) {
        this.matrixAutoUpdate && this.updateMatrix(),
          (this.matrixWorldNeedsUpdate || e) &&
            (this.parent === null
              ? this.matrixWorld.multiplyMatrices(
                  this.hiddenMatrix,
                  this.matrix
                )
              : (this.matrixWorld.multiplyMatrices(
                  this.parent.matrixWorld,
                  this.hiddenMatrix
                ),
                this.matrixWorld.multiplyMatrices(
                  this.matrixWorld,
                  this.matrix
                )),
            (this.matrixWorldNeedsUpdate = !1),
            (e = !0));
        for (let i of this.children) i.updateMatrixWorld(e);
      }
      updateWorldMatrix(e, i) {
        let n = this.parent;
        if (
          (e && n !== null && n.updateWorldMatrix(!0, !1),
          this.matrixAutoUpdate && this.updateMatrix(),
          this.parent === null
            ? this.matrixWorld.multiplyMatrices(this.hiddenMatrix, this.matrix)
            : (this.matrixWorld.multiplyMatrices(
                this.parent.matrixWorld,
                this.hiddenMatrix
              ),
              this.matrixWorld.multiplyMatrices(this.matrixWorld, this.matrix)),
          i)
        )
          for (let r of this.children) r.updateWorldMatrix(!1, !0);
      }
      traverseChildren(e, i = 0) {
        for (let n of this.children) ml.is(n) && n.traverseObject(e, i + 1);
      }
      traverseObject(e, i = 0) {
        if (e(this, i) !== !0)
          for (let n of this.children) ml.is(n) && n.traverseObject(e, i + 1);
      }
      updateMatrixWorldSVD() {
        let e = this.matrixWorld.elements,
          i = [
            [e[0], e[4], e[8]],
            [e[1], e[5], e[9]],
            [e[2], e[6], e[10]],
          ],
          { u: n, v: r, q: s } = (0, SN.SVD)(i),
          a = MN.set(
            n[0][0],
            n[0][1],
            n[0][2],
            0,
            n[1][0],
            n[1][1],
            n[1][2],
            0,
            n[2][0],
            n[2][1],
            n[2][2],
            0,
            0,
            0,
            0,
            1
          ),
          o = EN.set(
            r[0][0],
            r[0][1],
            r[0][2],
            0,
            r[1][0],
            r[1][1],
            r[1][2],
            0,
            r[2][0],
            r[2][1],
            r[2][2],
            0,
            0,
            0,
            0,
            1
          ),
          l = TN.copy(o).transpose();
        this.shearScale.makeScale(s[0], s[1], s[2]).multiply(l).premultiply(o),
          this.shearScaleInv.copy(this.shearScale).invert(),
          this.matrixWorldRigid
            .multiplyMatrices(a, l)
            .copyPosition(this.matrixWorld),
          s.every((c) => Math.abs(s[0] - c) < 0.01)
            ? (this.hasNonUniformScale = !1)
            : (this.hasNonUniformScale = !0);
      }
      attach(e, i) {
        this.updateWorldMatrix(!0, !1);
        let n = new ze().copy(this.matrixWorld).invert();
        return (
          e.parent !== null &&
            (e.parent.updateWorldMatrix(!0, !1),
            n.multiply(e.parent.matrixWorld)),
          "hiddenMatrix" in e && e.hiddenMatrix instanceof ze
            ? e.hiddenMatrix.premultiply(n)
            : e.applyMatrix4(n),
          e.updateWorldMatrix(!1, !1),
          this.add(e),
          i !== void 0 && (this.children.pop(), this.children.splice(i, 0, e)),
          this
        );
      }
      copy(e, i = !1) {
        return (
          super.copy(e, i),
          (this.hasNonUniformScale = e.hasNonUniformScale),
          this
        );
      }
      onAfterRender(e, i, n, r, s, a) {
        this.copyPreviousMatrix &&
          this.previousModelViewMatrix.copy(this.modelViewMatrix);
      }
    },
  AN = class extends Lp(Ht) {},
  CN = (t) => t.type === "Mesh",
  Fo = class extends AN {
    constructor(t) {
      super(),
        (this.object = t),
        (this.matrixAutoUpdate = !1),
        (this.hasNonUniformScale = t.hasNonUniformScale);
    }
    raycast(t, e) {}
    expand() {
      let t = 0,
        e = this.object.entityChildren(t);
      for (; e; ) {
        let i = this.children[t];
        (i == null ? void 0 : i.object) !== e &&
          (i && this.remove(i),
          (i = new Fo(e)),
          this.add(i),
          this.children.splice(t, 0, this.children.pop()),
          (i.matrixWorldNeedsUpdate = !0),
          (i.matrixAutoUpdate = !1),
          (i.matrix = e.matrix),
          (i.hiddenMatrix = e.hiddenMatrix)),
          i.expand(),
          (t += 1),
          (e = this.object.entityChildren(t));
      }
      for (; this.children.length > t; ) this.remove(this.children[t]);
    }
    get visible() {
      var t;
      return this.playModeVisible !== void 0
        ? this.playModeVisible
        : this.object.visible ||
            (this.object.dataPatched.visible &&
              ((t = this.object.dataPatched.cloner) == null
                ? void 0
                : t.hideBase) === !0);
    }
    set visible(t) {}
    get castShadow() {
      return this.object.castShadow;
    }
    set castShadow(t) {}
    get receiveShadow() {
      return this.object.receiveShadow;
    }
    set receiveShadow(t) {}
    get isMesh() {
      return CN(this.object);
    }
    get isLight() {
      return this.object.isLight;
    }
    get layers() {
      return this.object.layers;
    }
    set layers(t) {}
    get isCamera() {
      return !1;
    }
    get geometry() {
      if (this.object.geometry) return this.object.geometry;
    }
    get material() {
      if (this.object.material) return this.object.material;
    }
  },
  Os = new A(),
  Is = new A(),
  Ha = new ze(),
  L_ = [
    new A(-1, 1, 1),
    new A(-1, -1, 1),
    new A(1, -1, 1),
    new A(1, 1, 1),
    new A(-1, 1, -1),
    new A(-1, -1, -1),
    new A(1, -1, -1),
    new A(1, 1, -1),
  ],
  PN = [
    [0, 3],
    [1, 2],
    [5, 6],
    [4, 7],
    [0, 1],
    [3, 2],
    [7, 6],
    [4, 5],
    [0, 4],
    [1, 5],
    [2, 6],
    [3, 7],
  ],
  LN = [
    [0, 2],
    [7, 5],
    [4, 1],
    [3, 6],
    [4, 3],
    [1, 6],
  ],
  iv = (t, e, i) => {
    t.updateEntityBoxSize(Os, Is),
      Ha.copy(e).multiply(t.matrixWorld),
      Is.x === 0 && Is.y === 0 && Is.z === 0
        ? i.push(new A(Os.x, Os.y, Os.z).applyMatrix4(Ha))
        : L_.forEach((n) => {
            i.push(n.clone().multiply(Is).add(Os).applyMatrix4(Ha));
          });
  },
  nv = class extends An {
    constructor() {
      super(...arguments),
        (this.matrix = new ze()),
        (this.vertices = []),
        (this.faces = []),
        (this.edges = []),
        (this.centerEdges = []);
    }
    copy(t) {
      return (
        super.copy(t),
        this.matrix.copy(t.matrix),
        (this.vertices = t.vertices.map((e) => e.clone())),
        (this.faces = t.faces.map((e) => e.clone())),
        (this.edges = t.edges.map((e) => e.clone())),
        (this.centerEdges = t.centerEdges.map((e) => e.clone())),
        this
      );
    }
    setFromObjectSize(t, e = !1) {
      t.updateWorldMatrix(!1, e),
        this.makeEmpty(),
        this.matrix.copy(t.matrixWorld);
      let i = new ze().copy(t.matrixWorld).invert();
      return this.expandByObjectSize(t, i, e);
    }
    expandByObjectSize(t, e, i = !1) {
      let n = [];
      return (
        i === !0
          ? t.traverseEntity((r) => {
              if (r.visible || (r.cloner && r.data.visible)) {
                if (!("geometry" in r)) {
                  n.push(new A());
                  return;
                }
                iv(r, e, n);
              }
            })
          : iv(t, e, n),
        this.setFromPoints(n)
      );
    }
    getCenter(t) {
      return (t = super.getCenter(t)), t.applyMatrix4(this.matrix), t;
    }
    getPositionToCenter(t) {
      return (
        (t = super.getCenter(t)),
        t.applyMatrix4(Ha.copy(this.matrix).setPosition(0, 0, 0)),
        t
      );
    }
    computeVertices() {
      this.getSize(Is).multiplyScalar(0.5),
        this.getCenter(Os),
        Ha.copy(this.matrix).setPosition(Os),
        (this.vertices = L_.map((t) =>
          t.clone().multiply(Is).applyMatrix4(Ha)
        ));
    }
    computeEdges() {
      this.vertices.length > 0 && this.computeVertices(),
        (this.edges = PN.map(
          ([t, e]) => new jA(this.vertices[t], this.vertices[e])
        )),
        (this.centerEdges = this.edges.map((t) => t.getCenter(new A())));
    }
    computeFaces() {
      this.vertices.length > 0 && this.computeVertices(),
        (this.faces = LN.map(([t, e]) =>
          this.vertices[t].clone().add(this.vertices[e]).multiplyScalar(0.5)
        ));
    }
  },
  ts = {
    Cloner: () => {},
    changeEntityProptotype: () => {},
    createEntity: () => {},
  },
  DN = class extends _x {
    constructor() {
      super();
    }
    getPoints(t = 12) {
      let e = [],
        i,
        n = this.getCurveLengths(),
        r = n[n.length - 1] / n.length;
      for (let s = 0, a = this.curves; s < a.length; s++) {
        let o = a[s],
          l = s === 0 ? n[s] : n[s] - n[s - 1],
          c = Math.ceil((t * l) / r),
          d = o.getPoints(c);
        for (let h = 0; h < d.length; h++) {
          let u = d[h];
          (i && i.equals(u)) || (e.push(u), (i = u));
        }
      }
      return (
        this.autoClose &&
          e.length > 1 &&
          !e[e.length - 1].equals(e[0]) &&
          e.push(e[0]),
        e
      );
    }
  },
  lf = 0.001;
function cf(t, e, i) {
  return e.clone().sub(t).cross(e.clone().sub(i)).length() <= lf;
}
function ku(t, e) {
  let i = new A(...t.position),
    n = new A(...t.controlNext.position),
    r = new A(...e.controlPrevious.position),
    s = new A(...e.position);
  return cf(i, n, s) && cf(i, r, s);
}
function D_(t) {
  let e = t.points.map((d) => new A(...d.data.position)),
    i = [t.points[0]],
    n = new A(...i[0].data.position);
  for (let d = 0; d < t.points.length - 1; d++)
    cf(n, e[d], e[d + 1]) || (i.push(t.points[d]), (n = e[d]));
  i.push(t.points[t.points.length - 1]);
  let r = t.isClosed,
    s = i.length - (r ? 0 : 1),
    a = i.length,
    o = [];
  for (let d = 0; d < a; d++) {
    let h = i[d].data,
      u = new A(...h.position),
      f = new A(...h.controlPrevious.position),
      p = new A(...h.controlNext.position),
      v = {
        position: u,
        baseRoundness: h.roundness,
        controlPrevious: f,
        controlNext: p,
      };
    if (h.roundness === 0 || (!t.isClosed && (d === 0 || d === a - 1))) {
      o[d] = { ...v, removedLength: 0 };
      continue;
    }
    let g = r && d == 0 ? a - 1 : d - 1,
      m = r && d == a - 1 ? 0 : d + 1,
      x = i[g].data,
      y = i[m].data,
      _ = new A(...x.position),
      M = new A(...y.position),
      b = _.clone().sub(u).normalize(),
      E = M.clone().sub(u).normalize();
    Object.assign(v, { prevDir: b, nextDir: E });
    let T = ku(x, h),
      S = ku(h, y);
    if (!T || !S) o[d] = { ...v, removedLength: 0 };
    else {
      let w = b.clone().add(E).normalize(),
        C = w.clone().cross(b).length() / b.dot(w);
      o[d] = { ...v, tan: C, removedLength: h.roundness / C };
    }
  }
  for (let d = 0; d < s; d++) {
    let h = d,
      u = r && d === a - 1 ? 0 : d + 1,
      f = o[h],
      p = o[u];
    if (f.removedLength !== 0 || p.removedLength !== 0) {
      let v = f.position.distanceTo(p.position);
      (f.removedLength = Math.min(f.removedLength, v / 2)),
        (p.removedLength = Math.min(p.removedLength, v / 2));
    }
  }
  let l = [];
  for (let d = 0; d < s; d++) {
    let h = d,
      u = r && d === a - 1 ? 0 : d + 1,
      f = o[h],
      p = o[u],
      v = null;
    if (!ku(i[h].data, i[u].data))
      f.position.distanceTo(p.position) > lf &&
        (v = new Dc(f.position, f.controlNext, p.controlPrevious, p.position));
    else {
      let g = f.position.clone(),
        m = p.position.clone();
      (f.removedLength !== 0 || p.removedLength !== 0) &&
        (f.nextDir && g.add(f.nextDir.clone().setLength(f.removedLength)),
        p.prevDir && m.add(p.prevDir.clone().setLength(p.removedLength))),
        g.distanceTo(m) > lf &&
          (v = new Dc(g, g.clone().lerp(m, 0.3), m.clone().lerp(g, 0.3), m));
    }
    l[2 * d + 1] = v;
  }
  for (let d = 0; d < a; d++) {
    let h = o[d];
    if (h.removedLength === 0) {
      l[2 * d] = null;
      continue;
    }
    let u = h.position,
      f = h.prevDir.clone().multiplyScalar(h.removedLength).add(u),
      p = h.nextDir.clone().multiplyScalar(h.removedLength).add(u),
      v = h.tan * h.removedLength,
      g = h.prevDir.clone().add(h.nextDir).normalize(),
      m = f.clone().lerp(p, 0.5),
      x = f.distanceTo(p) / 2,
      y = g
        .clone()
        .multiplyScalar(Math.sqrt(Math.pow(v, 2) - Math.pow(x, 2)))
        .add(m),
      _ = g.clone().multiplyScalar(-v).add(y),
      M = u.distanceTo(_) / u.distanceTo(m),
      b = h.prevDir
        .clone()
        .multiplyScalar(M * u.distanceTo(f))
        .add(u),
      E = b.clone().lerp(_, 2),
      T = f.clone().lerp(b, 4 / 3),
      S = p.clone().lerp(E, 4 / 3);
    l[2 * d] = new Dc(f, T, S, p);
  }
  let c = new DN();
  return (
    l.forEach((d) => {
      d && c.add(d);
    }),
    c
  );
}
var Bt;
((t) => {
  function e(i) {
    return i && i.__isEntity;
  }
  t.is = e;
})(Bt || (Bt = {}));
var _a = (t) => Bt.is(t),
  RN = { type: "completeState", isfromEntity: !0 },
  Dp = (t) =>
    class extends Lp(t) {
      constructor() {
        super(...arguments),
          (this.raycastLock = !1),
          (this.scaleLock = !1),
          (this.disposed = !1),
          (this.stateSelection = null),
          (this.instances = []),
          (this.prevState = null),
          (this.currentState = null),
          (this.reversibleToState = null),
          (this.currentTransitionEvent = null),
          (this.previousAction = null),
          (this._singleBBox = new nv()),
          (this._recursiveBBox = new nv()),
          (this.singleBBoxNeedsUpdate = !0),
          (this.recursiveBBoxNeedsUpdate = !0),
          (this._needApplyPathSnapping = !0),
          (this.attachedPaths = new Set());
      }
      get __isEntity() {
        return !0;
      }
      entityChildren(e) {
        let i = this.children[e];
        if (Bt.is(i)) return i;
      }
      entityChildrenCount() {
        let e = this.children.length;
        for (; e--; ) if (Bt.is(this.children[e])) return e + 1;
        return 0;
      }
      get isConcreteEntity() {
        return typeof this.identity == "string";
      }
      get isVirtualEntity() {
        return typeof this.identity != "string";
      }
      get isInstanceRoot() {
        return this.isConcreteEntity && this.data.type === "Instance";
      }
      nearestInstanceSelfOrParent() {
        let e = this;
        for (; e.data.type !== "Instance"; ) {
          let i = e.parent;
          if (Bt.is(i)) e = i;
          else return;
        }
        return e;
      }
      forInstancesRec(e) {
        this.instances.forEach((i) => {
          i.disposed || e(i), i.forInstancesRec(e);
        });
      }
      super_Entity(e, i) {
        typeof e == "string" && (this.uuid = e),
          (this.identity = e),
          (this.data = i),
          (this.matrixAutoUpdate = !1),
          (this.dataPatched = this.data);
      }
      changeSelectedState(e, i, n = !1) {
        if (!(this.data.states.length === 0 && !n)) {
          for (let r of this.data.states)
            Oa.toOps(this.data, r.data).forEach((s) => {
              let a = Dd.replaceProps(s, this.data);
              (this.dataPatched = this.data),
                this.updateByPatchedOp(a, this.data, i);
            });
          if (e !== null) {
            let r = this.data.states.data(e);
            r &&
              ((this.dataPatched = Oa.patch(this.data, r)),
              Oa.toOps(this.data, r).forEach((s) => {
                this.updateByPatchedOp(s, this.dataPatched, i);
              }));
          }
          n && this.updateTransformState(this.dataPatched),
            (this.stateSelection = e),
            this.updatePathSnapping(this.dataPatched.pathSnapping);
        }
      }
      get singleBBox() {
        return (
          this.singleBBoxNeedsUpdate &&
            ((this.singleBBoxNeedsUpdate = !1),
            this._singleBBox.setFromObjectSize(this, !1),
            this._singleBBox.computeVertices(),
            this._singleBBox.computeEdges(),
            this._singleBBox.computeFaces()),
          this._singleBBox
        );
      }
      get recursiveBBox() {
        return (
          this.recursiveBBoxNeedsUpdate &&
            ((this.recursiveBBoxNeedsUpdate = !1),
            this._recursiveBBox.setFromObjectSize(this, !0),
            this._recursiveBBox.computeVertices(),
            this._recursiveBBox.computeEdges(),
            this._recursiveBBox.computeFaces()),
          this._recursiveBBox
        );
      }
      updateEntityBoxSize(e, i) {
        e.setScalar(0), i.setScalar(0);
      }
      resetBBoxNeedsUpdateSelf() {
        (this.singleBBoxNeedsUpdate = !0), (this.recursiveBBoxNeedsUpdate = !0);
      }
      resetBBoxNeedsUpdate() {
        this.resetBBoxNeedsUpdateSelf(),
          this.traverseAncestors((e) => {
            _a(e) && e.resetBBoxNeedsUpdateSelf();
          }),
          this.traverseEntity((e) => {
            e.resetBBoxNeedsUpdateSelf();
          });
      }
      find(e) {
        let i;
        return (
          this.traverseEntity((n) => {
            n.uuid === e && (i = n);
          }),
          i
        );
      }
      traverseSortNextHelper() {
        let e = this.parent;
        if (e) {
          let i = e.children,
            n = i.indexOf(this) + 1;
          if (Bt.is(i[n])) return i[n];
          if (Bt.is(e)) return e.traverseSortNextHelper();
        }
      }
      sortNext() {
        let e = this.children;
        return this.children.length > 0 && Bt.is(this.children[0])
          ? e[0]
          : this.traverseSortNextHelper();
      }
      goUp(e) {
        let i = this;
        for (; e > 0 && i !== null; ) (i = i.parent), (e -= 1);
        return i;
      }
      hasAnccestorOrSelf(e) {
        return this === e || this.hasAnccestor(e);
      }
      hasAnccestor(e) {
        let i = this.parent;
        for (; i; ) {
          if (e === i) return !0;
          i = i.parent;
        }
        return !1;
      }
      countToAccestor(e) {
        let i = 0,
          n = this;
        for (; n !== e; ) {
          if (n === null) return -1;
          (n = n.parent), (i += 1);
        }
        return i;
      }
      forEachEntity(e) {
        for (let i of this.children) _a(i) && e(i);
      }
      traverseEntityAncestors(e) {
        this.traverseAncestors((i) => {
          Bt.is(i) && e(i);
        });
      }
      traverseConcreteEntity(e, i = 0) {
        if (e(this, i) !== !0)
          for (let n of this.children)
            _a(n) && n.isConcreteEntity && n.traverseEntity(e, i + 1);
      }
      traverseEntity(e, i = 0) {
        if (e(this, i) !== !0)
          for (let n of this.children) _a(n) && n.traverseEntity(e, i + 1);
      }
      traverseVisibleEntity(e) {
        e(this);
        for (let i of this.children)
          _a(i) && i.visible && i.traverseVisibleEntity(e);
      }
      updateMatrix() {
        super.updateMatrix(),
          this.cloner && this.cloner.onObjUpdateMatrix(),
          this.dispatchEvent({ type: "updateMatrix" });
      }
      copy(e, i = !1) {
        return (
          super.copy(e, i),
          (this.dataPatched = e.dataPatched),
          (this.raycastLock = e.raycastLock),
          (this.scaleLock = e.scaleLock),
          this.hiddenMatrix.copy(e.hiddenMatrix),
          this
        );
      }
      hasEntityChild() {
        return this.children.some((e) => _a(e));
      }
      isAncestorOf(e) {
        if (this.uuid === e) return !1;
        let i = !1;
        return (
          this.traverseEntity((n) => {
            n.uuid === e && (i = !0);
          }),
          i
        );
      }
      toObjectTransformState(e = []) {
        this.updateWorldMatrix(!0, !1);
        let i = {
          position: this.position.toArray(),
          rotation: [this.rotation.x, this.rotation.y, this.rotation.z],
          scale: this.scale.toArray(),
          hiddenMatrix: this.hiddenMatrix.toArray(),
        };
        return Ld(i, e);
      }
      updateTransformState(e) {
        let i = !1;
        return (
          e.position && (this.position.fromArray(e.position), (i = !0)),
          e.rotation && (this.rotation.fromArray(e.rotation), (i = !0)),
          e.scale && ((i = !0), this.scale.fromArray(e.scale)),
          e.hiddenMatrix !== void 0 &&
            ((i = !0),
            this.hiddenMatrix.fromArray(e.hiddenMatrix ?? eo.identity)),
          i &&
            (this.updateMatrix(),
            this.resetBBoxNeedsUpdate(),
            this.invalidateClonerTransform(this),
            this.traverseEntityAncestors((n) => {
              n.invalidateClonerTransform(this);
            })),
          e.position &&
            e.rotation &&
            e.scale &&
            e.hiddenMatrix !== void 0 &&
            this.updateWorldMatrix(!1, !0),
          i
        );
      }
      dispose() {
        (this.disposed = !0),
          this.cloner &&
            (this.cloner.removeFromParent(), (this.cloner = void 0));
      }
      disposeChildrenRecursively() {
        for (let e of this.children) Bt.is(e) && e.disposeRecursively();
      }
      disposeRecursively() {
        this.dispose(),
          this.children.forEach((e) => {
            Bt.is(e) && e.disposeRecursively();
          });
      }
      toState(e = []) {
        let i = {
          name: this.name,
          visible: this.visible,
          raycastLock: this.raycastLock,
          ...this.toObjectTransformState(e),
        };
        return Ld(i, e);
      }
      updateByObjUpdateOp(e, i) {
        e !== void 0 &&
          this.updateByOp(
            { type: 0, props: e, path: [] },
            { ...this.data, ...e },
            i,
            !1
          );
      }
      updateByOp(e, i, n, r) {
        let s = this.data;
        this.data = i;
        let a = e,
          o = Sn(e.path, ["states", "*"]);
        if (o !== null) {
          if (e.type === 0) {
            let [l] = o;
            if ((this == null ? void 0 : this.stateSelection) === l) {
              let c = { ...e.props };
              if (
                (delete c.name,
                Object.values(e.props).some((d) => d === void 0))
              ) {
                let d = this.data;
                if (d !== void 0) {
                  let h = hr.zoom(d, e.path.slice(2));
                  if (h)
                    for (let u in e.props)
                      e.props[u] === void 0 && u in h && (c[u] = h[u]);
                }
              }
              a = { ...e, props: c, path: e.path.slice(2) };
            }
          }
        } else if (e.type === 0) {
          let l = this.stateSelection
            ? this.data.states.data(this.stateSelection)
            : void 0;
          if (l !== void 0) {
            if (e.props.name !== void 0 && l.name) {
              let { name: d, ...h } = l;
              l = h;
            }
            if (e.props.material !== void 0 && "material" in l) {
              let { material: d, ...h } = l;
              l = h;
            }
            let c = hr.removeOverridden(e.path, e.props, l);
            a = { ...e, props: c };
          }
        }
        if (
          (this.updateByPatchedOpBase(
            a,
            Oa.patch(
              this.data,
              this.stateSelection
                ? this.data.states.data(this.stateSelection)
                : void 0
            ),
            n
          ),
          Sn(e.path, ["overrides"]))
        ) {
          let l = [],
            c = [...e.path];
          for (
            l.push(c[1]), c.splice(0, 2);
            c.length > 0 && c[0] === "descendants";

          )
            l.push(c[1]), c.splice(0, 2);
          if (l[l.length - 1] === void 0) {
            if (e.type === 0)
              for (let d of Object.keys(e.props)) {
                l[l.length - 1] = d;
                let h = n.scene.findInstance([this.uuid, ...l]);
                h &&
                  ((h.overrideData = e.props[d]),
                  h.updateState(ls.apply(h.component.data, h.overrideData), n));
              }
          } else {
            let d = n.scene.findInstance([this.uuid, ...l]);
            if (d) {
              let h = hr.zoom(d.component.data, c);
              if (((e = { ...e, path: c }), e.type === 0)) {
                let u = e.props;
                if (h)
                  for (let [f, p] of Object.entries(e.props))
                    p === void 0 &&
                      (u === e.props && (u = { ...e.props }), (u[f] = h[f]));
                e = { ...e, props: u };
              }
              (d.overrideData = oh.resolve(i.overrides, l)),
                d.updateByOp(e, dn.applySimple(d.data, e), n, !1);
            }
          }
        } else if (this.instances.length > 0) {
          let l;
          if (e.path.length === 0 && e.type === 0) {
            let c;
            for (let d of es.rootOverrideProps)
              d in e.props && (c === void 0 && (c = {}), (c[d] = e.props[d]));
            c && (l = { ...e, props: c });
          } else
            for (let c of es.rootOverrideProps)
              if (Sn(e.path, [c])) {
                l = e;
                break;
              }
          l !== void 0 &&
            this.instances.forEach((c) => {
              if (c.isInstanceRoot) {
                let d = ls.filterOp(c.overrideData, l);
                d && c.updateByOp(d, dn.applySimple(c.data, d), n, !0);
              }
            }),
            this.instances.forEach((c) => {
              if (!c.isInstanceRoot) {
                let d = ls.filterOp(c.overrideData, e);
                if (d) {
                  let h;
                  s === c.data && e === d
                    ? (h = i)
                    : (h = dn.applySimple(c.data, d)),
                    c.updateByOp(d, h, n, !0);
                }
              }
            });
        }
      }
      updateByPatchedOpBase(e, i, n) {
        if (((this.dataPatched = i), e.path.length === 0 && e.type === 0))
          e.props.type !== void 0 &&
            !$s.is(e.props.type) &&
            ts.changeEntityProptotype(this, i, n);
        else if (
          e.path.length === 1 &&
          e.path[0] === "geometry" &&
          e.type === 0 &&
          "type" in e.props
        ) {
          ts.changeEntityProptotype(this, i, n);
          for (let r of this.children) Bt.is(r) && r.updateVisible();
        }
        this.updateByPatchedOp(e, i, n);
      }
      updateByPatchedOp(e, i, n) {
        if (
          (e.path.length === 0 && e.type === 0 && this.updateState(e.props, n),
          Sn(e.path, ["pathSnapping"]) !== null &&
            this.updatePathSnapping(i.pathSnapping),
          Sn(e.path, ["cloner"]) !== null)
        ) {
          let r = dn.drop(e, 1);
          r.path.length === 0 && r.type === 0 && r.props.disabled === !0
            ? this.setFromClonerState(null, n)
            : this.cloner
            ? this.cloner.updateState(i.cloner, n.scene)
            : (this.setFromClonerState(i.cloner, n),
              this.expandCloner(n.scene)),
            this.updateVisible();
        }
      }
      updatePathSnapping(e) {
        (this._updatedPathSnapping = e), (this._needApplyPathSnapping = !0);
      }
      get updatedPathSnapping() {
        return this._updatedPathSnapping;
      }
      applyPathSnapping(e) {
        var p, v, g, m, x;
        let i =
            ((p = this._updatedPathSnapping) == null ? void 0 : p.pathId) ??
            this.dataPatched.pathSnapping.pathId,
          n =
            ((v = this._updatedPathSnapping) == null ? void 0 : v.slide) ??
            this.dataPatched.pathSnapping.slide ??
            0,
          r =
            ((g = this._updatedPathSnapping) == null ? void 0 : g.offset) ??
            this.dataPatched.pathSnapping.offset,
          s =
            ((m = this._updatedPathSnapping) == null
              ? void 0
              : m.orientation) ?? this.dataPatched.pathSnapping.orientation;
        if (i === null) return;
        let a = e.find(i);
        if (!a || this._needApplyPathSnapping === !1) return;
        this._needApplyPathSnapping = !1;
        let o = a.data;
        if (o.geometry.path.points.length <= 1) return;
        let l = D_(o.geometry.path),
          c = (n + r) % 1;
        n + r === 1 && c === 0 && (c = 1);
        let d = l.getPointAt(c),
          h = this.parent
            ? (x = this.parent) == null
              ? void 0
              : x.matrixWorld
            : new ze();
        a.updateMatrixWorld();
        let u = new ze().multiplyMatrices(h.clone().invert(), a.matrixWorld);
        d.applyMatrix4(u);
        let f = { position: d.toArray(), rotation: o.rotation };
        if (s === "tangential") {
          let y = new ze().extractRotation(a.matrixWorld),
            _ = l.getTangentAt(c).applyMatrix4(y).add(d),
            M = new ze().lookAt(d, _, new A(0, 1, 0)),
            b = new as().setFromRotationMatrix(M);
          f = { ...f, rotation: [b.x, b.y, b.z] };
        }
        this.updateTransformState(f),
          this.traverseEntity((y) => {
            y._cameraType && y.dispatchEvent(RN);
          });
      }
      updateVisible() {
        var e;
        this.visible =
          this.dataPatched.visible &&
          (!this.dataPatched.cloner ||
            (this.dataPatched.cloner.disabled ?? !1) ||
            ((e = this.dataPatched.cloner) == null ? void 0 : e.hideBase) !==
              !0);
      }
      updateState_Entity(e, i) {
        e.name !== void 0 && (this.name = e.name),
          e.raycastLock !== void 0 && (this.raycastLock = e.raycastLock),
          e.visible !== void 0 &&
            (this.updateVisible(), this.resetBBoxNeedsUpdate()),
          i &&
            "cloner" in e &&
            e.cloner !== void 0 &&
            (this.setFromClonerState(e.cloner, i), this.updateVisible()),
          this.updateTransformState(e);
      }
      get attachedSurfaceCloners() {
        return this.children.filter(
          (e) => e instanceof ts.Cloner && e.parameters.type === "toObject"
        );
      }
      setFromClonerState(e, i) {
        this.disposed ||
          (e === null || e.disabled
            ? (this.cloner && this.cloner.removeFromParent(),
              (this.cloner = void 0))
            : this.cloner === void 0
            ? ((this.cloner = new ts.Cloner(this, e)),
              i.scene.addPendingExpandCloner(this))
            : this.cloner.updateState(e, i.scene));
      }
      expandCloner(e) {
        !this.disposed && this.cloner && this.cloner.expandClones(e);
      }
      invalidateClonerTransform(e) {
        this.cloner && this.cloner.invalidateTransform(e);
      }
    },
  ON = class {
    static create(t) {
      return this.build(this.normalizeInputs(t));
    }
    static normalizeInputs(t, e) {
      let i = Object.assign(
          {},
          (e == null ? void 0 : e.parameters) ?? {
            width: 100,
            radialSegments: 64,
            heightSegments: 1,
            openEnded: !1,
            thetaStart: 0,
            thetaLength: 360,
            cornerRadius: 8,
            cornerSegments: 8,
            hollow: 0,
          },
          t.parameters
        ),
        n = i.width / 2,
        r = i.radiusTop ?? n,
        s = i.radiusBottom ?? n;
      return (
        r === s
          ? ((r = n), (s = n))
          : r > s
          ? ((r = n), (s = (s * n) / r))
          : ((r = (r * n) / s), (s = n)),
        {
          parameters: Object.assign(i, {
            width: Math.abs(i.width),
            height: Math.abs(i.height ?? i.width),
            depth: Math.abs(i.depth ?? i.width),
            radiusTop: r,
            radiusBottom: s,
          }),
        }
      );
    }
    static build(t) {
      let {
          width: e,
          depth: i,
          height: n,
          radialSegments: r,
          heightSegments: s,
          openEnded: a,
          thetaStart: o,
          thetaLength: l,
          radiusTop: c,
          radiusBottom: d,
          cornerRadius: h,
          cornerSegments: u,
          hollow: f,
        } = t.parameters,
        p;
      return (
        h || f
          ? (p = new R_(c, d, n, r, s, a, o, (l * Math.PI) / 180, h, h, u, f))
          : (p = new Mh(c, d, n, r, s, a, o, (l * Math.PI) / 180)),
        p.scale(1, 1, i / e),
        Object.assign(p, { userData: { ...t, type: "CylinderGeometry" } })
      );
    }
  };
function jr(t, e, i) {
  (i.x = t.x * e.x), (i.y = t.y), (i.z = t.x * e.y);
}
function rv(t) {
  return new J(t.y, -t.x);
}
var R_ = class extends st {
    constructor(t, e, i, n, r, s, a, o, l, c, d, h, u = !1) {
      super(),
        (this.type = "RoundedCylinderBufferGeometry"),
        (t = t !== void 0 ? t : 1),
        (e = e !== void 0 ? e : 1),
        (i = i || 1),
        (n = Math.floor(n) || 8),
        (r = Math.floor(r) || 1),
        (s = s !== void 0 ? s : !1),
        (a = a !== void 0 ? a : 0),
        (o = o !== void 0 ? o : Math.PI * 2),
        s && ((l = 0), (c = 0));
      let f = [],
        p = [],
        v = [],
        g = [],
        m = 0,
        x = i / 2,
        y = new A(),
        _ = new A();
      u && t == 0 && (t = l), u && e == 0 && (e = c);
      let M = new J(t, x),
        b = new J(e, -x),
        E = null,
        T = null,
        S = null,
        w = null,
        C = M.clone().sub(b),
        L = 0,
        P = 0,
        R = 0;
      h > 0 && ((L = Math.min(t, e) * (1 - h)), (P = t - L), (R = e - L));
      let I = M.clone();
      I.x -= L;
      let W = Math.PI - C.angle(),
        N = C.angle(),
        U = Math.tan(N / 2),
        G = Math.tan(W / 2),
        k = U + G,
        B = h ? k : G,
        V = h ? k : U;
      if (
        ((l = Math.min(l, (t - P) / B, C.length() / k)),
        (c = Math.min(c, (e - R) / V, C.length() / k)),
        l > 0)
      ) {
        let Z = l / U;
        (E = M.clone().sub(new J(Z, l))),
          h && ((S = E.clone()), (S.x -= L - k * l)),
          M.sub(C.clone().setLength(Z));
      }
      if (c > 0) {
        let Z = c / G;
        (T = b.clone().sub(new J(Z, -c))),
          b.add(C.clone().setLength(Z)),
          h &&
            ((w = T.clone()),
            (w.x -= L - k * c),
            I.sub(C.clone().setLength(Z)));
      }
      C = M.clone().sub(b);
      let X = C.length() < 0.5,
        H = [];
      for (let Z = 0; Z <= n; Z++) {
        let K = [],
          me = Z / n,
          re = me * o + a,
          F = new J(Math.sin(re), Math.cos(re));
        w && T
          ? (j(K, me, F, W, c, w, -1, !0), j(K, me, F, N, c, T, -1, !1))
          : T
          ? (Y(K, F, T.x, 0, -1), j(K, me, F, N, c, T, -1, !1))
          : s || Y(K, F, e, R, -1);
        let Te = rv(C).normalize();
        if ((jr(Te, F, y), !X))
          for (let be = 0; be <= r; be++) {
            let oe = be / r,
              Me = C.clone().multiplyScalar(oe).add(b);
            jr(Me, F, _),
              p.push(_.x, _.y, _.z),
              v.push(y.x, y.y, y.z),
              g.push(me, 0.5 + _.y / i),
              K.push(m++);
          }
        if (
          (S && E
            ? (j(K, me, F, W, l, E, 1, !1), j(K, me, F, N, l, S, 1, !0))
            : E
            ? (j(K, me, F, W, l, E, 1, !1), Y(K, F, E.x, 0, 1))
            : s || Y(K, F, t, P, 1),
          h && !X)
        ) {
          let be = rv(C).multiplyScalar(-1).normalize();
          jr(be, F, y);
          for (let oe = 0; oe <= r; oe++) {
            let Me = oe / r,
              Ae = C.clone().multiplyScalar(-Me).add(I);
            jr(Ae, F, _),
              p.push(_.x, _.y, _.z),
              v.push(y.x, y.y, y.z),
              g.push(me, 0.5 + _.y / i),
              K.push(m++);
          }
        }
        h && !s && K.push(K[0]), H.push(K);
      }
      for (let Z = 0; Z < H.length - 1; Z++)
        for (let K = 0; K < H[0].length - 1; K++) {
          if (s && h && K == r) continue;
          let me = H[Z][K],
            re = H[Z + 1][K],
            F = H[Z + 1][K + 1],
            Te = H[Z][K + 1],
            be = p[F * 3 + 0],
            oe = p[F * 3 + 2];
          f.push(me, re, Te), (be != 0 || oe != 0) && f.push(re, F, Te);
        }
      o < Math.PI * 2 && (ee(-1, H[0], a), ee(1, H[H.length - 1], a + o)),
        this.setIndex(f),
        this.setAttribute("position", new We(p, 3)),
        this.setAttribute("normal", new We(v, 3)),
        this.setAttribute("uv", new We(g, 2));
      function j(Z, K, me, re, F, Te, be, oe) {
        for (let Me = 0; Me < d + 1; Me++) {
          let Ae = Me / d,
            ye = be < 0 ? Ae : 1 - Ae;
          oe && (ye -= 1), (ye *= re);
          let _e = new J(Math.sin(ye), Math.cos(ye) * be),
            Ee = _e.clone().multiplyScalar(F).add(Te);
          jr(Ee, me, _),
            p.push(_.x, _.y, _.z),
            jr(_e, me, y),
            v.push(y.x, y.y, y.z),
            g.push(K, 0.5 + _.y / i),
            Z.push(m++);
        }
      }
      function Y(Z, K, me, re, F) {
        let Te = new A(),
          be = new J(),
          oe = [me, re];
        F < 0 && oe.reverse();
        for (let Me of oe)
          be.set(Me, x * F),
            jr(be, K, Te),
            p.push(Te.x, Te.y, Te.z),
            v.push(0, F, 0),
            g.push(0.5, 0.5),
            Z.push(m++);
      }
      function ee(Z, K, me) {
        let re = new J(Math.sin(me), Math.cos(me)),
          F = new J(-Math.cos(me), Math.sin(me)),
          Te = new A(),
          be =
            Z < 0
              ? (Ae, ye, _e) => f.push(Ae, ye, _e)
              : (Ae, ye, _e) => f.push(Ae, _e, ye),
          oe = new J((t + e + P + R) / 4, 0);
        jr(oe, re, Te),
          p.push(Te.x, Te.y, Te.z),
          v.push(F.x, 0, F.y),
          g.push(0.5, 0.5);
        let Me = m++;
        for (let Ae of K) {
          let ye = p.slice(Ae * 3, Ae * 3 + 3);
          p.push(...ye), v.push(F.x, 0, F.y);
          let _e = g.slice(Ae * 2, Ae * 2 + 2);
          g.push(..._e), m++;
        }
        for (let Ae = Me + 1; Ae < m - 1; Ae++) be(Me, Ae, Ae + 1);
        be(Me, m - 1, Me + 1);
      }
    }
  },
  IN = class {
    static create(t) {
      return this.build(this.normalizeInputs(t));
    }
    static normalizeInputs(t, e) {
      let i = Object.assign(
        {},
        (e == null ? void 0 : e.parameters) ?? {
          width: 100,
          radialSegments: 32,
          heightSegments: 8,
          openEnded: !1,
          thetaStart: 0,
          thetaLength: 360,
          cornerRadiusTop: 8,
          cornerRadiusBottom: 8,
          cornerSegments: 8,
        },
        t.parameters
      );
      return {
        parameters: Object.assign(i, {
          width: Math.abs(i.width),
          height: Math.abs(i.height ?? i.width),
          depth: Math.abs(i.depth ?? i.width),
        }),
      };
    }
    static build(t) {
      let {
          width: e,
          depth: i,
          height: n,
          radialSegments: r,
          heightSegments: s,
          openEnded: a,
          thetaStart: o,
          thetaLength: l,
          cornerRadiusTop: c,
          cornerRadiusBottom: d,
          cornerSegments: h,
        } = t.parameters,
        u;
      return (
        c > 0 || d > 0 || l < 360
          ? (u = new R_(
              0,
              e / 2,
              n,
              r,
              s,
              a,
              o,
              (l * Math.PI) / 180,
              c,
              d,
              h,
              0,
              !0
            ))
          : (u = new Zf(e / 2, n, r, s, a)),
        u.scale(1, 1, i / e),
        Object.assign(u, { userData: { ...t, type: "ConeGeometry" } })
      );
    }
  },
  UN = class {
    static create(t) {
      return this.build(this.normalizeInputs(t));
    }
    static normalizeInputs(t, e) {
      let i = Object.assign(
        {},
        (e == null ? void 0 : e.parameters) ?? {
          width: 100,
          widthSegments: 1,
          heightSegments: 1,
          depthSegments: 1,
          cornerRadius: 8,
          cornerSegments: 8,
        },
        t.parameters
      );
      return {
        parameters: Object.assign(i, {
          width: Math.abs(i.width),
          height: Math.abs(i.height ?? i.width),
          depth: Math.abs(i.depth ?? i.width),
        }),
      };
    }
    static build(t) {
      let {
          width: e,
          height: i,
          depth: n,
          widthSegments: r,
          heightSegments: s,
          depthSegments: a,
          cornerRadius: o,
          cornerSegments: l,
        } = t.parameters,
        c;
      return (
        o == 0
          ? (c = new $n(e, i, n, r, s, a))
          : (c = new NN(e, i, n, r, s, a, o, l)),
        Object.assign(c, { userData: { ...t, type: "CubeGeometry" } })
      );
    }
  },
  Vu = Math.PI / 2,
  NN = class extends st {
    constructor(t = 1, e = 1, i = 1, n = 1, r = 1, s = 1, a = 0, o = 4) {
      super(), (this.type = "BoxGeometry");
      let l = this;
      (n = Math.floor(n)),
        (r = Math.floor(r)),
        (s = Math.floor(s)),
        (o = Math.floor(o)),
        (a = Math.min(a, t / 2, e / 2, i / 2));
      let c = [],
        d = [],
        h = [],
        u = [],
        f = 0,
        p = 0;
      v("z", "y", "x", -1, -1, i, e, t, s, r, 0),
        v("z", "y", "x", 1, -1, i, e, -t, s, r, 1),
        v("x", "z", "y", 1, 1, t, i, e, n, s, 2),
        v("x", "z", "y", 1, -1, t, i, -e, n, s, 3),
        v("x", "y", "z", 1, -1, t, e, i, n, r, 4),
        v("x", "y", "z", -1, -1, t, e, -i, n, r, 5),
        a > 0 &&
          (g("z", "y", "x", -1, -1, 1, i, e, t, s, 0),
          g("z", "y", "x", 1, -1, -1, i, e, t, s, 1),
          g("z", "y", "x", -1, 1, -1, i, e, t, s, 1),
          g("z", "y", "x", 1, 1, 1, i, e, t, s, 0),
          g("x", "y", "z", -1, -1, -1, t, e, i, n, 0),
          g("x", "y", "z", 1, -1, 1, t, e, i, n, 1),
          g("x", "y", "z", -1, 1, 1, t, e, i, n, 0),
          g("x", "y", "z", 1, 1, -1, t, e, i, n, 1),
          g("y", "x", "z", -1, -1, 1, e, t, i, r, 0),
          g("y", "x", "z", 1, -1, -1, e, t, i, r, 1),
          g("y", "x", "z", 1, 1, 1, e, t, i, r, 1),
          g("y", "x", "z", -1, 1, -1, e, t, i, r, 0),
          m(1, 1, 1),
          m(-1, 1, 1),
          m(1, -1, 1),
          m(-1, -1, 1),
          m(1, 1, -1),
          m(-1, 1, -1),
          m(1, -1, -1),
          m(-1, -1, -1)),
        this.setIndex(c),
        this.setAttribute("position", new We(d, 3)),
        this.setAttribute("normal", new We(h, 3)),
        this.setAttribute("uv", new We(u, 2));
      function v(x, y, _, M, b, E, T, S, w, C, L) {
        let P = (E - 2 * a) / w,
          R = (T - 2 * a) / C,
          I = E / 2 - a,
          W = T / 2 - a,
          N = S / 2,
          U = w + 1,
          G = C + 1,
          k = 0,
          B = 0,
          V = new A();
        for (let X = 0; X < G; X++) {
          let H = X * R - W;
          for (let j = 0; j < U; j++) {
            let Y = j * P - I;
            (V[x] = Y * M),
              (V[y] = H * b),
              (V[_] = N),
              d.push(V.x, V.y, V.z),
              (V[x] = 0),
              (V[y] = 0),
              (V[_] = S > 0 ? 1 : -1),
              h.push(V.x, V.y, V.z),
              u.push(j / w),
              u.push(1 - X / C),
              (k += 1);
          }
        }
        for (let X = 0; X < C; X++)
          for (let H = 0; H < w; H++) {
            let j = f + H + U * X,
              Y = f + H + U * (X + 1),
              ee = f + (H + 1) + U * (X + 1),
              Z = f + (H + 1) + U * X;
            c.push(j, Y, Z), c.push(Y, ee, Z), (B += 6);
          }
        l.addGroup(p, B, L), (p += B), (f += k);
      }
      function g(x, y, _, M, b, E, T, S, w, C, L) {
        let P = (T - 2 * a) / C,
          R = T / 2 - a,
          I = S / 2 - a,
          W = w / 2,
          N = C + 1,
          U = 0,
          G = 0,
          k = new A(),
          B = new A();
        for (let V = 0; V < o + 1; V++) {
          let X = (V / o) * Vu,
            H = Math.sin(X) * a,
            j = (1 - Math.cos(X)) * a,
            Y = Math.sin(X),
            ee = Math.cos(X);
          (k[y] = (I + H) * b),
            (k[_] = (W - j) * E),
            (B[x] = 0),
            (B[y] = Y * Math.sign(k[y])),
            (B[_] = ee * Math.sign(k[_]));
          for (let Z = 0; Z < N; Z++) {
            let K = Z * P - R;
            (k[x] = K * M),
              d.push(k.x, k.y, k.z),
              h.push(B.x, B.y, B.z),
              u.push(Z / C),
              u.push(0),
              (U += 1);
          }
        }
        for (let V = 0; V < o; V++)
          for (let X = 0; X < C; X++) {
            let H = f + X + N * V,
              j = f + X + N * (V + 1),
              Y = f + (X + 1) + N * (V + 1),
              ee = f + (X + 1) + N * V;
            c.push(H, j, ee), c.push(j, Y, ee), (G += 6);
          }
        l.addGroup(p, G, L), (p += G), (f += U);
      }
      function m(x, y, _) {
        let M = new A(),
          b = new A(t / 2, e / 2, i / 2);
        b.subScalar(a);
        let E = [],
          T =
            x * y * _ > 0
              ? (w, C, L) => c.push(w, C, L)
              : (w, C, L) => c.push(w, L, C);
        for (let w = 0; w <= o; w++) {
          let C = [],
            L = Vu * (1 - w / o),
            P = Math.cos(L),
            R = Math.sin(L),
            I = 0;
          for (let W = 0; W <= w; W++) {
            let N = Math.cos(I),
              U = Math.sin(I);
            (M.x = P * N), (M.y = R), (M.z = P * U);
            let G = b.clone().addScaledVector(M, a);
            d.push(x * G.x, y * G.y, _ * G.z),
              h.push(x * M.x, y * M.y, _ * M.z),
              u.push(0, 0),
              C.push(f++),
              (I += Vu / w);
          }
          E.push(C);
        }
        let S = E.length - 1;
        for (let w = 0; w < S; w++) {
          let C = E[w],
            L = E[w + 1],
            P = C.length - 1;
          T(C[0], L[1], L[0]);
          for (let R = 1; R <= P; R++)
            T(C[R - 1], C[R], L[R]), T(C[R], L[R + 1], L[R]);
        }
      }
    }
  },
  Rp = class extends st {
    constructor(t = [], e = [], i = "", n = 1, r = 0.2, s = 4) {
      super(), (this.type = "PolyhedronGeometryRound");
      let a = [],
        o = [],
        l = [];
      c(),
        d(),
        this.setAttribute("position", new We(a, 3)),
        this.setAttribute("normal", new We(l, 3)),
        this.setAttribute("uv", new We(o, 2));
      return;
      function c() {
        var N;
        (r = Math.min(1 - 1e-5, r)), r == 0 && (s = 0);
        let h = {
            IcosahedronGeometry: 5,
            DodecahedronGeometry: 3,
            HexahedronGeometry: 3,
            OctahedronGeometry: 4,
            TetrahedronGeometry: 3,
          }[i],
          u = new A(),
          f = u.clone(),
          p = new Ki(),
          v = r * n,
          g = n - v,
          m = s + 1,
          x = new A(),
          y = (U, G) => x.subVectors(U, G).normalize(),
          _ = (U, G) =>
            Array(U)
              .fill(void 0)
              .map(G),
          M = _(t.length / 3, (U, G) =>
            new A().fromArray(t, G * 3).setLength(n)
          ),
          b = [],
          E = 1e6;
        for (let U = 0; U < M.length; U++) {
          let G = M[U],
            k = [],
            B,
            V,
            X,
            H = 1e10,
            j = -1;
          for (; (j = e.indexOf(U, j + 1)) != -1; ) {
            let K = j - (j % 3);
            (B = e[K + ((j + 1) % 3)]),
              (V = e[K + ((j + 2) % 3)]),
              (X = G.distanceToSquared(M[B])),
              (H = Math.min(H, X)),
              k.push([B, V, X]);
          }
          H += 1e-6;
          let Y = [],
            ee = 0,
            Z = k.length;
          for (let K = 0; K < Z; K++) {
            [B, V, X] = k[ee];
            let me = ((N = b[B]) == null ? void 0 : N.includes(U)) == !0;
            X <= H && Y.push(B + +me * E),
              (ee = k.findIndex((re) => re[0] == V));
          }
          b.push(Y);
        }
        let T = [];
        {
          let U = 0,
            G = 0,
            k,
            B,
            V = h == 3;
          for (let X = 0; X <= s; X++) {
            (k = (X * (X + 1)) / 2), (B = ((X + 1) * (X + 2)) / 2);
            for (let H = 0; H < s - X; H++)
              ([U, G] = [k + H + X + 2, B + H + X + 3]),
                T.push(k, B, ...(V ? [G, k] : [U, B]), G, U),
                ([k, B] = [U, G]);
            T.push(k, B, k + s + 2);
          }
        }
        let S = u.clone(),
          w = u.clone(),
          C = u.clone(),
          L = u.clone(),
          P = u.clone(),
          R = [],
          I = _(M.length, () => _(h, () => u.clone()));
        for (let U = 0; U < M.length; U++) {
          u.copy(M[U]).normalize(), S.copy(u).multiplyScalar(g);
          let G = b[U];
          for (let Y = 0; Y < G.length; Y++) {
            let ee = G[Y],
              Z = G[(Y + 1) % h];
            p.setFromPointsAndIndices(M, U, ee % E, Z % E),
              p.b.sub(p.a).setLength(1e10).add(p.a),
              p.c.sub(p.a).setLength(1e10).add(p.a),
              p.closestPointToPoint(S, I[U][Y]);
          }
          let k = [],
            B = [],
            V = [],
            X = new A();
          s == 0 &&
            [...I[U]].reduce((Y, ee) => Y.add(ee), X).multiplyScalar(1 / h);
          for (let Y = 0; Y < h; Y++) {
            let ee = [],
              Z = (Y - 1 + h) % h,
              K = I[U][Z],
              me = I[U][Y];
            u.copy(K).sub(S), f.copy(me).sub(S);
            let re = S.angleTo(u),
              F = u.angleTo(f),
              Te = Math.cos(re) * v;
            s == 0 ? w.copy(X) : w.copy(S).setLength(g + Te), B.push(Te);
            let be = [w, K, me];
            for (let oe = 0; oe < 2; oe++) {
              let Me = be[oe],
                Ae = be[oe + 1];
              L.subVectors(Me, S),
                P.subVectors(Ae, S),
                C.crossVectors(L, P).normalize();
              for (let ye = 0; ye < m; ye++) {
                let _e = ([re, F][oe] * ye) / m;
                u.copy(L).applyAxisAngle(C, _e).add(S),
                  k.push(u.clone()),
                  oe &&
                    (y(u, S), ee.push([ye == 0 ? Me : u.clone(), x.clone()]));
              }
              oe && (y(Ae, S), ee.push([Ae, x.clone()]));
            }
            V.push(ee);
          }
          R.push(V);
          let H = 2 * m,
            j = 2;
          for (let Y = 0; Y < h; Y++) {
            let ee = H * Y,
              Z = H * ((Y + 1) % h),
              K = [k[ee]];
            for (let re = 1; re < m; re++) {
              (L = k[ee + re]), (P = k[Z + re]), K.push(L);
              for (let F = 1, Te = re - j + 1; F <= Te; F++)
                u.lerpVectors(L, P, F / (Te + 1)),
                  u.sub(S).setLength(B[Y]).add(S),
                  K.push(u.clone());
              K.push(P);
            }
            for (let re = 0; re < m; re++) K.push(k[re + m + ee]);
            K.push(k[Z + m]);
            let me = T.map((re) => K[re]);
            a.push(...me.map((re) => [re.x, re.y, re.z]).flat()),
              l.push(...me.map((re) => (y(re, S), [x.x, x.y, x.z])).flat());
          }
        }
        let W = [];
        for (let U = 0; U < b.length; U++)
          for (let G = 0; G < h; G++) {
            let k = b[U][G];
            if (k < E) {
              let B = b[k].findIndex((H) => H % E == U),
                V = R[U][G],
                X = R[k][B];
              for (let H = 0; H < m; H++) {
                let j = V[H],
                  Y = X[m - H],
                  ee = V[H + 1],
                  Z = X[m - (H + 1)];
                [j, Y, ee, ee, Y, Z].forEach((K) => {
                  a.push(K[0].x, K[0].y, K[0].z),
                    l.push(K[1].x, K[1].y, K[1].z);
                });
              }
              W.push(V[0][0], X[m][0], V[m][0], X[0][0]);
            }
          }
        for (; W.length; ) {
          let U, G, k, B;
          [U, G] = W.splice(0, 2);
          let V = [U];
          for (; U != G; )
            V.push(G),
              (k = W.indexOf(G)),
              (B = k % 2),
              (G = W.splice(k - B, 2)[1 - B]);
          x.subVectors(V[0], V[1]).cross(u.subVectors(V[0], V[2])).normalize();
          let X = x.dot(V[0]) < 0;
          X && x.negate();
          for (let H = 1; H <= V.length - 2; H++)
            [V[H + +X], V[H + 1 - +X], V[0]].forEach((j) => {
              a.push(j.x, j.y, j.z), l.push(x.x, x.y, x.z);
            });
        }
      }
      function d() {
        let h = new A();
        for (let b = 0; b < a.length; b += 3) {
          (h.x = a[b + 0]), (h.y = a[b + 1]), (h.z = a[b + 2]);
          let E = _(h) / 2 / Math.PI + 0.5,
            T = M(h) / Math.PI + 0.5;
          o.push(E, 1 - T);
        }
        let u = new A(),
          f = new A(),
          p = new A(),
          v = new A(),
          g = new J(),
          m = new J(),
          x = new J(),
          y = (b, E, T, S) => {
            S < 0 && b.x === 1 && (o[E] = b.x - 1),
              T.x === 0 && T.z === 0 && (o[E] = S / 2 / Math.PI + 0.5);
          };
        for (let b = 0, E = 0; b < a.length; b += 9, E += 6) {
          u.set(a[b + 0], a[b + 1], a[b + 2]),
            f.set(a[b + 3], a[b + 4], a[b + 5]),
            p.set(a[b + 6], a[b + 7], a[b + 8]),
            g.set(o[E + 0], o[E + 1]),
            m.set(o[E + 2], o[E + 3]),
            x.set(o[E + 4], o[E + 5]),
            v.copy(u).add(f).add(p).divideScalar(3);
          let T = _(v);
          y(g, E + 0, u, T), y(m, E + 2, f, T), y(x, E + 4, p, T);
        }
        for (let b = 0; b < o.length; b += 6) {
          let E = o[b + 0],
            T = o[b + 2],
            S = o[b + 4],
            w = Math.max(E, T, S),
            C = Math.min(E, T, S);
          w > 0.9 &&
            C < 0.1 &&
            (E < 0.2 && (o[b + 0] += 1),
            T < 0.2 && (o[b + 2] += 1),
            S < 0.2 && (o[b + 4] += 1));
        }
        function _(b) {
          return Math.atan2(b.z, -b.x);
        }
        function M(b) {
          return Math.atan2(-b.y, Math.sqrt(b.x * b.x + b.z * b.z));
        }
      }
    }
    static fromJSON(t) {
      return new Rp(t.vertices, t.indices, t.radius, t.corner, t.cornerSides);
    }
  },
  zN = class {
    static create(t) {
      return this.build(this.normalizeInputs(t));
    }
    static normalizeInputs(t, e) {
      let i = Object.assign(
        {},
        (e == null ? void 0 : e.parameters) ?? {
          width: 100,
          detail: 0,
          corner: 0,
          cornerSides: 4,
        },
        t.parameters
      );
      return {
        parameters: Object.assign(i, {
          width: Math.abs(i.width),
          height: Math.abs(i.height ?? i.width),
          depth: Math.abs(i.depth ?? i.width),
        }),
      };
    }
    static build(t) {
      let {
          width: e,
          height: i,
          depth: n,
          detail: r,
          corner: s,
          cornerSides: a,
        } = t.parameters,
        o = r === 0 && s !== 0 ? new O_(e * 0.5, s, a) : new Kf(e * 0.5, r);
      return (
        o.scale(1, i / e, n / e),
        Object.assign(o, { userData: { ...t, type: "DodecahedronGeometry" } })
      );
    }
  },
  O_ = class extends Rp {
    constructor(t = 1, e = 0.2, i = 4) {
      let n = (1 + Math.sqrt(5)) / 2,
        r = 1 / n,
        s = [
          -1,
          -1,
          -1,
          -1,
          -1,
          1,
          -1,
          1,
          -1,
          -1,
          1,
          1,
          1,
          -1,
          -1,
          1,
          -1,
          1,
          1,
          1,
          -1,
          1,
          1,
          1,
          0,
          -r,
          -n,
          0,
          -r,
          n,
          0,
          r,
          -n,
          0,
          r,
          n,
          -r,
          -n,
          0,
          -r,
          n,
          0,
          r,
          -n,
          0,
          r,
          n,
          0,
          -n,
          0,
          -r,
          n,
          0,
          -r,
          -n,
          0,
          r,
          n,
          0,
          r,
        ],
        a = [
          3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4,
          8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1,
          18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2,
          3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8,
          11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1,
          12, 14, 1, 14, 5, 1, 5, 9,
        ],
        o = "DodecahedronGeometry";
      super(s, a, o, t, e, i), (this.type = o);
    }
    static fromJSON(t) {
      return new O_(t.radius, t.corner, t.cornerSides);
    }
  },
  Do = 1e-12,
  Op = class {
    constructor(t) {
      (this.position = new J()),
        (this.startPosition = new J()),
        (this.uuid = Jt.generateUUID()),
        (this.position = t.clone());
    }
    start() {
      this.reset();
    }
    reset() {
      this.startPosition.copy(this.position);
    }
    applyOffset(t) {
      this.position.copy(this.startPosition).add(t);
    }
    copy(t) {
      return (
        this.position.copy(t.position),
        this.startPosition.copy(t.startPosition),
        this
      );
    }
    clone() {
      return new Op(this.position).copy(this);
    }
    toJSON() {
      return [this.position.x, this.position.y];
    }
  },
  hf = class extends Op {
    constructor(t) {
      super(t.position), (this.parent = t);
    }
    copy(t) {
      return super.copy(t), this;
    }
    clone() {
      return new hf(this.parent).copy(this);
    }
  },
  Ga = class extends Op {
    constructor(t, e) {
      super(e),
        (this.controls = []),
        (this.roundness = 0),
        (this.areControlsDirectionsMirrored = !0),
        (this.uuid = t),
        this.controls.push(new hf(this), new hf(this));
    }
    static create(t, e) {
      let i = new Ga(t, new J(...e.position));
      return (
        i.controls[0].position.set(...e.controlPrevious.position),
        i.controls[1].position.set(...e.controlNext.position),
        (i.roundness = e.roundness),
        (i.areControlsDirectionsMirrored = e.areControlsDirectionsMirrored),
        i
      );
    }
    getOppositeControl(t) {
      let e = this.controls.indexOf(t);
      return e === 0 ? this.controls[1] : e === 1 ? this.controls[0] : null;
    }
    applyOffsetToControls(t, e = 1) {
      for (let i = 0, n = this.controls.length; i < n; i++) {
        let r = this.controls[i];
        this.position.distanceTo(r.position) <= e
          ? r.position.copy(this.position)
          : r.applyOffset(t);
      }
    }
    controlsMoved() {
      return !(
        this.position.equals(this.controls[0].position) &&
        this.position.equals(this.controls[1].position)
      );
    }
    copy(t) {
      return (
        super.copy(t),
        this.controls[0].copy(t.controls[0]),
        this.controls[1].copy(t.controls[1]),
        (this.roundness = t.roundness),
        (this.uuid = t.uuid),
        this
      );
    }
    clone() {
      return new Ga(this.uuid, this.position).copy(this);
    }
    toJSON() {
      return super
        .toJSON()
        .concat(this.controls[0].toJSON(), this.controls[1].toJSON(), [
          this.roundness,
        ]);
    }
    computeTangents() {
      var i, n;
      let t = (i = this.curveBefore) == null ? void 0 : i.getTangentAt(1),
        e = (n = this.curveAfter) == null ? void 0 : n.getTangentAt(0);
      return [t, e];
    }
    computeNormals(t = new J(), e = new J()) {
      let [i, n] = this.computeTangents();
      return i && n && (sv(i, t), sv(n, e)), [t, e];
    }
    computeTangent(t = new J()) {
      let [e, i] = this.computeTangents();
      return e && i && t.copy(e).add(i).normalize(), t;
    }
    computeNormal(t = new J()) {
      let [e, i] = this.computeNormals();
      return t.copy(e).add(i).normalize(), t;
    }
  };
function sv(t, e = new J()) {
  let i = t.length();
  return e.set(-t.y / i, t.x / i);
}
var Ip = (t) => t,
  _o = new J(),
  kh = new J(),
  BN = new J(),
  FN = new J(),
  kN = new J(),
  VN = new J(),
  I_ = new A(),
  U_ = new A();
function HN(t) {
  let e = new J();
  e.addVectors(t.v0, _o.subVectors(t.v1, t.v0).multiplyScalar(2 / 3));
  let i = new J();
  return (
    i.addVectors(t.v2, kh.subVectors(t.v1, t.v2).multiplyScalar(2 / 3)),
    new kn(t.v0, e, i, t.v2)
  );
}
function ko(t, e, i = Number.EPSILON) {
  return Math.abs(t - e) < i;
}
function GN(t, e, i = Number.EPSILON) {
  return t.distanceTo(e) < i;
}
function jN(t, e, i = Number.EPSILON) {
  return t.distanceTo(e) < i;
}
function N_(t, e, i) {
  let n = Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2)),
    r = Math.sqrt(Math.pow(e.x - i.x, 2) + Math.pow(e.y - i.y, 2)),
    s = Math.sqrt(Math.pow(i.x - t.x, 2) + Math.pow(i.y - t.y, 2));
  return Math.acos((r * r + n * n - s * s) / (2 * r * n));
}
function WN(t, e, i) {
  return ov(t, e) && ov(e, i) && uf(t.position, e.position, i.position);
}
function uf(t, e, i) {
  return _o.copy(e).sub(t).cross(kh.copy(i).sub(t)) === 0;
}
function qN(t, e, i, n, r) {
  let s = Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2)),
    a = (t.y + e.y) / 2,
    o = (t.x + e.x) / 2,
    l = (Math.sqrt(Math.pow(i, 2) - Math.pow(s / 2, 2)) * (t.y - e.y)) / s,
    c = (Math.sqrt(Math.pow(i, 2) - Math.pow(s / 2, 2)) * (e.x - t.x)) / s;
  return n.set(o + l, a + c), r.set(o - l, a - c), [n, r];
}
function XN(t, e, i) {
  let n = t.distanceTo(i),
    r = e.distanceTo(i);
  return n < r ? e : t;
}
function $N(t, e, i, n, r, s) {
  let a = e.x - t.x,
    o = e.y - t.y,
    l = i.x - t.x,
    c = i.y - t.y,
    d = Math.sqrt((a + l) * (a + l) + (o + c) * (o + c)),
    h;
  return (
    N_(e, t, i) > Math.PI && (d *= -1),
    ko(c, o)
      ? (h = ((o + c) * (n / d - 0.5) * 8) / 3 / (a - l))
      : (h = ((a + l) * (n / d - 0.5) * 8) / 3 / (c - o)),
    r.set(e.x - h * o, e.y + h * a),
    s.set(i.x + h * c, i.y - h * l),
    [r, s]
  );
}
function av(t, e) {
  return (
    t.position.equals(t.controls[1].position) &&
    e.position.equals(e.controls[0].position)
  );
}
function ov(t, e) {
  return (
    uf(t.position, t.controls[1].position, e.position) &&
    uf(t.position, e.controls[0].position, e.position)
  );
}
function YN(t, e, i, n, r = 0.5) {
  let s = _o.subVectors(e, t).multiplyScalar(r).add(t),
    a = kh.subVectors(i, e).multiplyScalar(r).add(e),
    o = BN.subVectors(n, i).multiplyScalar(r).add(i),
    l = s,
    c = FN.subVectors(a, s).multiplyScalar(r).add(s),
    d = kN.subVectors(o, a).multiplyScalar(r).add(a),
    h = o,
    u = VN.subVectors(d, c).multiplyScalar(r).add(c);
  return [t.x, t.y, l.x, l.y, c.x, c.y, u.x, u.y, d.x, d.y, h.x, h.y, n.x, n.y];
}
function ZN(t, e, i = 12, n = !0) {
  let r = U_.set(0, 0, 0),
    s,
    a = 0;
  for (let o = 0; o < e.length; o++) {
    let l = Ip(e[o]),
      c = _o,
      d = ks(l, i);
    for (let h = 0; h <= d; h++)
      if (l instanceof kn || l instanceof fs || l instanceof jn) {
        if (
          (l.getPoint(h / d, c), r.set(c.x, c.y, 0), s !== void 0 && jN(s, r))
        )
          continue;
        s === void 0 && (s = I_), s.copy(r), t.setXYZ(a, r.x, r.y, r.z), a++;
      }
  }
  return (
    n &&
      a > 1 &&
      !(
        t.getX(a - 1) === t.getX(0) &&
        t.getY(a - 1) === t.getY(0) &&
        t.getZ(a - 1) === t.getZ(0)
      ) &&
      (t.setXYZ(a, t.getX(0), t.getY(0), t.getZ(0)), a++),
    t
  );
}
function KN(t, e, i, n = 12, r = !0) {
  let s = U_.set(0, 0, 0),
    a = 0,
    o = [];
  for (let l = 0; l < e.length; l++) {
    if (i[l] === !1) continue;
    let c,
      d = Ip(e[l]),
      h = _o,
      u = ks(d, n);
    o.push(u);
    for (let f = 0; f <= u; f++)
      if (d instanceof kn || d instanceof fs || d instanceof jn) {
        if (
          (d.getPoint(f / u, h),
          s.set(h.x, h.y, 0),
          c == null ? void 0 : c.equals(s))
        )
          continue;
        c === void 0
          ? (c = I_)
          : (t.setXYZ(a, c.x, c.y, c.z), a++, t.setXYZ(a, s.x, s.y, s.z), a++),
          c.copy(s);
      }
  }
  return (
    r &&
      a > 1 &&
      !(
        t.getX(a - 1) === t.getX(0) &&
        t.getY(a - 1) === t.getY(0) &&
        t.getZ(a - 1) === t.getZ(0)
      ) &&
      (t.setXYZ(a, t.getX(0), t.getY(0), t.getZ(0)), a++),
    o
  );
}
function lv(t, e = 12, i = !1) {
  let n = [];
  for (let r = 0, s = t.length; r < s; r++) {
    let a = t[r],
      o = 0;
    if (i && a.roundedCurveCorner !== void 0) {
      let l = ks(a.roundedCurveCorner, e) * 0.5;
      r > 0 && (n[r - 1] += l), (o += l);
    }
    a.curveAfter !== void 0 && (o += ks(a.curveAfter, e)), n.push(o);
  }
  return (
    t.length > 0 &&
      i &&
      t[0].roundedCurveCorner !== void 0 &&
      (n[t.length - 1] += ks(t[0].roundedCurveCorner, e) * 0.5),
    n
  );
}
function ks(t, e = 12) {
  return t && t instanceof Sh
    ? e * 2
    : t && (t instanceof jn || t instanceof xx)
    ? 1
    : t && t instanceof $f
    ? e * t.points.length
    : e;
}
function JN(t, e, i = 12, n = !0) {
  let r,
    s = 0;
  for (let a = 0; a < e.length; a++) {
    let o = Ip(e[a]),
      l = ks(o, i),
      c = _o;
    for (let d = 0; d <= l; d++)
      if (o instanceof kn || o instanceof fs || o instanceof jn) {
        if ((o.getPoint(d / l, c), r !== void 0 && GN(r, c, Do))) continue;
        r === void 0 && (r = kh), r.copy(c), t.push(c.x, c.y), s++;
      }
  }
  return (
    ko(t[0], t[t.length - 2], Do) &&
      ko(t[1], t[t.length - 1], Do) &&
      (t.pop(), t.pop()),
    n &&
      s > 1 &&
      !(ko(t[s - 1], t[1], Do) && ko(t[s - 2], t[0], Do)) &&
      (t.push(t[0], t[1]), s++),
    t
  );
}
var Hu = new J(),
  QN = new J(),
  ez = new J(),
  tz = new J(),
  iz = new J(),
  nz = new J(),
  si = class extends Hc {
    constructor(t = 100, e = 100) {
      super(),
        (this.points = []),
        (this.shapeHoles = []),
        (this.plane = new qr(new A(0, 0, -1))),
        (this.subdivision = 0),
        (this.controlSnapDistance = 4),
        (this.pointIDs = 0),
        (this.isMesh2D = !1),
        (this._roundness = 0),
        (this.isClosed = !1),
        (this.useCubicForRoundedCorners = !0),
        (this.uuid = Jt.generateUUID()),
        (this.needsUpdate = !1),
        (this.roundedCurves = []),
        (this._width = t),
        (this._height = e);
    }
    static createFromState(t, e, i) {
      let n = new si();
      return (
        (n.isClosed = t.isClosed),
        (n.points = t.points.map((r) => Ga.create(r.id, r.data))),
        typeof t.roundness == "number" && (n.roundness = t.roundness),
        (n.shapeHoles = t.shapeHoles.map((r) => si.createFromState(r))),
        e !== void 0 && i !== void 0 && n.applySize(e, i),
        n.update(),
        n
      );
    }
    get width() {
      return this._width;
    }
    get height() {
      return this._height;
    }
    get roundness() {
      return this._roundness;
    }
    set roundness(t) {
      if (this._roundness !== t) {
        this._roundness = t;
        for (let e = 0, i = this.points.length; e < i; e++)
          this.points[e].roundness = t;
        this.needsUpdate = !0;
      }
    }
    getPointsIndexesByIds(t) {
      return t.map((e) => this.getPointIndexById(e)).filter((e) => e >= 0);
    }
    getPointIndexById(t) {
      let e = this.points.length,
        i = this.points.findIndex((n) => n.uuid === t);
      if (i < 0) {
        let n = e;
        for (let r = 0, s = this.shapeHoles.length; r < s; r++) {
          let a = this.shapeHoles[r],
            o = a.points.length,
            l = a.getPointIndexById(t);
          if (l < 0) n += o;
          else return l + n;
        }
      }
      return i;
    }
    getLineIndexById(t) {
      return this.getPointIndexById(t);
    }
    getBezierPoint(t) {
      if (t <= this.points.length - 1) return this.points[t];
      if (this.shapeHoles.length > 0) {
        let e = this.points.length;
        for (let i = 0, n = this.shapeHoles.length; i < n; i++) {
          let r = this.shapeHoles[i],
            s = t - e;
          if (s <= r.points.length - 1) return r.points[s];
          e += r.points.length;
        }
      }
      throw new Error("This shape does not have a point for this index: " + t);
    }
    getBezierPointIndex(t) {
      let e = this.points.indexOf(t);
      if (e >= 0) return e;
      if (((e = this.points.length), this.shapeHoles.length > 0))
        for (let i = 0, n = this.shapeHoles.length; i < n; i++) {
          let r = this.shapeHoles[i],
            s = r.points.indexOf(t);
          if (s >= 0) return e + s;
          e += r.points.length;
        }
      return -1;
    }
    getAllPoints() {
      let t = [].concat(...this.shapeHoles.map((e) => e.points));
      return [...this.points, ...t];
    }
    applySize(t, e) {
      t === 0 && (t = 0.001),
        e === 0 && (e = 0.001),
        (this._width = t),
        (this._height = e);
    }
    applyScale(t, e) {
      let i = Hu.set(t, e);
      for (let n = 0, r = this.points.length; n < r; n++) {
        let s = this.points[n];
        s.position.multiply(i),
          s.controls[0].position.multiply(i),
          s.controls[1].position.multiply(i);
      }
      for (let n = 0, r = this.shapeHoles.length; n < r; n++)
        this.shapeHoles[n].applyScale(t, e);
      this._update();
    }
    createPoint(t, e = 0, i = Jt.generateUUID()) {
      let n;
      t instanceof J ? (n = t) : (n = new J(t, e));
      let r = new Ga(i, n);
      return (r.roundness = this.roundness), r;
    }
    addPoint(t) {
      this.points.push(t), (this.needsUpdate = !0);
    }
    addPointAt(t, e) {
      this.points.splice(e, 0, t), (this.needsUpdate = !0);
    }
    getPointByUuid(t) {
      for (let e = 0, i = this.points.length; e < i; e++) {
        let n = this.points[e];
        if (n.uuid === t) return n;
      }
      for (let e = 0, i = this.shapeHoles.length; e < i; e++) {
        let n = this.shapeHoles[e].getPointByUuid(t);
        if (n) return n;
      }
    }
    getFirstPoint() {
      return this.points[0];
    }
    getLastPoint() {
      return this.points[this.points.length - 1];
    }
    removePoint(t) {
      let e = this.points.indexOf(t);
      e >= 0 && this.points.splice(e, 1), (this.needsUpdate = !0);
    }
    removePointById(t) {
      let e = this.points.find((i) => i.uuid === t);
      e && this.removePoint(e);
    }
    update() {
      for (let t = 0, e = this.shapeHoles.length; t < e; t++)
        this.shapeHoles[t].update();
      this._update();
    }
    extractShapePointsToBuffer(t, e = 12, i = !1) {
      (this.subdivision = e),
        this.curveDivisions === void 0 && this.computeCurveDivisions(e);
      let n = i ? this.roundedCurveDivisions : this.curveDivisions;
      return (
        ZN(t, i ? this.roundedCurves : this.curves, e, this.autoClose),
        n.reduce((r, s) => r + s, 0) + 1
      );
    }
    computeCurveDivisions(t = 12) {
      return (
        (this.curveDivisions = lv(this.points, t, !1)),
        (this.roundedCurveDivisions = lv(this.points, t, !0)),
        this.curveDivisions
      );
    }
    extractFilteredShapePointsToBuffer(t, e, i = 12) {
      return (
        KN(t, this.curves, e, i, this.autoClose).reduce((n, r) => n + r, 0) * 2
      );
    }
    extractShapePointsToFlatArray(t, e = 12) {
      return (
        (this.subdivision = e),
        this.curveDivisions === void 0 && this.computeCurveDivisions(e),
        JN(t, this.roundedCurves, e, this.autoClose)
      );
    }
    getCurveIndexFromVertexId(t, e = !1) {
      let i = 0;
      this.curveDivisions === void 0 &&
        this.computeCurveDivisions(this.subdivision);
      let n = e ? this.roundedCurveDivisions : this.curveDivisions,
        r = 0;
      e &&
        this.points[0].roundedCurveCorner !== void 0 &&
        (r = ks(this.points[0].roundedCurveCorner, this.subdivision) * 0.5);
      let s = t - r;
      s < 0 && (s += n.reduce((a, o) => a + o, 0));
      for (let a = 0, o = n.length; a < o; a++) {
        let l = n[a];
        if (s < i + l) return [a, (s - i + 1) / l];
        i += l;
      }
      return [0, 1];
    }
    getCurveT(t, e, i) {
      let n = this.points[t],
        r = this.points[t >= this.points.length - 1 ? 0 : t + 1],
        s = this.curveDivisions,
        a = s[t];
      if (av(n, r)) {
        let l = n.position.distanceTo(r.position);
        return n.position.distanceTo(Hu.set(i.x, i.y)) / l;
      }
      let o = 0;
      for (let l = 0; l < t; l++) o += s[l];
      return (e - o) / a;
    }
    dispose() {}
    _applyCurveForPoint(t, e) {
      av(e, t)
        ? this.lineTo(t.position.x, t.position.y)
        : this.bezierCurveTo(
            e.controls[1].position.x,
            e.controls[1].position.y,
            t.controls[0].position.x,
            t.controls[0].position.y,
            t.position.x,
            t.position.y
          );
      let i = this.curves[this.curves.length - 1];
      (t.curveBefore = i), (e.curveAfter = i);
      let n = i.clone();
      (t.roundedCurveBefore = n),
        (e.roundedCurveAfter = n),
        (t.roundedCurveCorner = void 0),
        this.roundedCurves.push(n);
    }
    _update() {
      if (((this.curves = []), (this.roundedCurves = []), !this.points.length))
        return;
      for (let e = 0, i = this.points.length; e < i; e++) {
        let n = this.points[e];
        if (e === 0) this.moveTo(n.position.x, n.position.y);
        else {
          let r = this.points[e - 1];
          this._applyCurveForPoint(n, r);
        }
      }
      let t = this.getLastPoint();
      if (
        (t != null && t.curveAfter && (t.curveAfter = void 0), this.isClosed)
      ) {
        let e = this.points[0],
          i = this.points[this.points.length - 1];
        this._applyCurveForPoint(e, i);
      }
      if (this.points.length > 2) {
        let e = 0;
        for (let i = 0, n = this.points.length; i < n; i++) {
          let r = this.points[i],
            s = this.points[i - 1] ?? this.points[this.points.length - 1],
            a = this.points[i + 1] ?? this.points[0],
            o = r.roundness,
            l = s && a && WN(s, r, a);
          if (!r.controlsMoved() && o > 0 && !l) {
            let c = r.curveBefore,
              d = r.curveAfter;
            if (c === void 0 || d === void 0) continue;
            let h = r.roundedCurveBefore,
              u = r.roundedCurveAfter,
              f = c.getLength(),
              p = d.getLength(),
              v = Math.min(o, f * 0.499),
              g = Math.min(o, p * 0.499),
              m = Math.min(v, g),
              x = 1 - m / f,
              y = m / p,
              _ = c.getPointAt(x, Hu),
              M = d.getPointAt(y, QN);
            this._subSplitCurve(c, h, x, _, void 0),
              this._subSplitCurve(d, u, y, void 0, M);
            let b;
            if (this.useCubicForRoundedCorners) {
              let E = N_(_, r.position, M) / 2,
                T = Math.tan(E) * _.distanceTo(r.position),
                [S, w] = qN(_, M, T, ez, tz),
                C = XN(S, w, r.position),
                [L, P] = $N(C, _, M, T, iz, nz);
              b = new kn(_.clone(), L.clone(), P.clone(), M.clone());
            } else b = new fs(_.clone(), r.position.clone(), M.clone());
            (r.roundedCurveCorner = b),
              this.roundedCurves.splice(i + e, 0, b),
              e++;
          }
        }
      }
    }
    _subSplitCurve(t, e, i, n, r) {
      if (t instanceof jn)
        n !== void 0 && e.v2.copy(n), r !== void 0 && e.v1.copy(r);
      else {
        let s = t,
          a = e,
          o = s.getUtoTmapping(i, 0),
          l = YN(s.v0, s.v1, s.v2, s.v3, o);
        return (
          n !== void 0 &&
            (a.v0.set(l[0], l[1]),
            a.v1.set(l[2], l[3]),
            a.v2.set(l[4], l[5]),
            a.v3.set(l[6], l[7])),
          r !== void 0 &&
            (a.v0.set(l[6], l[7]),
            a.v1.set(l[8], l[9]),
            a.v2.set(l[10], l[11]),
            a.v3.set(l[12], l[13])),
          a
        );
      }
      return e;
    }
    clone() {
      let t = new si(this._width, this._height);
      return (
        (t.points = this.points.map((e) => e.clone())),
        (t.isClosed = this.isClosed),
        (t.roundness = this.roundness),
        (t.isMesh2D = this.isMesh2D),
        (t.shapeHoles = this.shapeHoles.map((e) => e.clone())),
        t
      );
    }
    toJSON() {
      return {
        points: this.points.reduce((t, e) => t.concat(e.toJSON()), []),
        shapeHoles: this.shapeHoles.map((t) => t.toJSON()),
        isClosed: this.isClosed,
        roundness: this.roundness,
      };
    }
    fromJSON(t) {
      var i;
      (this.points = []), (this.pointIDs = 0);
      let e = t.points.length / 7;
      for (let n = 0; n < e; n++) {
        let r = n * 7,
          s = t.points[r + 0],
          a = t.points[r + 1],
          o = t.points[r + 2],
          l = t.points[r + 3],
          c = t.points[r + 4],
          d = t.points[r + 5],
          h = t.points[r + 6],
          u = new Ga(Jt.generateUUID(), new J(s, a));
        u.controls[0].position.set(o, l),
          u.controls[1].position.set(c, d),
          (u.roundness = h),
          this.points.push(u);
      }
      return (
        (this.shapeHoles =
          (i = t.shapeHoles) != null && i.length
            ? t.shapeHoles.map((n) => {
                let r = new si();
                return r.fromJSON(n), r;
              })
            : []),
        (this.isClosed = t.isClosed),
        (this._roundness = t.roundness),
        this._update(),
        this
      );
    }
    fromShape(t) {
      let e = (n, r) => {
          r instanceof kn &&
            r.v3.equals(n.position) &&
            n.controls[0].position.copy(r.v2);
        },
        i = (n) => {
          let r = [],
            s,
            a;
          for (s = 0, a = n.length; s < a; s++)
            n[s] instanceof fs && (n[s] = HN(n[s]));
          for (s = 0, a = n.length; s < a; s++) {
            let c = n[s],
              d = s > 0 ? n[s - 1] : null,
              h;
            c instanceof kn
              ? ((h = this.createPoint(c.v0)),
                h.controls[1].position.copy(c.v1))
              : c instanceof jn && (h = this.createPoint(c.v1)),
              h !== void 0 && (d !== null && e(h, d), r.push(h));
          }
          let o = n[n.length - 1],
            l = !1;
          return (
            o instanceof kn
              ? o.v3.equals(r[0].position) &&
                (r[0].controls[0].position.copy(o.v2), (l = !0))
              : o instanceof jn && o.v2.equals(r[0].position) && (l = !0),
            (this.isClosed = l),
            r
          );
        };
      return (
        (this.points = i(t.curves)),
        t instanceof Hc &&
          (this.shapeHoles = t.holes.map((n) => {
            let r = new si();
            return r.fromShape(n), r;
          })),
        this.update(),
        this
      );
    }
    updatePoint(t, e) {
      let i = this.getPointByUuid(t);
      i &&
        (e.position !== void 0 && i.position.fromArray(e.position),
        e.roundness !== void 0 && (i.roundness = e.roundness),
        e.areControlsDirectionsMirrored !== void 0 &&
          (i.areControlsDirectionsMirrored = e.areControlsDirectionsMirrored),
        (this.needsUpdate = !0));
    }
    updatePreviousControl(t, e) {
      var n;
      let i = (n = this.getPointByUuid(t)) == null ? void 0 : n.controls[0];
      i &&
        (e.position && i.position.fromArray(e.position),
        (this.needsUpdate = !0));
    }
    updateNextControl(t, e) {
      var n;
      let i = (n = this.getPointByUuid(t)) == null ? void 0 : n.controls[1];
      i &&
        (e.position && i.position.fromArray(e.position),
        (this.needsUpdate = !0));
    }
  },
  df = Math.PI * 2;
function Gu({ x: t, y: e }, i, n, r, s) {
  return { x: t * i + r, y: e * n + s };
}
function rz(t, e) {
  let i =
      e === 1.5707963267948966
        ? 0.551915024494
        : e === -1.5707963267948966
        ? -0.551915024494
        : 1.3333333333333333 * Math.tan(e / 4),
    n = Math.cos(t),
    r = Math.sin(t),
    s = Math.cos(t + e),
    a = Math.sin(t + e);
  return [
    { x: n - r * i, y: r + n * i },
    { x: s + a * i, y: a - s * i },
    { x: s, y: a },
  ];
}
function cv(t, e, i, n) {
  let r = t * n - e * i < 0 ? -1 : 1,
    s = Math.min(1, Math.max(-1, t * i + e * n));
  return r * Math.acos(s);
}
function sz(t, e, i, n, r, s, a, o, l, c) {
  let d = Math.pow(r, 2),
    h = Math.pow(s, 2),
    u = Math.pow(a, 2),
    f = Math.pow(o, 2),
    p = d * h - d * f - h * u;
  p < 0 && (p = 0),
    (p /= d * f + h * u),
    (p = Math.sqrt(p) * (l === c ? -1 : 1));
  let v = ((p * r) / s) * o,
    g = ((p * -s) / r) * a,
    m = v + (t + i) / 2,
    x = g + (e + n) / 2,
    y = (a - v) / r,
    _ = (o - g) / s,
    M = (-a - v) / r,
    b = (-o - g) / s,
    E = cv(1, 0, y, _),
    T = cv(y, _, M, b);
  return (
    !c && T > 0 && (T -= df),
    c && T < 0 && (T += df),
    { centerx: m, centery: x, ang1: E, ang2: T }
  );
}
function az({
  px: t,
  py: e,
  cx: i,
  cy: n,
  rx: r,
  ry: s,
  largeArcFlag: a,
  sweepFlag: o,
}) {
  let l = [];
  if (r === 0 || s === 0) return [];
  let c = (t - i) / 2,
    d = (e - n) / 2;
  if (c === 0 && d === 0) return [];
  (r = Math.abs(r)), (s = Math.abs(s));
  let h = Math.pow(c, 2) / Math.pow(r, 2) + Math.pow(d, 2) / Math.pow(s, 2);
  h > 1 && ((r *= Math.sqrt(h)), (s *= Math.sqrt(h)));
  let u = sz(t, e, i, n, r, s, c, d, a, o),
    { ang1: f, ang2: p } = u,
    { centerx: v, centery: g } = u,
    m = Math.abs(p) / (df / 4);
  Math.abs(1 - m) < 1e-7 && (m = 1);
  let x = Math.max(Math.ceil(m), 1);
  p /= x;
  for (let y = 0; y < x; y++) l.push(rz(f, p)), (f += p);
  return l.map((y) => {
    let { x: _, y: M } = Gu(y[0], r, s, v, g),
      { x: b, y: E } = Gu(y[1], r, s, v, g),
      { x: T, y: S } = Gu(y[2], r, s, v, g);
    return { x1: _, y1: M, x2: b, y2: E, x: T, y: S };
  });
}
var Vt;
(function (t) {
  (t[(t.ODD = 0)] = "ODD"),
    (t[(t.NONZERO = 1)] = "NONZERO"),
    (t[(t.POSITIVE = 2)] = "POSITIVE"),
    (t[(t.NEGATIVE = 3)] = "NEGATIVE"),
    (t[(t.ABS_GEQ_TWO = 4)] = "ABS_GEQ_TWO");
})(Vt || (Vt = {}));
var mi;
(function (t) {
  (t[(t.POLYGONS = 0)] = "POLYGONS"),
    (t[(t.CONNECTED_POLYGONS = 1)] = "CONNECTED_POLYGONS"),
    (t[(t.BOUNDARY_CONTOURS = 2)] = "BOUNDARY_CONTOURS");
})(mi || (mi = {}));
function rt(t, e) {
  if (!t) throw e || "Assertion Failed!";
}
var Ke = (function () {
    function t() {}
    return (
      (t.vertEq = function (e, i) {
        return e.s === i.s && e.t === i.t;
      }),
      (t.vertLeq = function (e, i) {
        return e.s < i.s || (e.s === i.s && e.t <= i.t);
      }),
      (t.transLeq = function (e, i) {
        return e.t < i.t || (e.t === i.t && e.s <= i.s);
      }),
      (t.edgeGoesLeft = function (e) {
        return t.vertLeq(e.Dst, e.Org);
      }),
      (t.edgeGoesRight = function (e) {
        return t.vertLeq(e.Org, e.Dst);
      }),
      (t.vertL1dist = function (e, i) {
        return Math.abs(e.s - i.s) + Math.abs(e.t - i.t);
      }),
      (t.edgeEval = function (e, i, n) {
        rt(t.vertLeq(e, i) && t.vertLeq(i, n));
        var r = i.s - e.s,
          s = n.s - i.s;
        return r + s > 0
          ? r < s
            ? i.t - e.t + (e.t - n.t) * (r / (r + s))
            : i.t - n.t + (n.t - e.t) * (s / (r + s))
          : 0;
      }),
      (t.edgeSign = function (e, i, n) {
        rt(t.vertLeq(e, i) && t.vertLeq(i, n));
        var r = i.s - e.s,
          s = n.s - i.s;
        return r + s > 0 ? (i.t - n.t) * r + (i.t - e.t) * s : 0;
      }),
      (t.transEval = function (e, i, n) {
        rt(t.transLeq(e, i) && t.transLeq(i, n));
        var r = i.t - e.t,
          s = n.t - i.t;
        return r + s > 0
          ? r < s
            ? i.s - e.s + (e.s - n.s) * (r / (r + s))
            : i.s - n.s + (n.s - e.s) * (s / (r + s))
          : 0;
      }),
      (t.transSign = function (e, i, n) {
        rt(t.transLeq(e, i) && t.transLeq(i, n));
        var r = i.t - e.t,
          s = n.t - i.t;
        return r + s > 0 ? (i.s - n.s) * r + (i.s - e.s) * s : 0;
      }),
      (t.vertCCW = function (e, i, n) {
        return e.s * (i.t - n.t) + i.s * (n.t - e.t) + n.s * (e.t - i.t) >= 0;
      }),
      (t.interpolate = function (e, i, n, r) {
        return (
          (e = e < 0 ? 0 : e),
          (n = n < 0 ? 0 : n),
          e <= n
            ? n === 0
              ? (i + r) / 2
              : i + (r - i) * (e / (e + n))
            : r + (i - r) * (n / (e + n))
        );
      }),
      (t.intersect = function (e, i, n, r, s) {
        var a, o, l;
        t.vertLeq(e, i) || ((l = e), (e = i), (i = l)),
          t.vertLeq(n, r) || ((l = n), (n = r), (r = l)),
          t.vertLeq(e, n) ||
            ((l = e), (e = n), (n = l), (l = i), (i = r), (r = l)),
          t.vertLeq(n, i)
            ? t.vertLeq(i, r)
              ? ((a = t.edgeEval(e, n, i)),
                (o = t.edgeEval(n, i, r)),
                a + o < 0 && ((a = -a), (o = -o)),
                (s.s = t.interpolate(a, n.s, o, i.s)))
              : ((a = t.edgeSign(e, n, i)),
                (o = -t.edgeSign(e, r, i)),
                a + o < 0 && ((a = -a), (o = -o)),
                (s.s = t.interpolate(a, n.s, o, r.s)))
            : (s.s = (n.s + i.s) / 2),
          t.transLeq(e, i) || ((l = e), (e = i), (i = l)),
          t.transLeq(n, r) || ((l = n), (n = r), (r = l)),
          t.transLeq(e, n) ||
            ((l = e), (e = n), (n = l), (l = i), (i = r), (r = l)),
          t.transLeq(n, i)
            ? t.transLeq(i, r)
              ? ((a = t.transEval(e, n, i)),
                (o = t.transEval(n, i, r)),
                a + o < 0 && ((a = -a), (o = -o)),
                (s.t = t.interpolate(a, n.t, o, i.t)))
              : ((a = t.transSign(e, n, i)),
                (o = -t.transSign(e, r, i)),
                a + o < 0 && ((a = -a), (o = -o)),
                (s.t = t.interpolate(a, n.t, o, r.t)))
            : (s.t = (n.t + i.t) / 2);
      }),
      t
    );
  })(),
  Ro = (function () {
    function t() {
      (this.next = null),
        (this.prev = null),
        (this.anEdge = null),
        (this.trail = null),
        (this.n = 0),
        (this.marked = !1),
        (this.inside = !1);
    }
    return t;
  })(),
  cc = (function () {
    function t(e) {
      (this.side = e),
        (this.next = null),
        (this.Org = null),
        (this.Sym = null),
        (this.Onext = null),
        (this.Lnext = null),
        (this.Lface = null),
        (this.activeRegion = null),
        (this.winding = 0);
    }
    return (
      Object.defineProperty(t.prototype, "Rface", {
        get: function () {
          return this.Sym.Lface;
        },
        set: function (e) {
          this.Sym.Lface = e;
        },
        enumerable: !0,
        configurable: !0,
      }),
      Object.defineProperty(t.prototype, "Dst", {
        get: function () {
          return this.Sym.Org;
        },
        set: function (e) {
          this.Sym.Org = e;
        },
        enumerable: !0,
        configurable: !0,
      }),
      Object.defineProperty(t.prototype, "Oprev", {
        get: function () {
          return this.Sym.Lnext;
        },
        set: function (e) {
          this.Sym.Lnext = e;
        },
        enumerable: !0,
        configurable: !0,
      }),
      Object.defineProperty(t.prototype, "Lprev", {
        get: function () {
          return this.Onext.Sym;
        },
        set: function (e) {
          this.Onext.Sym = e;
        },
        enumerable: !0,
        configurable: !0,
      }),
      Object.defineProperty(t.prototype, "Dprev", {
        get: function () {
          return this.Lnext.Sym;
        },
        set: function (e) {
          this.Lnext.Sym = e;
        },
        enumerable: !0,
        configurable: !0,
      }),
      Object.defineProperty(t.prototype, "Rprev", {
        get: function () {
          return this.Sym.Onext;
        },
        set: function (e) {
          this.Sym.Onext = e;
        },
        enumerable: !0,
        configurable: !0,
      }),
      Object.defineProperty(t.prototype, "Dnext", {
        get: function () {
          return this.Sym.Onext.Sym;
        },
        set: function (e) {
          this.Sym.Onext.Sym = e;
        },
        enumerable: !0,
        configurable: !0,
      }),
      Object.defineProperty(t.prototype, "Rnext", {
        get: function () {
          return this.Sym.Lnext.Sym;
        },
        set: function (e) {
          this.Sym.Lnext.Sym = e;
        },
        enumerable: !0,
        configurable: !0,
      }),
      t
    );
  })(),
  Ea = (function () {
    function t() {
      (this.next = null),
        (this.prev = null),
        (this.anEdge = null),
        (this.coords = [0, 0, 0]),
        (this.s = 0),
        (this.t = 0),
        (this.pqHandle = 0),
        (this.n = 0),
        (this.idx = 0);
    }
    return t;
  })(),
  hv = (function () {
    function t() {
      var e = new Ea(),
        i = new Ro(),
        n = new cc(0),
        r = new cc(1);
      (e.next = e.prev = e),
        (e.anEdge = null),
        (i.next = i.prev = i),
        (n.next = n),
        (n.Sym = r),
        (r.next = r),
        (r.Sym = n),
        (this.vHead = e),
        (this.fHead = i),
        (this.eHead = n),
        (this.eHeadSym = r);
    }
    return (
      (t.prototype.makeEdge_ = function (e) {
        var i = new cc(0),
          n = new cc(1);
        e.Sym.side < e.side && (e = e.Sym);
        var r = e.Sym.next;
        return (
          (n.next = r),
          (r.Sym.next = i),
          (i.next = e),
          (e.Sym.next = n),
          (i.Sym = n),
          (i.Onext = i),
          (i.Lnext = n),
          (i.Org = null),
          (i.Lface = null),
          (i.winding = 0),
          (i.activeRegion = null),
          (n.Sym = i),
          (n.Onext = n),
          (n.Lnext = i),
          (n.Org = null),
          (n.Lface = null),
          (n.winding = 0),
          (n.activeRegion = null),
          i
        );
      }),
      (t.prototype.splice_ = function (e, i) {
        var n = e.Onext,
          r = i.Onext;
        (n.Sym.Lnext = i), (r.Sym.Lnext = e), (e.Onext = r), (i.Onext = n);
      }),
      (t.prototype.makeVertex_ = function (e, i, n) {
        var r = e;
        rt(r, "Vertex can't be null!");
        var s = n.prev;
        (r.prev = s), (s.next = r), (r.next = n), (n.prev = r), (r.anEdge = i);
        var a = i;
        do (a.Org = r), (a = a.Onext);
        while (a !== i);
      }),
      (t.prototype.makeFace_ = function (e, i, n) {
        var r = e;
        rt(r, "Face can't be null");
        var s = n.prev;
        (r.prev = s),
          (s.next = r),
          (r.next = n),
          (n.prev = r),
          (r.anEdge = i),
          (r.trail = null),
          (r.marked = !1),
          (r.inside = n.inside);
        var a = i;
        do (a.Lface = r), (a = a.Lnext);
        while (a !== i);
      }),
      (t.prototype.killEdge_ = function (e) {
        e.Sym.side < e.side && (e = e.Sym);
        var i = e.next,
          n = e.Sym.next;
        (i.Sym.next = n), (n.Sym.next = i);
      }),
      (t.prototype.killVertex_ = function (e, i) {
        var n = e.anEdge,
          r = n;
        do (r.Org = i), (r = r.Onext);
        while (r !== n);
        var s = e.prev,
          a = e.next;
        (a.prev = s), (s.next = a);
      }),
      (t.prototype.killFace_ = function (e, i) {
        var n = e.anEdge,
          r = n;
        do (r.Lface = i), (r = r.Lnext);
        while (r !== n);
        var s = e.prev,
          a = e.next;
        (a.prev = s), (s.next = a);
      }),
      (t.prototype.makeEdge = function () {
        var e = new Ea(),
          i = new Ea(),
          n = new Ro(),
          r = this.makeEdge_(this.eHead);
        return (
          this.makeVertex_(e, r, this.vHead),
          this.makeVertex_(i, r.Sym, this.vHead),
          this.makeFace_(n, r, this.fHead),
          r
        );
      }),
      (t.prototype.splice = function (e, i) {
        var n = !1,
          r = !1;
        if (e !== i) {
          if (
            (i.Org !== e.Org && ((r = !0), this.killVertex_(i.Org, e.Org)),
            i.Lface !== e.Lface && ((n = !0), this.killFace_(i.Lface, e.Lface)),
            this.splice_(i, e),
            !r)
          ) {
            var s = new Ea();
            this.makeVertex_(s, i, e.Org), (e.Org.anEdge = e);
          }
          if (!n) {
            var a = new Ro();
            this.makeFace_(a, i, e.Lface), (e.Lface.anEdge = e);
          }
        }
      }),
      (t.prototype.delete = function (e) {
        var i = e.Sym,
          n = !1;
        if (
          (e.Lface !== e.Rface && ((n = !0), this.killFace_(e.Lface, e.Rface)),
          e.Onext === e)
        )
          this.killVertex_(e.Org, null);
        else if (
          ((e.Rface.anEdge = e.Oprev),
          (e.Org.anEdge = e.Onext),
          this.splice_(e, e.Oprev),
          !n)
        ) {
          var r = new Ro();
          this.makeFace_(r, e, e.Lface);
        }
        i.Onext === i
          ? (this.killVertex_(i.Org, null), this.killFace_(i.Lface, null))
          : ((e.Lface.anEdge = i.Oprev),
            (i.Org.anEdge = i.Onext),
            this.splice_(i, i.Oprev)),
          this.killEdge_(e);
      }),
      (t.prototype.addEdgeVertex = function (e) {
        var i = this.makeEdge_(e),
          n = i.Sym;
        this.splice_(i, e.Lnext), (i.Org = e.Dst);
        var r = new Ea();
        return this.makeVertex_(r, n, i.Org), (i.Lface = n.Lface = e.Lface), i;
      }),
      (t.prototype.splitEdge = function (e) {
        var i = this.addEdgeVertex(e),
          n = i.Sym;
        return (
          this.splice_(e.Sym, e.Sym.Oprev),
          this.splice_(e.Sym, n),
          (e.Dst = n.Org),
          (n.Dst.anEdge = n.Sym),
          (n.Rface = e.Rface),
          (n.winding = e.winding),
          (n.Sym.winding = e.Sym.winding),
          (n.idx = e.idx),
          (n.Sym.idx = e.Sym.idx),
          n
        );
      }),
      (t.prototype.connect = function (e, i) {
        var n = !1,
          r = this.makeEdge_(e),
          s = r.Sym;
        if (
          (i.Lface !== e.Lface && ((n = !0), this.killFace_(i.Lface, e.Lface)),
          this.splice_(r, e.Lnext),
          this.splice_(s, i),
          (r.Org = e.Dst),
          (s.Org = i.Org),
          (r.Lface = s.Lface = e.Lface),
          (e.Lface.anEdge = s),
          !n)
        ) {
          var a = new Ro();
          this.makeFace_(a, r, e.Lface);
        }
        return r;
      }),
      (t.prototype.zapFace = function (e) {
        var i = e.anEdge,
          n,
          r,
          s,
          a,
          o;
        r = i.Lnext;
        do
          (n = r),
            (r = n.Lnext),
            (n.Lface = null),
            n.Rface === null &&
              (n.Onext === n
                ? this.killVertex_(n.Org, null)
                : ((n.Org.anEdge = n.Onext), this.splice_(n, n.Oprev)),
              (s = n.Sym),
              s.Onext === s
                ? this.killVertex_(s.Org, null)
                : ((s.Org.anEdge = s.Onext), this.splice_(s, s.Oprev)),
              this.killEdge_(n));
        while (n != i);
        (a = e.prev), (o = e.next), (o.prev = a), (a.next = o);
      }),
      (t.prototype.countFaceVerts_ = function (e) {
        var i = e.anEdge,
          n = 0;
        do n++, (i = i.Lnext);
        while (i !== e.anEdge);
        return n;
      }),
      (t.prototype.mergeConvexFaces = function (e) {
        var i, n, r, s, a, o, l;
        for (i = this.fHead.next; i !== this.fHead; i = i.next)
          if (i.inside)
            for (
              n = i.anEdge, a = n.Org;
              (r = n.Lnext),
                (s = n.Sym),
                s &&
                  s.Lface &&
                  s.Lface.inside &&
                  ((o = this.countFaceVerts_(i)),
                  (l = this.countFaceVerts_(s.Lface)),
                  o + l - 2 <= e &&
                    Ke.vertCCW(n.Lprev.Org, n.Org, s.Lnext.Lnext.Org) &&
                    Ke.vertCCW(s.Lprev.Org, s.Org, n.Lnext.Lnext.Org) &&
                    ((r = s.Lnext), this.delete(s), (n = null), (s = null))),
                !(n && n.Lnext.Org === a);

            )
              n = r;
        return !0;
      }),
      (t.prototype.check = function () {
        var e = this.fHead,
          i = this.vHead,
          n = this.eHead,
          r,
          s,
          a,
          o,
          l,
          c;
        for (s = e, s = e; (r = s.next) !== e; s = r) {
          rt(r.prev === s), (l = r.anEdge);
          do
            rt(l.Sym !== l),
              rt(l.Sym.Sym === l),
              rt(l.Lnext.Onext.Sym === l),
              rt(l.Onext.Sym.Lnext === l),
              rt(l.Lface === r),
              (l = l.Lnext);
          while (l !== r.anEdge);
        }
        for (
          rt(r.prev === s && r.anEdge === null), o = i, o = i;
          (a = o.next) !== i;
          o = a
        ) {
          rt(a.prev === o), (l = a.anEdge);
          do
            rt(l.Sym !== l),
              rt(l.Sym.Sym === l),
              rt(l.Lnext.Onext.Sym === l),
              rt(l.Onext.Sym.Lnext === l),
              rt(l.Org === a),
              (l = l.Onext);
          while (l !== a.anEdge);
        }
        for (
          rt(a.prev === o && a.anEdge === null), c = n, c = n;
          (l = c.next) !== n;
          c = l
        )
          rt(l.Sym.next === c.Sym),
            rt(l.Sym !== l),
            rt(l.Sym.Sym === l),
            rt(l.Org !== null),
            rt(l.Dst !== null),
            rt(l.Lnext.Onext.Sym === l),
            rt(l.Onext.Sym.Lnext === l);
        rt(
          l.Sym.next === c.Sym &&
            l.Sym === this.eHeadSym &&
            l.Sym.Sym === l &&
            l.Org === null &&
            l.Dst === null &&
            l.Lface === null &&
            l.Rface === null
        );
      }),
      t
    );
  })(),
  uv = (function () {
    function t() {
      this.handle = null;
    }
    return t;
  })(),
  dv = (function () {
    function t() {
      (this.key = null), (this.node = 0);
    }
    return t;
  })(),
  oz = (function () {
    function t(e, i) {
      (this.leq = i),
        (this.max = 0),
        (this.nodes = []),
        (this.handles = []),
        (this.initialized = !1),
        (this.freeList = 0),
        (this.size = 0),
        (this.max = e),
        (this.nodes = []),
        (this.handles = []);
      for (var n = 0; n < e + 1; n++)
        (this.nodes[n] = new uv()), (this.handles[n] = new dv());
      (this.initialized = !1),
        (this.nodes[1].handle = 1),
        (this.handles[1].key = null);
    }
    return (
      (t.prototype.floatDown_ = function (e) {
        var i = this.nodes,
          n = this.handles,
          r,
          s,
          a;
        for (r = i[e].handle; ; ) {
          if (
            ((a = e << 1),
            a < this.size &&
              this.leq(n[i[a + 1].handle].key, n[i[a].handle].key) &&
              ++a,
            rt(a <= this.max),
            (s = i[a].handle),
            a > this.size || this.leq(n[r].key, n[s].key))
          ) {
            (i[e].handle = r), (n[r].node = e);
            break;
          }
          (i[e].handle = s), (n[s].node = e), (e = a);
        }
      }),
      (t.prototype.floatUp_ = function (e) {
        var i = this.nodes,
          n = this.handles,
          r,
          s,
          a;
        for (r = i[e].handle; ; ) {
          if (
            ((a = e >> 1),
            (s = i[a].handle),
            a === 0 || this.leq(n[s].key, n[r].key))
          ) {
            (i[e].handle = r), (n[r].node = e);
            break;
          }
          (i[e].handle = s), (n[s].node = e), (e = a);
        }
      }),
      (t.prototype.init = function () {
        for (var e = this.size; e >= 1; --e) this.floatDown_(e);
        this.initialized = !0;
      }),
      (t.prototype.min = function () {
        return this.handles[this.nodes[1].handle].key;
      }),
      (t.prototype.insert = function (e) {
        var i, n;
        if (((i = ++this.size), i * 2 > this.max)) {
          this.max *= 2;
          var r, s;
          for (
            s = this.nodes.length, this.nodes.length = this.max + 1, r = s;
            r < this.nodes.length;
            r++
          )
            this.nodes[r] = new uv();
          for (
            s = this.handles.length, this.handles.length = this.max + 1, r = s;
            r < this.handles.length;
            r++
          )
            this.handles[r] = new dv();
        }
        return (
          this.freeList === 0
            ? (n = i)
            : ((n = this.freeList), (this.freeList = this.handles[n].node)),
          (this.nodes[i].handle = n),
          (this.handles[n].node = i),
          (this.handles[n].key = e),
          this.initialized && this.floatUp_(i),
          n
        );
      }),
      (t.prototype.extractMin = function () {
        var e = this.nodes,
          i = this.handles,
          n = e[1].handle,
          r = i[n].key;
        return (
          this.size > 0 &&
            ((e[1].handle = e[this.size].handle),
            (i[e[1].handle].node = 1),
            (i[n].key = null),
            (i[n].node = this.freeList),
            (this.freeList = n),
            --this.size,
            this.size > 0 && this.floatDown_(1)),
          r
        );
      }),
      (t.prototype.delete = function (e) {
        var i = this.nodes,
          n = this.handles,
          r;
        rt(e >= 1 && e <= this.max && n[e].key !== null),
          (r = n[e].node),
          (i[r].handle = i[this.size].handle),
          (n[i[r].handle].node = r),
          --this.size,
          r <= this.size &&
            (r <= 1 || this.leq(n[i[r >> 1].handle].key, n[i[r].handle].key)
              ? this.floatDown_(r)
              : this.floatUp_(r)),
          (n[e].key = null),
          (n[e].node = this.freeList),
          (this.freeList = e);
      }),
      t
    );
  })(),
  ju = (function () {
    function t() {
      (this.eUp = null),
        (this.nodeUp = null),
        (this.windingNumber = 0),
        (this.inside = !1),
        (this.sentinel = !1),
        (this.dirty = !1),
        (this.fixUpperEdge = !1);
    }
    return t;
  })(),
  fv = (function () {
    function t() {
      (this.key = null), (this.next = null), (this.prev = null);
    }
    return t;
  })(),
  lz = (function () {
    function t(e, i) {
      (this.frame = e),
        (this.leq = i),
        (this.head = new fv()),
        (this.head.next = this.head),
        (this.head.prev = this.head);
    }
    return (
      (t.prototype.min = function () {
        return this.head.next;
      }),
      (t.prototype.max = function () {
        return this.head.prev;
      }),
      (t.prototype.insert = function (e) {
        return this.insertBefore(this.head, e);
      }),
      (t.prototype.search = function (e) {
        var i = this.head;
        do i = i.next;
        while (i.key !== null && !this.leq(this.frame, e, i.key));
        return i;
      }),
      (t.prototype.insertBefore = function (e, i) {
        do e = e.prev;
        while (e.key !== null && !this.leq(this.frame, e.key, i));
        var n = new fv();
        return (
          (n.key = i),
          (n.next = e.next),
          (e.next.prev = n),
          (n.prev = e),
          (e.next = n),
          n
        );
      }),
      (t.prototype.delete = function (e) {
        (e.next.prev = e.prev), (e.prev.next = e.next);
      }),
      t
    );
  })(),
  cz = (function () {
    function t() {}
    return (
      (t.regionBelow = function (e) {
        return e.nodeUp.prev.key;
      }),
      (t.regionAbove = function (e) {
        return e.nodeUp.next.key;
      }),
      (t.debugEvent = function (e) {}),
      (t.addWinding = function (e, i) {
        (e.winding += i.winding), (e.Sym.winding += i.Sym.winding);
      }),
      (t.edgeLeq = function (e, i, n) {
        var r = e.event,
          s = i.eUp,
          a = n.eUp;
        if (s.Dst === r)
          return a.Dst === r
            ? Ke.vertLeq(s.Org, a.Org)
              ? Ke.edgeSign(a.Dst, s.Org, a.Org) <= 0
              : Ke.edgeSign(s.Dst, a.Org, s.Org) >= 0
            : Ke.edgeSign(a.Dst, r, a.Org) <= 0;
        if (a.Dst === r) return Ke.edgeSign(s.Dst, r, s.Org) >= 0;
        var o = Ke.edgeEval(s.Dst, r, s.Org),
          l = Ke.edgeEval(a.Dst, r, a.Org);
        return o >= l;
      }),
      (t.deleteRegion = function (e, i) {
        i.fixUpperEdge && rt(i.eUp.winding === 0),
          (i.eUp.activeRegion = null),
          e.dict.delete(i.nodeUp);
      }),
      (t.fixUpperEdge = function (e, i, n) {
        rt(i.fixUpperEdge),
          e.mesh.delete(i.eUp),
          (i.fixUpperEdge = !1),
          (i.eUp = n),
          (n.activeRegion = i);
      }),
      (t.topLeftRegion = function (e, i) {
        var n = i.eUp.Org,
          r;
        do i = t.regionAbove(i);
        while (i.eUp.Org === n);
        if (i.fixUpperEdge) {
          if (
            ((r = e.mesh.connect(t.regionBelow(i).eUp.Sym, i.eUp.Lnext)),
            r === null)
          )
            return null;
          t.fixUpperEdge(e, i, r), (i = t.regionAbove(i));
        }
        return i;
      }),
      (t.topRightRegion = function (e) {
        var i = e.eUp.Dst;
        do e = t.regionAbove(e);
        while (e.eUp.Dst === i);
        return e;
      }),
      (t.addRegionBelow = function (e, i, n) {
        var r = new ju();
        return (
          (r.eUp = n),
          (r.nodeUp = e.dict.insertBefore(i.nodeUp, r)),
          (r.fixUpperEdge = !1),
          (r.sentinel = !1),
          (r.dirty = !1),
          (n.activeRegion = r),
          r
        );
      }),
      (t.isWindingInside = function (e, i) {
        switch (e.windingRule) {
          case Vt.ODD:
            return (i & 1) !== 0;
          case Vt.NONZERO:
            return i !== 0;
          case Vt.POSITIVE:
            return i > 0;
          case Vt.NEGATIVE:
            return i < 0;
          case Vt.ABS_GEQ_TWO:
            return i >= 2 || i <= -2;
        }
        throw new Error("Invalid winding rulle");
      }),
      (t.computeWinding = function (e, i) {
        (i.windingNumber = t.regionAbove(i).windingNumber + i.eUp.winding),
          (i.inside = t.isWindingInside(e, i.windingNumber));
      }),
      (t.finishRegion = function (e, i) {
        var n = i.eUp,
          r = n.Lface;
        (r.inside = i.inside), (r.anEdge = n), t.deleteRegion(e, i);
      }),
      (t.finishLeftRegions = function (e, i, n) {
        for (var r, s = null, a = i, o = i.eUp; a !== n; ) {
          if (
            ((a.fixUpperEdge = !1),
            (s = t.regionBelow(a)),
            (r = s.eUp),
            r.Org != o.Org)
          ) {
            if (!s.fixUpperEdge) {
              t.finishRegion(e, a);
              break;
            }
            (r = e.mesh.connect(o.Lprev, r.Sym)), t.fixUpperEdge(e, s, r);
          }
          o.Onext !== r && (e.mesh.splice(r.Oprev, r), e.mesh.splice(o, r)),
            t.finishRegion(e, a),
            (o = s.eUp),
            (a = s);
        }
        return o;
      }),
      (t.addRightEdges = function (e, i, n, r, s, a) {
        var o,
          l,
          c,
          d,
          h = !0;
        c = n;
        do
          rt(Ke.vertLeq(c.Org, c.Dst)),
            t.addRegionBelow(e, i, c.Sym),
            (c = c.Onext);
        while (c !== r);
        for (
          s === null && (s = t.regionBelow(i).eUp.Rprev), l = i, d = s;
          (o = t.regionBelow(l)), (c = o.eUp.Sym), c.Org === d.Org;

        )
          c.Onext !== d &&
            (e.mesh.splice(c.Oprev, c), e.mesh.splice(d.Oprev, c)),
            (o.windingNumber = l.windingNumber - c.winding),
            (o.inside = t.isWindingInside(e, o.windingNumber)),
            (l.dirty = !0),
            !h &&
              t.checkForRightSplice(e, l) &&
              (t.addWinding(c, d), t.deleteRegion(e, l), e.mesh.delete(d)),
            (h = !1),
            (l = o),
            (d = c);
        (l.dirty = !0),
          rt(l.windingNumber - c.winding === o.windingNumber),
          a && t.walkDirtyRegions(e, l);
      }),
      (t.spliceMergeVertices = function (e, i, n) {
        e.mesh.splice(i, n);
      }),
      (t.vertexWeights = function (e, i, n) {
        var r = Ke.vertL1dist(i, e),
          s = Ke.vertL1dist(n, e),
          a = (0.5 * s) / (r + s),
          o = (0.5 * r) / (r + s);
        (e.coords[0] += a * i.coords[0] + o * n.coords[0]),
          (e.coords[1] += a * i.coords[1] + o * n.coords[1]),
          (e.coords[2] += a * i.coords[2] + o * n.coords[2]);
      }),
      (t.getIntersectData = function (e, i, n, r, s, a) {
        (i.coords[0] = i.coords[1] = i.coords[2] = 0),
          (i.idx = -1),
          t.vertexWeights(i, n, r),
          t.vertexWeights(i, s, a);
      }),
      (t.checkForRightSplice = function (e, i) {
        var n = t.regionBelow(i),
          r = i.eUp,
          s = n.eUp;
        if (Ke.vertLeq(r.Org, s.Org)) {
          if (Ke.edgeSign(s.Dst, r.Org, s.Org) > 0) return !1;
          Ke.vertEq(r.Org, s.Org)
            ? r.Org !== s.Org &&
              (e.pq.delete(r.Org.pqHandle),
              t.spliceMergeVertices(e, s.Oprev, r))
            : (e.mesh.splitEdge(s.Sym),
              e.mesh.splice(r, s.Oprev),
              (i.dirty = n.dirty = !0));
        } else {
          if (Ke.edgeSign(r.Dst, s.Org, r.Org) < 0) return !1;
          (t.regionAbove(i).dirty = i.dirty = !0),
            e.mesh.splitEdge(r.Sym),
            e.mesh.splice(s.Oprev, r);
        }
        return !0;
      }),
      (t.checkForLeftSplice = function (e, i) {
        var n = t.regionBelow(i),
          r = i.eUp,
          s = n.eUp,
          a;
        if ((rt(!Ke.vertEq(r.Dst, s.Dst)), Ke.vertLeq(r.Dst, s.Dst))) {
          if (Ke.edgeSign(r.Dst, s.Dst, r.Org) < 0) return !1;
          (t.regionAbove(i).dirty = i.dirty = !0),
            (a = e.mesh.splitEdge(r)),
            e.mesh.splice(s.Sym, a),
            (a.Lface.inside = i.inside);
        } else {
          if (Ke.edgeSign(s.Dst, r.Dst, s.Org) > 0) return !1;
          (i.dirty = n.dirty = !0),
            (a = e.mesh.splitEdge(s)),
            e.mesh.splice(r.Lnext, s.Sym),
            (a.Rface.inside = i.inside);
        }
        return !0;
      }),
      (t.checkForIntersect = function (e, i) {
        var n = t.regionBelow(i),
          r = i.eUp,
          s = n.eUp,
          a = r.Org,
          o = s.Org,
          l = r.Dst,
          c = s.Dst,
          d,
          h,
          u = new Ea(),
          f,
          p;
        if (
          (rt(!Ke.vertEq(c, l)),
          rt(Ke.edgeSign(l, e.event, a) <= 0),
          rt(Ke.edgeSign(c, e.event, o) >= 0),
          rt(a !== e.event && o !== e.event),
          rt(!i.fixUpperEdge && !n.fixUpperEdge),
          a === o ||
            ((d = Math.min(a.t, l.t)), (h = Math.max(o.t, c.t)), d > h))
        )
          return !1;
        if (Ke.vertLeq(a, o)) {
          if (Ke.edgeSign(c, a, o) > 0) return !1;
        } else if (Ke.edgeSign(l, o, a) < 0) return !1;
        return (
          t.debugEvent(e),
          Ke.intersect(l, a, c, o, u),
          rt(Math.min(a.t, l.t) <= u.t),
          rt(u.t <= Math.max(o.t, c.t)),
          rt(Math.min(c.s, l.s) <= u.s),
          rt(u.s <= Math.max(o.s, a.s)),
          Ke.vertLeq(u, e.event) && ((u.s = e.event.s), (u.t = e.event.t)),
          (f = Ke.vertLeq(a, o) ? a : o),
          Ke.vertLeq(f, u) && ((u.s = f.s), (u.t = f.t)),
          Ke.vertEq(u, a) || Ke.vertEq(u, o)
            ? (t.checkForRightSplice(e, i), !1)
            : (!Ke.vertEq(l, e.event) && Ke.edgeSign(l, e.event, u) >= 0) ||
              (!Ke.vertEq(c, e.event) && Ke.edgeSign(c, e.event, u) <= 0)
            ? c === e.event
              ? (e.mesh.splitEdge(r.Sym),
                e.mesh.splice(s.Sym, r),
                (i = t.topLeftRegion(e, i)),
                (r = t.regionBelow(i).eUp),
                t.finishLeftRegions(e, t.regionBelow(i), n),
                t.addRightEdges(e, i, r.Oprev, r, r, !0),
                !0)
              : l === e.event
              ? (e.mesh.splitEdge(s.Sym),
                e.mesh.splice(r.Lnext, s.Oprev),
                (n = i),
                (i = t.topRightRegion(i)),
                (p = t.regionBelow(i).eUp.Rprev),
                (n.eUp = s.Oprev),
                (s = t.finishLeftRegions(e, n, null)),
                t.addRightEdges(e, i, s.Onext, r.Rprev, p, !0),
                !0)
              : (Ke.edgeSign(l, e.event, u) >= 0 &&
                  ((t.regionAbove(i).dirty = i.dirty = !0),
                  e.mesh.splitEdge(r.Sym),
                  (r.Org.s = e.event.s),
                  (r.Org.t = e.event.t)),
                Ke.edgeSign(c, e.event, u) <= 0 &&
                  ((i.dirty = n.dirty = !0),
                  e.mesh.splitEdge(s.Sym),
                  (s.Org.s = e.event.s),
                  (s.Org.t = e.event.t)),
                !1)
            : (e.mesh.splitEdge(r.Sym),
              e.mesh.splitEdge(s.Sym),
              e.mesh.splice(s.Oprev, r),
              (r.Org.s = u.s),
              (r.Org.t = u.t),
              (r.Org.pqHandle = e.pq.insert(r.Org)),
              t.getIntersectData(e, r.Org, a, l, o, c),
              (t.regionAbove(i).dirty = i.dirty = n.dirty = !0),
              !1)
        );
      }),
      (t.walkDirtyRegions = function (e, i) {
        for (var n = t.regionBelow(i), r, s; ; ) {
          for (; n.dirty; ) (i = n), (n = t.regionBelow(n));
          if (
            !i.dirty &&
            ((n = i), (i = t.regionAbove(i)), i === null || !i.dirty)
          )
            return;
          if (
            ((i.dirty = !1),
            (r = i.eUp),
            (s = n.eUp),
            r.Dst !== s.Dst &&
              t.checkForLeftSplice(e, i) &&
              (n.fixUpperEdge
                ? (t.deleteRegion(e, n),
                  e.mesh.delete(s),
                  (n = t.regionBelow(i)),
                  (s = n.eUp))
                : i.fixUpperEdge &&
                  (t.deleteRegion(e, i),
                  e.mesh.delete(r),
                  (i = t.regionAbove(n)),
                  (r = i.eUp))),
            r.Org !== s.Org)
          )
            if (
              r.Dst !== s.Dst &&
              !i.fixUpperEdge &&
              !n.fixUpperEdge &&
              (r.Dst === e.event || s.Dst === e.event)
            ) {
              if (t.checkForIntersect(e, i)) return;
            } else t.checkForRightSplice(e, i);
          r.Org === s.Org &&
            r.Dst === s.Dst &&
            (t.addWinding(s, r),
            t.deleteRegion(e, i),
            e.mesh.delete(r),
            (i = t.regionAbove(n)));
        }
      }),
      (t.connectRightVertex = function (e, i, n) {
        var r,
          s = n.Onext,
          a = t.regionBelow(i),
          o = i.eUp,
          l = a.eUp,
          c = !1;
        if (
          (o.Dst !== l.Dst && t.checkForIntersect(e, i),
          Ke.vertEq(o.Org, e.event) &&
            (e.mesh.splice(s.Oprev, o),
            (i = t.topLeftRegion(e, i)),
            (s = t.regionBelow(i).eUp),
            t.finishLeftRegions(e, t.regionBelow(i), a),
            (c = !0)),
          Ke.vertEq(l.Org, e.event) &&
            (e.mesh.splice(n, l.Oprev),
            (n = t.finishLeftRegions(e, a, null)),
            (c = !0)),
          c)
        ) {
          t.addRightEdges(e, i, n.Onext, s, s, !0);
          return;
        }
        Ke.vertLeq(l.Org, o.Org) ? (r = l.Oprev) : (r = o),
          (r = e.mesh.connect(n.Lprev, r)),
          t.addRightEdges(e, i, r, r.Onext, r.Onext, !1),
          (r.Sym.activeRegion.fixUpperEdge = !0),
          t.walkDirtyRegions(e, i);
      }),
      (t.connectLeftDegenerate = function (e, i, n) {
        var r, s, a, o, l;
        if (((r = i.eUp), Ke.vertEq(r.Org, n))) {
          rt(!1), t.spliceMergeVertices(e, r, n.anEdge);
          return;
        }
        if (!Ke.vertEq(r.Dst, n)) {
          e.mesh.splitEdge(r.Sym),
            i.fixUpperEdge && (e.mesh.delete(r.Onext), (i.fixUpperEdge = !1)),
            e.mesh.splice(n.anEdge, r),
            t.sweepEvent(e, n);
          return;
        }
        rt(!1),
          (i = t.topRightRegion(i)),
          (l = t.regionBelow(i)),
          (a = l.eUp.Sym),
          (s = o = a.Onext),
          l.fixUpperEdge &&
            (rt(s !== a),
            t.deleteRegion(e, l),
            e.mesh.delete(a),
            (a = s.Oprev)),
          e.mesh.splice(n.anEdge, a),
          Ke.edgeGoesLeft(s) || (s = null),
          t.addRightEdges(e, i, a.Onext, o, s, !0);
      }),
      (t.connectLeftVertex = function (e, i) {
        var n,
          r,
          s,
          a,
          o,
          l,
          c = new ju();
        if (
          ((c.eUp = i.anEdge.Sym),
          (n = e.dict.search(c).key),
          (r = t.regionBelow(n)),
          !!r)
        ) {
          if (((a = n.eUp), (o = r.eUp), Ke.edgeSign(a.Dst, i, a.Org) === 0)) {
            t.connectLeftDegenerate(e, n, i);
            return;
          }
          if (
            ((s = Ke.vertLeq(o.Dst, a.Dst) ? n : r), n.inside || s.fixUpperEdge)
          ) {
            if (s === n) l = e.mesh.connect(i.anEdge.Sym, a.Lnext);
            else {
              var d = e.mesh.connect(o.Dnext, i.anEdge);
              l = d.Sym;
            }
            s.fixUpperEdge
              ? t.fixUpperEdge(e, s, l)
              : t.computeWinding(e, t.addRegionBelow(e, n, l)),
              t.sweepEvent(e, i);
          } else t.addRightEdges(e, n, i.anEdge, i.anEdge, null, !0);
        }
      }),
      (t.sweepEvent = function (e, i) {
        (e.event = i), t.debugEvent(e);
        for (var n = i.anEdge; n.activeRegion === null; )
          if (((n = n.Onext), n === i.anEdge)) {
            t.connectLeftVertex(e, i);
            return;
          }
        var r = t.topLeftRegion(e, n.activeRegion);
        rt(r !== null);
        var s = t.regionBelow(r),
          a = s.eUp,
          o = t.finishLeftRegions(e, s, null);
        o.Onext === a
          ? t.connectRightVertex(e, r, o)
          : t.addRightEdges(e, r, o.Onext, a, a, !0);
      }),
      (t.addSentinel = function (e, i, n, r) {
        var s = new ju(),
          a = e.mesh.makeEdge();
        (a.Org.s = n),
          (a.Org.t = r),
          (a.Dst.s = i),
          (a.Dst.t = r),
          (e.event = a.Dst),
          (s.eUp = a),
          (s.windingNumber = 0),
          (s.inside = !1),
          (s.fixUpperEdge = !1),
          (s.sentinel = !0),
          (s.dirty = !1),
          (s.nodeUp = e.dict.insert(s));
      }),
      (t.initEdgeDict = function (e) {
        e.dict = new lz(e, t.edgeLeq);
        var i = e.bmax[0] - e.bmin[0],
          n = e.bmax[1] - e.bmin[1],
          r = e.bmin[0] - i,
          s = e.bmax[0] + i,
          a = e.bmin[1] - n,
          o = e.bmax[1] + n;
        t.addSentinel(e, r, s, a), t.addSentinel(e, r, s, o);
      }),
      (t.doneEdgeDict = function (e) {
        for (var i, n = 0; (i = e.dict.min().key) !== null; )
          i.sentinel || (rt(i.fixUpperEdge), rt(++n === 1)),
            rt(i.windingNumber === 0),
            t.deleteRegion(e, i);
      }),
      (t.removeDegenerateEdges = function (e) {
        var i,
          n,
          r,
          s = e.mesh.eHead;
        for (i = s.next; i !== s; i = n)
          (n = i.next),
            (r = i.Lnext),
            Ke.vertEq(i.Org, i.Dst) &&
              i.Lnext.Lnext !== i &&
              (t.spliceMergeVertices(e, r, i),
              e.mesh.delete(i),
              (i = r),
              (r = i.Lnext)),
            r.Lnext === i &&
              (r !== i &&
                ((r === n || r === n.Sym) && (n = n.next), e.mesh.delete(r)),
              (i === n || i === n.Sym) && (n = n.next),
              e.mesh.delete(i));
      }),
      (t.initPriorityQ = function (e) {
        var i,
          n,
          r,
          s = 0;
        for (r = e.mesh.vHead, n = r.next; n !== r; n = n.next) s++;
        for (
          s += 8,
            i = e.pq = new oz(s, Ke.vertLeq),
            r = e.mesh.vHead,
            n = r.next;
          n !== r;
          n = n.next
        )
          n.pqHandle = i.insert(n);
        return n !== r ? !1 : (i.init(), !0);
      }),
      (t.donePriorityQ = function (e) {
        e.pq = null;
      }),
      (t.removeDegenerateFaces = function (e, i) {
        var n, r, s;
        for (n = i.fHead.next; n !== i.fHead; n = r)
          (r = n.next),
            (s = n.anEdge),
            rt(s.Lnext !== s),
            s.Lnext.Lnext === s && (t.addWinding(s.Onext, s), e.mesh.delete(s));
        return !0;
      }),
      (t.computeInterior = function (e, i) {
        i === void 0 && (i = !0);
        var n, r;
        if ((t.removeDegenerateEdges(e), !t.initPriorityQ(e))) return !1;
        for (t.initEdgeDict(e); (n = e.pq.extractMin()) !== null; ) {
          for (; (r = e.pq.min()), !(r === null || !Ke.vertEq(r, n)); )
            (r = e.pq.extractMin()),
              t.spliceMergeVertices(e, n.anEdge, r.anEdge);
          t.sweepEvent(e, n);
        }
        return (
          (e.event = e.dict.min().key.eUp.Org),
          t.debugEvent(e),
          t.doneEdgeDict(e),
          t.donePriorityQ(e),
          t.removeDegenerateFaces(e, e.mesh) ? (i && e.mesh.check(), !0) : !1
        );
      }),
      t
    );
  })(),
  hz = (function () {
    function t() {
      (this.mesh = new hv()),
        (this.normal = [0, 0, 0]),
        (this.sUnit = [0, 0, 0]),
        (this.tUnit = [0, 0, 0]),
        (this.bmin = [0, 0]),
        (this.bmax = [0, 0]),
        (this.windingRule = Vt.ODD),
        (this.dict = null),
        (this.pq = null),
        (this.event = null),
        (this.vertexIndexCounter = 0),
        (this.vertices = []),
        (this.vertexIndices = []),
        (this.vertexCount = 0),
        (this.elements = []),
        (this.elementCount = 0);
    }
    return (
      (t.prototype.dot_ = function (e, i) {
        return e[0] * i[0] + e[1] * i[1] + e[2] * i[2];
      }),
      (t.prototype.normalize_ = function (e) {
        var i = e[0] * e[0] + e[1] * e[1] + e[2] * e[2];
        if (!i) throw "Zero-size vector!";
        (i = Math.sqrt(i)), (e[0] /= i), (e[1] /= i), (e[2] /= i);
      }),
      (t.prototype.longAxis_ = function (e) {
        var i = 0;
        return (
          Math.abs(e[1]) > Math.abs(e[0]) && (i = 1),
          Math.abs(e[2]) > Math.abs(e[i]) && (i = 2),
          i
        );
      }),
      (t.prototype.computeNormal_ = function (e) {
        var i,
          n,
          r,
          s,
          a,
          o,
          l = [0, 0, 0],
          c = [0, 0, 0],
          d = [0, 0, 0],
          h = [0, 0, 0],
          u = [0, 0, 0],
          f = [null, null, null],
          p = [null, null, null],
          v = this.mesh.vHead;
        i = v.next;
        for (var g = 0; g < 3; ++g)
          (s = i.coords[g]), (c[g] = s), (p[g] = i), (l[g] = s), (f[g] = i);
        for (i = v.next; i !== v; i = i.next)
          for (var m = 0; m < 3; ++m)
            (s = i.coords[m]),
              s < c[m] && ((c[m] = s), (p[m] = i)),
              s > l[m] && ((l[m] = s), (f[m] = i));
        var x = 0;
        if (
          (l[1] - c[1] > l[0] - c[0] && (x = 1),
          l[2] - c[2] > l[x] - c[x] && (x = 2),
          c[x] >= l[x])
        ) {
          (e[0] = 0), (e[1] = 0), (e[2] = 1);
          return;
        }
        for (
          o = 0,
            n = p[x],
            r = f[x],
            d[0] = n.coords[0] - r.coords[0],
            d[1] = n.coords[1] - r.coords[1],
            d[2] = n.coords[2] - r.coords[2],
            i = v.next;
          i !== v;
          i = i.next
        )
          (h[0] = i.coords[0] - r.coords[0]),
            (h[1] = i.coords[1] - r.coords[1]),
            (h[2] = i.coords[2] - r.coords[2]),
            (u[0] = d[1] * h[2] - d[2] * h[1]),
            (u[1] = d[2] * h[0] - d[0] * h[2]),
            (u[2] = d[0] * h[1] - d[1] * h[0]),
            (a = u[0] * u[0] + u[1] * u[1] + u[2] * u[2]),
            a > o && ((o = a), (e[0] = u[0]), (e[1] = u[1]), (e[2] = u[2]));
        o <= 0 && ((e[0] = e[1] = e[2] = 0), (e[this.longAxis_(d)] = 1));
      }),
      (t.prototype.checkOrientation_ = function () {
        for (
          var e = this.mesh.fHead, i, n = this.mesh.vHead, r, s = 0, a = e.next;
          a !== e;
          a = a.next
        )
          if (((r = a.anEdge), !(r.winding <= 0)))
            do (s += (r.Org.s - r.Dst.s) * (r.Org.t + r.Dst.t)), (r = r.Lnext);
            while (r !== a.anEdge);
        if (s < 0) {
          for (i = n.next; i !== n; i = i.next) i.t = -i.t;
          (this.tUnit[0] = -this.tUnit[0]),
            (this.tUnit[1] = -this.tUnit[1]),
            (this.tUnit[2] = -this.tUnit[2]);
        }
      }),
      (t.prototype.projectPolygon_ = function () {
        var e = this.mesh.vHead,
          i = [0, 0, 0],
          n,
          r,
          s = !1;
        (i[0] = this.normal[0]),
          (i[1] = this.normal[1]),
          (i[2] = this.normal[2]),
          !i[0] && !i[1] && !i[2] && (this.computeNormal_(i), (s = !0)),
          (n = this.sUnit),
          (r = this.tUnit);
        var a = this.longAxis_(i);
        (n[a] = 0),
          (n[(a + 1) % 3] = 1),
          (n[(a + 2) % 3] = 0),
          (r[a] = 0),
          (r[(a + 1) % 3] = 0),
          (r[(a + 2) % 3] = i[a] > 0 ? 1 : -1);
        for (var o = e.next; o !== e; o = o.next)
          (o.s = this.dot_(o.coords, n)), (o.t = this.dot_(o.coords, r));
        s && this.checkOrientation_();
        for (var l = !0, c = e.next; c !== e; c = c.next)
          l
            ? ((this.bmin[0] = this.bmax[0] = c.s),
              (this.bmin[1] = this.bmax[1] = c.t),
              (l = !1))
            : (c.s < this.bmin[0] && (this.bmin[0] = c.s),
              c.s > this.bmax[0] && (this.bmax[0] = c.s),
              c.t < this.bmin[1] && (this.bmin[1] = c.t),
              c.t > this.bmax[1] && (this.bmax[1] = c.t));
      }),
      (t.prototype.addWinding_ = function (e, i) {
        (e.winding += i.winding), (e.Sym.winding += i.Sym.winding);
      }),
      (t.prototype.tessellateMonoRegion_ = function (e, i) {
        var n, r;
        if (((n = i.anEdge), !(n.Lnext !== n && n.Lnext.Lnext !== n)))
          throw "Mono region invalid";
        for (; Ke.vertLeq(n.Dst, n.Org); n = n.Lprev);
        for (; Ke.vertLeq(n.Org, n.Dst); n = n.Lnext);
        r = n.Lprev;
        for (var s = void 0; n.Lnext !== r; )
          if (Ke.vertLeq(n.Dst, r.Org)) {
            for (
              ;
              r.Lnext !== n &&
              (Ke.edgeGoesLeft(r.Lnext) ||
                Ke.edgeSign(r.Org, r.Dst, r.Lnext.Dst) <= 0);

            )
              (s = e.connect(r.Lnext, r)), (r = s.Sym);
            r = r.Lprev;
          } else {
            for (
              ;
              r.Lnext !== n &&
              (Ke.edgeGoesRight(n.Lprev) ||
                Ke.edgeSign(n.Dst, n.Org, n.Lprev.Org) >= 0);

            )
              (s = e.connect(n, n.Lprev)), (n = s.Sym);
            n = n.Lnext;
          }
        if (r.Lnext === n) throw "Mono region invalid";
        for (; r.Lnext.Lnext !== n; ) (s = e.connect(r.Lnext, r)), (r = s.Sym);
        return !0;
      }),
      (t.prototype.tessellateInterior_ = function (e) {
        for (var i, n = e.fHead.next; n !== e.fHead; n = i)
          if (((i = n.next), n.inside && !this.tessellateMonoRegion_(e, n)))
            return !1;
        return !0;
      }),
      (t.prototype.discardExterior_ = function (e) {
        for (var i, n = e.fHead.next; n !== e.fHead; n = i)
          (i = n.next), n.inside || e.zapFace(n);
      }),
      (t.prototype.setWindingNumber_ = function (e, i, n) {
        for (var r, s = e.eHead.next; s !== e.eHead; s = r)
          (r = s.next),
            s.Rface.inside !== s.Lface.inside
              ? (s.winding = s.Lface.inside ? i : -i)
              : n
              ? e.delete(s)
              : (s.winding = 0);
      }),
      (t.prototype.getNeighbourFace_ = function (e) {
        return !e.Rface || !e.Rface.inside ? -1 : e.Rface.n;
      }),
      (t.prototype.outputPolymesh_ = function (e, i, n, r) {
        var s,
          a = 0,
          o = 0,
          l;
        n > 3 && e.mergeConvexFaces(n);
        for (var c = e.vHead.next; c !== e.vHead; c = c.next) c.n = -1;
        for (var d = e.fHead.next; d !== e.fHead; d = d.next)
          if (((d.n = -1), !!d.inside)) {
            (s = d.anEdge), (l = 0);
            do {
              var c = s.Org;
              c.n === -1 && ((c.n = o), o++), l++, (s = s.Lnext);
            } while (s !== d.anEdge);
            if (l > n) throw "Face vertex greater that support polygon";
            (d.n = a), ++a;
          }
        (this.elementCount = a),
          i === mi.CONNECTED_POLYGONS && (a *= 2),
          (this.elements = []),
          (this.elements.length = a * n),
          (this.vertexCount = o),
          (this.vertices = []),
          (this.vertices.length = o * r),
          (this.vertexIndices = []),
          (this.vertexIndices.length = o);
        for (var c = e.vHead.next; c !== e.vHead; c = c.next)
          if (c.n !== -1) {
            var h = c.n * r;
            (this.vertices[h + 0] = c.coords[0]),
              (this.vertices[h + 1] = c.coords[1]),
              r > 2 && (this.vertices[h + 2] = c.coords[2]),
              (this.vertexIndices[c.n] = c.idx);
          }
        for (var u = 0, d = e.fHead.next; d !== e.fHead; d = d.next)
          if (d.inside) {
            (s = d.anEdge), (l = 0);
            do {
              var c = s.Org;
              (this.elements[u++] = c.n), l++, (s = s.Lnext);
            } while (s !== d.anEdge);
            for (var f = l; f < n; ++f) this.elements[u++] = -1;
            if (i === mi.CONNECTED_POLYGONS) {
              s = d.anEdge;
              do
                (this.elements[u++] = this.getNeighbourFace_(s)), (s = s.Lnext);
              while (s !== d.anEdge);
              for (var p = l; p < n; ++p) this.elements[u++] = -1;
            }
          }
      }),
      (t.prototype.outputContours_ = function (e, i) {
        var n,
          r,
          s = 0,
          a = 0;
        (this.vertexCount = 0), (this.elementCount = 0);
        for (var o = e.fHead.next; o !== e.fHead; o = o.next)
          if (o.inside) {
            r = n = o.anEdge;
            do this.vertexCount++, (n = n.Lnext);
            while (n !== r);
            this.elementCount++;
          }
        (this.elements = []),
          (this.elements.length = this.elementCount * 2),
          (this.vertices = []),
          (this.vertices.length = this.vertexCount * i),
          (this.vertexIndices = []),
          (this.vertexIndices.length = this.vertexCount);
        var l = 0,
          c = 0,
          d = 0;
        s = 0;
        for (var o = e.fHead.next; o !== e.fHead; o = o.next)
          if (o.inside) {
            (a = 0), (r = n = o.anEdge);
            do
              (this.vertices[l++] = n.Org.coords[0]),
                (this.vertices[l++] = n.Org.coords[1]),
                i > 2 && (this.vertices[l++] = n.Org.coords[2]),
                (this.vertexIndices[c++] = this.vertexIdCallback
                  ? this.vertexIdCallback(n)
                  : n.Org.idx),
                a++,
                (n = n.Lnext);
            while (n !== r);
            (this.elements[d++] = s), (this.elements[d++] = a), (s += a);
          }
      }),
      (t.prototype.addContour = function (e, i) {
        this.mesh === null && (this.mesh = new hv()),
          e < 2 && (e = 2),
          e > 3 && (e = 3);
        for (var n = null, r = 0; r < i.length; r += e)
          n === null
            ? ((n = this.mesh.makeEdge()), this.mesh.splice(n, n.Sym))
            : (this.mesh.splitEdge(n), (n = n.Lnext)),
            (n.Org.coords[0] = i[r + 0]),
            (n.Org.coords[1] = i[r + 1]),
            e > 2 ? (n.Org.coords[2] = i[r + 2]) : (n.Org.coords[2] = 0),
            (n.Org.idx = this.vertexIndexCounter++),
            this.edgeCreateCallback && this.edgeCreateCallback(n),
            (n.winding = 1),
            (n.Sym.winding = -1);
      }),
      (t.prototype.tesselate = function (e, i, n, r, s, a) {
        if (
          (e === void 0 && (e = Vt.ODD),
          i === void 0 && (i = mi.POLYGONS),
          a === void 0 && (a = !0),
          (this.vertices = []),
          (this.elements = []),
          (this.vertexIndices = []),
          (this.vertexIndexCounter = 0),
          s &&
            ((this.normal[0] = s[0]),
            (this.normal[1] = s[1]),
            (this.normal[2] = s[2])),
          (this.windingRule = e),
          r < 2 && (r = 2),
          r > 3 && (r = 3),
          !this.mesh)
        )
          return !1;
        this.projectPolygon_(), cz.computeInterior(this, a);
        var o = this.mesh;
        return (
          i === mi.BOUNDARY_CONTOURS
            ? this.setWindingNumber_(o, 1, !0)
            : this.tessellateInterior_(o),
          a && o.check(),
          i === mi.BOUNDARY_CONTOURS
            ? this.outputContours_(o, r)
            : this.outputPolymesh_(o, i, n, r),
          !0
        );
      }),
      t
    );
  })();
function is(t) {
  var e = t.windingRule,
    i = e === void 0 ? Vt.ODD : e,
    n = t.elementType,
    r = n === void 0 ? mi.POLYGONS : n,
    s = t.polySize,
    a = s === void 0 ? 3 : s,
    o = t.vertexSize,
    l = o === void 0 ? 2 : o,
    c = t.normal,
    d = c === void 0 ? [0, 0, 1] : c,
    h = t.contours,
    u = h === void 0 ? [] : h,
    f = t.strict,
    p = f === void 0 ? !0 : f,
    v = t.debug,
    g = v === void 0 ? !1 : v;
  if (!u && p) throw new Error("Contours can't be empty");
  if (u) {
    var m = new hz();
    t.edgeCreateCallback && (m.edgeCreateCallback = t.edgeCreateCallback),
      t.vertexIdCallback && (m.vertexIdCallback = t.vertexIdCallback);
    for (var x = 0; x < u.length; x++) m.addContour(l || 2, u[x]);
    return (
      m.tesselate(i, r, a, l, d, p),
      {
        vertices: m.vertices,
        vertexIndices: m.vertexIndices,
        vertexCount: m.vertexCount,
        elements: m.elements,
        elementCount: m.elementCount,
        mesh: g ? m.mesh : void 0,
      }
    );
  }
}
Vt.ODD;
Vt.NONZERO;
Vt.POSITIVE;
Vt.NEGATIVE;
Vt.ABS_GEQ_TWO;
mi.POLYGONS;
mi.CONNECTED_POLYGONS;
mi.BOUNDARY_CONTOURS;
var ff = class {
    constructor(t = 256, e = !1) {
      (this.capacity = t),
        (this.size = 0),
        (this.debug = e),
        this.debug && console.log(`allocating with cap ${t}`);
      let i = t * ff.eSize;
      this.buffer = new ArrayBuffer(i);
      let n = Float32Array.BYTES_PER_ELEMENT,
        r = 0;
      (this.positions = new Float32Array(this.buffer, r * n, 3 * t)),
        (r += 3 * t),
        (this.normals = new Float32Array(this.buffer, r * n, 3 * t)),
        (r += 3 * t),
        (this.uvs = new Float32Array(this.buffer, r * n, 2 * t));
    }
    realloc(t, e = !1) {
      if (t < this.size) throw Error("cannot shrink buffer");
      if (t <= this.capacity && !e) return;
      this.debug && console.log(`resizing from ${this.capacity} → ${t}`);
      let i = t * ff.eSize,
        n = new ArrayBuffer(i),
        r = Float32Array.BYTES_PER_ELEMENT,
        s = 0,
        a = new Float32Array(n, s * r, 3 * t);
      s += 3 * t;
      let o = new Float32Array(n, s * r, 3 * t);
      s += 3 * t;
      let l = new Float32Array(n, s * r, 2 * t);
      e
        ? (a.set(this.positions.subarray(0, this.size * 3)),
          o.set(this.normals.subarray(0, this.size * 3)),
          l.set(this.uvs.subarray(0, this.size * 2)))
        : (a.set(this.positions), o.set(this.normals), l.set(this.uvs)),
        (this.buffer = n),
        (this.positions = a),
        (this.normals = o),
        (this.uvs = l),
        (this.capacity = t);
    }
    get(t = 1) {
      let e = this.size + t;
      if (e > this.capacity) {
        let n = this.capacity;
        for (; e > n; ) n *= 2;
        this.realloc(n);
      }
      let i = this.size;
      return (this.size = e), i;
    }
    reserve(t) {
      let e = this.size + t;
      e > this.capacity && this.realloc(e);
    }
    shrink() {
      this.debug && console.log(`shrinking ${this.capacity} → ${this.size}`),
        this.realloc(this.size, !0);
    }
  },
  z_ = ff;
z_.eSize = (3 + 3 + 2) * Float32Array.BYTES_PER_ELEMENT;
var uz = wl(pC()),
  Up = {
    vertices: [160, 160, -160, 160, -160, -160, 160, -160],
    vertexIndices: [1, 0, 3, 2],
    vertexCount: 4,
    elements: [0, 4],
    elementCount: 1,
    mesh: void 0,
  },
  B_ = {
    vertices: [],
    vertexIndices: [],
    vertexCount: 0,
    elements: [],
    elementCount: 0,
    mesh: void 0,
  },
  F_ = {
    vertices: [-160, 160, 160, -160, 160, 160, -160, -160],
    vertexIndices: [1, 3, 0, 2],
    vertexCount: 4,
    elements: [0, 1, 2, 1, 0, 3],
    elementCount: 2,
    mesh: void 0,
  },
  Wu =
    (t, e) =>
    ([i, n]) => (n < i && (n += e), (t >= i ? t : t + e) <= n),
  Np = class extends st {
    constructor(t, e, i = 0, n = 12, r = 3, s = Vt.ODD, a = !1) {
      super(),
        (this.forPathBevel = a),
        (this.type = "ShapeGeometry"),
        (this.vertexCache = {}),
        (this._shape = t),
        (this._depth = e),
        (this._curveSegments = n),
        (this._bevelSegmentsInput = r);
      let o = this._shape.extractShapePointsToFlatArray([], n),
        l = this._shape.shapeHoles.map((S) => {
          let w = S.extractShapePointsToFlatArray([], n),
            C = [];
          for (let L = w.length - 1; L >= 1; L -= 2) {
            let P = w[L - 1],
              R = w[L - 0];
            C.push(P, R);
          }
          return C;
        }),
        c = [],
        d = [];
      for (let S = 0; S < o.length; S += 2) d.push([o[S], o[S + 1]]);
      c.push(d);
      for (let S = 0; S < l.length; S++) {
        let w = l[S],
          C = [];
        for (let L = 0; L < w.length; L += 2) C.push([w[L], w[L + 1]]);
        c.push(C);
      }
      let h = c[0].length ? (0, uz.default)(c).distance : i;
      i <= 0
        ? ((this._bevel = 0), (this._bevelSegments = 0))
        : ((this._bevel = Math.min(i, h, e / 2)),
          (this._bevelSegments = Math.floor(r)));
      let u;
      try {
        u = is({
          windingRule: s,
          elementType: mi.BOUNDARY_CONTOURS,
          vertexSize: 2,
          strict: !0,
          contours: [o],
        });
      } catch {
        u = Up;
      }
      let f;
      try {
        f = is({
          windingRule: Vt.ODD,
          elementType: mi.BOUNDARY_CONTOURS,
          vertexSize: 2,
          strict: !0,
          contours: [...l],
        });
      } catch {
        f = B_;
      }
      if (!u) throw new Error("error generating geometry");
      let p = u.elementCount;
      if (f) {
        u.elementCount += f.elementCount;
        for (let S = 0; S < f.elements.length; S++) {
          let w = f.elements[S],
            C = S % 2 === 0 ? u.vertexCount : 0;
          u.elements.push(w + C);
        }
        for (let S = 0; S < f.vertexIndices.length; S++) {
          let w = f.vertexIndices[S],
            C = u.vertexCount;
          u.vertexIndices.push(w + C);
        }
        for (let S = 0; S < f.vertices.length; S++) {
          let w = f.vertices[S];
          u.vertices.push(w);
        }
      }
      let v = 1 / 0,
        g = -1 / 0,
        m = 1 / 0,
        x = -1 / 0;
      for (let S = 0, w = u.vertexCount; S < w; S++) {
        let C = S * 2,
          L = u.vertices[C + 0],
          P = u.vertices[C + 1];
        L < v && (v = L), L > g && (g = L), P < m && (m = P), P > x && (x = P);
      }
      (this._minX = v),
        (this._minY = m),
        (this._width = g - v),
        (this._height = x - m),
        (this._buffer = new z_(this._computeBufferEstimatedSize(u)));
      let y = [],
        _ = [];
      for (let S = u.elementCount - 1; S >= 0; S--) {
        let w = S >= p,
          C = S * 2,
          L = u.elements[C + 0],
          P = u.elements[C + 1],
          R = L + P,
          I = { start: L, count: P, normals: [], continuous: [], concave: [] },
          W = L,
          N = R - 1,
          U = L + 1,
          G = this._shape.roundedCurves.length;
        do {
          let H = W - L,
            j = u.vertices[N * 2 + 0],
            Y = u.vertices[N * 2 + 1],
            ee = u.vertices[W * 2 + 0],
            Z = u.vertices[W * 2 + 1],
            K = u.vertices[U * 2 + 0],
            me = u.vertices[U * 2 + 1],
            re = ee - j,
            F = Z - Y,
            Te = Math.sqrt(re * re + F * F);
          (re /= Te), (F /= Te);
          let be = ee - K,
            oe = Z - me,
            Me = Math.sqrt(be * be + oe * oe);
          (be /= Me),
            (oe /= Me),
            (I.normals[H * 2 + 0] = -oe),
            (I.normals[H * 2 + 1] = be),
            (I.concave[H] = re * oe - F * be > 0);
          let Ae = u.vertexIndices[W];
          if (Array.isArray(Ae)) I.continuous[H] = !1;
          else {
            let [ye, _e] = this._shape.getCurveIndexFromVertexId(Ae - 1, !0);
            if (_e > 0 && _e < 1) I.continuous[H] = !0;
            else {
              let Ee = _e === 1 ? ye + 1 : ye - 1;
              Ee = (Ee + G) % G;
              let Le = _e === 1 ? 0 : 1,
                it = this._shape.roundedCurves[ye].getTangent(_e),
                O = this._shape.roundedCurves[Ee].getTangent(Le);
              I.continuous[H] = it.dot(O) > 0.95;
            }
          }
          w && ((I.normals[H * 2 + 0] *= -1), (I.normals[H * 2 + 1] *= -1)),
            ([N, W, U] = [W, U, U + 1]),
            U >= R && (U -= P);
        } while (U !== L + 1);
        let k = [];
        k.push({
          bevelI: 0,
          angle: 0,
          size: 0,
          boundary: {
            vertices: u.vertices.slice(L * 2, R * 2),
            vertexCount: P,
            vertexIndices: new Array(P).fill(!0).map((H, j) => [j, j]),
            elements: [0, P],
            elementCount: 1,
            mesh: null,
          },
          reverseMap: [],
          insetPoints: u.vertices.slice(L * 2, R * 2),
        });
        let B = 0;
        for (let H = 1; H <= this._bevelSegments; H++) {
          let j = ((H / this._bevelSegments) * Math.PI) / 2,
            Y = (1 - Math.cos(j)) * this._bevel,
            ee = [],
            Z = [],
            K = 0;
          for (let re = 0; re < P; re++) {
            let F = re * 2,
              Te = ((re - 1 + P) % P) * 2,
              be = u.vertices[I.start * 2 + F + 0],
              oe = u.vertices[I.start * 2 + F + 1],
              Me = -I.normals[Te + 0] * Y,
              Ae = -I.normals[Te + 1] * Y,
              ye = -I.normals[F + 0] * Y,
              _e = -I.normals[F + 1] * Y;
            if (I.concave[re] || (!I.concave[re] && w)) {
              let Ee = Math.atan2(Ae, Me),
                Le = Math.atan2(_e, ye);
              Le > Ee && (Le -= Math.PI * 2);
              let it = Le - Ee;
              if (I.continuous[re] || w) {
                let O = Ee + it / 2,
                  D = Math.cos(O) * Y,
                  ne = Math.sin(O) * Y;
                (ee[2 * K + 0] = be + D * (w ? -1 : 1)),
                  (ee[2 * K + 1] = oe + ne * (w ? -1 : 1)),
                  (Z[K] = re),
                  K++;
              } else {
                let O = Math.max(
                  1,
                  Math.floor(((n / 4) * Math.abs(it)) / Math.PI)
                );
                for (let D = 0; D <= O; D++) {
                  let ne = Ee + it * (D / O),
                    pe = Math.cos(ne) * Y,
                    xe = Math.sin(ne) * Y;
                  (ee[2 * K + 0] = be + pe),
                    (ee[2 * K + 1] = oe + xe),
                    (Z[K] = re),
                    K++;
                }
              }
            } else
              (ee[2 * K + 0] = be + Me),
                (ee[2 * K + 1] = oe + Ae),
                (Z[K] = re),
                K++,
                (ee[2 * K + 0] = be),
                (ee[2 * K + 1] = oe),
                (Z[K] = re),
                K++,
                (ee[2 * K + 0] = be + ye),
                (ee[2 * K + 1] = oe + _e),
                (Z[K] = re),
                K++;
          }
          let me = is({
            windingRule: Vt.POSITIVE,
            elementType: mi.BOUNDARY_CONTOURS,
            vertexSize: 2,
            strict: !0,
            contours: [ee],
            edgeCreateCallback: (re) => {
              let F = re.Org.idx,
                Te = Z[F],
                be = Z[(F + 1) % Z.length];
              (re.idx = [Te, be]), (re.Sym.idx = [be, Te]);
            },
            vertexIdCallback: (re) => {
              let F = re.Lprev.idx;
              return [F ? F[1] : 0, re.idx ? re.idx[0] : 0];
            },
          });
          if (!me)
            throw (
              (console.log("Error"),
              new Error(`error generating bevel geometry for ${H}'th loop`))
            );
          if (!me.vertexCount) {
            let re = (((H - 1) / this._bevelSegments) * Math.PI) / 2;
            B = (1 - Math.sin(re)) * this._bevel;
            break;
          }
          for (let re = 0; re < me.vertexIndices.length; re++) {
            let [F, Te] = me.vertexIndices[re];
            if (F === Te) continue;
            let be = Te;
            Te < F && (be += P);
            for (let oe = F; oe < be; oe++) {
              let Me = oe % P,
                Ae = (oe + 1) % P;
              if (!I.continuous[Me] || !I.continuous[Ae]) {
                (me.vertexIndices[re] = [F, Me]),
                  me.vertexIndices.splice(re + 1, 0, [Ae, Te]),
                  me.vertices.splice(
                    (re + 1) * 2,
                    0,
                    me.vertices[re * 2],
                    me.vertices[re * 2 + 1]
                  );
                break;
              }
            }
          }
          k.push({
            bevelI: H,
            angle: j,
            size: Y,
            boundary: me,
            reverseMap: Z,
            insetPoints: ee,
          });
        }
        let V = (H, j, Y) => {
            let ee = 0,
              Z = H.boundary.vertexIndices.length;
            for (; ee < Z && Y(H.boundary.vertexIndices[j]); )
              (j = (j + 1) % Z), ee++;
            return ee;
          },
          X = y.length;
        for (let H = 1; H < k.length; H++) {
          let j = k[H - 1],
            Y = k[H],
            ee = j.boundary.vertexIndices.length,
            Z = Y.boundary.vertexIndices.length;
          if (!ee || !Z) break;
          let K = I.concave.length,
            me = 0,
            re = Wu(me, P);
          for (
            ;
            !j.boundary.vertexIndices.filter(re).length ||
            !Y.boundary.vertexIndices.filter(re).length;

          )
            me++, (re = Wu(me, P));
          let F = j.boundary.vertexIndices.findIndex(re),
            Te = Y.boundary.vertexIndices.findIndex(re);
          do F = (F + 1) % ee;
          while (re(j.boundary.vertexIndices[F]));
          do Te = (Te + 1) % Z;
          while (re(Y.boundary.vertexIndices[Te]));
          me = (me + 1) % P;
          let be = me,
            oe = 0,
            Me = this._buildBevelVert(I, j, (F - 1 + ee) % ee, void 0, oe),
            Ae = this._buildBevelVert(I, Y, (Te - 1 + Z) % Z, void 0, oe),
            ye = Me,
            _e = Ae,
            Ee,
            Le,
            it = !1;
          do {
            (oe = (me || K) / K), (re = Wu(me, P));
            let O = V(j, F, re),
              D = V(Y, Te, re),
              ne = it;
            if (((it = !1), O && !D)) {
              for (let pe = 0; pe < O; pe++)
                (Ee = this._buildBevelVert(
                  I,
                  j,
                  (F + pe) % ee,
                  pe / (O - 1),
                  oe
                )),
                  y.push(ye.topN, Ee.topP, _e.topN),
                  a === !1 && y.push(Ee.bottomP, ye.bottomN, _e.bottomN),
                  (ye = Ee);
              it = !0;
            } else if (!O && D)
              for (let pe = 0; pe < D; pe++)
                (Le = this._buildBevelVert(
                  I,
                  Y,
                  (Te + pe) % Z,
                  pe / (D - 1),
                  oe
                )),
                  y.push(_e.topN, ye.topP, Le.topP),
                  a === !1 && y.push(ye.bottomP, _e.bottomN, Le.bottomP),
                  (_e = Le);
            else if (O && D)
              if (
                ((Ee = this._buildBevelVert(I, j, F, 0, oe)),
                (Le = this._buildBevelVert(I, Y, Te, 0, oe)),
                ne
                  ? (y.push(ye.topN, Le.topP, _e.topN),
                    y.push(ye.topN, Ee.topP, Le.topP),
                    a === !1 &&
                      (y.push(Le.bottomP, ye.bottomN, _e.bottomN),
                      y.push(Le.bottomP, Ee.bottomP, ye.bottomN)))
                  : (y.push(_e.topN, ye.topN, Ee.topP),
                    y.push(_e.topN, Ee.topP, Le.topP),
                    a === !1 &&
                      (y.push(Ee.bottomP, ye.bottomN, _e.bottomN),
                      y.push(Ee.bottomP, _e.bottomN, Le.bottomP))),
                (ye = Ee),
                (_e = Le),
                O === D)
              )
                for (let pe = 1; pe < O; pe++)
                  (Ee = this._buildBevelVert(
                    I,
                    j,
                    (F + pe) % ee,
                    pe / (O - 1),
                    oe
                  )),
                    (Le = this._buildBevelVert(
                      I,
                      Y,
                      (Te + pe) % Z,
                      pe / (D - 1),
                      oe
                    )),
                    y.push(ye.topN, Ee.topP, _e.topN),
                    y.push(_e.topN, Ee.topP, Le.topP),
                    a === !1 &&
                      (y.push(Ee.bottomP, ye.bottomN, _e.bottomN),
                      y.push(Ee.bottomP, _e.bottomN, Le.bottomP)),
                    (ye = Ee),
                    (_e = Le);
              else if (O > D) {
                let pe = O / D,
                  xe = 0;
                for (let we = 1; we < O; we++)
                  (Ee = this._buildBevelVert(
                    I,
                    j,
                    (F + we) % ee,
                    we / (O - 1),
                    oe
                  )),
                    y.push(ye.topN, Ee.topP, _e.topN),
                    a === !1 && y.push(Ee.bottomP, ye.bottomN, _e.bottomN),
                    (ye = Ee),
                    we > (xe + 1) * pe &&
                      (xe++,
                      (Le = this._buildBevelVert(
                        I,
                        Y,
                        (Te + xe) % Z,
                        xe / (D - 1),
                        oe
                      )),
                      y.push(_e.topN, Ee.topP, Le.topP),
                      a === !1 && y.push(Ee.bottomP, _e.bottomN, Le.bottomP),
                      (_e = Le));
              } else {
                let pe = D / O,
                  xe = 0;
                for (let we = 1; we < D; we++)
                  (Le = this._buildBevelVert(
                    I,
                    Y,
                    (Te + we) % Z,
                    we / (D - 1),
                    oe
                  )),
                    y.push(_e.topN, Ee.topP, Le.topP),
                    a === !1 && y.push(Ee.bottomP, _e.bottomN, Le.bottomP),
                    (_e = Le),
                    we > (xe + 1) * pe &&
                      (xe++,
                      (Ee = this._buildBevelVert(
                        I,
                        j,
                        (F + xe) % ee,
                        xe / (O - 1),
                        oe
                      )),
                      y.push(ye.topN, Ee.topP, _e.topN),
                      a === !1 && y.push(Ee.bottomP, ye.bottomN, _e.bottomN),
                      (ye = Ee));
              }
            (F = (F + O) % ee), (Te = (Te + D) % Z), (me = (me + 1) % K);
          } while (me !== be);
        }
        if (
          (a === !1 &&
            this._depth > this._bevel * 2 &&
            this._buildWall(k, I, y),
          w)
        ) {
          let H = [];
          for (let j = y.length - 1; j >= X + 2; j -= 3) {
            let Y = y[j - 2],
              ee = y[j - 1],
              Z = y[j - 0];
            H.push(Z, ee, Y);
          }
          y.splice(X, y.length - X, ...H);
        }
        if (w) {
          let H = [];
          for (
            let j = k[k.length - 1].boundary.vertices.length - 1;
            j >= 1;
            j -= 2
          ) {
            let Y = k[k.length - 1].boundary.vertices[j - 1],
              ee = k[k.length - 1].boundary.vertices[j - 0];
            H.push(Y, ee);
          }
          _.push(H);
        }
        if (!w) {
          let H = k[k.length - 1],
            j;
          try {
            j = is({
              windingRule: k.length > 1 ? Vt.POSITIVE : Vt.ODD,
              elementType: mi.POLYGONS,
              vertexSize: 2,
              strict: !0,
              contours: [H.insetPoints, ..._],
            });
          } catch {
            j = F_;
          }
          if (!j) throw new Error("Error generating geometry for surface");
          l.length === 0 &&
            this._bevel < h &&
            Object.assign(this, { useNgonForTopBottomFaceDuringBake: !0 });
          for (let Y = 0; Y < j.elementCount * 3; Y += 3) {
            let ee = this._buildSurfaceVert(j, j.elements[Y + 0], B),
              Z = this._buildSurfaceVert(j, j.elements[Y + 1], B),
              K = this._buildSurfaceVert(j, j.elements[Y + 2], B);
            y.push(ee.top, Z.top, K.top),
              a === !1 && y.push(K.bottom, Z.bottom, ee.bottom);
          }
        }
        this.vertexCache = {};
      }
      this._buffer.shrink();
      let M = new pt(Uint32Array.from(y), 1),
        b = new pt(this._buffer.positions, 3),
        E = new pt(this._buffer.normals, 3),
        T = new pt(this._buffer.uvs, 2);
      (b.needsUpdate = !0),
        (E.needsUpdate = !0),
        (T.needsUpdate = !0),
        (M.needsUpdate = !0),
        this.setAttribute("position", b),
        this.setAttribute("normal", E),
        this.setAttribute("uv", T),
        this.setIndex(M);
    }
    _computeBufferEstimatedSize(t) {
      return t.vertexCount * 2 * (2 + this._bevelSegments);
    }
    _buildWall(t, e, i) {
      let n = t[0];
      for (let r = 0, s = n.boundary.vertexCount; r < s; r++) {
        let a = this._buildBevelVert(e, n, r),
          o = this._buildBevelVert(e, n, (r + 1) % s);
        i.push(o.topP, a.topN, a.bottomN), i.push(o.topP, a.bottomN, o.bottomP);
      }
    }
    _buildSurfaceVert(t, e, i) {
      let n = e.toString();
      if (n in this.vertexCache) return this.vertexCache[n];
      let r = t.vertices[e * 2 + 0],
        s = t.vertices[e * 2 + 1],
        a = (r - this._minX) / this._width,
        o = (s - this._minY) / this._height;
      this.forPathBevel && (o = 1);
      let l = this._buffer.get(this.forPathBevel ? 1 : 2),
        c = l * 3,
        d = l * 2,
        h = { top: l + 0, bottom: l + 1 };
      return (
        (this._buffer.positions[c + 0] = r),
        (this._buffer.positions[c + 1] = s),
        (this._buffer.positions[c + 2] = this.forPathBevel
          ? this._bevel
          : this._depth - i),
        (this._buffer.normals[c + 0] = 0),
        (this._buffer.normals[c + 1] = 0),
        (this._buffer.normals[c + 2] = 1),
        (this._buffer.uvs[d + 0] = a),
        (this._buffer.uvs[d + 1] = o),
        this.forPathBevel === !1 &&
          ((this._buffer.positions[c + 3] = r),
          (this._buffer.positions[c + 4] = s),
          (this._buffer.positions[c + 5] = i),
          (this._buffer.normals[c + 3] = 0),
          (this._buffer.normals[c + 4] = 0),
          (this._buffer.normals[c + 5] = -1),
          (this._buffer.uvs[d + 2] = a),
          (this._buffer.uvs[d + 3] = o)),
        (this.vertexCache[n] = h),
        h
      );
    }
    _buildBevelVert(t, e, i, n = 1, r) {
      let s = `${e.bevelI}:${i}`;
      if (
        s in this.vertexCache &&
        r !== 0 &&
        r !== 1 &&
        (!r || r === this.vertexCache[s].pathBevelUCoord)
      )
        return this.vertexCache[s];
      let [a, o] = e.boundary.vertexIndices[i],
        l,
        c,
        d,
        h;
      a !== o
        ? ((c = a), (l = o), (h = !1), (d = t.continuous[c] && t.continuous[l]))
        : ((l = a),
          (c = (l - 1 + t.count) % t.count),
          (h = t.concave[l] && e.bevelI > 0),
          (d = t.continuous[l] || h));
      let u = Math.cos(e.angle),
        f = Math.sin(e.angle),
        p = i * 2,
        v = l * 2,
        g = c * 2,
        m = e.boundary.vertices[p + 0],
        x = e.boundary.vertices[p + 1],
        y = (1 - f) * this._bevel,
        _ = (m - this._minX) / this._width,
        M = (x - this._minY) / this._height;
      this.forPathBevel && (r !== void 0 && (_ = r), (M = 1));
      let b = t.normals[v + 0],
        E = t.normals[v + 1],
        T = t.normals[g + 0],
        S = t.normals[g + 1];
      if (h) {
        let R = T - b,
          I = S - E;
        (b = b + R * (1 - n)), (E = E + I * (1 - n));
        let W = Math.sqrt(b * b + E * E);
        (b /= W), (E /= W);
      }
      let w = this.forPathBevel
          ? this._buffer.get(d ? 1 : 2)
          : this._buffer.get(d ? 2 : 4),
        C = w * 3,
        L = w * 2,
        P = {
          i,
          fi: l,
          topP: w + 0,
          topN: w + 0,
          bottomP: w + 1,
          bottomN: w + 1,
          pathBevelUCoord: r,
        };
      return (
        (this._buffer.positions[C + 0] = m),
        (this._buffer.positions[C + 1] = x),
        (this._buffer.positions[C + 2] =
          (this.forPathBevel ? this._bevel : this._depth) - y),
        (this._buffer.normals[C + 0] = b * u),
        (this._buffer.normals[C + 1] = E * u),
        (this._buffer.normals[C + 2] = f),
        (this._buffer.uvs[L + 0] = _),
        (this._buffer.uvs[L + 1] = M),
        this.forPathBevel === !1 &&
          ((this._buffer.positions[C + 3] = m),
          (this._buffer.positions[C + 4] = x),
          (this._buffer.positions[C + 5] = y),
          (this._buffer.normals[C + 3] = b * u),
          (this._buffer.normals[C + 4] = E * u),
          (this._buffer.normals[C + 5] = -f),
          (this._buffer.uvs[L + 2] = M),
          (this._buffer.uvs[L + 3] = _)),
        d ||
          (this.forPathBevel
            ? ((w += 1), (C += 3), (L += 2))
            : ((w += 2), (C += 6), (L += 4)),
          (P.topP = w + 0),
          (P.bottomP = w + 1),
          (this._buffer.positions[C + 0] = m),
          (this._buffer.positions[C + 1] = x),
          (this._buffer.positions[C + 2] =
            (this.forPathBevel ? this._bevel : this._depth) - y),
          (this._buffer.normals[C + 0] = T * u),
          (this._buffer.normals[C + 1] = S * u),
          (this._buffer.normals[C + 2] = f),
          (this._buffer.uvs[L + 0] = _),
          (this._buffer.uvs[L + 1] = M),
          this.forPathBevel === !1 &&
            ((this._buffer.positions[C + 3] = m),
            (this._buffer.positions[C + 4] = x),
            (this._buffer.positions[C + 5] = y),
            (this._buffer.normals[C + 3] = T * u),
            (this._buffer.normals[C + 4] = S * u),
            (this._buffer.normals[C + 5] = -f),
            (this._buffer.uvs[L + 2] = M),
            (this._buffer.uvs[L + 3] = _))),
        (this.vertexCache[s] = P),
        P
      );
    }
    clone() {
      let t = new Np(
        this._shape,
        this._depth,
        this._bevel,
        this._curveSegments,
        this._bevelSegmentsInput
      );
      return (t.userData = Oh(this.userData)), t;
    }
  },
  k_ = class extends st {
    constructor(t, e = 12, i = {}) {
      super(),
        (this.type = "ShapeGeometry"),
        (this.windingRule = Vt.ODD),
        (this.elementType = mi.POLYGONS),
        (this.polySize = 3),
        (this.vertexSize = 2),
        (this.strict = !0),
        (this._shape = t),
        (this._curveSegments = e),
        (this._triangulationOptions = Object.assign(
          {
            windingRule: Vt.ODD,
            elementType: mi.POLYGONS,
            polySize: 3,
            vertexSize: 2,
            strict: !0,
          },
          i
        ));
      let n = this._shape.extractShapePointsToFlatArray(
          [],
          this._curveSegments
        ),
        r = this._shape.shapeHoles.map((u) =>
          u.extractShapePointsToFlatArray([], this._curveSegments)
        ),
        s,
        a = !0,
        o = !0,
        l,
        c;
      for (let u = 0, f = n.length / 2; u < f; u++) {
        let p = u * 2,
          v = n[p + 0],
          g = n[p + 1];
        if (
          (l !== void 0 && v !== l && (a = !1),
          c !== void 0 && g !== c && (o = !1),
          (l = v),
          (c = g),
          !a && !o)
        )
          break;
      }
      if (!a && !o)
        try {
          s = is({
            contours: [n, ...r],
            windingRule: this._triangulationOptions.windingRule,
            elementType: this._triangulationOptions.elementType,
            polySize: this._triangulationOptions.polySize,
            vertexSize: this._triangulationOptions.vertexSize,
            strict: this._triangulationOptions.strict,
          });
        } catch {
          s = Up;
        }
      let d = (s == null ? void 0 : s.vertexCount) ?? 1,
        h = (s == null ? void 0 : s.elementCount) ?? 1;
      if (
        ((this._positionAttribute = new pt(new Float32Array(d * 3), 3)),
        (this._normalAttribute = new pt(new Float32Array(d * 3), 3)),
        (this._uvAttribute = new pt(new Float32Array(d * 2), 2)),
        (this._indexAttribute = new pt(new Uint32Array(h * 3), 1)),
        s)
      ) {
        let u = 1 / 0,
          f = -1 / 0,
          p = 1 / 0,
          v = -1 / 0;
        for (let x = 0, y = d; x < y; x++) {
          let _ = x * 2,
            M = s.vertices[_ + 0],
            b = s.vertices[_ + 1];
          M < u && (u = M),
            M > f && (f = M),
            b < p && (p = b),
            b > v && (v = b);
        }
        let g = f - u,
          m = v - p;
        for (let x = 0, y = d; x < y; x++) {
          let _ = x * 2,
            M = s.vertices[_ + 0],
            b = s.vertices[_ + 1],
            E = (M - u) / g,
            T = (b - p) / m;
          this._positionAttribute.setXYZ(x, M, b, 0),
            this._normalAttribute.setXYZ(x, 0, 0, 1),
            this._uvAttribute.setXY(x, E, T);
        }
        for (let x = 0, y = h; x < y; x++) {
          let _ = x * 3,
            M = s.elements[_ + 0],
            b = s.elements[_ + 1],
            E = s.elements[_ + 2];
          this._indexAttribute.setX(_ + 0, M),
            this._indexAttribute.setX(_ + 1, b),
            this._indexAttribute.setX(_ + 2, E);
        }
      }
      this.setAttribute("position", this._positionAttribute),
        this.setAttribute("normal", this._normalAttribute),
        this.setAttribute("uv", this._uvAttribute),
        this.setIndex(this._indexAttribute),
        this.setDrawRange(0, ((s == null ? void 0 : s.elementCount) ?? 1) * 3);
    }
    clone() {
      let t = new k_(this._shape, this._curveSegments);
      return (t.userData = Oh(this.userData)), t;
    }
  },
  V_ = class extends Np {
    constructor(t, e, i = 0, n = 12, r = 3, s = Vt.ODD) {
      super(t, e, i, n, r, s), (this.type = "ShapeGeometry");
    }
    _computeBufferEstimatedSize(t) {
      return t.vertexCount * 2 * (2 + this._bevelSegments);
    }
    _buildWall(t, e, i) {
      let n = t[0];
      for (let r = 0, s = n.boundary.vertexCount; r < s; r++) {
        let a = this._buildBevelVert(e, n, r),
          o = this._buildBevelVert(e, n, (r + 1) % s);
        i.push(o.topP, a.topN, a.bottomN), i.push(o.topP, a.bottomN, o.bottomP);
      }
    }
    clone() {
      let t = new V_(
        this._shape,
        this._depth,
        this._bevel,
        this._curveSegments,
        this._bevelSegmentsInput
      );
      return (t.userData = Oh(this.userData)), t;
    }
  },
  ta = class {
    static create(t) {
      return this.build(this.normalizeInputs(t));
    }
    static normalizeInputs(t, e) {
      var c, d;
      let i = Object.assign(
          {},
          (e == null ? void 0 : e.parameters) ?? {
            width: 100,
            subdivisions: 40,
            roundness: 0,
            extrudeBevelSize: 0,
            extrudeBevelSegments: 3,
            windingRule: Vt.ODD,
          },
          t.parameters
        ),
        n = Math.abs(i.width),
        r = Math.abs(i.height ?? i.width),
        s = Math.abs(i.depth ?? 0),
        a = t.shape ?? (e == null ? void 0 : e.shape),
        o = (a == null ? void 0 : a.roundness) ?? i.roundness;
      a !== void 0 &&
        (a instanceof si
          ? (a.width !== n || a.height !== r) && a.applySize(n, r)
          : (a = new si(n, r).fromJSON(a)),
        ((c = t.parameters) == null ? void 0 : c.roundness) !== void 0 &&
          ((d = t.parameters) == null ? void 0 : d.roundness) > 0 &&
          a.update());
      let l = a ?? new si(n, r);
      return {
        parameters: Object.assign(i, {
          width: n,
          height: r,
          depth: s,
          roundness: o,
        }),
        shape: l,
      };
    }
    static build(t) {
      let {
        depth: e,
        extrudeBevelSize: i,
        extrudeBevelSegments: n,
        subdivisions: r,
        roundness: s,
        windingRule: a,
      } = t.parameters;
      t.shape.roundness = s;
      let o;
      return (
        e <= 0
          ? (o = new k_(t.shape, r, { windingRule: a }))
          : (o = new V_(t.shape, e, i, r, n, a)),
        Object.assign(o, { userData: { ...t, type: "VectorGeometry" } })
      );
    }
  },
  H_ = Math.PI * 2,
  zp = class {
    static create(t) {
      return this.build(this.normalizeInputs(t));
    }
    static normalizeInputs(t, e) {
      let i = Object.assign(
        {},
        (e == null ? void 0 : e.parameters) ?? {
          width: 100,
          depth: 0,
          spikes: 64,
          angle: 360,
          innerRadius: 0,
          extrudeBevelSize: 0,
          extrudeBevelSegments: 1,
        },
        t.parameters
      );
      return {
        shape: t.shape && t.shape instanceof si ? t.shape : new si(),
        parameters: Object.assign(i, {
          width: Math.abs(i.width),
          height: Math.abs(i.height ?? i.width),
          depth: Math.abs(i.depth ?? 0),
        }),
      };
    }
    static build(t) {
      let {
          width: e,
          height: i,
          spikes: n,
          angle: r,
          innerRadius: s,
          depth: a,
          extrudeBevelSize: o,
          extrudeBevelSegments: l,
        } = t.parameters,
        c = t.shape,
        d = e * 0.5,
        h = i * 0.5,
        u = dz(c, d, h, (r * Math.PI) / 180, n, s);
      (c.isClosed = !0), c.update();
      let f = ta.create({
        shape: c,
        parameters: {
          subdivisions: u,
          depth: a,
          extrudeBevelSize: o,
          extrudeBevelSegments: l,
        },
      });
      return Object.assign(f, { userData: { ...t, type: "EllipseGeometry" } });
    }
  };
function dz(t, e, i, n, r, s) {
  if (n >= H_)
    return r > 30 || r % 4 === 0
      ? (pz(t, e, i, s), Math.round(r / 4))
      : pv(t, n, r, e, i, s);
  n = Math.max(n, 0.001);
  let a = { x: 0, y: i },
    o = n + Math.PI * 0.5,
    l = { x: Math.cos(o) * e, y: Math.sin(o) * i },
    c = az({
      px: a.x,
      py: a.y,
      cx: l.x,
      cy: l.y,
      rx: e,
      ry: i,
      largeArcFlag: n > Math.PI,
      sweepFlag: !0,
    });
  return r > 30 || r % c.length === 0
    ? fz(t, a.x, a.y, c, r, e, i, s)
    : pv(t, n, r, e, i, s);
}
function fz(t, e, i, n, r, s, a, o) {
  let l = Math.round(r / n.length);
  t.addPoint(ja(e, i));
  for (let c = 0, d = n.length; c < d; c++) {
    let h = n[c],
      u = t.points[c],
      f = ja(h.x, h.y);
    u.controls[1].position.set(h.x1, h.y1),
      f.controls[0].position.set(h.x2, h.y2),
      t.addPoint(f);
  }
  return o > 0 ? G_(t, s, a, o) : t.addPoint(ja(0, 0)), l;
}
function pv(t, e, i, n, r, s) {
  let a = -e / i;
  for (let o = 0; o <= i; o++) {
    let l = a * o,
      c = Math.sin(l) * n,
      d = Math.cos(l) * r;
    t.addPoint(ja(c, d));
  }
  return (
    e < H_
      ? s > 0
        ? G_(t, n, r, s)
        : t.addPoint(ja(0, 0))
      : (t.removePoint(t.points[t.points.length - 1]), s > 0 && j_(t, n, r, s)),
    1
  );
}
function pz(t, e, i, n = 0, r = 0, s = 0) {
  let a = 0.5522847498,
    o = e * a,
    l = i * a;
  t.addPoint(hc(r - e, s, r - e, s - l, r - e, s + l)),
    t.addPoint(hc(r, s + i, r - o, s + i, r + o, s + i)),
    t.addPoint(hc(r + e, s, r + e, s + l, r + e, s - l)),
    t.addPoint(hc(r, s - i, r + o, s - i, r - o, s - i)),
    n > 0 && j_(t, e, i, n);
}
function ja(t, e) {
  return new Ga(Jt.generateUUID(), new J(t, e));
}
function hc(t, e, i, n, r, s) {
  let a = ja(t, e);
  return a.controls[0].position.set(i, n), a.controls[1].position.set(r, s), a;
}
function G_(t, e, i, n) {
  W_(t, e, i, n).forEach((r) => t.addPoint(r));
}
function j_(t, e, i, n) {
  let r = W_(t, e, i, n),
    s = new si();
  r.forEach((a) => s.addPoint(a)), (s.isClosed = !0), t.shapeHoles.push(s);
}
function W_(t, e, i, n) {
  let r = (n * e) / 100,
    s = r * (Math.abs(i) / Math.abs(e)),
    a = new J(r / e, s / i),
    o = t.points
      .map((l) => {
        let c = l.clone();
        return (c.uuid = Jt.generateUUID()), c;
      })
      .reverse();
  return (
    o.forEach((l) => {
      l.position.multiply(a);
      let c = l.controls[0].position.clone().multiply(a),
        d = l.controls[1].position.clone().multiply(a);
      l.controls[0].position.copy(d), l.controls[1].position.copy(c);
    }),
    o
  );
}
var mz = class {
    static create(t) {
      return this.build(this.normalizeInputs(t));
    }
    static normalizeInputs(t, e) {
      let i = Object.assign(
          {},
          (e == null ? void 0 : e.parameters) ?? {
            width: 100,
            revolutions: 2,
            segments: 40,
            pathRadius: 10,
            pathType: 0,
            pathSegments: 30,
            cornerRadius: 30,
            cornerSegments: 4,
          },
          t.parameters
        ),
        n = Math.abs(i.width),
        r = Math.abs(i.height ?? n),
        s = Math.abs(i.depth ?? n),
        a = Math.abs(Math.min(n, s)) / 2;
      return {
        parameters: Object.assign(i, {
          width: n,
          height: r,
          depth: s,
          radius: a,
          segments: Math.round(i.segments),
          pathSegments: Math.round(i.pathSegments),
          cornerSegments: Math.round(i.cornerSegments),
        }),
      };
    }
    static build(t) {
      let {
          width: e,
          height: i,
          depth: n,
          radius: r,
          revolutions: s,
          segments: a,
          pathRadius: o,
          pathType: l,
          pathSegments: c,
          cornerRadius: d,
          cornerSegments: h,
        } = t.parameters,
        u = new q_(!1, e, i, n, r, s, a, o, l, c, d, h);
      return Object.assign(u, { userData: { ...t, type: "HelixGeometry" } });
    }
  },
  qu = new za([0, 0, 0], 1),
  q_ = class extends st {
    constructor(
      t = !0,
      e = 1,
      i = 1,
      n = 1,
      r = 1,
      s = 1,
      a = 1,
      o = 1,
      l = 1,
      c = 1,
      d = 1,
      h = 1
    ) {
      if ((super(), s === 0)) return;
      let u = t && s === 1;
      u && (h = 0), d > 100 && (d = 100), d === 0 && (h = 0);
      let f = () => new A(),
        p = new A(),
        v = f(),
        g = f(),
        m = f(),
        x,
        y,
        _,
        M,
        b,
        E,
        T,
        S,
        w = f(),
        C = f(),
        L = f(),
        P = f(),
        R = f(),
        I = f(),
        W = f(),
        N = f(),
        U = i - 2 * o + 0.001,
        G = U / s,
        k = Math.ceil(a * s),
        B = k + 1,
        V = U / k,
        X = -U / 2,
        H = c + 1,
        j = (2 * Math.PI) / c,
        Y = Math.PI / 2 / h,
        ee = 0.01,
        Z = Math.min((1 - d / 100) * o, o - ee),
        K = o - Z,
        me = 0,
        re = 2,
        F = h * re + re,
        Te = (H * F) / re,
        be = Te + H * B,
        oe = H * (B + F),
        [Me, Ae, ye] = [3, 3, 2].map((Se) => Array(oe * Se).fill(0)),
        _e = [],
        Ee = r - o;
      function Le(Se, le) {
        let je = Math.PI / 2;
        (E = le * V),
          (S = (2 * Math.PI * (E % G)) / G + je),
          (E += X),
          (T = Math.sin(S) * Ee),
          (b = Math.cos(S) * Ee),
          t ? Se.set(b, T, E) : Se.set(b, E, T);
      }
      Le(p, -1e-10), Le(v, 0), w.copy(p), Le(p, 1);
      let it = p.distanceTo(v),
        O = u ? 0 : K + Z,
        D = it * k + 2 * O,
        ne = Z,
        pe = D - O;
      for (let Se = 0; Se <= k; Se++) {
        Le(g, Se),
          N.subVectors(g, w).normalize(),
          w.copy(g),
          I.copy(g)
            .setComponent(+t + 1, 0)
            .normalize(),
          W.crossVectors(N, I).normalize();
        let le = Se === 0,
          je = Se === k,
          $e = le ? (3 * Math.PI) / 2 : Y,
          Ye = le ? ne : pe,
          He = le ? H : be,
          Ge = le ? 0 : oe - H,
          nt = N.clone()
            .multiplyScalar(le ? -K : K)
            .add(g),
          wt = N.clone()
            .multiplyScalar(le ? -1 : 1)
            .normalize();
        for (let q = 0; q < H; q++) {
          let De = q * j;
          if (
            (C.addVectors(
              p.copy(I).multiplyScalar(o * Math.cos(De)),
              v.copy(W).multiplyScalar(o * Math.sin(De))
            ),
            L.copy(C).normalize(),
            le || je)
          ) {
            u ||
              ((me = Ge + q),
              [0, 1, 2].forEach((se) => {
                (Me[me * 3 + se] = nt.getComponent(se)),
                  (Ae[me * 3 + se] = wt.getComponent(se));
              }),
              (ye[me * 2] = +je),
              (ye[me * 2 + 1] = q / c)),
              v.copy(L).multiplyScalar(Z),
              m.addVectors(g, v);
            for (let se = 0; se < h; se++) {
              let Ce = se * Y + $e;
              P.addVectors(
                p.copy(N).multiplyScalar(K * Math.sin(Ce)),
                v.copy(L).multiplyScalar(K * Math.cos(Ce))
              ),
                R.copy(P).normalize(),
                v.addVectors(m, P),
                P.normalize(),
                (me = He + se * H + q),
                [0, 1, 2].forEach((xt) => {
                  (Me[me * 3 + xt] = v.getComponent(xt)),
                    (Ae[me * 3 + xt] = R.getComponent(xt));
                });
              let Ne = +le + Math.sin(Ce);
              (ye[me * 2] = (Ye + K * Ne) / D), (ye[me * 2 + 1] = q / c);
            }
          }
          v.addVectors(g, C),
            (me = Te + Se * H + q),
            [0, 1, 2].forEach((se) => {
              (Me[me * 3 + se] = v.getComponent(se)),
                (Ae[me * 3 + se] = L.getComponent(se));
            }),
            (ye[me * 2] = (O + Se * it) / D),
            (ye[me * 2 + 1] = q / c);
        }
      }
      let xe = B + 2 * h + re,
        [we, Fe] = [+u, xe - 1];
      for (let Se = we; Se <= Fe - 1; Se++) {
        let le = u && Se === Fe - 1;
        for (let je = 0; je < H - 1; je++)
          (x = Se * H + je),
            (y = x + 1),
            (_ = (le ? je : x) + H),
            (M = (le ? je + 1 : y) + H),
            Se === 0
              ? _e.push(y, M, _)
              : Se === xe - 2
              ? _e.push(x, y, _)
              : _e.push(x, y, _, y, M, _);
      }
      this.setIndex(_e),
        this.setAttribute("position", new We(Me, 3)),
        this.setAttribute("normal", new We(Ae, 3)),
        this.setAttribute("uv", new We(ye, 2));
    }
    getClosedTorusIndicesForBooleanOrSubdiv() {
      let t = this.userData.parameters,
        e = Math.ceil(t.tubularSegments),
        i = t.radialSegments + 1,
        n = Array.from(this.getIndex().array),
        r,
        s,
        a,
        o,
        l = 6 * (e - 1) * t.radialSegments,
        c = e,
        d = c === e;
      for (let h = 0; h < t.radialSegments; h++)
        (r = c * i + h),
          (s = r + 1),
          (a = (d ? h : r) + i),
          (o = (d ? h + 1 : s) + i),
          (n[l++] = r),
          (n[l++] = s),
          (n[l++] = a),
          (n[l++] = s),
          (n[l++] = o),
          (n[l++] = a);
      return (n.length = l), (qu.array = n), (qu.count = n.length), qu;
    }
  },
  gz = class {
    static create(t) {
      return this.build(this.normalizeInputs(t));
    }
    static normalizeInputs(t, e) {
      let i = Object.assign(
        {},
        (e == null ? void 0 : e.parameters) ?? {
          width: 100,
          detail: 0,
          corner: 0,
          cornerSides: 4,
        },
        t.parameters
      );
      return {
        parameters: Object.assign(i, {
          width: Math.abs(i.width),
          height: Math.abs(i.height ?? i.width),
          depth: Math.abs(i.depth ?? i.width),
        }),
      };
    }
    static build(t) {
      let {
          width: e,
          height: i,
          depth: n,
          detail: r,
          corner: s,
          cornerSides: a,
        } = t.parameters,
        o = r === 0 && s !== 0 ? new X_(e * 0.5, s, a) : new Qf(e * 0.5, r);
      return (
        o.scale(1, i / e, n / e),
        Object.assign(o, { userData: { ...t, type: "IcosahedronGeometry" } })
      );
    }
  },
  X_ = class extends Rp {
    constructor(t = 1, e = 0.2, i = 4) {
      let n = (1 + Math.sqrt(5)) / 2,
        r = [
          -1,
          n,
          0,
          1,
          n,
          0,
          -1,
          -n,
          0,
          1,
          -n,
          0,
          0,
          -1,
          n,
          0,
          1,
          n,
          0,
          -1,
          -n,
          0,
          1,
          -n,
          n,
          0,
          -1,
          n,
          0,
          1,
          -n,
          0,
          -1,
          -n,
          0,
          1,
        ],
        s = [
          0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4,
          11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3,
          8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1,
        ],
        a = "IcosahedronGeometry";
      super(r, s, a, t, e, i), (this.type = a);
    }
    static fromJSON(t) {
      return new X_(t.radius, t.corner, t.cornerSides);
    }
  },
  vz = class {
    static create(t) {
      return this.build(this.normalizeInputs(t));
    }
    static normalizeInputs(t, e) {
      var n;
      (((n = t.parameters) == null ? void 0 : n.points) ?? []).forEach((r) => {
        Array.isArray(r) && ((r.x = r[0]), (r.y = r[1]));
      });
      let i = Object.assign(
        {},
        (e == null ? void 0 : e.parameters) ?? {
          width: 100,
          segments: 64,
          verticalSegments: 64,
          points: [
            { x: 0, y: -50, id: 0 },
            { x: 50, y: -50, id: 1 },
            { x: 50, y: 50, id: 2 },
            { x: 0, y: 50, id: 3 },
          ],
        },
        t.parameters
      );
      return {
        parameters: Object.assign(i, {
          width: Math.abs(i.width),
          height: Math.abs(i.height ?? i.width),
          depth: Math.abs(i.depth ?? i.width),
        }),
      };
    }
    static build(t) {
      let { points: e, segments: i, verticalSegments: n } = t.parameters,
        r = new Hc();
      r.moveTo(e[0].x, e[0].y),
        r.bezierCurveTo(e[1].x, e[1].y, e[2].x, e[2].y, e[3].x, e[3].y);
      let s = new Yf(r.extractPoints(n).shape, i);
      return (
        s.rotateZ(Math.PI),
        Object.assign(s, { userData: { ...t, type: "LatheGeometry" } })
      );
    }
  },
  tr = new ze(),
  Xu = new Ht(),
  uc = new A(),
  hh = class extends Ys {
    constructor() {
      super(),
        (this.uuid = Jt.generateUUID()),
        (this.name = ""),
        (this.type = "Geometry"),
        (this.vertices = []),
        (this.colors = []),
        (this.faces = []),
        (this.faceVertexUvs = [[]]),
        (this.morphTargets = []),
        (this.morphNormals = []),
        (this.skinWeights = []),
        (this.skinIndices = []),
        (this.lineDistances = []),
        (this.boundingBox = null),
        (this.boundingSphere = null),
        (this.elementsNeedUpdate = !1),
        (this.verticesNeedUpdate = !1),
        (this.uvsNeedUpdate = !1),
        (this.normalsNeedUpdate = !1),
        (this.colorsNeedUpdate = !1),
        (this.lineDistancesNeedUpdate = !1),
        (this.groupsNeedUpdate = !1);
    }
    applyMatrix4(t) {
      let e = new ft().getNormalMatrix(t);
      for (let i = 0, n = this.vertices.length; i < n; i++)
        this.vertices[i].applyMatrix4(t);
      for (let i = 0, n = this.faces.length; i < n; i++) {
        let r = this.faces[i];
        r.normal.applyMatrix3(e).normalize();
        for (let s = 0, a = r.vertexNormals.length; s < a; s++)
          r.vertexNormals[s].applyMatrix3(e).normalize();
      }
      return (
        this.boundingBox !== null && this.computeBoundingBox(),
        this.boundingSphere !== null && this.computeBoundingSphere(),
        (this.verticesNeedUpdate = !0),
        (this.normalsNeedUpdate = !0),
        this
      );
    }
    rotateX(t) {
      return tr.makeRotationX(t), this.applyMatrix4(tr), this;
    }
    rotateY(t) {
      return tr.makeRotationY(t), this.applyMatrix4(tr), this;
    }
    rotateZ(t) {
      return tr.makeRotationZ(t), this.applyMatrix4(tr), this;
    }
    translate(t, e, i) {
      return tr.makeTranslation(t, e, i), this.applyMatrix4(tr), this;
    }
    scale(t, e, i) {
      return tr.makeScale(t, e, i), this.applyMatrix4(tr), this;
    }
    lookAt(t) {
      return (
        Xu.lookAt(t), Xu.updateMatrix(), this.applyMatrix4(Xu.matrix), this
      );
    }
    fromBufferGeometry(t) {
      let e = this,
        i = t.index !== null ? t.index : void 0,
        n = t.attributes;
      if (n.position === void 0)
        return (
          console.error(
            "THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion."
          ),
          this
        );
      let r = n.position,
        s = n.normal,
        a = n.color,
        o = n.uv,
        l = n.uv2;
      l !== void 0 && (this.faceVertexUvs[1] = []);
      for (let h = 0; h < r.count; h++)
        e.vertices.push(new A().fromBufferAttribute(r, h)),
          a !== void 0 && e.colors.push(new tt().fromBufferAttribute(a, h));
      function c(h, u, f, p) {
        let v =
            a === void 0
              ? []
              : [e.colors[h].clone(), e.colors[u].clone(), e.colors[f].clone()],
          g =
            s === void 0
              ? []
              : [
                  new A().fromBufferAttribute(s, h),
                  new A().fromBufferAttribute(s, u),
                  new A().fromBufferAttribute(s, f),
                ],
          m = new pf(h, u, f, g, v, p);
        e.faces.push(m),
          o !== void 0 &&
            e.faceVertexUvs[0].push([
              new J().fromBufferAttribute(o, h),
              new J().fromBufferAttribute(o, u),
              new J().fromBufferAttribute(o, f),
            ]),
          l !== void 0 &&
            e.faceVertexUvs[1].push([
              new J().fromBufferAttribute(l, h),
              new J().fromBufferAttribute(l, u),
              new J().fromBufferAttribute(l, f),
            ]);
      }
      let d = t.groups;
      if (d.length > 0)
        for (let h = 0; h < d.length; h++) {
          let u = d[h],
            f = u.start,
            p = u.count;
          for (let v = f, g = f + p; v < g; v += 3)
            i !== void 0
              ? c(i.getX(v), i.getX(v + 1), i.getX(v + 2), u.materialIndex)
              : c(v, v + 1, v + 2, u.materialIndex);
        }
      else if (i !== void 0)
        for (let h = 0; h < i.count; h += 3)
          c(i.getX(h), i.getX(h + 1), i.getX(h + 2));
      else for (let h = 0; h < r.count; h += 3) c(h, h + 1, h + 2);
      return (
        this.computeFaceNormals(),
        t.boundingBox !== null && (this.boundingBox = t.boundingBox.clone()),
        t.boundingSphere !== null &&
          (this.boundingSphere = t.boundingSphere.clone()),
        this
      );
    }
    center() {
      return (
        this.computeBoundingBox(),
        this.boundingBox.getCenter(uc).negate(),
        this.translate(uc.x, uc.y, uc.z),
        this
      );
    }
    normalize() {
      this.computeBoundingSphere();
      let t = this.boundingSphere.center,
        e = this.boundingSphere.radius,
        i = e === 0 ? 1 : 1 / e,
        n = new ze();
      return (
        n.set(
          i,
          0,
          0,
          -i * t.x,
          0,
          i,
          0,
          -i * t.y,
          0,
          0,
          i,
          -i * t.z,
          0,
          0,
          0,
          1
        ),
        this.applyMatrix4(n),
        this
      );
    }
    computeFaceNormals() {
      let t = new A(),
        e = new A();
      for (let i = 0, n = this.faces.length; i < n; i++) {
        let r = this.faces[i],
          s = this.vertices[r.a],
          a = this.vertices[r.b],
          o = this.vertices[r.c];
        t.subVectors(o, a),
          e.subVectors(s, a),
          t.cross(e),
          t.normalize(),
          r.normal.copy(t);
      }
    }
    computeVertexNormals(t = !0) {
      let e = new Array(this.vertices.length);
      for (let i = 0, n = this.vertices.length; i < n; i++) e[i] = new A();
      if (t) {
        let i = new A(),
          n = new A();
        for (let r = 0, s = this.faces.length; r < s; r++) {
          let a = this.faces[r],
            o = this.vertices[a.a],
            l = this.vertices[a.b],
            c = this.vertices[a.c];
          i.subVectors(c, l),
            n.subVectors(o, l),
            i.cross(n),
            e[a.a].add(i),
            e[a.b].add(i),
            e[a.c].add(i);
        }
      } else {
        this.computeFaceNormals();
        for (let i = 0, n = this.faces.length; i < n; i++) {
          let r = this.faces[i];
          e[r.a].add(r.normal), e[r.b].add(r.normal), e[r.c].add(r.normal);
        }
      }
      for (let i = 0, n = this.vertices.length; i < n; i++) e[i].normalize();
      for (let i = 0, n = this.faces.length; i < n; i++) {
        let r = this.faces[i],
          s = r.vertexNormals;
        s.length === 3
          ? (s[0].copy(e[r.a]), s[1].copy(e[r.b]), s[2].copy(e[r.c]))
          : ((s[0] = e[r.a].clone()),
            (s[1] = e[r.b].clone()),
            (s[2] = e[r.c].clone()));
      }
      this.faces.length > 0 && (this.normalsNeedUpdate = !0);
    }
    computeFlatVertexNormals() {
      this.computeFaceNormals();
      for (let t = 0, e = this.faces.length; t < e; t++) {
        let i = this.faces[t],
          n = i.vertexNormals;
        n.length === 3
          ? (n[0].copy(i.normal), n[1].copy(i.normal), n[2].copy(i.normal))
          : ((n[0] = i.normal.clone()),
            (n[1] = i.normal.clone()),
            (n[2] = i.normal.clone()));
      }
      this.faces.length > 0 && (this.normalsNeedUpdate = !0);
    }
    computeMorphNormals() {
      for (let e = 0, i = this.faces.length; e < i; e++) {
        let n = this.faces[e];
        n.__originalFaceNormal
          ? n.__originalFaceNormal.copy(n.normal)
          : (n.__originalFaceNormal = n.normal.clone()),
          n.__originalVertexNormals || (n.__originalVertexNormals = []);
        for (let r = 0, s = n.vertexNormals.length; r < s; r++)
          n.__originalVertexNormals[r]
            ? n.__originalVertexNormals[r].copy(n.vertexNormals[r])
            : (n.__originalVertexNormals[r] = n.vertexNormals[r].clone());
      }
      let t = new hh();
      t.faces = this.faces;
      for (let e = 0, i = this.morphTargets.length; e < i; e++) {
        if (!this.morphNormals[e]) {
          (this.morphNormals[e] = {}),
            (this.morphNormals[e].faceNormals = []),
            (this.morphNormals[e].vertexNormals = []);
          let r = this.morphNormals[e].faceNormals,
            s = this.morphNormals[e].vertexNormals;
          for (let a = 0, o = this.faces.length; a < o; a++) {
            let l = new A(),
              c = { a: new A(), b: new A(), c: new A() };
            r.push(l), s.push(c);
          }
        }
        let n = this.morphNormals[e];
        (t.vertices = this.morphTargets[e].vertices),
          t.computeFaceNormals(),
          t.computeVertexNormals();
        for (let r = 0, s = this.faces.length; r < s; r++) {
          let a = this.faces[r],
            o = n.faceNormals[r],
            l = n.vertexNormals[r];
          o.copy(a.normal),
            l.a.copy(a.vertexNormals[0]),
            l.b.copy(a.vertexNormals[1]),
            l.c.copy(a.vertexNormals[2]);
        }
      }
      for (let e = 0, i = this.faces.length; e < i; e++) {
        let n = this.faces[e];
        (n.normal = n.__originalFaceNormal),
          (n.vertexNormals = n.__originalVertexNormals);
      }
    }
    computeBoundingBox() {
      this.boundingBox === null && (this.boundingBox = new An()),
        this.boundingBox.setFromPoints(this.vertices);
    }
    computeBoundingSphere() {
      this.boundingSphere === null && (this.boundingSphere = new Xn()),
        this.boundingSphere.setFromPoints(this.vertices);
    }
    merge(t, e, i = 0) {
      if (!(t && t.isGeometry)) {
        console.error(
          "THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.",
          t
        );
        return;
      }
      let n,
        r = this.vertices.length,
        s = this.vertices,
        a = t.vertices,
        o = this.faces,
        l = t.faces,
        c = this.colors,
        d = t.colors;
      e !== void 0 && (n = new ft().getNormalMatrix(e));
      for (let h = 0, u = a.length; h < u; h++) {
        let f = a[h].clone();
        e !== void 0 && f.applyMatrix4(e), s.push(f);
      }
      for (let h = 0, u = d.length; h < u; h++) c.push(d[h].clone());
      for (let h = 0, u = l.length; h < u; h++) {
        let f = l[h],
          p,
          v,
          g = f.vertexNormals,
          m = f.vertexColors,
          x = new pf(f.a + r, f.b + r, f.c + r);
        x.normal.copy(f.normal),
          n !== void 0 && x.normal.applyMatrix3(n).normalize();
        for (let y = 0, _ = g.length; y < _; y++)
          (p = g[y].clone()),
            n !== void 0 && p.applyMatrix3(n).normalize(),
            x.vertexNormals.push(p);
        x.color.copy(f.color);
        for (let y = 0, _ = m.length; y < _; y++)
          (v = m[y]), x.vertexColors.push(v.clone());
        (x.materialIndex = f.materialIndex + i), o.push(x);
      }
      for (let h = 0, u = t.faceVertexUvs.length; h < u; h++) {
        let f = t.faceVertexUvs[h];
        this.faceVertexUvs[h] === void 0 && (this.faceVertexUvs[h] = []);
        for (let p = 0, v = f.length; p < v; p++) {
          let g = f[p],
            m = [];
          for (let x = 0, y = g.length; x < y; x++) m.push(g[x].clone());
          this.faceVertexUvs[h].push(m);
        }
      }
    }
    mergeMesh(t) {
      if (!(t && t.isMesh)) {
        console.error(
          "THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.",
          t
        );
        return;
      }
      t.matrixAutoUpdate && t.updateMatrix(), this.merge(t.geometry, t.matrix);
    }
    mergeVertices(t = 4) {
      let e = {},
        i = [],
        n = [],
        r = Math.pow(10, t);
      for (let o = 0, l = this.vertices.length; o < l; o++) {
        let c = this.vertices[o],
          d =
            Math.round(c.x * r) +
            "_" +
            Math.round(c.y * r) +
            "_" +
            Math.round(c.z * r);
        e[d] === void 0
          ? ((e[d] = o), i.push(this.vertices[o]), (n[o] = i.length - 1))
          : (n[o] = n[e[d]]);
      }
      let s = [];
      for (let o = 0, l = this.faces.length; o < l; o++) {
        let c = this.faces[o];
        (c.a = n[c.a]), (c.b = n[c.b]), (c.c = n[c.c]);
        let d = [c.a, c.b, c.c];
        for (let h = 0; h < 3; h++)
          if (d[h] === d[(h + 1) % 3]) {
            s.push(o);
            break;
          }
      }
      for (let o = s.length - 1; o >= 0; o--) {
        let l = s[o];
        this.faces.splice(l, 1);
        for (let c = 0, d = this.faceVertexUvs.length; c < d; c++)
          this.faceVertexUvs[c].splice(l, 1);
      }
      let a = this.vertices.length - i.length;
      return (this.vertices = i), a;
    }
    setFromPoints(t) {
      this.vertices = [];
      for (let e = 0, i = t.length; e < i; e++) {
        let n = t[e];
        this.vertices.push(new A(n.x, n.y, n.z || 0));
      }
      return this;
    }
    sortFacesByMaterialIndex() {
      let t = this.faces,
        e = t.length;
      for (let o = 0; o < e; o++) t[o]._id = o;
      function i(o, l) {
        return o.materialIndex - l.materialIndex;
      }
      t.sort(i);
      let n = this.faceVertexUvs[0],
        r = this.faceVertexUvs[1],
        s,
        a;
      n && n.length === e && (s = []), r && r.length === e && (a = []);
      for (let o = 0; o < e; o++) {
        let l = t[o]._id;
        s && s.push(n[l]), a && a.push(r[l]);
      }
      s && (this.faceVertexUvs[0] = s), a && (this.faceVertexUvs[1] = a);
    }
    toJSON() {
      let t = {
        metadata: {
          version: 4.5,
          type: "Geometry",
          generator: "Geometry.toJSON",
        },
      };
      if (
        ((t.uuid = this.uuid),
        (t.type = this.type),
        this.name !== "" && (t.name = this.name),
        this.parameters !== void 0)
      ) {
        let f = this.parameters;
        for (let p in f) f[p] !== void 0 && (t[p] = f[p]);
        return t;
      }
      let e = [];
      for (let f = 0; f < this.vertices.length; f++) {
        let p = this.vertices[f];
        e.push(p.x, p.y, p.z);
      }
      let i = [],
        n = [],
        r = {},
        s = [],
        a = {},
        o = [],
        l = {};
      for (let f = 0; f < this.faces.length; f++) {
        let p = this.faces[f],
          v = !0,
          g = !1,
          m = this.faceVertexUvs[0][f] !== void 0,
          x = p.normal.length() > 0,
          y = p.vertexNormals.length > 0,
          _ = p.color.r !== 1 || p.color.g !== 1 || p.color.b !== 1,
          M = p.vertexColors.length > 0,
          b = 0;
        if (
          ((b = c(b, 0, 0)),
          (b = c(b, 1, v)),
          (b = c(b, 2, g)),
          (b = c(b, 3, m)),
          (b = c(b, 4, x)),
          (b = c(b, 5, y)),
          (b = c(b, 6, _)),
          (b = c(b, 7, M)),
          i.push(b),
          i.push(p.a, p.b, p.c),
          i.push(p.materialIndex),
          m)
        ) {
          let E = this.faceVertexUvs[0][f];
          i.push(u(E[0]), u(E[1]), u(E[2]));
        }
        if ((x && i.push(d(p.normal)), y)) {
          let E = p.vertexNormals;
          i.push(d(E[0]), d(E[1]), d(E[2]));
        }
        if ((_ && i.push(h(p.color)), M)) {
          let E = p.vertexColors;
          i.push(h(E[0]), h(E[1]), h(E[2]));
        }
      }
      function c(f, p, v) {
        return v ? f | (1 << p) : f & ~(1 << p);
      }
      function d(f) {
        let p = f.x.toString() + f.y.toString() + f.z.toString();
        return (
          r[p] !== void 0 || ((r[p] = n.length / 3), n.push(f.x, f.y, f.z)),
          r[p]
        );
      }
      function h(f) {
        let p = f.r.toString() + f.g.toString() + f.b.toString();
        return a[p] !== void 0 || ((a[p] = s.length), s.push(f.getHex())), a[p];
      }
      function u(f) {
        let p = f.x.toString() + f.y.toString();
        return (
          l[p] !== void 0 || ((l[p] = o.length / 2), o.push(f.x, f.y)), l[p]
        );
      }
      return (
        (t.data = {}),
        (t.data.vertices = e),
        (t.data.normals = n),
        s.length > 0 && (t.data.colors = s),
        o.length > 0 && (t.data.uvs = [o]),
        (t.data.faces = i),
        t
      );
    }
    clone() {
      return new hh().copy(this);
    }
    copy(t) {
      (this.vertices = []),
        (this.colors = []),
        (this.faces = []),
        (this.faceVertexUvs = [[]]),
        (this.morphTargets = []),
        (this.morphNormals = []),
        (this.skinWeights = []),
        (this.skinIndices = []),
        (this.lineDistances = []),
        (this.boundingBox = null),
        (this.boundingSphere = null),
        (this.name = t.name);
      let e = t.vertices;
      for (let h = 0, u = e.length; h < u; h++)
        this.vertices.push(e[h].clone());
      let i = t.colors;
      for (let h = 0, u = i.length; h < u; h++) this.colors.push(i[h].clone());
      let n = t.faces;
      for (let h = 0, u = n.length; h < u; h++) this.faces.push(n[h].clone());
      for (let h = 0, u = t.faceVertexUvs.length; h < u; h++) {
        let f = t.faceVertexUvs[h];
        this.faceVertexUvs[h] === void 0 && (this.faceVertexUvs[h] = []);
        for (let p = 0, v = f.length; p < v; p++) {
          let g = f[p],
            m = [];
          for (let x = 0, y = g.length; x < y; x++) {
            let _ = g[x];
            m.push(_.clone());
          }
          this.faceVertexUvs[h].push(m);
        }
      }
      let r = t.morphTargets;
      for (let h = 0, u = r.length; h < u; h++) {
        let f = {};
        if (((f.name = r[h].name), r[h].vertices !== void 0)) {
          f.vertices = [];
          for (let p = 0, v = r[h].vertices.length; p < v; p++)
            f.vertices.push(r[h].vertices[p].clone());
        }
        if (r[h].normals !== void 0) {
          f.normals = [];
          for (let p = 0, v = r[h].normals.length; p < v; p++)
            f.normals.push(r[h].normals[p].clone());
        }
        this.morphTargets.push(f);
      }
      let s = t.morphNormals;
      for (let h = 0, u = s.length; h < u; h++) {
        let f = {};
        if (s[h].vertexNormals !== void 0) {
          f.vertexNormals = [];
          for (let p = 0, v = s[h].vertexNormals.length; p < v; p++) {
            let g = s[h].vertexNormals[p],
              m = {};
            (m.a = g.a.clone()),
              (m.b = g.b.clone()),
              (m.c = g.c.clone()),
              f.vertexNormals.push(m);
          }
        }
        if (s[h].faceNormals !== void 0) {
          f.faceNormals = [];
          for (let p = 0, v = s[h].faceNormals.length; p < v; p++)
            f.faceNormals.push(s[h].faceNormals[p].clone());
        }
        this.morphNormals.push(f);
      }
      let a = t.skinWeights;
      for (let h = 0, u = a.length; h < u; h++)
        this.skinWeights.push(a[h].clone());
      let o = t.skinIndices;
      for (let h = 0, u = o.length; h < u; h++)
        this.skinIndices.push(o[h].clone());
      let l = t.lineDistances;
      for (let h = 0, u = l.length; h < u; h++) this.lineDistances.push(l[h]);
      let c = t.boundingBox;
      c !== null && (this.boundingBox = c.clone());
      let d = t.boundingSphere;
      return (
        d !== null && (this.boundingSphere = d.clone()),
        (this.elementsNeedUpdate = t.elementsNeedUpdate),
        (this.verticesNeedUpdate = t.verticesNeedUpdate),
        (this.uvsNeedUpdate = t.uvsNeedUpdate),
        (this.normalsNeedUpdate = t.normalsNeedUpdate),
        (this.colorsNeedUpdate = t.colorsNeedUpdate),
        (this.lineDistancesNeedUpdate = t.lineDistancesNeedUpdate),
        (this.groupsNeedUpdate = t.groupsNeedUpdate),
        this
      );
    }
    toBufferGeometry() {
      let t = new yz().fromGeometry(this),
        e = new st(),
        i = new Float32Array(t.vertices.length * 3);
      if (
        (e.setAttribute("position", dc.call(new pt(i, 3), t.vertices)),
        t.normals.length > 0)
      ) {
        let n = new Float32Array(t.normals.length * 3);
        e.setAttribute("normal", dc.call(new pt(n, 3), t.normals));
      }
      if (t.colors.length > 0) {
        let n = new Float32Array(t.colors.length * 3);
        e.setAttribute("color", mv.call(new pt(n, 3), t.colors));
      }
      if (t.uvs.length > 0) {
        let n = new Float32Array(t.uvs.length * 2);
        e.setAttribute("uv", gv.call(new pt(n, 2), t.uvs));
      }
      if (t.uvs2.length > 0) {
        let n = new Float32Array(t.uvs2.length * 2);
        e.setAttribute("uv2", gv.call(new pt(n, 2), t.uvs2));
      }
      e.groups = t.groups;
      for (let n in t.morphTargets) {
        let r = [],
          s = t.morphTargets[n];
        for (let a = 0, o = s.length; a < o; a++) {
          let l = s[a],
            c = new We(l.data.length * 3, 3);
          (c.name = l.name), r.push(dc.call(c, l.data));
        }
        e.morphAttributes[n] = r;
      }
      if (t.skinIndices.length > 0) {
        let n = new We(t.skinIndices.length * 4, 4);
        e.setAttribute("skinIndex", vv.call(n, t.skinIndices));
      }
      if (t.skinWeights.length > 0) {
        let n = new We(t.skinWeights.length * 4, 4);
        e.setAttribute("skinWeight", vv.call(n, t.skinWeights));
      }
      return (
        t.boundingSphere !== null &&
          (e.boundingSphere = t.boundingSphere.clone()),
        t.boundingBox !== null && (e.boundingBox = t.boundingBox.clone()),
        e
      );
    }
    computeTangents() {
      console.error("THREE.Geometry: .computeTangents() has been removed.");
    }
    computeLineDistances() {
      console.error(
        "THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead."
      );
    }
    applyMatrix(t) {
      return (
        console.warn(
          "THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4()."
        ),
        this.applyMatrix4(t)
      );
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
    static createBufferGeometryFromObject(t) {
      let e = new st(),
        i = t.geometry;
      if (t.isPoints || t.isLine) {
        let n = new We(i.vertices.length * 3, 3),
          r = new We(i.colors.length * 3, 3);
        if (
          (e.setAttribute("position", dc.call(n, i.vertices)),
          e.setAttribute("color", mv.call(r, i.colors)),
          i.lineDistances && i.lineDistances.length === i.vertices.length)
        ) {
          let s = new We(i.lineDistances.length, 1);
          e.setAttribute("lineDistance", xz.call(s, i.lineDistances));
        }
        i.boundingSphere !== null &&
          (e.boundingSphere = i.boundingSphere.clone()),
          i.boundingBox !== null && (e.boundingBox = i.boundingBox.clone());
      } else t.isMesh && (e = i.toBufferGeometry());
      return e;
    }
  };
hh.prototype.isGeometry = !0;
var yz = class {
    constructor() {
      (this.vertices = []),
        (this.normals = []),
        (this.colors = []),
        (this.uvs = []),
        (this.uvs2 = []),
        (this.groups = []),
        (this.morphTargets = {}),
        (this.skinWeights = []),
        (this.skinIndices = []),
        (this.boundingBox = null),
        (this.boundingSphere = null),
        (this.verticesNeedUpdate = !1),
        (this.normalsNeedUpdate = !1),
        (this.colorsNeedUpdate = !1),
        (this.uvsNeedUpdate = !1),
        (this.groupsNeedUpdate = !1);
    }
    computeGroups(t) {
      let e = [],
        i,
        n,
        r,
        s = t.faces;
      for (n = 0; n < s.length; n++) {
        let a = s[n];
        a.materialIndex !== r &&
          ((r = a.materialIndex),
          i !== void 0 && ((i.count = n * 3 - i.start), e.push(i)),
          (i = { start: n * 3, materialIndex: r }));
      }
      i !== void 0 && ((i.count = n * 3 - i.start), e.push(i)),
        (this.groups = e);
    }
    fromGeometry(t) {
      let e = t.faces,
        i = t.vertices,
        n = t.faceVertexUvs,
        r = n[0] && n[0].length > 0,
        s = n[1] && n[1].length > 0,
        a = t.morphTargets,
        o = a.length,
        l;
      if (o > 0) {
        l = [];
        for (let g = 0; g < o; g++) l[g] = { name: a[g].name, data: [] };
        this.morphTargets.position = l;
      }
      let c = t.morphNormals,
        d = c.length,
        h;
      if (d > 0) {
        h = [];
        for (let g = 0; g < d; g++) h[g] = { name: c[g].name, data: [] };
        this.morphTargets.normal = h;
      }
      let u = t.skinIndices,
        f = t.skinWeights,
        p = u.length === i.length,
        v = f.length === i.length;
      i.length > 0 &&
        e.length === 0 &&
        console.error(
          "THREE.DirectGeometry: Faceless geometries are not supported."
        );
      for (let g = 0; g < e.length; g++) {
        let m = e[g];
        this.vertices.push(i[m.a], i[m.b], i[m.c]);
        let x = m.vertexNormals;
        if (x.length === 3) this.normals.push(x[0], x[1], x[2]);
        else {
          let _ = m.normal;
          this.normals.push(_, _, _);
        }
        let y = m.vertexColors;
        if (y.length === 3) this.colors.push(y[0], y[1], y[2]);
        else {
          let _ = m.color;
          this.colors.push(_, _, _);
        }
        if (r === !0) {
          let _ = n[0][g];
          _ !== void 0
            ? this.uvs.push(_[0], _[1], _[2])
            : (console.warn(
                "THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ",
                g
              ),
              this.uvs.push(new J(), new J(), new J()));
        }
        if (s === !0) {
          let _ = n[1][g];
          _ !== void 0
            ? this.uvs2.push(_[0], _[1], _[2])
            : (console.warn(
                "THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ",
                g
              ),
              this.uvs2.push(new J(), new J(), new J()));
        }
        for (let _ = 0; _ < o; _++) {
          let M = a[_].vertices;
          l[_].data.push(M[m.a], M[m.b], M[m.c]);
        }
        for (let _ = 0; _ < d; _++) {
          let M = c[_].vertexNormals[g];
          h[_].data.push(M.a, M.b, M.c);
        }
        p && this.skinIndices.push(u[m.a], u[m.b], u[m.c]),
          v && this.skinWeights.push(f[m.a], f[m.b], f[m.c]);
      }
      return (
        this.computeGroups(t),
        (this.verticesNeedUpdate = t.verticesNeedUpdate),
        (this.normalsNeedUpdate = t.normalsNeedUpdate),
        (this.colorsNeedUpdate = t.colorsNeedUpdate),
        (this.uvsNeedUpdate = t.uvsNeedUpdate),
        (this.groupsNeedUpdate = t.groupsNeedUpdate),
        t.boundingSphere !== null &&
          (this.boundingSphere = t.boundingSphere.clone()),
        t.boundingBox !== null && (this.boundingBox = t.boundingBox.clone()),
        this
      );
    }
  },
  pf = class {
    constructor(t, e, i, n, r, s = 0) {
      (this.a = t),
        (this.b = e),
        (this.c = i),
        (this.normal = n && n.isVector3 ? n : new A()),
        (this.vertexNormals = Array.isArray(n) ? n : []),
        (this.color = r && r.isColor ? r : new tt()),
        (this.vertexColors = Array.isArray(r) ? r : []),
        (this.materialIndex = s);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(t) {
      (this.a = t.a),
        (this.b = t.b),
        (this.c = t.c),
        this.normal.copy(t.normal),
        this.color.copy(t.color),
        (this.materialIndex = t.materialIndex);
      for (let e = 0, i = t.vertexNormals.length; e < i; e++)
        this.vertexNormals[e] = t.vertexNormals[e].clone();
      for (let e = 0, i = t.vertexColors.length; e < i; e++)
        this.vertexColors[e] = t.vertexColors[e].clone();
      return this;
    }
  };
function xz(t) {
  return this.array.set(t), this;
}
function mv(t) {
  let e = this.array,
    i = 0;
  for (let n = 0, r = t.length; n < r; n++) {
    let s = t[n];
    s === void 0 &&
      (console.warn(
        "THREE.BufferAttribute.copyColorsArray(): color is undefined",
        n
      ),
      (s = new tt())),
      (e[i++] = s.r),
      (e[i++] = s.g),
      (e[i++] = s.b);
  }
  return this;
}
function gv(t) {
  let e = this.array,
    i = 0;
  for (let n = 0, r = t.length; n < r; n++) {
    let s = t[n];
    s === void 0 &&
      (console.warn(
        "THREE.BufferAttribute.copyVector2sArray(): vector is undefined",
        n
      ),
      (s = new J())),
      (e[i++] = s.x),
      (e[i++] = s.y);
  }
  return this;
}
function dc(t) {
  let e = this.array,
    i = 0;
  for (let n = 0, r = t.length; n < r; n++) {
    let s = t[n];
    s === void 0 &&
      (console.warn(
        "THREE.BufferAttribute.copyVector3sArray(): vector is undefined",
        n
      ),
      (s = new A())),
      (e[i++] = s.x),
      (e[i++] = s.y),
      (e[i++] = s.z);
  }
  return this;
}
function vv(t) {
  let e = this.array,
    i = 0;
  for (let n = 0, r = t.length; n < r; n++) {
    let s = t[n];
    s === void 0 &&
      (console.warn(
        "THREE.BufferAttribute.copyVector4sArray(): vector is undefined",
        n
      ),
      (s = new yt())),
      (e[i++] = s.x),
      (e[i++] = s.y),
      (e[i++] = s.z),
      (e[i++] = s.w);
  }
  return this;
}
var _z = ["a", "b", "c"];
function bz(t, e) {
  switch (e) {
    case "c":
      return t.c;
    case "b":
      return t.b;
    case "a":
    default:
      return t.a;
  }
}
function $u(t, e, i) {
  let n = Math.min(t, e),
    r = Math.max(t, e),
    s = n + "_" + r;
  return i.get(s);
}
function Yu(t, e, i, n, r, s) {
  let a = Math.min(t, e),
    o = Math.max(t, e),
    l = a + "_" + o,
    c;
  if (n.has(l)) c = n.get(l);
  else {
    let d = i[a],
      h = i[o];
    (c = { a: d, b: h, newEdge: null, faces: [] }), n.set(l, c);
  }
  c.faces.push(r), s[t].edges.push(c), s[e].edges.push(c);
}
function wz(t, e, i, n) {
  let r, s, a;
  for (r = 0, s = t.length; r < s; r++) i[r] = { edges: [] };
  for (r = 0, s = e.length; r < s; r++)
    (a = e[r]),
      Yu(a.a, a.b, t, n, a, i),
      Yu(a.b, a.c, t, n, a, i),
      Yu(a.c, a.a, t, n, a, i);
}
function fc(t, e, i, n, r) {
  t.push(new pf(e, i, n, void 0, void 0, r));
}
function ba(t, e) {
  return Math.abs(e - t) / 2 + Math.min(t, e);
}
function pc(t, e, i, n) {
  t.push([e.clone(), i.clone(), n.clone()]);
}
var Sz = class {
    constructor(t = 1) {
      this.subdivisions = t;
    }
    modify(t) {
      t instanceof st ? (t = new hh().fromBufferGeometry(t)) : (t = t.clone()),
        t.mergeVertices();
      let e = this.subdivisions;
      for (; e-- > 0; ) this._smooth(t);
      return t.computeFaceNormals(), t.computeVertexNormals(), t;
    }
    _smooth(t) {
      let e = new A(),
        i,
        n,
        r,
        s,
        a,
        o = t.vertices,
        l = t.faces,
        c = t.faceVertexUvs[0],
        d = c !== void 0 && c.length > 0,
        h = [],
        u = new Map();
      wz(o, l, h, u);
      let f = [],
        p,
        v,
        g,
        m,
        x,
        y,
        _;
      for (let ee of Array.from(u.keys())) {
        for (
          v = u.get(ee),
            g = new A(),
            x = 3 / 8,
            y = 1 / 8,
            _ = v.faces.length,
            _ != 2 && ((x = 0.5), (y = 0), _ != 1),
            g.addVectors(v.a, v.b).multiplyScalar(x),
            e.set(0, 0, 0),
            s = 0;
          s < _;
          s++
        ) {
          for (
            m = v.faces[s], a = 0;
            a < 3 && ((p = o[bz(m, _z[a])]), !(p !== v.a && p !== v.b));
            a++
          );
          p && e.add(p);
        }
        e.multiplyScalar(y), g.add(e), (v.newEdge = f.length), f.push(g);
      }
      let M,
        b,
        E,
        T,
        S,
        w,
        C,
        L = [];
      for (n = 0, r = o.length; n < r; n++) {
        for (
          w = o[n],
            S = h[n].edges,
            i = S.length,
            i == 3 ? (M = 3 / 16) : i > 3 && (M = 3 / (8 * i)),
            b = 1 - i * Number(M),
            E = M,
            i <= 2 && (i == 2 ? ((b = 3 / 4), (E = 1 / 8)) : i == 1 || i == 0),
            C = w.clone().multiplyScalar(b),
            e.set(0, 0, 0),
            s = 0;
          s < i;
          s++
        )
          (T = S[s]), (p = T.a !== w ? T.a : T.b), e.add(p);
        e.multiplyScalar(Number(E)), C.add(e), L.push(C);
      }
      let P = L.concat(f),
        R = L.length,
        I,
        W,
        N,
        U = [],
        G = [],
        k,
        B,
        V,
        X,
        H = new J(),
        j = new J(),
        Y = new J();
      for (n = 0, r = l.length; n < r; n++)
        (m = l[n]),
          (I = Number($u(m.a, m.b, u).newEdge) + R),
          (W = Number($u(m.b, m.c, u).newEdge) + R),
          (N = Number($u(m.c, m.a, u).newEdge) + R),
          fc(U, I, W, N, m.materialIndex),
          fc(U, m.a, I, N, m.materialIndex),
          fc(U, m.b, W, I, m.materialIndex),
          fc(U, m.c, N, W, m.materialIndex),
          d &&
            ((k = c[n]),
            (B = k[0]),
            (V = k[1]),
            (X = k[2]),
            H.set(ba(B.x, V.x), ba(B.y, V.y)),
            j.set(ba(V.x, X.x), ba(V.y, X.y)),
            Y.set(ba(B.x, X.x), ba(B.y, X.y)),
            pc(G, H, j, Y),
            pc(G, B, H, Y),
            pc(G, V, j, H),
            pc(G, X, Y, j));
      (t.vertices = P), (t.faces = U), d && (t.faceVertexUvs[0] = G);
    }
  },
  gi = new A(),
  Mz = class {
    static create(t) {
      return this.build(this.normalizeInputs(t));
    }
    static normalizeInputs(t, e) {
      let i =
          t.geometry ??
          (e == null ? void 0 : e.geometry) ??
          new st().copy(new $n(100, 100, 100)),
        n;
      e === void 0
        ? (i.computeBoundingBox(),
          i.boundingBox.getSize(gi),
          (n = { width: gi.x, height: gi.y, depth: gi.z, subdivisions: 0 }))
        : (n = e.parameters);
      let r = { ...n, ...t.parameters };
      return {
        parameters: {
          width: Math.abs(r.width),
          height: Math.abs(r.height),
          depth: Math.abs(r.depth),
          subdivisions: Math.abs(r.subdivisions),
        },
        geometry: i,
      };
    }
    static build(t) {
      let { width: e, height: i, depth: n, subdivisions: r } = t.parameters,
        s = t.geometry ?? new st().copy(new $n(100, 100, 100)),
        a = s.userData.parameters;
      a === void 0
        ? (s.computeBoundingBox(), s.boundingBox.getSize(gi))
        : gi.set(a.width, a.height, a.depth),
        (e !== gi.x || i !== gi.y || n !== gi.z) &&
          s.scale(
            gi.x === 0 ? 1 : e / gi.x,
            gi.y === 0 ? 1 : i / gi.y,
            gi.z === 0 ? 1 : n / gi.z
          );
      let o = s.originalGeometry;
      try {
        r > 0
          ? (o === void 0 || (a == null ? void 0 : a.subdivisions) !== r) &&
            (o === void 0 && (o = s),
            (s = new Sz(r).modify(o).toBufferGeometry()))
          : (o !== void 0 && (s = o),
            (o = void 0),
            s.getAttribute("normal") === void 0 && s.computeVertexNormals());
      } catch {
        o !== void 0 && (s = o),
          (o = void 0),
          s.getAttribute("normal") === void 0 && s.computeVertexNormals();
      }
      return (
        o !== void 0 && Object.assign(s, { originalGeometry: o }),
        delete t.geometry,
        Object.assign(s, { userData: { ...t, type: "NonParametricGeometry" } })
      );
    }
    static loadFromUrl(t, e, i) {
      new Tx(i).load(t, (n) => {
        let r = this.normalizeInputs({ geometry: n });
        n.boundingBox.getSize(gi);
        let s = 100 / gi.x;
        Object.assign(r.parameters, {
          width: 100,
          height: gi.y * s,
          depth: gi.z * s,
        }),
          e(this.build(r));
      });
    }
  },
  $_ = class {
    static create(t) {
      return this.build(this.normalizeInputs(t));
    }
    static normalizeInputs(t, e) {
      let i = Object.assign(
        {},
        (e == null ? void 0 : e.parameters) ?? {
          width: 100,
          depth: 0,
          spikes: 5,
          cornerRadius: 0,
          extrudeBevelSize: 0,
          extrudeBevelSegments: 3,
        },
        t.parameters
      );
      return {
        shape: t.shape && t.shape instanceof si ? t.shape : new si(),
        parameters: Object.assign(i, {
          width: Math.abs(i.width),
          height: Math.abs(i.height ?? i.width),
          depth: Math.abs(i.depth ?? 0),
        }),
      };
    }
    static build(t) {
      let {
          width: e,
          height: i,
          spikes: n,
          cornerRadius: r,
          depth: s,
          extrudeBevelSize: a,
          extrudeBevelSegments: o,
        } = t.parameters,
        l = t.shape,
        c = e * 0.5,
        d = i * 0.5,
        h = 0,
        u = 0,
        f = (2 * Math.PI) / n;
      for (let v = 0; v < n; v++) {
        let g = f * v,
          m = h + Math.sin(g) * c,
          x = u + Math.cos(g) * d;
        l.addPoint(l.createPoint(m, x));
      }
      l.isClosed = !0;
      for (let v = 0, g = l.points.length; v < g; v++)
        l.points[v].roundness = r;
      (l.roundness = r), l.update();
      let p = ta.create({
        shape: l,
        parameters: {
          roundness: r,
          depth: s,
          extrudeBevelSize: a,
          extrudeBevelSegments: o,
        },
      });
      return Object.assign(p, { userData: { ...t, type: "PolygonGeometry" } });
    }
  },
  Ez = class {
    static create(t) {
      return this.build(this.normalizeInputs(t));
    }
    static normalizeInputs(t, e) {
      let i = Object.assign(
        {},
        (e == null ? void 0 : e.parameters) ?? {
          width: 100,
          radialSegments: 4,
          heightSegments: 1,
          cornerRadius: 0,
          cornerSegments: 8,
          openEnded: !1,
        },
        t.parameters
      );
      return {
        parameters: Object.assign(i, {
          width: Math.abs(i.width),
          height: Math.abs(i.height ?? i.width),
          depth: Math.abs(i.depth ?? i.width),
        }),
      };
    }
    static build(t) {
      let {
          width: e,
          height: i,
          depth: n,
          radialSegments: r,
          heightSegments: s,
          openEnded: a,
          cornerRadius: o,
          cornerSegments: l,
        } = t.parameters,
        c = new Az(e * 0.5, i, r, s, a, o, l);
      return (
        c.scale(1, 1, n / e),
        Object.assign(c, { userData: { ...t, type: "PyramidGeometry" } })
      );
    }
  };
function Oo(t, e, i) {
  (i.x = t.x * e.x), (i.y = t.y), (i.z = t.x * e.y);
}
function Zu(t, e, i, n, r, s) {
  let a = e.clone().sub(t),
    o = i.clone().sub(t),
    l = a.angleTo(o);
  if ((a.normalize(), o.normalize(), n === r)) {
    let c = a.add(o).normalize();
    s.copy(t).addScaledVector(c, n / Math.sin(l / 2));
  } else {
    let c = a.angleTo(o);
    s.copy(t),
      s.addScaledVector(a, r / Math.sin(c)),
      s.addScaledVector(o, n / Math.sin(c));
  }
}
function Tz(t, e, i) {
  let n = t.clone().sub(e),
    r = i.clone().sub(e);
  return n.projectOnVector(r), n.add(e);
}
var Az = class extends st {
    constructor(t = 0.5, e = 1, i = 4, n = 1, r = !1, s = 0, a = 4) {
      super(),
        (i = Math.floor(Math.max(3, i))),
        (n = Math.floor(n)),
        (a = Math.floor(a));
      let o = [],
        l = [],
        c = [],
        d = [],
        h = 0,
        u = e / 2,
        f = Math.PI / i,
        p = t * Math.cos(Math.PI / i),
        v = (2 * Math.PI) / i,
        g = ((i - 2) * Math.PI) / i,
        m = Math.PI - g,
        x = new A(0, -u, 0),
        y = new A(0, u, 0),
        _ = new J(t, -u),
        M = new J(p, -u),
        b = new J(0, y.y).sub(M),
        E = new J(0, y.y).sub(_),
        T = new J(b.y, -b.x).normalize(),
        S = new J(E.y, -E.x).normalize(),
        w =
          t * Math.cos(Math.PI / i) * Math.tan((Math.PI - b.angle()) / 2) -
          1e-8;
      s = Math.min(s, w);
      let C;
      {
        let N = new A(T.x, T.y, 0),
          U = new A(Math.cos(v) * N.x, N.y, Math.sin(v) * N.x);
        C = N.angleTo(U);
      }
      let L = s / Math.tan((Math.PI - b.angle()) / 2),
        P = s / Math.tan((Math.PI - C) / 2),
        R = new A();
      if (!r) {
        l.push(x.x, x.y, x.z), c.push(0, -1, 0), d.push(0, 0);
        let N = h++,
          U = [],
          G = _.clone(),
          k = L / Math.cos(Math.PI / i);
        G.x -= k;
        for (let B = 0; B < i; B++) {
          let V = (B / i) * Math.PI * 2 + f,
            X = new J(Math.sin(V), Math.cos(V));
          Oo(G, X, R),
            l.push(R.x, R.y, R.z),
            c.push(0, -1, 0),
            d.push(0, 0),
            U.push(h++);
        }
        for (let B = 0; B < U.length; B++)
          o.push(U[B], N, U[(B + 1) % U.length]);
      }
      {
        let N = new A(),
          U = new A(),
          G = new A(),
          k = new A(),
          B = new A(),
          V = new A();
        for (let X = 0; X < i; X++) {
          let H = (X / i) * Math.PI * 2 + f,
            j = ((X + 0.5) / i) * Math.PI * 2 + f,
            Y = ((X + 1) / i) * Math.PI * 2 + f,
            ee = new J(Math.sin(H), Math.cos(H)),
            Z = new J(Math.sin(j), Math.cos(j)),
            K = new J(Math.sin(Y), Math.cos(Y));
          Oo(_, ee, U),
            Oo(_, K, G),
            Oo(T, Z, N),
            Zu(y, U, G, P, P, k),
            l.push(k.x, k.y, k.z),
            Zu(U, y, G, P, L, B),
            l.push(B.x, B.y, B.z),
            Zu(G, U, y, L, P, V),
            l.push(V.x, V.y, V.z),
            c.push(N.x, N.y, N.z),
            c.push(N.x, N.y, N.z),
            c.push(N.x, N.y, N.z),
            d.push(0, 0),
            d.push(0, 0),
            d.push(0, 0);
          let me = h++,
            re = h++,
            F = h++;
          if ((o.push(me, re, F), s > 0)) {
            {
              let oe = U.clone().add(G).multiplyScalar(0.5),
                Me = y.clone().sub(oe).normalize(),
                Ae = x
                  .clone()
                  .sub(oe)
                  .normalize()
                  .add(Me)
                  .normalize()
                  .multiplyScalar(-1),
                ye = V.clone().sub(B);
              I(oe, ye, Ae, b.angle());
            }
            let Te, be;
            {
              let oe = new A();
              Oo(S, K, oe);
              let Me = V.clone().add(k).multiplyScalar(0.5);
              Me = Tz(Me, G, y);
              let Ae = V.clone().sub(k);
              [Te, be] = I(Me, Ae, oe, C, k.y);
            }
            {
              let oe = Te,
                Me = oe.clone().setY(0).normalize(),
                Ae = new A(0, -1, 0),
                ye = Me.clone().cross(Ae);
              W(oe, Me, Ae, ye);
            }
            {
              let oe = b.angle(),
                Me = Math.PI - oe,
                Ae = y.clone();
              Ae.y -= s / Math.sin(oe - Math.PI / 2);
              let ye = new A(),
                _e = [];
              for (let Le = 0; Le < a; Le++) {
                let it = [],
                  O = Math.PI / 2 - (Me * Le) / a,
                  D = Math.cos(O),
                  ne = Math.sin(O),
                  pe = j;
                for (let xe = 0; xe <= Le; xe++) {
                  let we = Math.cos(pe),
                    Fe = Math.sin(pe);
                  (N.x = D * Fe),
                    (N.y = ne),
                    (N.z = D * we),
                    ye.copy(Ae).addScaledVector(N, s),
                    l.push(ye.x, ye.y, ye.z),
                    c.push(N.x, N.y, N.z),
                    d.push(0, 0),
                    it.push(h++),
                    (pe += (Math.PI * 2) / Le / i);
                }
                _e.push(it);
              }
              be.reverse(), _e.push(be);
              let Ee = _e.length - 1;
              for (let Le = 0; Le < Ee; Le++) {
                let it = _e[Le],
                  O = _e[Le + 1],
                  D = it.length - 1;
                o.push(O[1], it[0], O[0]);
                for (let ne = 1; ne <= D; ne++)
                  o.push(it[ne], it[ne - 1], O[ne]),
                    o.push(O[ne + 1], it[ne], O[ne]);
              }
            }
          }
        }
      }
      this.setIndex(o),
        this.setAttribute("position", new We(l, 3)),
        this.setAttribute("normal", new We(c, 3)),
        this.setAttribute("uv", new We(d, 2));
      function I(N, U, G, k, B) {
        let V = -k / 2,
          X = (Math.PI - k) / 2,
          H = U.clone().normalize().cross(G);
        N.addScaledVector(G, -s / Math.sin(X));
        let j = new A(),
          Y = new A(),
          ee = 1,
          Z = h,
          K = [];
        for (let me = 0; me <= a; me++) {
          let re = V + (me / a) * k;
          Y.set(0, 0, 0),
            Y.addScaledVector(H, Math.sin(re)),
            Y.addScaledVector(G, Math.cos(re));
          for (let F = 0; F <= ee; F++) {
            let Te = F / ee - 0.5;
            if (
              (j.copy(N),
              j.addScaledVector(U, Te),
              j.addScaledVector(Y, s),
              B != null)
            ) {
              let be = Math.max(0, j.y - B);
              j.addScaledVector(U, -be / U.y);
            }
            l.push(j.x, j.y, j.z),
              c.push(Y.x, Y.y, Y.z),
              d.push(0, 0),
              F === 0 && K.push(h),
              h++;
          }
        }
        for (let me = 0; me < a; me++)
          for (let re = 0; re < ee; re++) {
            let F = Z + re + (ee + 1) * me,
              Te = F + (ee + 1),
              be = Te + 1,
              oe = F + 1;
            o.push(F, Te, oe), o.push(Te, be, oe);
          }
        return [N.clone().addScaledVector(U, 0.5), K];
      }
      function W(N, U, G, k) {
        let B = Math.PI / 2,
          V = E.angle() - B,
          X = [],
          H = new A(),
          j = new A();
        for (let ee = 0; ee <= a; ee++) {
          let Z = [],
            K = ee / a;
          for (let me = 0; me <= ee; me++) {
            let re = ((ee ? me / ee : 0) - 0.5) * m,
              F = Math.cos(re),
              Te = Math.sin(re),
              be = Math.atan(Math.tan(V) * F),
              oe = (B + be) * K,
              Me = Math.cos(oe),
              Ae = Math.sin(oe);
            H.set(0, 0, 0),
              H.addScaledVector(U, Ae * F),
              H.addScaledVector(G, Me),
              H.addScaledVector(k, Ae * Te),
              j.copy(N).addScaledVector(H, s),
              l.push(j.x, j.y, j.z),
              c.push(H.x, H.y, H.z),
              d.push(0, 0),
              Z.push(h++);
          }
          X.push(Z);
        }
        let Y = X.length - 1;
        for (let ee = 0; ee < Y; ee++) {
          let Z = X[ee],
            K = X[ee + 1],
            me = Z.length - 1;
          o.push(Z[0], K[1], K[0]);
          for (let re = 1; re <= me; re++)
            o.push(Z[re - 1], Z[re], K[re]), o.push(Z[re], K[re + 1], K[re]);
        }
      }
    }
  },
  Y_ = class {
    static create(t) {
      return this.build(this.normalizeInputs(t));
    }
    static normalizeInputs(t, e) {
      let i = Object.assign(
          {},
          (e == null ? void 0 : e.parameters) ?? {
            width: 100,
            depth: 0,
            cornerRadius: [0, 0, 0, 0],
            cornerType: 1,
            extrudeBevelSize: 0,
            extrudeBevelSegments: 1,
          },
          t.parameters
        ),
        n = Object.assign(
          (e == null ? void 0 : e.ui) ?? { enabledIndieCorners: !1 },
          t.ui
        );
      return {
        shape: t.shape && t.shape instanceof si ? t.shape : new si(),
        parameters: Object.assign(i, {
          width: Math.abs(i.width),
          height: Math.abs(i.height ?? i.width),
          depth: Math.abs(i.depth ?? 0),
        }),
        ui: n,
      };
    }
    static build(t) {
      let e = t.shape,
        {
          width: i,
          height: n,
          cornerRadius: r,
          cornerType: s,
          depth: a,
          extrudeBevelSize: o,
          extrudeBevelSegments: l,
        } = t.parameters,
        c = { x: i * 0.5, y: n * 0.5 },
        d = { x: -c.x, y: -c.y },
        h = { x: c.x, y: c.y };
      function u(_, M, b) {
        return M > i && b > n
          ? Math.min((_ * i) / M, (_ * n) / b)
          : M > i
          ? (_ * i) / M
          : b > n
          ? (_ * n) / b
          : _;
      }
      let f = [];
      (f[0] = r[0] === 0 ? 0 : u(r[0], r[0] + r[3], r[0] + r[1])),
        (f[1] = r[1] === 0 ? 0 : u(r[1], r[1] + r[2], r[1] + r[0])),
        (f[2] = r[2] === 0 ? 0 : u(r[2], r[2] + r[1], r[2] + r[3])),
        (f[3] = r[3] === 0 ? 0 : u(r[3], r[3] + r[0], r[3] + r[2]));
      let p = d.x,
        v = h.x,
        g = h.y,
        m = d.y;
      e.addPoint(e.createPoint(p, g)),
        e.addPoint(e.createPoint(v, g)),
        e.addPoint(e.createPoint(v, m)),
        e.addPoint(e.createPoint(p, m)),
        (e.isClosed = !0);
      let x = !0;
      for (let _ = 0, M = e.points.length; _ < M; _++)
        (e.points[_].roundness = f[_]), _ > 0 && f[_] !== f[_ - 1] && (x = !1);
      x && (e.roundness = f[0]),
        (e.useCubicForRoundedCorners = s !== 1),
        e.update();
      let y = ta.create({
        shape: e,
        parameters: { depth: a, extrudeBevelSize: o, extrudeBevelSegments: l },
      });
      return Object.assign(y, {
        userData: { ...t, type: "RectangleGeometry" },
      });
    }
  },
  Cz = class {
    static create(t) {
      return this.build(this.normalizeInputs(t));
    }
    static normalizeInputs(t, e) {
      let i = Object.assign(
        {},
        (e == null ? void 0 : e.parameters) ?? {
          width: 100,
          widthSegments: 64,
          heightSegments: 64,
          phiStart: 0,
          phiLength: 2 * Math.PI,
          thetaStart: 0,
          thetaLength: Math.PI,
        },
        t.parameters
      );
      return {
        parameters: Object.assign(i, {
          width: Math.abs(i.width),
          height: Math.abs(i.height ?? i.width),
          depth: Math.abs(i.depth ?? i.width),
        }),
      };
    }
    static build(t) {
      let {
          width: e = 100,
          height: i = e,
          depth: n = e,
          widthSegments: r = 64,
          heightSegments: s = 64,
          phiStart: a,
          phiLength: o,
          thetaStart: l,
          thetaLength: c,
        } = t.parameters,
        d = new Ah(0.5 * e, r, s, a, o, l, c);
      return (
        d.scale(1, i / e, n / e),
        Object.assign(d, { userData: { ...t, type: "SphereGeometry" } })
      );
    }
  },
  Pz = class {
    static create(t) {
      return this.build(this.normalizeInputs(t));
    }
    static normalizeInputs(t, e) {
      let i = Object.assign(
        {},
        (e == null ? void 0 : e.parameters) ?? {
          width: 100,
          depth: 0,
          widthSegments: 8,
          heightSegments: 8,
        },
        t.parameters
      );
      return {
        parameters: Object.assign(i, {
          width: Math.abs(i.width),
          height: Math.abs(i.height ?? i.width),
          depth: 0,
        }),
      };
    }
    static build(t) {
      let {
          width: e = 100,
          height: i = e,
          widthSegments: n = 8,
          heightSegments: r = 8,
        } = t.parameters,
        s = new yl(e, i, n, r);
      return (
        s.scale(1, 1, 1),
        Object.assign(s, { userData: { ...t, type: "PlaneGeometry" } })
      );
    }
  },
  Lz = class {
    static create(t) {
      return this.build(this.normalizeInputs(t));
    }
    static normalizeInputs(t, e) {
      let i = Object.assign(
        {},
        (e == null ? void 0 : e.parameters) ?? {
          width: 100,
          angle: 90,
          cornerRadius: 24,
          cornerSegments: 8,
        },
        t.parameters
      );
      return {
        parameters: Object.assign(i, {
          width: Math.abs(i.width),
          height: Math.abs(i.height ?? i.width),
          depth: Math.abs(i.depth ?? i.width),
        }),
      };
    }
    static build(t) {
      let {
          width: e,
          height: i,
          depth: n,
          angle: r,
          cornerRadius: s,
          cornerSegments: a,
        } = t.parameters,
        o = new Dz(e, i, n, r, s, a);
      return Object.assign(o, { userData: { ...t, type: "BackdropGeometry" } });
    }
  },
  Dz = class extends st {
    constructor(t = 1, e = 1, i = 1, n = 90, r = 10, s = 24) {
      super(), (this.type = "BackdropGeometry");
      let a = [],
        o = [],
        l = [],
        c = 0.001;
      r == 0 && (s = 1),
        (s = Math.max(1, Math.floor(s))),
        (r = Math.min(r, 100)),
        (n = Math.min(180 - c, n)),
        (n *= Math.PI / 180);
      let d = [],
        h = Math.PI / 2,
        u = (ee = 0, Z = 0, K = 0) => new A(ee, Z, K),
        f = u(),
        p = u(),
        [v, g, m] = [e / 2, t / 2, i / 2],
        x = -g,
        y = +g,
        [_, M, b] = [u(x, -v, +m), u(x, -v, -m), u(x, +v, -m)],
        E = (ee, Z = !1) => Math.sin(ee - Math.PI / (1 + +Z)),
        T = (ee, Z = !1) => Math.cos(ee - Math.PI / (1 + +Z));
      b.y = Math.sin(n) * e - v;
      let S = Math.cos(n) * e - m,
        w = _.z - c;
      n <= h
        ? ((b.z = Math.min(S, w)),
          b.z == w && (b.y -= (S - w) / Math.tan(h - n)))
        : (M.z = Math.min(M.z - S - m, _.z - c)),
        f.subVectors(_, M),
        p.subVectors(b, M);
      let C = (Math.min(f.length(), p.length()) * r) / 100,
        L = C * Math.tan(n / 2),
        P = C / Math.cos(n / 2),
        R = f.clone().normalize().add(p.normalize()).setLength(P).add(M);
      f.set(0, E(n, !0), T(n, !0)), d.push([b, f.clone()]);
      let I = (Math.PI - n) / s;
      for (let ee = 0; ee <= s; ee++) {
        let Z = h + n + ee * I;
        f.set(0, Math.sin(Z) * L, Math.cos(Z) * L),
          f.add(R),
          p.set(0, E(Z), T(Z)),
          d.push([f.clone(), p.clone()]);
      }
      d.push([_, u(0, 1, 0)]);
      let W = Math.sin(I / 2) * L * 2,
        N = d.length - 1,
        U = d[0][0].distanceTo(d[1][0]),
        G = d[N - 1][0].distanceTo(d[N][0]),
        k = U + W * s + G;
      d[0].push(1);
      for (let ee = 0; ee <= s; ee++) d[ee + 1].push(1 - (U + ee * W) / k);
      d[N].push(0);
      let [B, V, X] = d[0],
        H,
        j,
        Y;
      for (let ee = 1; ee < d.length; ee++)
        ([H, j, Y] = d[ee]),
          a.push(
            x,
            B.y,
            B.z,
            x,
            H.y,
            H.z,
            y,
            B.y,
            B.z,
            y,
            B.y,
            B.z,
            x,
            H.y,
            H.z,
            y,
            H.y,
            H.z
          ),
          o.push(
            0,
            V.y,
            V.z,
            0,
            j.y,
            j.z,
            0,
            V.y,
            V.z,
            0,
            V.y,
            V.z,
            0,
            j.y,
            j.z,
            0,
            j.y,
            j.z
          ),
          l.push(0, X, 0, Y, 1, X, 1, X, 0, Y, 1, Y),
          ([B, V, X] = [H, j, Y]);
      this.setAttribute("position", new We(a, 3)),
        this.setAttribute("normal", new We(o, 3)),
        this.setAttribute("uv", new We(l, 2));
    }
  },
  Z_ = class {
    static create(t) {
      return this.build(this.normalizeInputs(t));
    }
    static normalizeInputs(t, e) {
      let i = Object.assign(
        {},
        (e == null ? void 0 : e.parameters) ?? {
          width: 100,
          depth: 0,
          innerRadiusPercent: 38.19,
          spikes: 5,
          cornerRadius: 0,
          angle: 360,
          extrudeBevelSize: 0,
          extrudeBevelSegments: 1,
        },
        t.parameters
      );
      return {
        shape: t.shape && t.shape instanceof si ? t.shape : new si(),
        parameters: Object.assign(i, {
          width: Math.abs(i.width),
          height: Math.abs(i.height ?? i.width),
          depth: Math.abs(i.depth ?? 0),
        }),
      };
    }
    static build(t) {
      let {
          width: e,
          height: i,
          innerRadiusPercent: n,
          spikes: r,
          cornerRadius: s,
          angle: a,
          depth: o,
          extrudeBevelSize: l,
          extrudeBevelSegments: c,
        } = t.parameters,
        d = t.shape,
        h = e * 0.5,
        u = i * 0.5,
        f = 0,
        p = 0,
        v = (a * Math.PI) / 360 / r,
        g = (Math.PI / 2) * 3 * -1,
        m = (h * n) / 100,
        x = (u * n) / 100;
      if (r === 3 && n === 50) {
        v = (2 * Math.PI) / r;
        for (let _ = 0; _ < r; _++) {
          let M = v * _,
            b = f + Math.sin(M) * h,
            E = p + Math.cos(M) * u;
          d.addPoint(d.createPoint(b, E));
        }
      } else
        for (let _ = 0; _ < r; _++) {
          let M = f + Math.cos(g) * h,
            b = p + Math.sin(g) * u;
          d.addPoint(d.createPoint(M, b)),
            (g += v),
            (M = f + Math.cos(g) * m),
            (b = p + Math.sin(g) * x),
            d.addPoint(d.createPoint(M, b)),
            (g += v);
        }
      d.isClosed = !0;
      for (let _ = 0, M = d.points.length; _ < M; _++)
        d.points[_].roundness = s;
      (d.roundness = s), d.update();
      let y = ta.create({
        shape: d,
        parameters: {
          roundness: s,
          depth: o,
          extrudeBevelSize: l,
          extrudeBevelSegments: c,
        },
      });
      return Object.assign(y, { userData: { ...t, type: "StarGeometry" } });
    }
  },
  Rz = class {
    static create(t) {
      return this.build(this.normalizeInputs(t));
    }
    static normalizeInputs(t, e) {
      let i = Object.assign(
        {},
        (e == null ? void 0 : e.parameters) ?? { width: 100, depth: 0 },
        t.parameters
      );
      return {
        parameters: Object.assign(i, {
          width: Math.abs(i.width),
          height: Math.abs(i.height ?? i.width),
          depth: Math.abs(i.depth ?? 0),
        }),
      };
    }
    static build(t) {
      let { width: e, height: i } = t.parameters,
        n = new yl(e, i);
      return Object.assign(n, {
        userData: { ...t, type: "TextFrameGeometry" },
      });
    }
  },
  Oz = class {
    static create(t) {
      return this.build(this.normalizeInputs(t));
    }
    static normalizeInputs(t, e) {
      let i = Object.assign(
          {},
          (e == null ? void 0 : e.parameters) ?? {
            width: 100,
            radialSegments: 32,
            tubularSegments: 64,
            arc: Math.PI * 2,
            cornerRadius: 30,
            cornerSegments: 8,
          },
          t.parameters
        ),
        n = Math.abs(i.width),
        r = Math.abs(i.height ?? i.width),
        s = Math.round(Math.abs(i.depth ?? i.width * 0.25));
      return {
        parameters: Object.assign(i, { width: n, height: r, depth: s }),
      };
    }
    static build(t) {
      let {
          width: e,
          height: i,
          depth: n,
          radialSegments: r,
          tubularSegments: s,
          arc: a,
          cornerRadius: o,
          cornerSegments: l,
        } = t.parameters,
        c = Iz(e, i, n, e * 0.5, a, s, 0, 0, r, o, l);
      return (
        c.scale(1, i / e, 1),
        Object.assign(c, { userData: { ...t, type: "TorusGeometry" } })
      );
    }
  };
function Iz(t, e, i, n, r, s, a, o, l, c, d) {
  return (
    ([e, i] = [i, e]),
    (a = e / 2),
    (r /= 2 * Math.PI),
    r == 1 && (c = 0),
    new q_(!0, t, e, i, n, r, s, a, o, l, c, d)
  );
}
var Uz = class {
    static create(t) {
      return this.build(this.normalizeInputs(t));
    }
    static normalizeInputs(t, e) {
      let i = Object.assign(
        {},
        (e == null ? void 0 : e.parameters) ?? {
          width: 100,
          tubularSegments: 64,
          radialSegments: 32,
          p: 2,
          q: 3,
        },
        t.parameters
      );
      return {
        parameters: Object.assign(i, {
          width: Math.abs(i.width),
          height: Math.abs(i.height ?? i.width),
          depth: Math.abs(i.depth ?? i.width),
          tube: i.tube ?? i.width * 0.125,
        }),
      };
    }
    static build(t) {
      let {
          width: e,
          tube: i,
          tubularSegments: n,
          radialSegments: r,
          p: s,
          q: a,
        } = t.parameters,
        o = e * 0.5;
      o !== i && (o -= i);
      let l = new ep(o, i, n, r, s, a);
      return Object.assign(l, {
        userData: { ...t, type: "TorusKnotGeometry" },
      });
    }
  },
  Nz = class {
    static create(t) {
      return this.build(this.normalizeInputs(t));
    }
    static normalizeInputs(t, e) {
      let i = Object.assign(
        {},
        (e == null ? void 0 : e.parameters) ?? {
          width: 100,
          depth: 0,
          spikes: 5,
          cornerRadius: 0,
          extrudeBevelSize: 0,
          extrudeBevelSegments: 1,
          isRect: !1,
        },
        t.parameters
      );
      return {
        shape: t.shape && t.shape instanceof si ? t.shape : new si(),
        parameters: Object.assign(i, {
          width: Math.abs(i.width),
          height: Math.abs(
            i.height ?? i.width * (i.isRect ? 1 : Math.sqrt(3) / 2)
          ),
          depth: Math.abs(i.depth ?? 0),
        }),
      };
    }
    static build(t) {
      let {
          width: e = 100,
          height: i,
          cornerRadius: n,
          depth: r,
          extrudeBevelSize: s,
          extrudeBevelSegments: a,
          isRect: o,
        } = t.parameters,
        l = t.shape,
        c = e * 0.5,
        d = i * 0.5;
      o
        ? (l.addPoint(l.createPoint(-c, d)),
          l.addPoint(l.createPoint(c, -d)),
          l.addPoint(l.createPoint(-c, -d)))
        : (l.addPoint(l.createPoint(0, d)),
          l.addPoint(l.createPoint(c, -d)),
          l.addPoint(l.createPoint(-c, -d))),
        (l.isClosed = !0);
      for (let u = 0, f = l.points.length; u < f; u++)
        l.points[u].roundness = n;
      (l.roundness = n), l.update();
      let h = ta.create({
        shape: l,
        parameters: {
          roundness: n,
          depth: r,
          extrudeBevelSize: s,
          extrudeBevelSegments: a,
        },
      });
      return Object.assign(h, { userData: { ...t, type: "TriangleGeometry" } });
    }
  };
function zz(t, e) {
  let i = 2 * Math.PI;
  return ((t % i) + i) % i === ((e % i) + i) % i;
}
var Bz = new ze(),
  Fz = new ze();
function kz(t, e, i) {
  let n = [new A(), new A(), new A()],
    r = [new A(), new A(), new A()];
  return (
    t.extractBasis(n[0], n[1], n[2]),
    e.extractBasis(r[0], r[1], r[2]),
    n.forEach((s, a) => {
      let o = r[a],
        l = Jt.lerp(s.length(), o.length(), i);
      s.lerp(o, i).setLength(l);
    }),
    new ze().makeBasis(n[0], n[1], n[2])
  );
}
var Vz = class {
    static create(t) {
      return this.build(this.normalizeInputs(t));
    }
    static normalizeInputs(t, e) {
      let i = Object.assign(
          {},
          (e == null ? void 0 : e.parameters) ?? {
            width: 100,
            height: 100,
            depth: 1,
            subdivisions: 12,
            roundness: 0,
            extrudeBevelSize: 0,
            extrudeBevelSegments: 3,
          },
          t.parameters
        ),
        n = Math.abs(i.width),
        r = Math.abs(i.height ?? i.width),
        s = Math.abs(i.depth ?? 0),
        a =
          (e == null ? void 0 : e.shapeData) ??
          zp.create({ parameters: A_ }).userData.shape;
      return {
        path: t.path ?? rh.defaultData(),
        parameters: Object.assign(i, {
          width: n,
          height: r,
          depth: s,
          extrusion: { ...C_, ...i.extrusion },
        }),
        shapeData: a,
      };
    }
    static build(t) {
      if (t.path.points.length >= 2) {
        let e = new Hz(t);
        return Object.assign(e, { userData: { ...t, type: "PathGeometry" } });
      } else
        return Object.assign(new st(), {
          userData: { ...t, type: "PathGeometry" },
        });
    }
  },
  Hz = class extends st {
    constructor(t) {
      super(),
        (this.type = "PathExtrusionGeometry"),
        (this.inputs = t),
        this.build();
    }
    _isGeometryClosed() {
      return (
        this.inputs.path.isClosed &&
        this.inputs.parameters.extrusion.depth === 1
      );
    }
    _isOpenEnded() {
      let t = this.inputs.parameters.extrusion;
      return (
        !(this.inputs.path.isClosed && t.depth === 1) ||
        !zz(t.twist, 0) ||
        t.startScale !== t.endScale
      );
    }
    build() {
      let t = this._extractPathPoints();
      if (t.length < 2) return;
      let e = this._computeBasisMatrices(t),
        { depth: i, offset: n } = this.inputs.parameters.extrusion,
        r = this.inputs.path.isClosed ? t.length : t.length - 1,
        s = Math.floor(n * r),
        a = this.inputs.path.isClosed
          ? Math.ceil((i + n) * r)
          : Math.ceil(Math.min(1, i + n) * r),
        o = Math.min(Math.max(2, a - s + 1), r + 2),
        l = [],
        c = [];
      for (let N = 0; N < o; N++) {
        let U = this.inputs.path.isClosed
          ? (N + s) % t.length
          : Math.min(N + s, t.length - 1);
        l.push(t[U].clone()), c.push(e[U].clone());
      }
      let d = (N, U, G) => {
          (l[N] = l[N].clone().lerp(l[U], G)), (c[N] = kz(c[N], c[U], G));
        },
        h = 0,
        u = (n * r) % 1;
      (!this.inputs.path.isClosed || i <= 1) &&
        (u || n === 0) &&
        ((h = u), d(0, 1, h));
      let f = 0,
        p = ((n + i) * r) % 1;
      if (
        (((this.inputs.path.isClosed && i <= 1) ||
          (!this.inputs.path.isClosed && n + i < 1)) &&
          p &&
          ((f = p), d(l.length - 1, l.length - 2, 1 - f)),
        i === 0)
      ) {
        let N = l.length - 1;
        l[N].copy(l[0]), c[N].copy(c[0]);
      }
      this._applyPathModifiers(c, h, f);
      let { bevel: v, bevelSides: g } = this.inputs.parameters.extrusion,
        m = v > 0 ? this.inputs.parameters.extrusion.capType : "flat",
        x = 5;
      this.inputs.parameters.extrusion.shape.type === "Custom" &&
        (x =
          this.inputs.parameters.extrusion.shape.shapeQuality === "low"
            ? 5
            : 12);
      let { regions: y, infos: _, vertices: M } = this._computeShapePoints(x),
        b = 0,
        E;
      m === "round" &&
        ((E = new Np(this.inputs.shapeData, 2 * v, v, x, g, void 0, !0)),
        (b = E.getAttribute("position").count));
      let T = 0,
        S = 0;
      _.sort((N, U) => N.start - U.start),
        _.forEach((N) => {
          (N.verticesStart = T),
            (N.verticesCount = N.continuous.reduce(
              (U, G, k) => U + (k === 0 || !G ? 2 : 1),
              0
            )),
            (S += N.verticesCount),
            (T = S);
        });
      let w = S * o,
        C,
        L = 0;
      if (this._isOpenEnded() && m === "flat") {
        try {
          C = is({
            windingRule: Vt.ODD,
            elementType: mi.POLYGONS,
            polySize: 3,
            vertexSize: 2,
            strict: !0,
            contours: y,
          });
        } catch {
          C = F_;
        }
        L = C.vertexCount;
      }
      let P = w + 2 * L + b * 2,
        R = w + 2 * L,
        I = {
          positions: new Float32Array(P * 3),
          normals: new Float32Array(P * 3),
          uvs: new Float32Array(P * 2),
        },
        W = [];
      if (
        (_.forEach((N) => {
          this._extrudeRegion(
            N,
            M,
            c,
            l,
            I,
            W,
            this._isGeometryClosed() && !this._isOpenEnded()
          );
        }),
        C &&
          (this._closeEnd(C, w, W, I, c[0], l[0], !1),
          this._closeEnd(C, w + L, W, I, c[c.length - 1], l[l.length - 1], !0)),
        E)
      ) {
        I.positions.set(E.getAttribute("position").array, R * 3),
          I.normals.set(E.getAttribute("normal").array, R * 3),
          I.uvs.set(E.getAttribute("uv").array, R * 2);
        let N = W.length;
        W.push(...E.getIndex().array.map((k) => k + R)),
          (R += b),
          I.positions.set(E.getAttribute("position").array, R * 3),
          I.normals.set(E.getAttribute("normal").array, R * 3),
          I.uvs.set(E.getAttribute("uv").array, R * 2);
        let U = W.length;
        W.push(...E.getIndex().array.map((k) => k + R)),
          this.setAttribute("position", new pt(I.positions, 3)),
          this.setAttribute("normal", new pt(I.normals, 3)),
          this.setAttribute("uv", new pt(I.uvs, 2)),
          this.setIndex(W);
        let G = Bz;
        G.copy(c[c.length - 1]).setPosition(l[l.length - 1]),
          this.applyMatrix4OnRange(G, R, P),
          G.copy(c[0]).setPosition(l[0]).multiply(Fz.makeScale(1, 1, -1)),
          this.applyMatrix4OnRange(G, R - b, R),
          this.reverseIndicesOnRange(N, U);
      } else
        this.setAttribute("position", new pt(I.positions, 3)),
          this.setAttribute("normal", new pt(I.normals, 3)),
          this.setAttribute("uv", new pt(I.uvs, 2)),
          this.setIndex(W);
    }
    _extractPathPoints() {
      let t = D_(this.inputs.path).getPoints(this.inputs.path.subdivisions);
      if (t.length < 2) return [];
      let e = [t[0]];
      return (
        t.forEach((i) => {
          e[e.length - 1].distanceToSquared(i) > 0.001 && e.push(i);
        }),
        this.inputs.path.isClosed &&
          e[e.length - 1].distanceTo(e[0]) < 0.001 &&
          e.pop(),
        e
      );
    }
    _computeBasisMatrices(t) {
      let e = [],
        i = t.length,
        n = this.inputs.path.isClosed,
        r = new A(),
        s = new A(),
        a = new A(),
        o = new A(),
        l = new A(0, 1, 0);
      for (let p = 0; p < i; p++) {
        let v = t[p],
          g;
        p === 0
          ? (g = n ? t[t.length - 2] : v.clone().multiplyScalar(2).sub(t[1]))
          : (g = t[p - 1]);
        let m;
        p === i - 1
          ? (m = n
              ? t[1]
              : v
                  .clone()
                  .multiplyScalar(2)
                  .sub(t[p - 1]))
          : (m = t[p + 1]);
        let x = v.clone().sub(g).normalize(),
          y = m.clone().sub(v).normalize(),
          _ = x.clone().add(y).normalize();
        a.copy(_),
          p === 0 &&
            (_.equals(l) || _.clone().negate().equals(l)) &&
            l.set(0, 0, 1);
        let M = l.clone().cross(_).normalize(),
          b = _.clone().cross(M).normalize();
        l.copy(b), o.copy(M), p === 0 && (r.copy(b), s.copy(_));
        let E = new ze().makeBasis(M, b, _);
        e.push(E);
      }
      let c = n ? s : a,
        d = n ? r : new A(0, 1, 0),
        h = c.clone().cross(o).normalize(),
        u = Math.acos(d.dot(h));
      if (isNaN(u)) return e;
      let f = d.clone().cross(h);
      c.dot(f) > 0 && (u *= -1);
      for (let p = 1; p < e.length; p++) {
        let v = new ze().makeRotationZ((u * p) / e.length);
        e[p].multiply(v);
      }
      return e;
    }
    _applyPathModifiers(t, e, i) {
      let n = t.length,
        {
          angle: r,
          twist: s,
          startScale: a,
          endScale: o,
        } = this.inputs.parameters.extrusion,
        l = new ze(),
        c = new ze();
      return (
        t.forEach((d, h) => {
          let u =
            h === 0
              ? 0
              : h === n - 1
              ? 1
              : (h - e) / (n - (i === 0 ? 0 : 1) - (e + (1 - i)));
          l.makeRotationZ(Jt.lerp(r, r + s, u));
          let f = Jt.lerp(a, o, u);
          c.makeScale(f, f, f), d.multiply(l).multiply(c);
        }),
        t
      );
    }
    _computeShapePoints(t = 12, e = Vt.ODD) {
      let i = this.inputs.shapeData,
        n = i.extractShapePointsToFlatArray([], t),
        r = i.shapeHoles.map((c) => {
          let d = c.extractShapePointsToFlatArray([], t),
            h = [];
          for (let u = d.length - 1; u >= 1; u -= 2) {
            let f = d[u - 1],
              p = d[u - 0];
            h.push(f, p);
          }
          return h;
        }),
        s;
      try {
        s = is({
          windingRule: e,
          elementType: mi.BOUNDARY_CONTOURS,
          vertexSize: 2,
          strict: !0,
          contours: [n],
        });
      } catch {
        s = Up;
      }
      let a;
      try {
        a = is({
          windingRule: Vt.ODD,
          elementType: mi.BOUNDARY_CONTOURS,
          vertexSize: 2,
          strict: !0,
          contours: [...r],
        });
      } catch {
        a = B_;
      }
      if (!s) throw new Error("error generating geometry");
      let o = s.elementCount;
      if (a) {
        s.elementCount += a.elementCount;
        for (let c = 0; c < a.elements.length; c++) {
          let d = a.elements[c],
            h = c % 2 === 0 ? s.vertexCount : 0;
          s.elements.push(d + h);
        }
        for (let c = 0; c < a.vertexIndices.length; c++) {
          let d = a.vertexIndices[c],
            h = s.vertexCount;
          s.vertexIndices.push(d + h);
        }
        for (let c = 0; c < a.vertices.length; c++) {
          let d = a.vertices[c];
          s.vertices.push(d);
        }
      }
      for (let c = 0, d = s.vertexCount; c < d; c++) {
        let h = c * 2;
        s.vertices[h + 0], s.vertices[h + 1];
      }
      let l = [];
      for (let c = s.elementCount - 1; c >= 0; c--) {
        let d = c >= o,
          h = c * 2,
          u = s.elements[h + 0],
          f = s.elements[h + 1],
          p = u + f,
          v = {
            start: u,
            count: f,
            normals: [],
            isHole: d,
            continuous: [],
            verticesStart: 0,
            verticesCount: 0,
          };
        l.push(v);
        let g = u,
          m = p - 1,
          x = u + 1,
          y = i.roundedCurves.length;
        do {
          let _ = g - u;
          s.vertices[m * 2 + 0], s.vertices[m * 2 + 1];
          let M = s.vertices[g * 2 + 0],
            b = s.vertices[g * 2 + 1],
            E = s.vertices[x * 2 + 0],
            T = s.vertices[x * 2 + 1],
            S = M - E,
            w = b - T,
            C = Math.sqrt(S * S + w * w);
          (S /= C),
            (w /= C),
            (v.normals[_ * 2 + 0] = -w),
            (v.normals[_ * 2 + 1] = S);
          let L = s.vertexIndices[g];
          if (Array.isArray(L)) v.continuous[_] = !1;
          else {
            let [P, R] = i.getCurveIndexFromVertexId(L - 1, !0);
            if (R > 0 && R < 1) v.continuous[_] = !0;
            else {
              let I = R === 1 ? P + 1 : P - 1;
              I = (I + y) % y;
              let W = R === 1 ? 0 : 1,
                N = i.roundedCurves[P].getTangent(R),
                U = i.roundedCurves[I].getTangent(W);
              v.continuous[_] = N.dot(U) > 0.95;
            }
          }
          d && ((v.normals[_ * 2 + 0] *= -1), (v.normals[_ * 2 + 1] *= -1)),
            ([m, g, x] = [g, x, x + 1]),
            x >= p && (x -= f);
        } while (x !== u + 1);
      }
      return { regions: [n, ...r], infos: l, vertices: s.vertices };
    }
    _insertVertex(t, e, i, n, r) {
      let s = e * 2,
        a = e * 3;
      (t.positions[a + 0] = i.x),
        (t.positions[a + 1] = i.y),
        (t.positions[a + 2] = i.z),
        (t.normals[a + 0] = n.x),
        (t.normals[a + 1] = n.y),
        (t.normals[a + 2] = n.z),
        (t.uvs[s + 0] = r.x),
        (t.uvs[s + 1] = r.y);
    }
    _extrudeRegion(t, e, i, n, r, s, a) {
      let o = new A(),
        l = new A(),
        c = new A(),
        d = new A(),
        h = new J();
      i.forEach((f, p) => {
        let v = n[p],
          g = t.verticesStart * i.length + t.verticesCount * p;
        for (let m = 0; m < t.count; m++) {
          let x = (t.start + m) * 2;
          if (
            (o.set(e[x + 0], e[x + 1], 0),
            c.copy(o).applyMatrix4(f).add(v),
            t.continuous[m])
          )
            d.set(t.normals[m * 2 + 0], t.normals[m * 2 + 1], 0);
          else {
            let y = m === 0 ? (t.start + t.count - 1) * 2 : x - 2;
            l.set(e[y + 0], e[y + 1], 0),
              d.copy(o).sub(l),
              d.set(-d.y, d.x, 0),
              t.isHole || d.negate();
          }
          if (
            (d.applyMatrix4(f).normalize(),
            h.set(m === 0 ? 1 : m / t.count, p / (i.length - 1)),
            this._insertVertex(r, g, c, d, h),
            g++,
            !t.continuous[m] || m === 0)
          ) {
            if (m === 0)
              d.set(t.normals[m * 2 + 0], t.normals[m * 2 + 1], 0),
                h.set(0, p / (i.length - 1));
            else {
              let y = m === t.count - 1 ? t.start * 2 : x + 2;
              l.set(e[y + 0], e[y + 1], 0),
                d.copy(l).sub(o),
                d.set(-d.y, d.x, 0),
                t.isHole || d.negate();
            }
            d.applyMatrix4(f).normalize(),
              this._insertVertex(r, g, c, d, h),
              g++;
          }
        }
      });
      let u = i.length - 1;
      for (let f = 0; f < u; f++) {
        let p = t.verticesStart * i.length + t.verticesCount * f,
          v = t.verticesStart * i.length + t.verticesCount * (f + 1),
          g = 0;
        for (let m = 0; m < t.count; m++) {
          (!t.continuous[m] || m === 0) && g++;
          let x = m === t.count - 1 ? 0 : g + 1,
            y = p + g,
            _ = p + x,
            M = v + x,
            b = v + g;
          t.isHole ? s.push(y, M, _, y, b, M) : s.push(y, _, M, y, M, b), g++;
        }
      }
    }
    _closeEnd(t, e, i, n, r, s, a) {
      let o = t.vertexCount,
        l = new A(0, 0, a ? -1 : 1).applyMatrix4(r),
        c = new A(),
        d = new J();
      for (let u = 0; u < o; u++) {
        let f = 2 * u;
        c
          .set(t.vertices[f + 0], t.vertices[f + 1], 0)
          .applyMatrix4(r)
          .add(s),
          this._insertVertex(n, e + u, c, l, d);
      }
      let h = t.elements;
      for (let u = 0; u < t.elementCount; u++) {
        let f = 3 * u,
          p = h[f + 0] + e,
          v = h[f + (a ? 1 : 2)] + e,
          g = h[f + (a ? 2 : 1)] + e;
        i.push(p, v, g);
      }
    }
    applyMatrix4OnRange(t, e, i) {
      let n = t.elements,
        r = new ft().getNormalMatrix(t).elements,
        s,
        a,
        o,
        l,
        c = this.attributes.position,
        d = this.attributes.normal;
      if (!c || !d) return;
      let h = c.array,
        u = d.array,
        f = c.itemSize;
      for (let p = e * f, v = i * f; p < v; p += f) {
        if (p === e) debugger;
        (s = h[p + 0]),
          (a = h[p + 1]),
          (o = h[p + 2]),
          (l = 1 / (n[3] * s + n[7] * a + n[11] * o + n[15])),
          (h[p + 0] = (n[0] * s + n[4] * a + n[8] * o + n[12]) * l),
          (h[p + 1] = (n[1] * s + n[5] * a + n[9] * o + n[13]) * l),
          (h[p + 2] = (n[2] * s + n[6] * a + n[10] * o + n[14]) * l),
          (s = u[p + 0]),
          (a = u[p + 1]),
          (o = u[p + 2]),
          (u[p + 0] = r[0] * s + r[3] * a + r[6] * o),
          (u[p + 1] = r[1] * s + r[4] * a + r[7] * o),
          (u[p + 2] = r[2] * s + r[5] * a + r[8] * o);
      }
      (c.needsUpdate = !0), (d.needsUpdate = !0);
    }
    reverseIndicesOnRange(t, e) {
      let i = this.index;
      if (i) {
        for (let n = t; n < e; n += 3) {
          let r = i.getX(n),
            s = i.getX(n + 1),
            a = i.getX(n + 2);
          i.setXYZ(n, a, s, r);
        }
        i.needsUpdate = !0;
      }
    }
  };
function K_() {
  let t = new st();
  return (
    t.setAttribute("position", new pt(new Float32Array([]), 3)),
    t.setIndex(new pt(new Uint16Array([]), 1)),
    t
  );
}
var Gz = K_().attributes,
  jz = 12,
  Wz = 1,
  J_ = class extends st {
    constructor(t, e) {
      super(),
        (this.charWidths = []),
        (this.charCoords = []),
        (this.wrappedText = []),
        (this.isLowResolution = !1),
        (this.vectorShapes = []),
        Object.assign(this.attributes, Gz),
        (this.userData = { parameters: t, type: "TextGeometry" });
      let i = e.getFont(t.font);
      i != null && i.isLoaded
        ? ((this.font = i), this.update(t))
        : this.updateFont(t.font, e).then(() => {
            this.update(t), e == null || e.requestRender();
          });
    }
    async updateFont(t, e) {
      let i = e.getFont(t);
      i && ((this.font = i), await i.loadingPromise);
    }
    update(t) {
      let e = this.font;
      if (
        ((this.userData = { parameters: t, type: "TextGeometry" }),
        !(e != null && e.isLoaded))
      ) {
        console.warn("Cannot update text because its font is not loaded");
        return;
      }
      let {
          width: i,
          height: n,
          depth: r,
          extrudeBevelSize: s,
          extrudeBevelSegments: a,
          text: o,
          textTransform: l,
        } = t,
        c = l === 2 ? o.toUpperCase() : l === 3 ? o.toLowerCase() : o,
        d = qz(t, e, c),
        { shapes: h, charWidths: u, charCoords: f } = e.generateShapes(d, t),
        p = i * 0.5,
        v = n * 0.5,
        g = h.map((y) => new si().fromShape(y));
      this.vectorShapes = g;
      let m = g.map((y) =>
          ta.create({
            shape: y,
            parameters: {
              depth: r,
              extrudeBevelSegments: a,
              extrudeBevelSize: s,
              windingRule: r <= 0 ? Vt.NONZERO : Vt.ODD,
              subdivisions: this.isLowResolution && r > 0 ? Wz : jz,
            },
          })
        ),
        x = m.length ? Lx(m) : K_();
      x.translate(-p, v, 0),
        this.dispose(),
        (this.wrappedText = d),
        (this.charCoords = f),
        (this.charWidths = u),
        this.deleteAttribute("extrudeNormal"),
        Object.entries(x.attributes).forEach(([y, _]) => {
          this.setAttribute(y, _);
        }),
        this.setIndex(x.index),
        this.computeBoundingSphere();
    }
    clone() {
      let t = qs(new st(), J_.prototype);
      return t.copy(this), console.log("CloneGeometry", this, t), t;
    }
    copy(t) {
      return (
        Object.entries(t.attributes).forEach(([e, i]) => {
          this.setAttribute(e, i);
        }),
        this.setIndex(t.index),
        (this.userData = {
          parameters: { ...t.userData.parameters },
          type: "TextGeometry",
        }),
        this
      );
    }
    async setText(t) {
      this.font && (await this.font.loadingPromise),
        await this.update({ ...this.userData.parameters, text: t });
    }
    get text() {
      return this.userData.parameters.text ?? "";
    }
  };
function qz(t, e, i) {
  i = i ?? t.text;
  let n = [""],
    r = "";
  for (let s of i)
    (r += s),
      s === " " ||
      s ===
        `
`
        ? ((n[n.length - 1] += r),
          (r = ""),
          s ===
            `
` && n.push(""))
        : e.getTextWidth(n[n.length - 1] + r, t) > t.width &&
          (n[n.length - 1].length && n.push(""),
          e.getTextWidth(n[n.length - 1] + r, t) > t.width &&
            (r.length === 1
              ? ((n[n.length - 1] += r), (r = ""))
              : ((n[n.length - 1] += r.slice(0, -1)),
                (r = r[r.length - 1]),
                n.push(""))));
  return (n[n.length - 1] += r), n;
}
var Q_,
  Bp = new Promise((t) => {
    Q_ = t;
  }),
  yv = !1,
  mc;
function Xz() {
  if (yv) return;
  if (mc) return mc;
  async function t() {
    let e = "https://unpkg.com/@splinetool/modelling-wasm@0.9.425/build",
      i = Tf(
        () => import("../chunks/process.6ac5400d.js"),
        [],
        import.meta.url
      ),
      [n, r] = await Promise.all([
        i,
        fetch(`${e}/process.wasm`).then((o) => o.arrayBuffer()),
      ]),
      s = n.default,
      a = await s({ wasmBinary: r });
    Q_(a), (yv = !0);
  }
  return (mc = t()), mc;
}
function uh(t, e, i) {
  let n = { parameters: t, type: t.type };
  if (t.type === "PathGeometry") n.path = t.path;
  else if (t.type === "VectorGeometry") {
    let s = si.createFromState(t.shape, t.width, t.height);
    n.shape = s;
  } else if (t.type === "NonParametricGeometry")
    t.data.groups &&
      t.data.groups.forEach(
        (s) => (s.materialIndex = Math.max(s.materialIndex ?? 0, 0))
      ),
      (n.geometry = new Tx().parse(t));
  else {
    if (t.type === "SubdivGeometry") return new Gi(t, i);
    if (t.type === "TextGeometry") return new J_(t, e);
  }
  let r;
  try {
    r = Sv(n);
  } catch (s) {
    console.error(s);
  }
  if (!r) {
    let s = si.createFromState(nh.defaultData(), 100, 100);
    (n.shape = s), (r = Sv(n));
  }
  return r;
}
var $z = new ze();
function mf(t, e, i, n) {
  let r = t.position.array,
    s = t.normal.array,
    a = $z.makeScale(e, i, n).invert().elements,
    o,
    l,
    c;
  for (var d = 0, h = r.length; d < h; d += 3)
    (r[d] *= e),
      (r[d + 1] *= i),
      (r[d + 2] *= n),
      (o = s[d]),
      (l = s[d + 1]),
      (c = s[d + 2]),
      (s[d] = a[0] * o + a[4] * l + a[8] * c),
      (s[d + 1] = a[1] * o + a[5] * l + a[9] * c),
      (s[d + 2] = a[2] * o + a[6] * l + a[10] * c);
  (t.position.needsUpdate = !0), (t.normal.needsUpdate = !0);
}
var gc = new An(),
  wa = new A(),
  et;
Bp.then((t) => {
  et = t;
});
var xv = new Float32Array([10, 10, 0, -10, 10, 0, -10, -10, 0, 10, -10, 0]),
  _v = new Uint32Array([0, 1, 2, 3]),
  bv = new Uint8Array([4]),
  Gi = class extends st {
    constructor(t, e) {
      super(),
        (this.data = t),
        (this.flatShading = e),
        (this.subdivPointer = 0),
        this.rebuild(),
        this.freeSubdivPointer();
    }
    mutateDirectlyScaleBaked(t, e) {
      this.freeSubdivPointer();
      let i = this.data.scaleBaked,
        n = Ba.div(e, i);
      this.subdividedGeometry && mf(this.subdividedGeometry.attributes, ...n),
        this.originalGeometry && mf(this.originalGeometry.attributes, ...n),
        (this.data = t);
      let r = this.userData.parameters;
      (this.userData.parameters = {
        width: r.width * n[0],
        height: r.height * n[1],
        depth: r.depth * n[2],
      }),
        this.originalGeometry.boundingSphere.center.multiply(wa.fromArray(n));
      let s = wa.set(r.width, r.height, r.depth).length();
      this.originalGeometry.boundingSphere.radius = s / 2;
    }
    ensureSubdivPointer() {
      return this.subdivPointer === 0 && this.rebuild(), this.subdivPointer;
    }
    rebuild() {
      let t, e, i;
      try {
        ({
          originalGeometry: t,
          subdividedGeometry: e,
          subdivPointer: i,
        } = Gi.build(this.data, void 0, !this.flatShading, void 0));
      } catch {
        (t = new $n(100, 100, 100)), (i = 0);
      }
      (this.subdivPointer = i),
        (this.originalGeometry = t),
        (this.subdividedGeometry = e ?? void 0);
      let n = this.subdividedGeometry ?? this.originalGeometry;
      Object.assign(this, n), this.calcBoundingBox();
    }
    freeSubdivPointer() {
      this.subdivPointer &&
        (Gi.freeSubdivPointer(this.subdivPointer), (this.subdivPointer = 0));
    }
    dispose() {
      super.dispose(), this.freeSubdivPointer();
    }
    calcBoundingBox() {
      let t = this.originalGeometry;
      t.boundingSphere === null &&
        ((t.boundingSphere = new Xn()),
        this.subdividedGeometry &&
          (this.subdividedGeometry.boundingSphere = t.boundingSphere));
      let e = t.attributes.position,
        i = t.boundingSphere.center;
      gc.setFromBufferAttribute(e),
        gc.getCenter(i),
        (t.boundingSphere.radius = i.distanceTo(gc.max)),
        isNaN(t.boundingSphere.radius) &&
          console.error(
            'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
            this
          ),
        gc.getSize(wa);
      let n = { width: wa.x, height: wa.y, depth: wa.z };
      return (this.userData.parameters = n), n;
    }
    static build(t, e, i, n) {
      let r,
        s,
        a,
        o = (t == null ? void 0 : t.phongAngle) ?? 35;
      i === !1 && (o = -1),
        e && (et.free_bvh(e), et.free_subdivision_surface(e));
      try {
        r = Gi.allocate(t, n);
      } catch (l) {
        console.error(l, t),
          (r = Gi.allocate(
            { positionWASM: xv, indexWASM: _v, verticesPerFaceWASM: bv },
            n
          ));
      }
      if (
        (et.set_destination_refinement_level(r, 0),
        (s = Gi.buildLevel(r, !0, o)),
        t.subdivisions > 0)
      )
        try {
          et.set_destination_refinement_level(r, t.subdivisions),
            (a = Gi.buildLevel(r, !1, o));
        } catch {
          try {
            et.set_destination_refinement_level(r, t.subdivisions - 1),
              (a = Gi.buildLevel(r, !1, o));
          } catch {
            a = null;
          }
        }
      else a = null;
      return { subdivPointer: r, originalGeometry: s, subdividedGeometry: a };
    }
    static primitiveToQuads(t, e, i) {
      t.widthSegments > 16 && (t.widthSegments = 16),
        t.heightSegments > 16 && (t.heightSegments = 16),
        t.depthSegments > 16 && (t.depthSegments = 16),
        t.radialSegments > 16 && (t.radialSegments = 16),
        t.type === "DodecahedronGeometry" && (t.detail = 0);
      let n =
          t.shape !== void 0 || t.path !== void 0 ? e.geometry : uh(t, i, !1),
        r;
      t.type === "TorusGeometry" && t.arc === Math.PI * 2
        ? (r = n.getClosedTorusIndicesForBooleanOrSubdiv())
        : (r = n.getIndex());
      let s, a, o, l;
      ({ positions: s, triIndices: l } = e1(n.getAttribute("position"), r));
      let c;
      if (
        t.type === "CylinderGeometry" &&
        t.cornerRadius === 0 &&
        t.hollow === 0 &&
        t.openEnded === !1
      ) {
        let d = t.radialSegments * t.heightSegments * 3 * 2,
          h = d + t.radialSegments * 3;
        c = [d, h];
      }
      return (
        ({ indices: a, verticesPerFace: o } = t1(s, l, n, c)),
        { positions: s, indices: a, verticesPerFace: o }
      );
    }
    static allocate(t, e) {
      var y;
      let i,
        n,
        r,
        s = [],
        a = [];
      t.positionWASM && t.positionWASM.length > 0
        ? ((i = t.positionWASM), (n = t.indexWASM), (r = t.verticesPerFaceWASM))
        : ((i = xv), (n = _v), (r = bv));
      let o = i.length,
        l = n.length,
        c = r.length,
        d = i.length + s.length + a.length,
        h = n.length + r.length,
        u =
          d * Float32Array.BYTES_PER_ELEMENT +
          h * Uint32Array.BYTES_PER_ELEMENT,
        f = d * Float32Array.BYTES_PER_ELEMENT,
        p = et._malloc(u),
        v = new Float32Array(et.HEAPF32.buffer, p, d),
        g = new Uint32Array(et.HEAPU32.buffer, p + f, h);
      v.set(i, 0),
        v.set(s, i.length),
        v.set(a, i.length + s.length),
        g.set(n, 0),
        g.set(r, n.length);
      let m;
      (y = t == null ? void 0 : t.scaleBaked) != null &&
        y.some((_) => _ !== 1) &&
        (m = new ze().makeScale(...t.scaleBaked)),
        e && (m ? m.premultiply(e) : (m = e));
      let x = m
        ? et.alloc_subdivision_surface2(
            p,
            o,
            p + f,
            l,
            p + f + n.length * Uint32Array.BYTES_PER_ELEMENT,
            c,
            m.elements
          )
        : et.alloc_subdivision_surface(
            p,
            o,
            p + f,
            l,
            p + f + n.length * Uint32Array.BYTES_PER_ELEMENT,
            c
          );
      return et._free(p), x;
    }
    static buildLevel(t, e, i, n, r) {
      let s = r
          ? et.get_mesh_data2(
              t,
              e ? et.Level.CONTROL : et.Level.REFINED,
              i,
              r.elements
            )
          : et.get_mesh_data(t, e ? et.Level.CONTROL : et.Level.REFINED, i),
        a = 8,
        o = et.HEAPU32.subarray(s >> 2, (s >> 2) + a),
        l = o.subarray(4, 4 + 4),
        c = 0,
        d = et.HEAPU32[o[c] >> 2],
        h = et.HEAPF32.subarray(d >> 2, (d >> 2) + l[c]);
      c++;
      let u = et.HEAPU32[o[c] >> 2],
        f = et.HEAPF32.subarray(u >> 2, (u >> 2) + l[c]);
      c++;
      let p = et.HEAPU32[o[c] >> 2],
        v = et.HEAPU32.subarray(p >> 2, (p >> 2) + l[c]);
      c++;
      let g = et.HEAPU32[o[c] >> 2],
        m = et.HEAPU32.subarray(g >> 2, (g >> 2) + l[c]);
      if ((c++, n === void 0)) {
        let x = new st();
        if (
          (x.setIndex(new za(m, 1)),
          x.setAttribute("position", new We(h, 3)),
          x.setAttribute("normal", new We(f, 3)),
          e)
        ) {
          x.setAttribute("faceMap", new za(v, 1));
          let y = new Float32Array((f.length / 3) * 4).fill(0);
          x.setAttribute("color", new pt(y, 4));
        }
        return et.free_mesh_data(s), (x.userData.type = "SubdivGeometry"), x;
      }
      n.getAttribute("position").copyArray(h),
        n.getAttribute("normal").copyArray(f),
        (n.attributes.position.needsUpdate = !0),
        (n.attributes.normal.needsUpdate = !0),
        et.free_mesh_data(s);
    }
    static freeSubdivPointer(t) {
      et.free_bvh(t), et.free_subdivision_surface(t);
    }
    static buildControlCageWireframe(t, e, i) {
      let n = et.get_wireframe_data_for_base_level(t),
        r = 4,
        s = et.HEAPU32.subarray(n >> 2, (n >> 2) + r),
        a = s.subarray(2, 2 + 2),
        o = 0,
        l = et.HEAPU32[s[o] >> 2],
        c = et.HEAPF32.subarray(l >> 2, (l >> 2) + a[o]);
      o++;
      let d = et.HEAPU32[s[o] >> 2],
        h = et.HEAPU32.subarray(d >> 2, (d >> 2) + a[o]);
      if (e === void 0) {
        let u = new st();
        u.setAttribute("position", new We(c, 3));
        let f = new Float32Array(c.length);
        for (let p = 0, v = c.length; p < v; )
          (f[p++] = i.r), (f[p++] = i.g), (f[p++] = i.b);
        return (
          u.setAttribute("color", new pt(f, 3)),
          u.setIndex(new za(h, 1)),
          et.free_wireframe_data_for_base_level(n),
          u
        );
      }
      e.getAttribute("position").copyArray(c),
        (e.attributes.position.needsUpdate = !0),
        et.free_wireframe_data_for_base_level(n);
    }
    static updateCollabMesh(t, e, i) {
      let n = e === 0;
      n || et.set_destination_refinement_level(t, e);
      let r = i
          ? et.get_topological_data2(
              t,
              n ? et.Level.CONTROL : et.Level.REFINED,
              i.elements
            )
          : et.get_topological_data(t, n ? et.Level.CONTROL : et.Level.REFINED),
        s = 6,
        a = et.HEAPU32.subarray(r >> 2, (r >> 2) + s),
        o = a.subarray(3, 3 + 3),
        l = 0,
        c = et.HEAPU32[a[l] >> 2],
        d = new Float32Array(et.HEAPF32.subarray(c >> 2, (c >> 2) + o[l]));
      l++;
      let h = et.HEAPU32[a[l] >> 2],
        u = new Uint32Array(et.HEAPU32.subarray(h >> 2, (h >> 2) + o[l]));
      l++;
      let f = et.HEAPU32[a[l] >> 2],
        p = new Uint8Array(et.HEAPU32.subarray(f >> 2, (f >> 2) + o[l]));
      return (
        et.free_topological_data(r),
        { positions: d, indices: u, verticesPerFace: p }
      );
    }
  },
  wv = ["getX", "getY", "getZ"];
function e1(t, e) {
  let i = {},
    n = e ? e.count : t.count,
    r = 0,
    s = [],
    a = [],
    o = 1e4;
  for (let c = 0; c < n; c++) {
    let d = e ? e.getX(c) : c,
      h = "";
    for (let u = 0; u < 3; u++) h += `${~~(t[wv[u]](d) * o)},`;
    if (h in i) s.push(i[h]);
    else {
      for (let u = 0; u < 3; u++) a.push(t[wv[u]](d));
      (i[h] = r), s.push(r), r++;
    }
  }
  let l = [];
  for (let c = 0; c < s.length; c += 3)
    s[c] === s[c + 1] ||
      s[c] === s[c + 2] ||
      s[c + 1] === s[c + 2] ||
      l.push(s[c], s[c + 1], s[c + 2]);
  return { positions: a, triIndices: l };
}
var vc = new A(),
  Ku = new A(),
  Ju = new A(),
  Qu = new A();
function t1(t, e, i, n) {
  let r = [],
    s = [];
  if (
    i.userData.shape !== void 0 &&
    i.userData.parameters.depth === 0 &&
    i.userData.shape.shapeHoles.length === 0
  ) {
    let l = i.userData.shape.extractShapePointsToFlatArray([]),
      c = i.userData.parameters.spikes;
    if (
      i.userData.type === "EllipseGeometry" &&
      c <= 24 &&
      c % 4 === 0 &&
      i.userData.parameters.angle >= 360
    ) {
      let u = l.length / 2 / c;
      l = l.filter((f, p) => Math.floor(p / 2) % u === 0);
    }
    let d = 0;
    for (let u = 0; u < l.length; u += 2)
      d +=
        (l[u] - l[(u === 0 ? l.length : u) - 2]) *
        (l[u + 1] + l[(u === 0 ? l.length : u) - 1]);
    t.length = 0;
    let h = 0;
    if (d < 0)
      for (let u = 0; u < l.length; u += 2)
        t.push(l[u], l[u + 1], 0), r.push(h++);
    else
      for (let u = l.length - 2; u >= 0; u -= 2)
        t.push(l[u], l[u + 1], 0), r.push(h++);
    return s.push(h), { indices: r, verticesPerFace: s };
  }
  let a = new Float32Array([i.userData.parameters.depth])[0],
    o = 0;
  for (; o < e.length; ) {
    if (i.useNgonForTopBottomFaceDuringBake) {
      let l = 0;
      if (
        ((t[e[o] * 3 + 2] === a || t[e[o] * 3 + 2] === 0) && l++,
        (t[e[o + 1] * 3 + 2] === a || t[e[o + 1] * 3 + 2] === 0) && l++,
        (t[e[o + 2] * 3 + 2] === a || t[e[o + 2] * 3 + 2] === 0) && l++,
        l === 3)
      )
        break;
    }
    if (
      (e[o + 1] === e[o + 3] && e[o + 2] === e[o + 5]) ||
      (e[o + 0] === e[o + 3] && e[o + 2] === e[o + 4])
    ) {
      vc.set(t[e[o] * 3], t[e[o] * 3 + 1], t[e[o] * 3 + 2]),
        Ku.set(t[e[o + 1] * 3], t[e[o + 1] * 3 + 1], t[e[o + 1] * 3 + 2]),
        Ju.set(t[e[o + 4] * 3], t[e[o + 4] * 3 + 1], t[e[o + 4] * 3 + 2]),
        Qu.set(t[e[o + 5] * 3], t[e[o + 5] * 3 + 1], t[e[o + 5] * 3 + 2]),
        Ku.sub(vc).normalize(),
        Ju.sub(vc).normalize(),
        Qu.sub(vc).normalize();
      let l = Ku.cross(Ju).dot(Qu);
      Math.abs(l) > 0.005 ||
      (n && n.some((c, d) => (d % 2 === 1 ? !1 : o >= n[d] && o < n[d + 1])))
        ? (r.push(e[o], e[o + 1], e[o + 2]), s.push(3), (o += 3))
        : (r.push(e[o], e[o + 1], e[o + 4], e[o + 5]), s.push(4), (o += 6));
    } else r.push(e[o], e[o + 1], e[o + 2]), s.push(3), (o += 3);
  }
  if (i.useNgonForTopBottomFaceDuringBake) {
    let l = [],
      c = [],
      d = 0;
    for (let h = 0, u = 0; h < t.length; h += 3, u++)
      t[h + 2] === 0 && (l.push(u), d++), t[h + 2] === a && c.push(u);
    if (i.userData.parameters.extrudeBevelSize === 0) {
      let h = c[0];
      (c[0] = c[1]), (c[1] = h);
    }
    l.reverse(), r.push(...l, ...c), s.push(d, d);
  }
  return { indices: r, verticesPerFace: s };
}
var Ar = {};
cC(Ar, {
  calcBoolean: () => Jz,
  calcBooleanTopological: () => Kz,
  freeMeshSet: () => iB,
  getMeshSet: () => Qz,
  hasOpenEdges: () => eB,
  transformMeshSet: () => tB,
});
var Yz = new Promise((t) => {}),
  bt,
  Wa;
Yz.then((t) => (bt = t));
function Zz(t, e, i) {
  let n, r;
  t.userData.parameters.type === "TorusGeometry" &&
  t.userData.parameters.arc === Math.PI * 2
    ? (r = t.getClosedTorusIndicesForBooleanOrSubdiv())
    : (r = t.getIndex());
  let { positions: s, triIndices: a } = e1(t.getAttribute("position"), r),
    o;
  if (e && i) {
    let { indices: l, verticesPerFace: c } = t1(s, a, t);
    (o = c.length), (n = []);
    for (let d = 0, h = 0; d < o; d++) {
      n.push(c[d]);
      for (let u = 0; u < c[d]; u++) n.push(l[h++]);
    }
  } else {
    let l = a.length;
    (n = Array(l + l / 3)), (o = 0);
    for (let c = 0, d = 0; d < n.length; )
      (n[d++] = 3),
        o++,
        (n[d++] = a[c++]),
        (n[d++] = a[c++]),
        (n[d++] = a[c++]);
  }
  return { positions: s, faceIndices: n, nFaces: o };
}
function i1(t) {
  let e = t.length,
    i = e * Uint32Array.BYTES_PER_ELEMENT,
    n = e * Float32Array.BYTES_PER_ELEMENT,
    r = Number.isInteger(t[0]) ? i : n,
    s = bt._malloc(r);
  return (
    (Number.isInteger(t[0])
      ? new Uint32Array(bt.HEAPU32.buffer, s, e)
      : new Float32Array(bt.HEAPF32.buffer, s, e)
    ).set(t, 0),
    s
  );
}
function n1(t) {
  switch (t) {
    case 0:
      return bt.OP.UNION;
    case 1:
      return bt.OP.INTERSECTION;
    case 2:
      return bt.OP.A_MINUS_B;
    case 3:
      return bt.OP.B_MINUS_A;
    case 4:
      return bt.OP.SYMMETRIC_DIFFERENCE;
    case 5:
      return bt.OP.ALL;
    default:
      throw new Error("Unknown boolean operation " + t);
  }
}
function Kz(t, e) {
  Wa === void 0 && (Wa = bt.init_csg());
  let i = i1(t),
    n = bt.csg_calc_topological(Wa, i, t.length, n1(e));
  bt._free(i);
  let r = 6,
    s = bt.HEAPU32.subarray(n >> 2, (n >> 2) + r),
    a = s.subarray(3, 3 + 3),
    o = 0,
    l = bt.HEAPU32[s[o] >> 2],
    c = new Float32Array(bt.HEAPF32.subarray(l >> 2, (l >> 2) + a[o]));
  o++;
  let d = bt.HEAPU32[s[o] >> 2],
    h = new Uint32Array(bt.HEAPU32.subarray(d >> 2, (d >> 2) + a[o]));
  o++;
  let u = bt.HEAPU32[s[o] >> 2],
    f = new Uint8Array(bt.HEAPU32.subarray(u >> 2, (u >> 2) + a[o]));
  return bt.free_mesh_data(n), { positions: c, indices: h, verticesPerFace: f };
}
function Jz(t, e, i, n) {
  Wa === void 0 && (Wa = bt.init_csg());
  let r = i1(t),
    s = bt.csg_calc(Wa, r, t.length, n, n1(e));
  bt._free(r);
  let a = 5,
    o = bt.HEAPU32.subarray(s >> 2, (s >> 2) + a),
    l = o.subarray(2, 2 + 3),
    c = 0,
    d = bt.HEAPU32[o[c] >> 2],
    h = bt.HEAPF32.subarray(d >> 2, (d >> 2) + l[c]);
  c++;
  let u = bt.HEAPU32[o[c] >> 2],
    f = bt.HEAPF32.subarray(u >> 2, (u >> 2) + l[c]);
  c++;
  let p = l[c];
  i.setAttribute("position", new We(h, 3)),
    i.setAttribute("normal", new We(f, 3));
  let v = bt.HEAPF32.subarray((s >> 2) + 5, (s >> 2) + 5 + 6);
  return (
    i.boundingSphere === null && (i.boundingSphere = new Xn()),
    i.boundingSphere.center.set(v[0], v[1], v[2]),
    (i.boundingSphere.radius = (v[3] ** 2 + v[4] ** 2 + v[5] ** 2) ** 0.5),
    (i.userData.parameters = {
      width: v[3] * 2,
      height: v[4] * 2,
      depth: v[5] * 2,
    }),
    bt.free_mesh_data(s),
    p
  );
}
function Qz(t, e, i) {
  if (bt === void 0) return -1;
  let n, r, s;
  if (e && t.userData.positions !== void 0) {
    let v = t.userData;
    (s = v.verticesPerFace.length),
      (n = v.positions),
      (r = Array(v.verticesPerFace.reduce((g, m) => g + m, 0) + s));
    for (let g = 0, m = 0, x = 0; g < v.verticesPerFace.length; g++) {
      r[x++] = v.verticesPerFace[g];
      for (let y = 0; y < v.verticesPerFace[g]; y++) r[x++] = v.indices[m++];
    }
  } else ({ positions: n, faceIndices: r, nFaces: s } = Zz(t, e, i));
  let a = n.length,
    o = r.length,
    l = n.length,
    c = r.length,
    d = l * Float32Array.BYTES_PER_ELEMENT + c * Uint32Array.BYTES_PER_ELEMENT,
    h = l * Float32Array.BYTES_PER_ELEMENT,
    u = bt._malloc(d),
    f = new Float32Array(bt.HEAPF32.buffer, u, l),
    p = new Uint32Array(bt.HEAPU32.buffer, u + h, c);
  return f.set(n, 0), p.set(r, 0), bt.get_csg_mesh(u, a, u + h, o, s);
}
function eB(t) {
  return bt.has_open_edges(t);
}
function tB(t, e) {
  bt.transform_csg_mesh(t, e.elements);
}
function iB(t) {
  bt.free_csg_mesh(t);
}
var nB = {
    ConeGeometry: IN,
    CubeGeometry: UN,
    CylinderGeometry: ON,
    DodecahedronGeometry: zN,
    EllipseGeometry: zp,
    HelixGeometry: mz,
    IcosahedronGeometry: gz,
    LatheGeometry: vz,
    NonParametricGeometry: Mz,
    PolygonGeometry: $_,
    PyramidGeometry: Ez,
    RectangleGeometry: Y_,
    SphereGeometry: Cz,
    PlaneGeometry: Pz,
    BackdropGeometry: Lz,
    StarGeometry: Z_,
    TextFrameGeometry: Rz,
    TorusGeometry: Oz,
    TorusKnotGeometry: Uz,
    TriangleGeometry: Nz,
    PathGeometry: Vz,
    VectorGeometry: ta,
  },
  Sv = (t) => nB[t.type].create(t);
function Io(t) {
  return t !== null && "booleanOp" in t;
}
var r1 = class extends Dp(Fn) {
    constructor() {
      super(...arguments),
        (this.booleanMeshSetAddress = -1),
        (this.booleanWasTransformed = !1),
        (this.booleanMatrixInvOld = new ze());
    }
    updateVisible() {
      super.updateVisible(),
        (this.visible = !Io(this.parent) && this.visible),
        Io(this.parent) && this.parent.invalidateDownstreamBooleanData();
    }
    freeBooleanPointer() {
      this.booleanMeshSetAddress !== -1 &&
        (Ar.freeMeshSet(this.booleanMeshSetAddress),
        (this.booleanMeshSetAddress = -1));
    }
    invalidateDownstreamBooleanData(t = !1) {
      return (
        t ? (this.booleanWasTransformed = !0) : this.freeBooleanPointer(),
        Io(this.parent) ? this.parent.invalidateDownstreamBooleanData() : this
      );
    }
    invalidateUpstreamBooleanData() {
      this.freeBooleanPointer();
      for (let t of this.children)
        t instanceof r1 &&
          (t.freeBooleanPointer(), Io(t) && t.invalidateUpstreamBooleanData());
    }
    updateTransformState(t) {
      let e = super.updateTransformState(t);
      return (
        e && Io(this.parent) && this.invalidateDownstreamBooleanData(!0), e
      );
    }
  },
  yc = new An();
function Fp(t, e = 0, i = t.count, n, r) {
  let s = 1 / 0,
    a = 1 / 0,
    o = 1 / 0,
    l = -1 / 0,
    c = -1 / 0,
    d = -1 / 0;
  for (let h = e; h < i; h++) {
    let u = t.getX(h),
      f = t.getY(h),
      p = t.getZ(h);
    u < s && (s = u),
      f < a && (a = f),
      p < o && (o = p),
      u > l && (l = u),
      f > c && (c = f),
      p > d && (d = p);
  }
  yc.min.set(s, a, o),
    yc.max.set(l, c, d),
    yc.getCenter(n),
    yc.getSize(r).multiplyScalar(0.5);
}
var rB = new st(),
  sB = new co(),
  ps = class extends r1 {
    constructor(t, e) {
      super(rB, sB), this.super_Entity(t, e);
    }
    updateState(t, e) {
      this.updateState_Entity(t, e);
    }
    updateEntityBoxSize(t, e) {
      let i = this.geometry.getAttribute("position");
      i !== void 0
        ? Fp(
            i,
            this.geometry.drawRange.start,
            this.geometry.drawRange.count < 1 / 0
              ? this.geometry.drawRange.count
              : i.count,
            t,
            e
          )
        : super.updateEntityBoxSize(t, e);
    }
  },
  Mv = class {
    constructor(t) {
      (t = t ?? {}),
        (this.name = t.name),
        (this.type = t.type),
        (this.node = t.node),
        (this.size = t.size),
        (this.needsUpdate = t.needsUpdate);
    }
    get value() {
      return this.node.value;
    }
    set value(t) {
      this.node.value = t;
    }
  },
  xs = class {
    constructor(t) {
      (this.hashProperties = void 0),
        (this.isNode = !0),
        (this.shortcuts = {}),
        (this.uuid = Jt.generateUUID()),
        (this.type = t),
        (this.name = "");
    }
    analyze(t, e) {
      (e = e ?? {}),
        (t.analyzing = !0),
        this.build(t.addFlow(e.slot, e.cache, e.context), "v4"),
        t.clearVertexNodeCode(),
        t.clearFragmentNodeCode(),
        t.removeFlow(),
        (t.analyzing = !1);
    }
    analyzeAndFlow(t, e, i) {
      return (i = i ?? {}), this.analyze(t, i), this.flow(t, e, i);
    }
    flow(t, e, i) {
      (i = i ?? {}), t.addFlow(i.slot, i.cache, i.context);
      let n = {
        result: this.build(t, e),
        code: t.clearNodeCode(),
        extra: t.context.extra,
      };
      return t.removeFlow(), n;
    }
    build(t, e, i) {
      e = e ?? this.getType(t, e);
      let n = t.getNodeData(i ?? this);
      return (
        t.analyzing && this.appendDepsNode(t, n, e),
        t.nodes.indexOf(this) === -1 && t.nodes.push(this),
        this.updateFrame !== void 0 &&
          t.updaters.indexOf(this) === -1 &&
          t.updaters.push(this),
        this.generate(t, e, i)
      );
    }
    updateFrame(t) {}
    generateReadonly(t, e, i, n, r, s) {
      return "";
    }
    generate(t, e, i, n, r) {
      return "";
    }
    parse(t, e, i, n) {}
    appendDepsNode(t, e, i) {
      e.deps = (e.deps || 0) + 1;
      let n = t.getTypeLength(i);
      (n > (e.outputMax || 0) || this.getType(t, i)) &&
        ((e.outputMax = n), (e.output = i));
    }
    setName(t) {
      this.name = t;
    }
    getName() {
      return this.name;
    }
    getType(t, e) {
      return e === "sampler2D" || e === "samplerCube" ? e : this.type;
    }
    getHash() {
      let t = "{",
        e,
        i;
      for (e in this)
        (i = this[e]),
          i instanceof xs && (t += '"' + e + '":' + i.getHash() + ",");
      if (this.hashProperties)
        for (let n = 0; n < this.hashProperties.length; n++)
          (e = this.hashProperties[n]),
            (i = this[e]),
            (t += '"' + e + '":"' + String(i) + '",');
      return (t += '"id":"' + this.uuid + '"}'), t;
    }
  },
  aB = class {
    constructor() {
      (this.nodes = {}), (this.keywords = {});
    }
    add(t) {
      this.nodes[t.name] = t;
    }
    addKeyword(t, e, i) {
      (i = i !== void 0 ? i : !0),
        (this.keywords[t] = { callback: e, cache: i });
    }
    remove(t) {
      delete this.nodes[t.name];
    }
    removeKeyword(t) {
      delete this.keywords[t];
    }
    get(t) {
      return this.nodes[t];
    }
    getKeyword(t, e) {
      return this.keywords[t].callback(e);
    }
    getKeywordData(t) {
      return this.keywords[t];
    }
    contains(t) {
      return this.nodes[t] !== void 0;
    }
    containsKeyword(t) {
      return this.keywords[t] !== void 0;
    }
  },
  en = new aB(),
  Gt = class extends xs {
    constructor(t, e) {
      super(t),
        (this.scope = ""),
        (e = e ?? {}),
        (this.shared = e.shared !== void 0 ? e.shared : !0),
        (this.unique = e.unique !== void 0 ? e.unique : !1);
    }
    build(t, e, i, n) {
      if (((e = e ?? this.getType(t)), this.getShared(t, e))) {
        let r = this.getUnique(t, e);
        r && this.uuid === void 0 && (this.uuid = Jt.generateUUID()),
          (i = t.getUUID(i ?? this.getUUID(), !r));
        let s = t.getNodeData(i),
          a = s.output || this.getType(t);
        if (t.analyzing)
          return (s.deps || 0) > 0 || this.getLabel()
            ? (this.appendDepsNode(t, s, e), this.generate(t, e, i))
            : super.build(t, e, i);
        if (r) return (s.name = s.name || super.build(t, e, i)), s.name;
        if (
          !this.getLabel() &&
          (!this.getShared(t, a) || t.context.ignoreCache || s.deps === 1)
        )
          return super.build(t, e, i);
        i = this.getUUID(!1);
        let o = this.getTemp(t, i);
        if (o) return t.format(o, a, e);
        {
          o = super.generate(t, e, i, s.output, n);
          let l = this.generate(t, a, i);
          return t.addNodeCode(o + " = " + l + ";"), t.format(o, a, e);
        }
      }
      return super.build(t, e, i);
    }
    getShared(t, e) {
      return e !== "sampler2D" && e !== "samplerCube" && this.shared;
    }
    getUnique(t, e) {
      return this.unique;
    }
    setLabel(t) {
      return (this.label = t), this;
    }
    getLabel() {
      return this.label;
    }
    getUUID(t) {
      let e = this.uuid;
      return typeof this.scope == "string" && (e = this.scope + "-" + e), e;
    }
    getTemp(t, e) {
      e = e || this.uuid;
      let i = t.getVars()[e];
      return i ? i.name : void 0;
    }
    generate(t, e, i, n, r) {
      return (
        this.getShared(t, e) || console.error("TempNode is not shared"),
        (i = i ?? this.uuid),
        t.getTempVar(i, n ?? this.getType(t), r, this.getLabel()).name
      );
    }
  },
  an = class extends Gt {
    constructor(t, e) {
      (e = e ?? {}),
        (e.shared = e.shared !== void 0 ? e.shared : !1),
        super(t, e),
        (this.readonly = !1);
    }
    setReadonly(t) {
      return (
        (this.readonly = t),
        (this.hashProperties = this.readonly ? ["value"] : void 0),
        this
      );
    }
    getReadonly() {
      return this.readonly;
    }
    generate(t, e, i, n, r, s) {
      (i = t.getUUID(i ?? this.getUUID())), (n = n ?? this.getType(t));
      let a = t.getNodeData(i);
      return this.getReadonly() && this.generateReadonly !== void 0
        ? this.generateReadonly(t, e, i, n, r, s)
        : t.isShader("vertex")
        ? (a.vertex ||
            (a.vertex = t.createVertexUniform(n, this, r, s, this.getLabel())),
          t.format(a.vertex.name, n, e))
        : (a.fragment ||
            (a.fragment = t.createFragmentUniform(
              n,
              this,
              r,
              s,
              this.getLabel()
            )),
          t.format(a.fragment.name, n, e));
    }
  },
  Ci = class extends an {
    constructor(t = 0, e) {
      super("v2"),
        (this.nodeType = "Vector2"),
        (this.value = t instanceof J ? t : new J(t, e));
    }
    get x() {
      return this.value.x;
    }
    set x(t) {
      this.value.x = t;
    }
    get y() {
      return this.value.y;
    }
    set y(t) {
      this.value.y = t;
    }
    generateReadonly(t, e, i, n, r, s) {
      return t.format("vec2(" + this.value.x + ", " + this.value.y + ")", n, e);
    }
  },
  yn = class extends an {
    constructor(t = 0, e, i) {
      super("v3"),
        (this.nodeType = "Vector3"),
        (this.value = t instanceof A ? t : new A(t, e, i));
    }
    get x() {
      return this.value.x;
    }
    set x(t) {
      this.value.x = t;
    }
    get y() {
      return this.value.y;
    }
    set y(t) {
      this.value.y = t;
    }
    get z() {
      return this.value.z;
    }
    set z(t) {
      this.value.z = t;
    }
    generateReadonly(t, e, i, n, r, s) {
      return t.format(
        "vec3(" +
          this.value.x +
          ", " +
          this.value.y +
          ", " +
          this.value.z +
          ")",
        n,
        e
      );
    }
  },
  Wn = class extends tt {
    constructor(t, e, i, n) {
      super(t, e, i), (this.isColorA = !0), (this.a = n);
    }
    setRGBA(t, e, i, n) {
      super.setRGB(t, e, i), (this.a = n);
    }
    copy(t) {
      return super.copy(t), (this.a = "a" in t ? t.a : 1), this;
    }
    clone() {
      return new this.constructor(this.r, this.g, this.b, this.a);
    }
    setStyle(t, e = "srgb") {
      let i;
      if (t === "transparent") return this.setRGBA(0, 0, 0, 0), this;
      if ((i = /^((?:rgb|hsl)a?)\(([^)]*)\)/.exec(t))) {
        let n,
          r = i[1],
          s = i[2];
        switch (r) {
          case "rgb":
          case "rgba":
            if (
              (n =
                /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                  s
                ))
            )
              return (
                (this.a = r === "rgba" ? parseFloat(n[4]) : 1),
                super.setStyle(t, e)
              );
            break;
          case "hsl":
          case "hsla":
            if (
              (n =
                /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)%\s*,\s*(\d*\.?\d+)%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                  s
                ))
            )
              return (
                (this.a = r === "hsla" ? parseFloat(n[4]) : 1),
                super.setStyle(t, e)
              );
            break;
        }
      }
      return super.setStyle(t, e);
    }
    get x() {
      return this.r;
    }
    get y() {
      return this.g;
    }
    get z() {
      return this.b;
    }
    get w() {
      return this.a;
    }
    set x(t) {
      this.r = t;
    }
    set y(t) {
      this.g = t;
    }
    set z(t) {
      this.b = t;
    }
    set w(t) {
      this.a = t;
    }
  },
  Cr = class extends an {
    constructor(t) {
      super("v4"),
        (this.nodeType = "Vector4"),
        (this.value = t instanceof Wn ? t : new Wn(t.r, t.g, t.b, t.a));
    }
    generateReadonly(t, e, i, n, r, s) {
      return t.format(
        "vec4(" +
          this.value.r +
          ", " +
          this.value.g +
          ", " +
          this.value.b +
          ", " +
          this.value.a +
          ")",
        n,
        e
      );
    }
  },
  oB = /^\s*([a-z_0-9]+)\s([a-z_0-9]+)\s*\((.*?)\)/i,
  Ev = /[a-z_0-9]+/gi,
  Re = class extends Gt {
    constructor(t, e, i, n, r) {
      super(r),
        (this.src = ""),
        (this.nodeType = "Function"),
        (this.useKeywords = !0),
        (this.includes = []),
        (this.extensions = {}),
        (this.keywords = {}),
        (this.isMethod = r === void 0),
        (this.isInterface = !1),
        this.parse(t, e, i, n);
    }
    getShared(t, e) {
      return !this.isMethod;
    }
    getType(t) {
      return t.getTypeByFormat(this.type);
    }
    getInputByName(t) {
      if (this.inputs) {
        let e = this.inputs.length;
        for (; e--; ) if (this.inputs[e].name === t) return this.inputs[e];
      }
    }
    getIncludeByName(t) {
      if (this.includes) {
        let e = this.includes.length;
        for (; e--; ) if (this.includes[e].name === t) return this.includes[e];
      }
    }
    generate(t, e, i, n, r) {
      let s,
        a = 0,
        o = this.src;
      if (this.includes)
        for (let c = 0; c < this.includes.length; c++)
          t.include(this.includes[c], this);
      for (let c in this.extensions) t.extensions[c] = !0;
      let l = [];
      for (; (s = Ev.exec(this.src)); ) l.push(s);
      for (let c = 0; c < l.length; c++) {
        let d = l[c],
          h = d[0],
          u = this.isMethod ? !this.getInputByName(h) : !0,
          f = h;
        if (
          this.keywords[h] ||
          (this.useKeywords && u && en.containsKeyword(h))
        ) {
          let p = this.keywords[h];
          if (!p) {
            let v = en.getKeywordData(h);
            v.cache && (p = t.keywords[h]),
              (p = p || en.getKeyword(h, t)),
              v.cache && (t.keywords[h] = p);
          }
          f = p.build(t);
        }
        h !== f &&
          o[d.index + a - 1] !== "." &&
          ((o =
            o.substring(0, d.index + a) +
            f +
            o.substring(d.index + h.length + a)),
          (a += f.length - h.length)),
          this.getIncludeByName(f) === void 0 &&
            en.contains(f) &&
            t.include(en.get(f));
      }
      return e === "source"
        ? o
        : this.isMethod
        ? (this.isInterface || t.include(this, void 0, o), this.name)
        : t.format("( " + o + " )", this.getType(t), e);
    }
    parse(t, e, i, n) {
      if (
        ((this.src = t || ""),
        (this.includes = e ?? []),
        (this.extensions = i ?? {}),
        (this.keywords = n ?? {}),
        this.isMethod)
      ) {
        let r = oB.exec(this.src);
        if (((this.inputs = []), r && r.length == 4)) {
          (this.type = r[1]), (this.name = r[2]);
          let s = r[3].match(Ev);
          if (s) {
            let a = 0;
            for (; a < s.length; ) {
              let o = s[a++],
                l;
              o === "in" || o === "out" || o === "inout"
                ? (l = s[a++])
                : ((l = o), (o = ""));
              let c = s[a++];
              this.inputs.push({ name: c, type: l, qualifier: o });
            }
          }
          this.isInterface = this.src.indexOf("{") === -1;
        } else (this.type = ""), (this.name = "");
      }
    }
  },
  lB = /^([a-z_0-9]+)\s([a-z_0-9]+)\s?\=?\s?(.*?)(\;|$)/i,
  s1 = class extends Gt {
    constructor(t = "", e) {
      super(),
        (this.src = ""),
        (this.useDefine = !1),
        (this.nodeType = "Const"),
        this.parse(t || s1.PI, void 0, void 0, void 0, e);
    }
    getType(t) {
      return t.getTypeByFormat(this.type);
    }
    parse(t, e, i, n, r) {
      this.src = t || "";
      let s,
        a,
        o = "",
        l = lB.exec(t);
      (this.useDefine = r ?? this.src.charAt(0) === "#"),
        l && l.length > 1
          ? ((a = l[1]), (s = l[2]), (o = l[3]))
          : ((s = this.src), (a = "f")),
        (this.name = s),
        (this.type = a),
        (this.value = o);
    }
    build(t, e) {
      if (e === "source") {
        if (this.value)
          return this.useDefine
            ? "#define " + this.name + " " + this.value
            : "const " + this.type + " " + this.name + " = " + this.value + ";";
        if (this.useDefine) return this.src;
      }
      return t.include(this), t.format(this.name, this.getType(t), e);
    }
    generate(t, e, i, n, r) {
      return t.format(this.name, this.getType(t), e);
    }
  },
  kt = s1;
(kt.PI = "PI"),
  (kt.PI2 = "PI2"),
  (kt.RECIPROCAL_PI = "RECIPROCAL_PI"),
  (kt.RECIPROCAL_PI2 = "RECIPROCAL_PI2"),
  (kt.LOG2 = "LOG2"),
  (kt.EPSILON = "EPSILON");
var cB = new RegExp(
    `^structs*([a-z_0-9]+)s*{s*((.|
)*?)}`,
    "gim"
  ),
  hB = new RegExp("s*(w*?)s*(w*?)(=|;)", "gim"),
  a1 = class extends Gt {
    constructor(t = "") {
      super(),
        (this.inputs = []),
        (this.src = ""),
        (this.nodeType = "Struct"),
        this.parse(t);
    }
    getType(t) {
      return t.getTypeByFormat(this.name);
    }
    getInputByName(t) {
      let e = this.inputs.length;
      for (; e--; ) if (this.inputs[e].name === t) return this.inputs[e];
    }
    generate(t, e, i, n, r) {
      return e === "source"
        ? this.src + ";"
        : t.format("( " + this.src + " )", this.getType(t), e);
    }
    parse(t = "") {
      (this.src = t), (this.inputs = []);
      let e = cB.exec(t);
      if (e) {
        let i = e[2],
          n;
        for (; (n = hB.exec(i)); ) this.inputs.push({ type: n[1], name: n[2] });
        this.name = e[1];
      } else this.name = "";
      this.type = this.name;
    }
  },
  kp = class extends Gt {
    constructor(t) {
      super("v2", { shared: !1 }),
        (this.nodeType = "UV"),
        (this.index = t ?? 0);
    }
    generate(t, e) {
      t.requires.uv[this.index] = !0;
      let i = this.index > 0 ? this.index + 1 : "",
        n = t.isShader("vertex") ? "uv" + i : "vUv" + i;
      return t.format(n, this.getType(t), e);
    }
  };
en.addKeyword("uv", function () {
  return new kp();
});
en.addKeyword("uv2", function () {
  return new kp(1);
});
var Ta = class extends Gt {
    constructor(t, e) {
      super("v4"),
        (this.nodeType = "ColorSpace"),
        (this.input = t),
        (this.method = e ?? Ta.LINEAR_TO_LINEAR),
        (this.hashProperties = ["method"]);
    }
    static getEncodingComponents(t) {
      switch (t) {
        case sl:
          return ["Linear"];
        case zr:
          return ["sRGB"];
        default:
          return [];
      }
    }
    generate(t, e) {
      var a;
      let i = this.input.build(t, "v4"),
        n = this.getType(t),
        r = Ta.Nodes[this.method],
        s = t.include(r);
      if (s === Ta.LINEAR_TO_LINEAR) return t.format(i, n, e);
      if (((a = r.inputs) == null ? void 0 : a.length) === 2) {
        let o = this.factor.build(t, "f");
        return t.format(s + "( " + i + ", " + o + " )", n, e);
      } else return t.format(s + "( " + i + " )", n, e);
    }
    fromEncoding(t) {
      let e = Ta.getEncodingComponents(t);
      (this.method = "LinearTo" + e[0]), (this.factor = e[1]);
    }
    fromDecoding(t) {
      let e = Ta.getEncodingComponents(t);
      (this.method = e[0] + "ToLinear"), (this.factor = e[1]);
    }
  },
  cr = Ta;
(cr.Nodes = {
  LinearToLinear: new Re(
    ["vec4 LinearToLinear( in vec4 value ) {", "	return value;", "}"].join(`
`)
  ),
  sRGBToLinear: new Re(
    [
      "vec4 sRGBToLinear( in vec4 value ) {",
      "	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );",
      "}",
    ].join(`
`)
  ),
  LinearTosRGB: new Re(
    [
      "vec4 LinearTosRGB( in vec4 value ) {",
      "	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );",
      "}",
    ].join(`
`)
  ),
}),
  (cr.LINEAR_TO_LINEAR = "LinearToLinear"),
  (cr.SRGB_TO_LINEAR = "sRGBToLinear"),
  (cr.LINEAR_TO_SRGB = "LinearTosRGB");
var Xt = class extends Re {
    constructor(t = "", e, i, n, r) {
      super(t, r, n, i, e), (this.nodeType = "Expression");
    }
  },
  Rr = class extends an {
    constructor(t = new Li(), e, i, n) {
      super("v4", { shared: !0 }),
        (this.nodeType = "Texture"),
        (this.value = t),
        (this.uv = e ?? new kp()),
        (this.bias = i),
        (this.project = n !== void 0 ? n : !1);
    }
    getTexture(t, e) {
      return super.generate(t, e, this.value.uuid, "t");
    }
    generate(t, e) {
      if (e === "sampler2D") return this.getTexture(t, e);
      let i = this.getTexture(t, e),
        n = this.uv.build(t, this.project ? "v4" : "v2"),
        r = this.bias ? this.bias.build(t, "f") : void 0;
      r === void 0 &&
        t.context.bias &&
        (r = t.context.bias.setTexture(this).build(t, "f"));
      let s, a;
      this.project ? (s = "texture2DProj") : (s = r ? "tex2DBias" : "tex2D"),
        r
          ? (a = s + "( " + i + ", " + n + ", " + r + " )")
          : (a = s + "( " + i + ", " + n + " )");
      let o = { include: t.isShader("vertex"), ignoreCache: !0 },
        l = this.getType(t);
      return (
        t.addContext(o),
        (this.colorSpace = this.colorSpace ?? new cr(new Xt("", l))),
        this.colorSpace.fromDecoding(t.getTextureEncodingFromMap(this.value)),
        this.colorSpace.input.parse(a),
        (a = this.colorSpace.build(t, l)),
        t.removeContext(),
        t.format(a, l, e)
      );
    }
  },
  ke = class extends an {
    constructor(t) {
      super("f"), (this.nodeType = "Float"), (this.value = t ?? 0);
    }
    generateReadonly(t, e, i, n, r, s) {
      return t.format(this.value + (this.value % 1 ? "" : ".0"), n, e);
    }
  },
  Tv = class extends Gt {
    constructor(t, e) {
      super(),
        (this.inputs = []),
        (this.nodeType = "FunctionCall"),
        (this.value = t),
        (this.inputs = e ?? []);
    }
    getFunction() {
      return this.value;
    }
    getType(t) {
      return this.value.getType(t);
    }
    generate(t, e, i, n, r) {
      n = this.getType(t);
      let s = this.value,
        a = s.build(t, e) + "( ",
        o = [];
      if (s.inputs) {
        for (let l = 0; l < s.inputs.length; l++) {
          let c = s.inputs[l],
            d = this.inputs[l] || this.inputs[c.name];
          o.push(d.build(t, t.getTypeByFormat(c.type)));
        }
        a += o.join(", ") + " )";
      }
      return t.format(a, n, e);
    }
  },
  o1 = class extends Gt {
    constructor(t, e, i = o1.ADD) {
      super(),
        (this.nodeType = "Operator"),
        (this.type = t.type),
        (this.a = t),
        (this.b = e),
        (this.op = i);
    }
    getType(t) {
      let e = this.a.getType(t),
        i = this.b.getType(t);
      return t.isTypeMatrix(e)
        ? "v4"
        : t.getTypeLength(i) > t.getTypeLength(e)
        ? i
        : e;
    }
    generate(t, e) {
      let i = this.getType(t);
      this.type = i;
      let n = this.a.build(t, i),
        r = this.b.build(t, i);
      return t.format("( " + n + " " + this.op + " " + r + " )", i, e);
    }
  },
  Yi = o1;
(Yi.ADD = "+"), (Yi.SUB = "-"), (Yi.MUL = "*"), (Yi.DIV = "/");
var Ft = class extends Gt {
    constructor(t, e = Ft.ABS, i, n) {
      super(),
        (this.nodeType = "Math"),
        (this.a = t),
        typeof e != "string" ? (this.b = e) : (n = e),
        typeof i != "string" ? (this.c = i) : (n = i),
        (this.method = n),
        (this.hashProperties = ["method"]);
    }
    getNumInputs(t) {
      switch (this.method) {
        case Ft.MIX:
        case Ft.CLAMP:
        case Ft.REFRACT:
        case Ft.SMOOTHSTEP:
        case Ft.FACEFORWARD:
          return 3;
        case Ft.MIN:
        case Ft.MAX:
        case Ft.MOD:
        case Ft.STEP:
        case Ft.REFLECT:
        case Ft.DISTANCE:
        case Ft.DOT:
        case Ft.CROSS:
        case Ft.POW:
          return 2;
        default:
          return 1;
      }
    }
    getInputType(t) {
      let e = t.getTypeLength(this.a.getType(t)),
        i = this.b ? t.getTypeLength(this.b.getType(t)) : 0,
        n = this.c ? t.getTypeLength(this.c.getType(t)) : 0;
      return e > i && e > n
        ? this.a.getType(t)
        : i > n
        ? this.b.getType(t)
        : this.c.getType(t);
    }
    getType(t) {
      switch (this.method) {
        case Ft.LENGTH:
        case Ft.DISTANCE:
        case Ft.DOT:
          return "f";
        case Ft.CROSS:
          return "v3";
      }
      return this.getInputType(t);
    }
    generate(t, e) {
      let i,
        n,
        r,
        s = this.a ? t.getTypeLength(this.a.getType(t)) : 0,
        a = this.b ? t.getTypeLength(this.b.getType(t)) : 0,
        o = this.c ? t.getTypeLength(this.c.getType(t)) : 0,
        l = this.getInputType(t),
        c = this.getType(t);
      switch (((this.type = c), this.method)) {
        case Ft.NEGATE:
          return t.format("( -" + this.a.build(t, l) + " )", l, e);
        case Ft.INVERT:
          return t.format("( 1.0 - " + this.a.build(t, l) + " )", l, e);
        case Ft.CROSS:
          (i = this.a.build(t, "v3")), (n = this.b.build(t, "v3"));
          break;
        case Ft.STEP:
          (i = this.a.build(t, s === 1 ? "f" : l)), (n = this.b.build(t, l));
          break;
        case Ft.MIN:
        case Ft.MAX:
        case Ft.MOD:
          (i = this.a.build(t, l)), (n = this.b.build(t, a === 1 ? "f" : l));
          break;
        case Ft.REFRACT:
          (i = this.a.build(t, l)),
            (n = this.b.build(t, l)),
            (r = this.c.build(t, "f"));
          break;
        case Ft.MIX:
          (i = this.a.build(t, l)),
            (n = this.b.build(t, l)),
            (r = this.c.build(t, o === 1 ? "f" : l));
          break;
        default:
          (i = this.a.build(t, l)),
            this.b && (n = this.b.build(t, l)),
            this.c && (r = this.c.build(t, l));
          break;
      }
      let d = [];
      d.push(i), n && d.push(n), r && d.push(r);
      let h = this.getNumInputs(t);
      if (d.length !== h)
        throw Error(
          `Arguments not match used in "${this.method}". Require ${h}, currently ${d.length}.`
        );
      return t.format(this.method + "( " + d.join(", ") + " )", c, e);
    }
  },
  at = Ft;
(at.RAD = "radians"),
  (at.DEG = "degrees"),
  (at.EXP = "exp"),
  (at.EXP2 = "exp2"),
  (at.LOG = "log"),
  (at.LOG2 = "log2"),
  (at.SQRT = "sqrt"),
  (at.INV_SQRT = "inversesqrt"),
  (at.FLOOR = "floor"),
  (at.CEIL = "ceil"),
  (at.NORMALIZE = "normalize"),
  (at.FRACT = "fract"),
  (at.SATURATE = "saturate"),
  (at.SIN = "sin"),
  (at.COS = "cos"),
  (at.TAN = "tan"),
  (at.ASIN = "asin"),
  (at.ACOS = "acos"),
  (at.ARCTAN = "atan"),
  (at.ABS = "abs"),
  (at.SIGN = "sign"),
  (at.LENGTH = "length"),
  (at.NEGATE = "negate"),
  (at.INVERT = "invert"),
  (at.MIN = "min"),
  (at.MAX = "max"),
  (at.MOD = "mod"),
  (at.STEP = "step"),
  (at.REFLECT = "reflect"),
  (at.DISTANCE = "distance"),
  (at.DOT = "dot"),
  (at.CROSS = "cross"),
  (at.POW = "pow"),
  (at.MIX = "mix"),
  (at.CLAMP = "clamp"),
  (at.REFRACT = "refract"),
  (at.SMOOTHSTEP = "smoothstep"),
  (at.FACEFORWARD = "faceforward");
var Vo = class extends Gt {
    constructor(t, e, i) {
      super("v4"),
        (this.nodeType = "TextureCubeUV"),
        (this.value = t),
        (this.uv = e),
        (this.bias = i);
    }
    bilinearCubeUV(t, e, i, n) {
      let r = new Tv(Vo.Nodes.bilinearCubeUV, [e, i, n]);
      (this.colorSpaceTL = this.colorSpaceTL ?? new cr(new Xt("", "v4"))),
        this.colorSpaceTL.fromDecoding(
          t.getTextureEncodingFromMap(this.value.value)
        ),
        this.colorSpaceTL.input.parse(r.build(t) + ".tl"),
        (this.colorSpaceTR = this.colorSpaceTR ?? new cr(new Xt("", "v4"))),
        this.colorSpaceTR.fromDecoding(
          t.getTextureEncodingFromMap(this.value.value)
        ),
        this.colorSpaceTR.input.parse(r.build(t) + ".tr"),
        (this.colorSpaceBL = this.colorSpaceBL ?? new cr(new Xt("", "v4"))),
        this.colorSpaceBL.fromDecoding(
          t.getTextureEncodingFromMap(this.value.value)
        ),
        this.colorSpaceBL.input.parse(r.build(t) + ".bl"),
        (this.colorSpaceBR = this.colorSpaceBR ?? new cr(new Xt("", "v4"))),
        this.colorSpaceBR.fromDecoding(
          t.getTextureEncodingFromMap(this.value.value)
        ),
        this.colorSpaceBR.input.parse(r.build(t) + ".br");
      let s = { include: t.isShader("vertex"), ignoreCache: !0 };
      t.addContext(s),
        (this.colorSpaceTLExp = new Xt(this.colorSpaceTL.build(t, "v4"), "v4")),
        (this.colorSpaceTRExp = new Xt(this.colorSpaceTR.build(t, "v4"), "v4")),
        (this.colorSpaceBLExp = new Xt(this.colorSpaceBL.build(t, "v4"), "v4")),
        (this.colorSpaceBRExp = new Xt(this.colorSpaceBR.build(t, "v4"), "v4")),
        t.removeContext();
      let a = new Xt(
        "mix( mix( cubeUV_TL, cubeUV_TR, cubeUV.f.x ), mix( cubeUV_BL, cubeUV_BR, cubeUV.f.x ), cubeUV.f.y )",
        "v4"
      );
      return (
        (a.keywords.cubeUV_TL = this.colorSpaceTLExp),
        (a.keywords.cubeUV_TR = this.colorSpaceTRExp),
        (a.keywords.cubeUV_BL = this.colorSpaceBLExp),
        (a.keywords.cubeUV_BR = this.colorSpaceBRExp),
        (a.keywords.cubeUV = r),
        a
      );
    }
    generate(t, e) {
      if (t.isShader("fragment")) {
        let i = this.uv,
          n = this.bias || t.context.roughness,
          r = new Tv(Vo.Nodes.roughnessToMip, [n]),
          s = new at(r, Vo.Nodes.m0, Vo.Nodes.cubeUV_maxMipLevel, at.CLAMP),
          a = new at(s, at.FLOOR),
          o = new at(s, at.FRACT),
          l = this.bilinearCubeUV(t, this.value, i, a),
          c = this.bilinearCubeUV(
            t,
            this.value,
            i,
            new Yi(a, new ke(1).setReadonly(!0), Yi.ADD)
          ),
          d = new at(l, c, o, at.MIX);
        return t.format(d.build(t), "v4", e);
      } else
        return (
          console.warn(
            "TextureCubeUVNode is not compatible with " + t.shader + " shader."
          ),
          t.format("vec4( 0.0 )", this.getType(t), e)
        );
    }
  },
  gf = Vo;
gf.Nodes = (function () {
  let t = new a1(`struct TextureCubeUVData {
			vec4 tl;
			vec4 tr;
			vec4 br;
			vec4 bl;
			vec2 f;
		}`),
    e = new kt("float cubeUV_maxMipLevel 8.0", !0),
    i = new kt("float cubeUV_minMipLevel 4.0", !0),
    n = new kt("float cubeUV_maxTileSize 256.0", !0),
    r = new kt("float cubeUV_minTileSize 16.0", !0),
    s = new Re(`float getFace(vec3 direction) {
				vec3 absDirection = abs(direction);
				float face = -1.0;
				if (absDirection.x > absDirection.z) {
					if (absDirection.x > absDirection.y)
						face = direction.x > 0.0 ? 0.0 : 3.0;
					else
						face = direction.y > 0.0 ? 1.0 : 4.0;
				} else {
					if (absDirection.z > absDirection.y)
						face = direction.z > 0.0 ? 2.0 : 5.0;
					else
						face = direction.y > 0.0 ? 1.0 : 4.0;
				}
				return face;
		}`);
  s.useKeywords = !1;
  let a = new Re(`vec2 getUV(vec3 direction, float face) {
				vec2 uv;
				if (face == 0.0) {
					uv = vec2(direction.z, direction.y) / abs(direction.x); // pos x
				} else if (face == 1.0) {
					uv = vec2(-direction.x, -direction.z) / abs(direction.y); // pos y
				} else if (face == 2.0) {
					uv = vec2(-direction.x, direction.y) / abs(direction.z); // pos z
				} else if (face == 3.0) {
					uv = vec2(-direction.z, direction.y) / abs(direction.x); // neg x
				} else if (face == 4.0) {
					uv = vec2(-direction.x, direction.z) / abs(direction.y); // neg y
				} else {
					uv = vec2(direction.x, direction.y) / abs(direction.z); // neg z
				}
				return 0.5 * (uv + 1.0);
		}`);
  a.useKeywords = !1;
  let o = new Re(
    `TextureCubeUVData bilinearCubeUV(sampler2D envMap, vec3 direction, float mipInt) {
			float face = getFace(direction);
			float filterInt = max(cubeUV_minMipLevel - mipInt, 0.0);
			mipInt = max(mipInt, cubeUV_minMipLevel);
			float faceSize = exp2(mipInt);
			float texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);
			vec2 uv = getUV(direction, face) * (faceSize - 1.0);
			vec2 f = fract(uv);
			uv += 0.5 - f;
			if (face > 2.0) {
				uv.y += faceSize;
				face -= 3.0;
			}
			uv.x += face * faceSize;
			if(mipInt < cubeUV_maxMipLevel){
				uv.y += 2.0 * cubeUV_maxTileSize;
			}
			uv.y += filterInt * 2.0 * cubeUV_minTileSize;
			uv.x += 3.0 * max(0.0, cubeUV_maxTileSize - 2.0 * faceSize);
			uv *= texelSize;
			vec4 tl = texture2D(envMap, uv);
			uv.x += texelSize;
			vec4 tr = texture2D(envMap, uv);
			uv.y += texelSize;
			vec4 br = texture2D(envMap, uv);
			uv.x -= texelSize;
			vec4 bl = texture2D(envMap, uv);
			return TextureCubeUVData( tl, tr, br, bl, f );
		}`,
    [t, s, a, e, i, n, r]
  );
  o.useKeywords = !1;
  let l = new kt("float r0 1.0", !0),
    c = new kt("float v0 0.339", !0),
    d = new kt("float m0 -2.0", !0),
    h = new kt("float r1 0.8", !0),
    u = new kt("float v1 0.276", !0),
    f = new kt("float m1 -1.0", !0),
    p = new kt("float r4 0.4", !0),
    v = new kt("float v4 0.046", !0),
    g = new kt("float m4 2.0", !0),
    m = new kt("float r5 0.305", !0),
    x = new kt("float v5 0.016", !0),
    y = new kt("float m5 3.0", !0),
    _ = new kt("float r6 0.21", !0),
    M = new kt("float v6 0.0038", !0),
    b = new kt("float m6 4.0", !0),
    E = [l, c, d, h, u, f, p, v, g, m, x, y, _, M, b],
    T = new Re(
      `float roughnessToMip(float roughness) {
			float mip = 0.0;
			if (roughness >= r1) {
				mip = (r0 - roughness) * (m1 - m0) / (r0 - r1) + m0;
			} else if (roughness >= r4) {
				mip = (r1 - roughness) * (m4 - m1) / (r1 - r4) + m1;
			} else if (roughness >= r5) {
				mip = (r4 - roughness) * (m5 - m4) / (r4 - r5) + m4;
			} else if (roughness >= r6) {
				mip = (r5 - roughness) * (m6 - m5) / (r5 - r6) + m5;
			} else {
				mip = -2.0 * log2(1.16 * roughness);// 1.16 = 1.79^0.25
			}
			return mip;
		}`,
      E
    );
  return { bilinearCubeUV: o, roughnessToMip: T, m0: d, cubeUV_maxMipLevel: e };
})();
var Aa = class extends Gt {
    constructor(t) {
      super("v3"), (this.nodeType = "Normal"), (this.scope = t ?? Aa.VIEW);
    }
    getShared() {
      return this.scope === Aa.WORLD;
    }
    build(t, e, i, n) {
      let r = t.context[this.scope + "Normal"];
      return r ? r.build(t, e, i, n) : super.build(t, e, i);
    }
    generate(t, e, i, n, r) {
      let s;
      switch (this.scope) {
        case Aa.VIEW:
          t.isShader("vertex")
            ? (s = "transformedNormal")
            : (s = "geometryNormal");
          break;
        case Aa.LOCAL:
          t.isShader("vertex")
            ? (s = "objectNormal")
            : ((t.requires.normal = !0), (s = "vObjectNormal"));
          break;
        case Aa.WORLD:
          t.isShader("vertex")
            ? (s =
                "inverseTransformDirection( transformedNormal, viewMatrix ).xyz")
            : ((t.requires.worldNormal = !0), (s = "vWNormal"));
          break;
      }
      return t.format(s, this.getType(t), e);
    }
  },
  tn = Aa;
(tn.LOCAL = "local"),
  (tn.WORLD = "world"),
  (tn.VIEW = "view"),
  (tn.NORMAL = "normal");
en.addKeyword("viewNormal", function () {
  return new tn(tn.VIEW);
});
en.addKeyword("localNormal", function () {
  return new tn(tn.NORMAL);
});
en.addKeyword("worldNormal", function () {
  return new tn(tn.WORLD);
});
var Er = class extends Gt {
    constructor(t) {
      super("v3"), (this.nodeType = "Position"), (this.scope = t ?? Er.LOCAL);
    }
    getType() {
      switch (this.scope) {
        case Er.PROJECTION:
          return "v4";
      }
      return this.type;
    }
    getShader() {
      switch (this.scope) {
        case Er.LOCAL:
        case Er.WORLD:
          return !1;
      }
      return !0;
    }
    generate(t, e, i, n, r) {
      let s;
      switch (this.scope) {
        case Er.LOCAL:
          t.isShader("vertex")
            ? (s = "transformed")
            : ((t.requires.position = !0), (s = "vPosition"));
          break;
        case Er.WORLD:
          if (t.isShader("vertex"))
            return "( modelMatrix * vec4( transformed, 1.0 ) ).xyz";
          (t.requires.worldPosition = !0), (s = "vWPosition");
          break;
        case Er.VIEW:
          s = t.isShader("vertex") ? "-mvPosition.xyz" : "vViewPosition";
          break;
        case Er.PROJECTION:
          s = t.isShader("vertex")
            ? "( projectionMatrix * modelViewMatrix * vec4( position, 1.0 ) )"
            : "vec4( 0.0 )";
          break;
      }
      return t.format(s, this.getType(), e);
    }
  },
  Hn = Er;
(Hn.LOCAL = "local"),
  (Hn.WORLD = "world"),
  (Hn.VIEW = "view"),
  (Hn.PROJECTION = "projection");
en.addKeyword("position", function () {
  return new Hn();
});
en.addKeyword("worldPosition", function () {
  return new Hn(Hn.WORLD);
});
en.addKeyword("viewPosition", function () {
  return new Hn(Hn.VIEW);
});
var rr = class extends Gt {
    constructor(t) {
      super("v3"), (this.nodeType = "Reflect"), (this.scope = t ?? rr.CUBE);
    }
    getUnique(t) {
      return !t.context.viewNormal;
    }
    getType() {
      switch (this.scope) {
        case rr.SPHERE:
          return "v2";
      }
      return this.type;
    }
    generate(t, e) {
      let i = this.getUnique(t);
      if (t.isShader("fragment")) {
        let n;
        switch (this.scope) {
          case rr.VECTOR: {
            let r = new tn(tn.VIEW),
              s = t.context.roughness,
              a = r.build(t, "v3"),
              o = new Hn(Hn.VIEW).build(t, "v3"),
              l = s ? s.build(t, "f") : void 0,
              c = `reflect( -normalize( ${o} ), ${a} )`;
            l && (c = `normalize( mix( ${c}, ${a}, ${l} * ${l} ) )`);
            let d = `inverseTransformDirection( ${c}, viewMatrix )`;
            i
              ? (t.addNodeCode(`vec3 reflectVec = ${d};`), (n = "reflectVec"))
              : (n = d);
            break;
          }
          case rr.CUBE: {
            let r = new rr(rr.VECTOR).build(t, "v3"),
              s = "vec3( -" + r + ".x, " + r + ".yz )";
            i
              ? (t.addNodeCode(`vec3 reflectCubeVec = ${s};`),
                (n = "reflectCubeVec"))
              : (n = s);
            break;
          }
          case rr.SPHERE: {
            let r =
              "normalize( ( viewMatrix * vec4( " +
              new rr(rr.VECTOR).build(t, "v3") +
              ", 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) ).xy * 0.5 + 0.5";
            i
              ? (t.addNodeCode(`vec2 reflectSphereVec = ${r};`),
                (n = "reflectSphereVec"))
              : (n = r);
            break;
          }
        }
        return t.format(n, this.getType(), e);
      } else
        return (
          console.warn(
            "ReflectNode is not compatible with " + t.shader + " shader."
          ),
          t.format("vec3( 0.0 )", this.type, e)
        );
    }
  },
  qa = rr;
(qa.CUBE = "cube"), (qa.SPHERE = "sphere"), (qa.VECTOR = "vector");
var uB = class extends Gt {
    constructor(t = new Rr(), e, i) {
      super("v4"),
        (this.nodeType = "TextureCube"),
        (this.value = t),
        (this.radianceNode = new gf(this.value, e ?? new qa(qa.VECTOR), i)),
        (this.irradianceNode = new gf(
          this.value,
          new tn(tn.WORLD),
          new ke(1).setReadonly(!0)
        ));
    }
    generate(t, e) {
      return t.isShader("fragment")
        ? (t.require("irradiance"),
          t.context.bias && t.context.bias.setTexture(this.value),
          (t.slot === "irradiance"
            ? this.irradianceNode
            : this.radianceNode
          ).build(t, e))
        : (console.warn(
            "TextureCubeNode is not compatible with " + t.shader + " shader."
          ),
          t.format("vec4( 0.0 )", this.getType(t), e));
    }
  },
  dB = class extends an {
    constructor(t = new Hf(), e, i) {
      super("v4", { shared: !0 }),
        (this.nodeType = "CubeTexture"),
        (this.value = t),
        (this.uv = e ?? new qa()),
        (this.bias = i);
    }
    getTexture(t, e) {
      return super.generate(t, e, this.value.uuid, "tc");
    }
    generate(t, e) {
      var l;
      if (e === "samplerCube") return this.getTexture(t, e);
      let i = this.getTexture(t, e),
        n = (l = this.uv) == null ? void 0 : l.build(t, "v3"),
        r = this.bias ? this.bias.build(t, "f") : void 0;
      r === void 0 &&
        t.context.bias &&
        (r = t.context.bias.setTexture(this).build(t, "f"));
      let s;
      r
        ? (s = "texCubeBias( " + i + ", " + n + ", " + r + " )")
        : (s = "texCube( " + i + ", " + n + " )");
      let a = { include: t.isShader("vertex"), ignoreCache: !0 },
        o = this.getType(t);
      return (
        t.addContext(a),
        (this.colorSpace = this.colorSpace ?? new cr(new Xt("", o))),
        this.colorSpace.fromDecoding(t.getTextureEncodingFromMap(this.value)),
        this.colorSpace.input.parse(s),
        (s = this.colorSpace.build(t, o)),
        t.removeContext(),
        t.format(s, o, e)
      );
    }
  },
  fB = `
uniform int frameIndex;
uniform vec2 resolution;
uniform mat4 previousModelViewMatrix;
uniform mat4 previousProjectionMatrix;

varying vec4 vCurrentPosition;
varying vec4 vPreviousPosition;
`,
  pB = `
layout(location = 1) out vec4 gVelocity;

uniform int frameIndex;
uniform vec2 resolution;

varying vec4 vCurrentPosition;
varying vec4 vPreviousPosition;

const vec2 haltonSequence[16] = vec2[16](
vec2( 0.000000,-0.333334),
vec2(-0.500000, 0.333334),
vec2( 0.500000,-0.777778),
vec2(-0.750000,-0.111112),
vec2( 0.250000, 0.555556),
vec2(-0.250000,-0.555556),
vec2( 0.750000, 0.111112),
vec2(-0.875000, 0.777778),
vec2(0.125000, -0.925926),
vec2(-0.375000, -0.259260),
vec2(0.625000, 0.407408),
vec2(-0.625000, -0.703704),
vec2(0.375000, -0.037038),
vec2(-0.125000, 0.629630),
vec2(0.875000, -0.481482),
vec2(-0.937500, 0.185186));

vec2 vogelDiskSample(int sampleIndex, int sampleCount, float angle) {
  const float goldenAngle = 2.399963f; // radians
  float r = sqrt(float(sampleIndex) + 0.5f) / sqrt(float(sampleCount));
  float theta = float(sampleIndex) * goldenAngle + angle;
  float sine = sin(theta);
  float cosine = cos(theta);
  return vec2(cosine, sine) * r;
}

// Derived from the interleaved gradient function from Jimenez 2014 http:goo.gl/eomGso
float getNoiseInterleavedGradient(vec2 screenPos) {
    vec3 magic = vec3(0.06711056f, 0.00583715f, 52.9829189f);
    return fract(magic.z * fract(dot(screenPos, magic.xy)));
}

`,
  mB = `
// TODO: This could be generated CPU side and passed to the shader every frame
const vec2 haltonSequence[16] = vec2[16](
vec2( 0.000000,-0.333334),
vec2(-0.500000, 0.333334),
vec2( 0.500000,-0.777778),
vec2(-0.750000,-0.111112),
vec2( 0.250000, 0.555556),
vec2(-0.250000,-0.555556),
vec2( 0.750000, 0.111112),
vec2(-0.875000, 0.777778),
vec2(0.125000, -0.925926),
vec2(-0.375000, -0.259260),
vec2(0.625000, 0.407408),
vec2(-0.625000, -0.703704),
vec2(0.375000, -0.037038),
vec2(-0.125000, 0.629630),
vec2(0.875000, -0.481482),
vec2(-0.937500, 0.185186));

// TODO: Pass correct view size
vec2 offset = haltonSequence[frameIndex];
offset.x /= resolution.x;
offset.y /= resolution.y;

vec4 currentPosition = gl_Position;
vec4 currentPositionJittered = currentPosition + (vec4(offset.x, offset.y, 0.0, 0.0) * currentPosition.w);

// We want to calculate the velocity with unjittered positions
// so that things that are not moving get a velocity = 0
vCurrentPosition = currentPosition;
vPreviousPosition = previousProjectionMatrix * previousModelViewMatrix * vec4(transformed, 1.0);
#ifdef OUTLINE_COMPENSATION
vPreviousPosition.xy += OUTLINE_COMPENSATION;
#endif
gl_Position = currentPositionJittered;

`,
  gB = `
vec2 oldPos = vPreviousPosition.xy;
    oldPos /= vPreviousPosition.w;
    oldPos.xy = (oldPos.xy+1.)/2.0;

vec2 newPos = vCurrentPosition.xy;
    newPos /= vCurrentPosition.w;
    newPos.xy = (newPos.xy+1.)/2.0;

vec2 velocity = (newPos - oldPos);

// Discard fully transparent pixels 
if (gl_FragColor.a <= 0.0) discard;

gVelocity = vec4(velocity, 0.0, 1.0);
`,
  Av = ["x", "y", "z", "w"],
  vB = ["float", "vec2", "vec3", "vec4"],
  yB = {
    float: "f",
    vec2: "v2",
    vec3: "v3",
    vec4: "v4",
    mat4: "v4",
    int: "i",
    bool: "b",
    "float[]": "f[]",
    "vec4[]": "v4[]",
  },
  xB = {
    t: "sampler2D",
    tc: "samplerCube",
    b: "bool",
    i: "int",
    f: "float",
    c: "vec3",
    v2: "vec2",
    v3: "vec3",
    v4: "vec4",
    m3: "mat3",
    m4: "mat4",
    "f[]": "float[]",
    "v4[]": "vec4[]",
  },
  _B = class {
    constructor() {
      (this.includes = { consts: {}, functions: {}, structs: {} }),
        (this.cache = ""),
        (this.slot = ""),
        (this.shader = ""),
        (this.context = {}),
        (this.needsJitter = !0),
        (this.getIncludesCode = (function () {
          function t(e, i) {
            return e.deps.length - i.deps.length;
          }
          return function (e, i) {
            let n = this.getIncludes(e, i);
            if (!n) return "";
            let r = "";
            n = n.sort(t);
            for (let s = 0; s < n.length; s++)
              n[s].src &&
                (r +=
                  n[s].src +
                  `
`);
            return r;
          };
        })()),
        (this.slots = []),
        (this.caches = []),
        (this.contexts = []),
        (this.keywords = {}),
        (this.nodeData = {}),
        (this.fragmentVariables = {}),
        (this.fragmentParsVariables = {}),
        (this.vertexParsVariables = {}),
        (this.requires = {
          uv: [],
          color: [],
          transparent: !1,
          irradiance: !1,
          position: !1,
          worldPosition: !1,
          normal: !1,
          worldNormal: !1,
          vWorldViewDir: !1,
          modelMatrix: !1,
          viewMatrix: !1,
          projectionMatrix: !1,
        }),
        (this.includes = { consts: [], functions: [], structs: [] }),
        (this.attributes = {}),
        (this.prefixCode = [
          "#ifdef TEXTURE_LOD_EXT",
          "	#define texCube(a, b) textureCube(a, b)",
          "	#define texCubeBias(a, b, c) textureCubeLodEXT(a, b, c)",
          "	#define tex2D(a, b) texture2D(a, b)",
          "	#define tex2DBias(a, b, c) texture2DLodEXT(a, b, c)",
          "#else",
          "	#define texCube(a, b) textureCube(a, b)",
          "	#define texCubeBias(a, b, c) textureCube(a, b, c)",
          "	#define tex2D(a, b) texture2D(a, b)",
          "	#define tex2DBias(a, b, c) texture2D(a, b, c)",
          "#endif",
          `
			// NOTE: Include Spline's blending modes. This could be part of BlendNode
			#define SPE_BLENDING_NORMAL 0
			#define SPE_BLENDING_MULTIPLY 1
			#define SPE_BLENDING_SCREEN 2
			#define SPE_BLENDING_OVERLAY 3

			vec3 spe_normalBlend( vec3 a, vec3 b, float alpha ) {
				return mix( a, b, alpha );
			}

			vec3 spe_multiplyBlend( vec3 a, vec3 b, float alpha ) {
				return mix( a, a * b, alpha );
			}

			vec3 spe_screenBlend( vec3 a, vec3 b, float alpha ) {
				vec3 tmp = 1.0 - ( 1.0 - a ) * ( 1.0 - b );
				return mix( a, tmp, alpha );
			}

			vec3 spe_overlayBlend( vec3 a, vec3 b, float alpha ) {
				vec3 tmp = mix( 1. - 2. * (1. - a) * (1. - b), 2. * a * b, step( a, vec3(.5) ) );
				return clamp( mix( a, tmp, alpha ), 0.0, 1.0 );
			}

			vec3 spe_blend( vec3 a, vec3 b, float alpha, int mode ) {
				if ( mode == SPE_BLENDING_NORMAL ) return spe_normalBlend( a, b, alpha );
				else if ( mode == SPE_BLENDING_MULTIPLY ) return spe_multiplyBlend( a, b, alpha );
				else if ( mode == SPE_BLENDING_SCREEN ) return spe_screenBlend( a, b, alpha );
				else if ( mode == SPE_BLENDING_OVERLAY ) return spe_overlayBlend( a, b, alpha );
				return vec3( 1.0 );
			}
			`,
          "#include <packing>",
          "#include <common>",
        ].join(`
`)),
        (this.parsCode = {
          vertex: ["float neighbor_offset = 0.0001;", ""].join(`
`),
          fragment: [
            "float accumAlpha = 0.0;",
            `void accumulateAlpha(float alpha) {
					accumAlpha += (1.0 - accumAlpha) * alpha;
				}`,
            "",
          ].join(`
`),
        }),
        (this.code = { vertex: "", fragment: "" }),
        (this.nodeCode = { vertex: "", fragment: "" }),
        (this.resultCode = { vertex: "", fragment: "" }),
        (this.finalCode = { vertex: "", fragment: "" }),
        (this.inputs = {
          uniforms: { list: [], vertex: [], fragment: [] },
          arrayUniforms: { list: [], vertex: [], fragment: [] },
          vars: { varying: [], vertex: [], fragment: [] },
        }),
        (this.defines = {}),
        (this.uniforms = {}),
        (this.extensions = {
          derivatives: !1,
          fragDepth: !1,
          drawBuffers: !1,
          shaderTextureLOD: !1,
        }),
        (this.updaters = []),
        (this.nodes = []),
        (this.analyzing = !1);
    }
    build(t, e) {
      this.addVertexParsCode(fB),
        this.addFragmentParsCode(pB),
        this.buildShader("vertex", t),
        this.buildShader("fragment", e);
      for (let i = 0; i < this.requires.uv.length; i++)
        if (this.requires.uv[i]) {
          let n = i > 0 ? i + 1 : "";
          this.addVaryCode("varying vec2 vUv" + n + ";"),
            i > 0 && this.addVertexParsCode("attribute vec2 uv" + n + ";"),
            this.addVertexFinalCode("vUv" + n + " = uv" + n + ";");
        }
      return (
        this.requires.color[0] &&
          (this.addVaryCode("varying vec4 vColor;"),
          this.addVertexParsCode("attribute vec4 color;"),
          this.addVertexFinalCode("vColor = color;")),
        this.requires.color[1] &&
          (this.addVaryCode("varying vec4 vColor2;"),
          this.addVertexParsCode("attribute vec4 color2;"),
          this.addVertexFinalCode("vColor2 = color2;")),
        this.requires.position &&
          (this.addVaryCode("varying vec3 vPosition;"),
          this.addVertexFinalCode("vPosition = transformed;")),
        this.requires.worldPosition,
        this.requires.normal &&
          (this.addVaryCode("varying vec3 vObjectNormal;"),
          this.addVertexFinalCode("vObjectNormal = normal;")),
        this.requires.modelMatrix &&
          this.addFragmentParsCode("uniform mat4 modelMatrix;"),
        this.requires.viewMatrix &&
          this.addFragmentParsCode("uniform mat4 viewMatrix;"),
        this.requires.projectionMatrix &&
          this.addFragmentParsCode("uniform mat4 projectionMatrix;"),
        this.requires.worldNormal &&
          (this.addVaryCode("varying vec3 vWNormal;"),
          this.addVertexFinalCode(
            "vWNormal = inverseTransformDirection( transformedNormal, viewMatrix ).xyz;"
          )),
        this.requires.vWorldViewDir &&
          (this.addVaryCode("varying vec3 vWorldViewDir;"),
          this.addVertexFinalCode(
            "vWorldViewDir = isPerspectiveMatrix( projectionMatrix ) ?  ( (modelMatrix * vec4(position, 1.0)).xyz - cameraPosition ) : vec3( -viewMatrix[0][2], -viewMatrix[1][2], -viewMatrix[2][2] );"
          )),
        this.needsJitter &&
          (this.addVertexFinalCode(mB), this.addFragmentFinalCode(gB)),
        this
      );
    }
    buildShader(t, e) {
      this.resultCode[t] = e.build(this.setShader(t), "v4");
    }
    setMaterial(t, e) {
      return (this.defines = {}), this;
    }
    addFlow(t, e, i) {
      return this.addSlot(t).addCache(e).addContext(i);
    }
    removeFlow() {
      return this.removeSlot().removeCache().removeContext();
    }
    addCache(t) {
      return (this.cache = t ?? ""), this.caches.push(this.cache), this;
    }
    removeCache() {
      return (
        this.caches.pop(),
        (this.cache = this.caches[this.caches.length - 1] || ""),
        this
      );
    }
    addContext(t) {
      return (
        (this.context = Object.assign({}, this.context, t)),
        (this.context.extra = this.context.extra || {}),
        this.contexts.push(this.context),
        this
      );
    }
    removeContext() {
      return (
        this.contexts.pop(),
        (this.context = this.contexts[this.contexts.length - 1] || {}),
        this
      );
    }
    addSlot(t) {
      return (this.slot = t || ""), this.slots.push(this.slot), this;
    }
    removeSlot() {
      return (
        this.slots.pop(),
        (this.slot = this.slots[this.slots.length - 1] || ""),
        this
      );
    }
    addFragmentVariable(t, e) {
      this.fragmentVariables[t] === void 0 &&
        (this.addFragmentCode(`${e} ${t};`), (this.fragmentVariables[t] = ""));
    }
    addFragmentParsVariable(t, e) {
      this.fragmentParsVariables[t] === void 0 &&
        (this.addFragmentParsCode(`${e} ${t};`),
        (this.fragmentParsVariables[t] = ""));
    }
    addVertexParsVariable(t, e) {
      this.vertexParsVariables[t] === void 0 &&
        (this.addVertexParsCode(`${e} ${t};`),
        (this.vertexParsVariables[t] = ""));
    }
    addVertexCode(t) {
      this.addCode(t, "vertex");
    }
    addFragmentCode(t) {
      this.addCode(t, "fragment");
    }
    addCode(t, e) {
      this.code[e ?? this.shader] +=
        t +
        `
`;
    }
    addVertexNodeCode(t) {
      this.addNodeCode(t, "vertex");
    }
    addFragmentNodeCode(t) {
      this.addNodeCode(t, "fragment");
    }
    addNodeCode(t, e) {
      this.nodeCode[e ?? this.shader] +=
        t +
        `
`;
    }
    clearNodeCode(t) {
      t = t ?? this.shader;
      let e = this.nodeCode[t];
      return (this.nodeCode[t] = ""), e;
    }
    clearVertexNodeCode() {
      return this.clearNodeCode("vertex");
    }
    clearFragmentNodeCode() {
      return this.clearNodeCode("fragment");
    }
    addVertexFinalCode(t) {
      this.addFinalCode(t, "vertex");
    }
    addFragmentFinalCode(t) {
      this.addFinalCode(t, "fragment");
    }
    addFinalCode(t, e) {
      this.finalCode[e ?? this.shader] +=
        t +
        `
`;
    }
    addVertexParsCode(t) {
      this.addParsCode(t, "vertex");
    }
    addFragmentParsCode(t) {
      this.addParsCode(t, "fragment");
    }
    addParsCode(t, e) {
      this.parsCode[e ?? this.shader] +=
        t +
        `
`;
    }
    addVaryCode(t) {
      this.addVertexParsCode(t), this.addFragmentParsCode(t);
    }
    isCache(t) {
      return this.caches.indexOf(t) !== -1;
    }
    isSlot(t) {
      return this.slots.indexOf(t) !== -1;
    }
    define(t, e) {
      this.defines[t] = e === void 0 ? 1 : e;
    }
    require(t) {
      this.requires[t] = !0;
    }
    isDefined(t) {
      return this.defines[t] !== void 0;
    }
    getVar(t, e, i, n = "varying", r = "V", s = "") {
      let a = this.getVars(n),
        o = a[t];
      if (!o) {
        let l = a.length;
        (o = { name: i || "node" + r + l + (s ? "_" + s : ""), type: e }),
          a.push(o),
          (a[t] = o);
      }
      return o;
    }
    getTempVar(t, e, i, n) {
      return this.getVar(t, e, i, this.shader, "T", n);
    }
    getAttribute(t, e) {
      if (!this.attributes[t]) {
        let i = this.getVar(t, e);
        this.addVertexParsCode("attribute " + e + " " + t + ";"),
          this.addVertexFinalCode(i.name + " = " + t + ";"),
          (this.attributes[t] = { varying: i, name: t, type: e });
      }
      return this.attributes[t];
    }
    getCode(t) {
      return [
        this.prefixCode,
        this.parsCode[t],
        this.getVarListCode(this.getVars("varying"), "varying"),
        this.getVarListCode(this.inputs.uniforms[t], "uniform"),
        this.getVarListCode(this.inputs.arrayUniforms[t], "uniform"),
        this.getIncludesCode("consts", t),
        this.getIncludesCode("structs", t),
        this.getIncludesCode("functions", t),
        "void main() {",
        this.getVarListCode(this.getVars(t)),
        this.code[t],
        this.resultCode[t],
        this.finalCode[t],
        "}",
      ].join(`
`);
    }
    getVarListCode(t, e) {
      e = e ?? "";
      let i = "";
      for (let n = 0, r = t.length; n < r; ++n) {
        let s = t[n],
          a = s.type,
          o = s.name,
          l = s.size,
          c = this.getFormatByType(a);
        if (c === void 0) throw new Error("Node pars " + c + " not found.");
        c.includes("[]")
          ? (i +=
              e +
              " " +
              c.substring(0, c.length - 2) +
              " " +
              o +
              `[${l}];
`)
          : (i +=
              e +
              " " +
              c +
              " " +
              o +
              `;
`);
      }
      return i;
    }
    getVars(t) {
      return this.inputs.vars[t ?? this.shader];
    }
    getNodeData(t) {
      let e = t instanceof xs ? t.uuid : t;
      return (this.nodeData[e] = this.nodeData[e] || {});
    }
    createUniform(t, e, i, n, r, s) {
      if (e.includes("[]")) {
        let a = this.inputs.arrayUniforms,
          o = a.list.length,
          l = new Mv({
            type: e,
            size: i.size,
            name: n || "nodeUA" + o + (s ? "_" + s : ""),
            node: i,
            needsUpdate: r,
          });
        return (
          a.list.push(l),
          a[t].push(l),
          (a[t][l.name] = l),
          (this.uniforms[l.name] = l),
          l
        );
      } else {
        let a = this.inputs.uniforms,
          o = a.list.length,
          l = new Mv({
            type: e,
            name: n || "nodeU" + o + (s ? "_" + s : ""),
            node: i,
            needsUpdate: r,
          });
        return (
          a.list.push(l),
          a[t].push(l),
          (a[t][l.name] = l),
          (this.uniforms[l.name] = l),
          l
        );
      }
    }
    createVertexUniform(t, e, i, n, r) {
      return this.createUniform("vertex", t, e, i, n, r);
    }
    createFragmentUniform(t, e, i, n, r) {
      return this.createUniform("fragment", t, e, i, n, r);
    }
    include(t, e, i) {
      var s;
      let n;
      if (
        ((t = typeof t == "string" ? en.get(t) : t),
        this.context.include === !1)
      )
        return t.name;
      t instanceof Re
        ? (n = this.includes.functions)
        : t instanceof kt
        ? (n = this.includes.consts)
        : t instanceof a1 && (n = this.includes.structs);
      let r = (n[this.shader] = n[this.shader] || []);
      if (t) {
        let a = r[t.name];
        if (
          (a ||
            ((a = r[t.name] = { node: t, deps: [] }),
            r.push(a),
            (a.src = t.build(this, "source"))),
          t instanceof Re &&
            e &&
            r[e.name] &&
            r[e.name].deps.indexOf(t) === -1 &&
            (r[e.name].deps.push(t),
            (s = t.includes) == null ? void 0 : s.length))
        ) {
          let o = 0;
          do this.include(t.includes[o++], e);
          while (o < t.includes.length);
        }
        return i && (a.src = i), t.name;
      } else throw new Error("Include not found.");
    }
    colorToVectorProperties(t) {
      return t
        .replace("r", "x")
        .replace("g", "y")
        .replace("b", "z")
        .replace("a", "w");
    }
    colorToVector(t) {
      return t.replace(/c/g, "v3");
    }
    getIncludes(t, e) {
      return this.includes[t][e || this.shader];
    }
    getConstructorFromLength(t) {
      return vB[t - 1];
    }
    isTypeMatrix(t) {
      return /^m/.test(t);
    }
    getTypeLength(t) {
      return t === "f" ? 1 : parseInt(this.colorToVector(t).substr(1));
    }
    getTypeFromLength(t) {
      return t === 1 ? "f" : "v" + t;
    }
    findNode(...t) {
      for (let e = 0; e < arguments.length; e++) {
        let i = t[e];
        if (i != null && i.isNode) return i;
      }
    }
    resolve(...t) {
      for (let e = 0; e < arguments.length; e++) {
        let i = t[e];
        if (i !== void 0) {
          if (i.isNode) return i;
          if (i.isTexture)
            switch (i.mapping) {
              case Hs:
              case Gs:
                return new dB(i);
              case gl:
                return new uB(new Rr(i));
              default:
                return new Rr(i);
            }
          else {
            if (i.isVector2) return new Ci(i);
            if (i.isVector3) return new yn(i);
            if (i.isVector4) return new Cr(i);
          }
        }
      }
    }
    format(t, e, i) {
      switch (this.colorToVector(i + " <- " + e)) {
        case "f <- v2":
          return t + ".x";
        case "f <- v3":
          return t + ".x";
        case "f <- v4":
          return t + ".x";
        case "f <- i":
        case "f <- b":
          return "float( " + t + " )";
        case "v2 <- f":
          return "vec2( " + t + " )";
        case "v2 <- v3":
          return t + ".xy";
        case "v2 <- v4":
          return t + ".xy";
        case "v2 <- i":
        case "v2 <- b":
          return "vec2( float( " + t + " ) )";
        case "v3 <- f":
          return "vec3( " + t + " )";
        case "v3 <- v2":
          return "vec3( " + t + ", 0.0 )";
        case "v3 <- v4":
          return t + ".xyz";
        case "v3 <- i":
        case "v3 <- b":
          return "vec2( float( " + t + " ) )";
        case "v4 <- f":
          return "vec4( " + t + " )";
        case "v4 <- v2":
          return "vec4( " + t + ", 0.0, 1.0 )";
        case "v4 <- v3":
          return "vec4( " + t + ", 1.0 )";
        case "v4 <- i":
        case "v4 <- b":
          return "vec4( float( " + t + " ) )";
        case "i <- f":
        case "i <- b":
          return "int( " + t + " )";
        case "i <- v2":
          return "int( " + t + ".x )";
        case "i <- v3":
          return "int( " + t + ".x )";
        case "i <- v4":
          return "int( " + t + ".x )";
        case "b <- f":
          return "( " + t + " != 0.0 )";
        case "b <- v2":
          return "( " + t + " != vec2( 0.0 ) )";
        case "b <- v3":
          return "( " + t + " != vec3( 0.0 ) )";
        case "b <- v4":
          return "( " + t + " != vec4( 0.0 ) )";
        case "b <- i":
          return "( " + t + " != 0 )";
      }
      return t;
    }
    getTypeByFormat(t) {
      return yB[t] || t;
    }
    getFormatByType(t) {
      return xB[t] || t;
    }
    getUUID(t, e) {
      return (
        (e = e !== void 0 ? e : !0),
        e && this.cache && (t = this.cache + "-" + t),
        t
      );
    }
    getElementByIndex(t) {
      return Av[t];
    }
    getIndexByElement(t) {
      return Av.indexOf(t);
    }
    isShader(t) {
      return this.shader === t;
    }
    setShader(t) {
      return (this.shader = t), this;
    }
    mergeDefines(t) {
      for (let e in t) this.defines[e] = t[e];
      return this.defines;
    }
    mergeUniform(t) {
      for (let e in t) this.uniforms[e] = t[e];
      return this.uniforms;
    }
    getTextureEncodingFromMap(t) {
      let e;
      return (
        t ? t.isTexture && (e = t.encoding) : (e = sl),
        e === sl && this.context.gamma && (e = zr),
        e
      );
    }
  },
  ai = class extends an {
    constructor(t = 0, e, i, n) {
      super("c"),
        (this.nodeType = "Color"),
        (this.value = t instanceof Wn ? t : new Wn(t || 0, e, i, n));
    }
    setRGBA(t) {
      this.value.setRGBA(t.r, t.g, t.b, t.a);
    }
    generate(t, e, i, n, r, s) {
      (i = t.getUUID(i ?? this.getUUID())), (n = n ?? this.getType(t));
      let a = t.getNodeData(i),
        o = this.getReadonly() && this.generateReadonly !== void 0;
      if (this.alpha) {
        let l = this.alpha.build(t, "f");
        t.addFragmentNodeCode(`accumAlpha += ( 1.0 - accumAlpha ) * ${l};`);
      }
      return o
        ? this.generateReadonly(t, e, i, n, r, s)
        : t.isShader("vertex")
        ? (a.vertex ||
            (a.vertex = t.createVertexUniform(n, this, r, s, this.getLabel())),
          t.format(a.vertex.name, n, e))
        : (a.fragment ||
            (a.fragment = t.createFragmentUniform(
              n,
              this,
              r,
              s,
              this.getLabel()
            )),
          t.format(a.fragment.name, n, e));
    }
    generateReadonly(t, e, i, n, r, s) {
      return t.format(
        "vec3(" +
          this.value.r +
          ", " +
          this.value.g +
          ", " +
          this.value.b +
          ")",
        n,
        e
      );
    }
  },
  jt = class extends an {
    constructor(t) {
      super("i"), (this.nodeType = "Int"), (this.value = Math.floor(t ?? 0));
    }
    generateReadonly(t, e, i, n, r, s) {
      return t.format(this.value.toString(), n, e);
    }
  },
  Wi = class extends an {
    constructor(t) {
      super("b"), (this.nodeType = "Bool"), (this.value = t ?? !1);
    }
    generateReadonly(t, e, i, n) {
      return t.format(this.value ? "true" : "false", n, e);
    }
  },
  Ls = class extends an {
    constructor(t = 1, e) {
      super("f[]"),
        (this.nodeType = "FloatArray"),
        (this.size = t),
        (this.value = Array.isArray(e)
          ? e
          : typeof e == "number"
          ? new Array(t).fill(e)
          : new Array(t).fill(0));
    }
  },
  Vp = class extends an {},
  bB = class extends Vp {
    constructor(t) {
      super("v3"), (this.image = t), (this._value = new A());
    }
    get value() {
      return (
        (this._value.x = this.image.isVideo
          ? this.image.img.videoWidth ?? 0
          : this.image.img.width),
        (this._value.y = this.image.isVideo
          ? this.image.img.videoHeight ?? 0
          : this.image.img.height),
        this._value
      );
    }
  },
  vf = class extends Vp {
    constructor(t, e) {
      super("t"), (this.image = t), (this.wrap = e);
    }
    get value() {
      return this.image.getTexture(this.wrap);
    }
  },
  l1 = class extends an {
    constructor(t) {
      super("m3"), (this.nodeType = "Matrix3"), (this.value = t ?? new ft());
    }
    generateReadonly(t, e, i, n, r, s) {
      return t.format("mat3(" + this.value.elements.join(", ") + ")", n, e);
    }
    get elements() {
      return this.value.elements;
    }
    set elements(t) {
      this.value.fromArray(t);
    }
  },
  dr = class extends an {
    constructor(t) {
      super("m4"), (this.nodeType = "Matrix4"), (this.value = t ?? new ze());
    }
    generateReadonly(t, e, i, n, r, s) {
      return t.format("mat4(" + this.value.elements.join(", ") + ")", n, e);
    }
    get elements() {
      return this.value.elements;
    }
    set elements(t) {
      this.value.fromArray(t);
    }
  };
function Cv(t, e, i) {
  t.setUvTransform(i[0], i[1], e[0], e[1], 0, 0, 0);
}
var wB = class extends l1 {
    constructor(t, e) {
      super(new ft()),
        (this.repeat = t),
        (this.offset = e),
        Cv(this.value, t, e);
    }
    updateMatrix() {
      Cv(this.value, this.repeat, this.offset);
    }
  },
  Ds = class extends an {
    constructor(t = 1, e) {
      super("v4[]"),
        (this.nodeType = "Vector4Array"),
        (this.size = t),
        (this.value = Array.isArray(e)
          ? e
          : e instanceof yt
          ? new Array(t).fill(e)
          : new Array(t).fill(new yt(0)));
    }
  },
  Pv = class extends Gt {
    constructor(t, e, i, n) {
      super("v3"),
        (this.nodeType = "Blend"),
        (this.a = t),
        (this.b = e),
        (this.alpha = i),
        (this.mode = n);
    }
    generate(t, e) {
      if (t.isShader("fragment")) {
        let i = [];
        return (
          i.push(this.a.build(t, "c")),
          i.push(this.b.build(t, "c")),
          i.push(this.alpha.build(t, "f")),
          i.push(this.mode.build(t, "i")),
          t.format("spe_blend(" + i.join(",") + ")", this.getType(t), e)
        );
      } else
        return (
          console.warn(
            "BlendNode is not compatible with " + t.shader + " shader."
          ),
          t.format("vec3( 0.0 )", this.getType(t), e)
        );
    }
  },
  c1 = class extends Gt {
    constructor(t, e) {
      super("v3"),
        (this.nodeType = "CustomColor"),
        (this.color = t),
        (this.alpha = e),
        (this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`);
    }
    generate(t, e) {
      if (t.isShader("fragment")) {
        let i = t.include(c1.Nodes.customColor);
        t.addFragmentVariable(this.calpha, "float");
        let n = [];
        return (
          n.push(this.color.build(t, "v3")),
          n.push(this.mask ? `luminance(${this.mask.build(t, "v3")})` : "1.0"),
          n.push(this.alpha.build(t, "f")),
          n.push(this.calpha),
          t.format(i + "(" + n.join(",") + ")", this.getType(t), e)
        );
      } else
        return (
          console.warn(
            "CustomColorNode is not compatible with " + t.shader + " shader."
          ),
          t.format("vec3( 0.0 )", this.getType(t), e)
        );
    }
  },
  yf = c1;
yf.Nodes = (function () {
  return {
    customColor:
      new Re(`vec3 customColor(vec3 color, float mask, float alpha, out float calpha) {
				float lalpha = alpha * mask;
				calpha =  lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0);
				accumAlpha += (1.0 - accumAlpha) * lalpha;

				return color;
			}`),
  };
})();
var h1 = class extends Gt {
    constructor(t, e) {
      super("v3"),
        (this.nodeType = "CustomNormal"),
        (this.cnormal = t),
        (this.alpha = e),
        (this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`);
    }
    generate(t, e) {
      if (t.isShader("fragment")) {
        let i = t.include(h1.Nodes.customNormal);
        t.addFragmentVariable(this.calpha, "float");
        let n = [];
        return (
          n.push(this.cnormal.build(t, "v3")),
          n.push("normal"),
          n.push(
            this.mask ? `luminance(${this.mask.flow(t, "v3").result})` : "1.0"
          ),
          n.push(this.alpha.build(t, "f")),
          n.push(this.calpha),
          t.format(i + "(" + n.join(",") + ")", this.getType(t), e)
        );
      } else
        return (
          console.warn(
            "CustomNormalNode is not compatible with " + t.shader + " shader."
          ),
          t.format("vec3( 0.0 )", this.getType(t), e)
        );
    }
  },
  u1 = h1;
u1.Nodes = (function () {
  return {
    customNormal:
      new Re(`vec3 customNormal(vec3 cnormal, vec3 norm, float mask, float alpha, out float calpha) {
				vec3 normal = packNormalToRGB( norm ).rgb;
				normal *= step( vec3(0.5), cnormal );

				float lalpha = alpha * mask;
				calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
				accumAlpha += ( 1.0 - accumAlpha ) * lalpha;

				return normal;
			}`),
  };
})();
var Ho = class extends Gt {
    constructor(t, e, i, n, r, s, a, o, l, c, d, h) {
      super("v3"),
        (this.nodeType = "CustomTexture"),
        (this.texture = t),
        (this.textureSize = e),
        (this.crop = i),
        (this.projection = n),
        (this.axis = r),
        (this.side = s),
        (this.size = a),
        (this.blending = o),
        (this.mat = l),
        (this.isMask = h),
        (this.alpha = c),
        (this.mode = d),
        (this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`);
    }
    generate(t, e) {
      t.require("position"),
        t.require("normal"),
        t.require("uv"),
        (t.requires.uv = [!0]),
        (t.extensions.shaderTextureLOD = !0),
        (t.extensions.derivatives = !0);
      let i = `g${this.uuid.toString().replace(/-/g, "")}`,
        n;
      switch (this.projection.value) {
        case 3:
          n = t.include(Ho.Nodes.cylindrical);
          break;
        case 2:
          n = t.include(Ho.Nodes.spherical);
          break;
        case 1:
          let s = [
              "vec3(1.0, 0.0, 0.0)",
              "vec3(0.0, 1.0, 0.0)",
              "vec3(0.0, 0.0, 1.0)",
            ][this.axis.value],
            a = ["zy", "xz", "xy"][this.axis.value],
            o = new Re(`
		vec3 ${i}_planarTexture(vec3 normal, sampler2D tex, vec2 textureSize, float crop, mat3 mat, vec2 size, float blending, bool isMask, float mask, float alpha, int mode, out float calpha, out vec2 writeUv) {
				vec2 projected = (1. + (position.${a})) / 2.;
				vec2 uvs = ( mat * vec3( (projected * 2. - 1.) / (size * .5), 1. ) / 2. + 0.5 ).xy;
				writeUv = uvs;

				vec4 tmp = texture2D( tex, uvs );

				vec3 col = tmp.rgb;
				float lalpha = alpha * tmp.a;
				${
          this.side.value === 2
            ? ""
            : `lalpha *= step(0.0, ${
                this.side.value === 1 ? "-1.0 * " : ""
              }dot(vObjectNormal, mat * ${s}));`
        }

				if ( crop > 0.5 ) {
					if ( uvs.x < 0.0 || uvs.x > 1.0 || uvs.y < 0.0 || uvs.y > 1.0 )  {
						lalpha = 0.0;
					}
				}
				
				lalpha *= mask;

				calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
				accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));

				return col;
			}`);
          n = t.include(o);
          break;
        case 4:
          n = t.include(Ho.Nodes.triplanar);
          break;
        default:
          n = t.include(Ho.Nodes.uv);
          break;
      }
      t.addFragmentVariable(this.calpha, "float");
      let r = [];
      if (
        (r.push("normal"),
        r.push(this.texture.generate(t, "t")),
        r.push(this.textureSize.build(t, "v2")),
        r.push(this.crop.build(t, "f")),
        r.push(this.mat.build(t, "mat3")),
        r.push(this.size.build(t, "v2")),
        r.push(this.blending.build(t, "f")),
        r.push(this.isMask.build(t, "b")),
        r.push(
          this.mask ? `luminance(${this.mask.flow(t, "v3").result})` : "1.0"
        ),
        r.push(this.alpha.build(t, "f")),
        r.push(this.mode.build(t, "i")),
        r.push(this.calpha),
        this.projection.value === 4)
      ) {
        let s = `${i}_writeUvs`,
          a = s + "0",
          o = s + "1",
          l = s + "2",
          c = `${i}_triplanarWeights`;
        t.addFragmentVariable(a, "vec2"),
          t.addFragmentVariable(o, "vec2"),
          t.addFragmentVariable(l, "vec2"),
          t.addFragmentVariable(c, "vec3"),
          r.push(a),
          r.push(o),
          r.push(l),
          r.push(c);
      } else {
        let s = `${i}_writeUvs`;
        t.addFragmentVariable(s, "vec2"), r.push(s);
      }
      return t.format(n + "(" + r.join(",") + ")", this.getType(t), e);
    }
  },
  Hp = Ho;
Hp.Nodes = (function () {
  let t = new Re(`
vec3 cylindricalTexture(vec3 normal, sampler2D tex, vec2 textureSize, float crop, mat3 mat, vec2 size, float blending, bool isMask, float mask, float alpha, int mode, out float calpha, out vec2 writeUv) {
                vec3 posN = normalize(position);
                float u = 0.5 + atan(posN.z, posN.x) / (2.*3.1415);
                float scaledHeight = position.y / (size.y * 0.5);
                float v =  (scaledHeight / 2.) + .5;

                vec2 calculatedUv = vec2(u,v);
				vec2 uvs = ( mat * vec3( calculatedUv * 2. - 1., 1. ) / 2. + 0.5 ).xy;
				writeUv = uvs;

                vec2 df = fwidth(uvs);
               	if(df.x > 0.5) df.x = 0.;

				#ifdef GL_EXT_shader_texture_lod
                vec4 tmp = texture2DLodEXT(tex, uvs, log2(max(df.x, df.y)*min(textureSize.x, textureSize.y)));
				#else
                vec4 tmp = textureLod(tex, uvs, log2(max(df.x, df.y)*min(textureSize.x, textureSize.y)));
				#endif

				vec3 col = tmp.rgb;
				float lalpha = alpha * tmp.a;
				if ( crop > 0.5 ) {
					if ( uvs.x < 0.0 || uvs.x > 1.0 || uvs.y < 0.0 || uvs.y > 1.0 )  {
						lalpha = 0.0;
					}
				}

				lalpha *= mask;
				
				calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
				accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));

				return col;
			}
`),
    e = new Re(`
vec3 sphericalTexture(vec3 normal, sampler2D tex, vec2 textureSize, float crop, mat3 mat, vec2 size, float blending, bool isMask, float mask, float alpha, int mode, out float calpha, out vec2 writeUv) {
                vec3 posN = normalize(vPosition);
                float u = 0.5 + atan(posN.z, posN.x) / (2.*3.1415);
                float v = 0.5 + asin(posN.y) / 3.1415;

                vec2 calculatedUv = vec2(u,v);
				vec2 uvs = ( mat * vec3( calculatedUv * 2. - 1., 1. ) / 2. + 0.5 ).xy;
				writeUv = uvs;

                vec2 df = fwidth(uvs);
               	if(df.x > 0.5) df.x = 0.;
				#ifdef GL_EXT_shader_texture_lod
                vec4 tmp = texture2DLodEXT(tex, uvs, log2(max(df.x, df.y)*min(textureSize.x, textureSize.y)));
				#else
                vec4 tmp = textureLod(tex, uvs, log2(max(df.x, df.y)*min(textureSize.x, textureSize.y)));
				#endif

				vec3 col = tmp.rgb;
				float lalpha = alpha * tmp.a;
				if ( crop > 0.5 ) {
					if ( uvs.x < 0.0 || uvs.x > 1.0 || uvs.y < 0.0 || uvs.y > 1.0 )  {
						lalpha = 0.0;
					}
				}

				lalpha *= mask;

				calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
				accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));

				return col;
			}
`),
    i =
      new Re(`vec3 uvTexture(vec3 normal, sampler2D tex, vec2 textureSize, float crop, mat3 mat, vec2 size, float blending, bool isMask, float mask, float alpha, int mode, out float calpha, out vec2 writeUv) {
				vec2 uvs = ( mat * vec3( vUv * 2. - 1., 1. ) / 2. + 0.5 ).xy;
				writeUv = uvs;

				vec4 tmp = texture2D( tex, uvs );

				vec3 col = tmp.rgb;

				float lalpha = alpha * tmp.a;
				if ( crop > 0.5 ) {
					if ( uvs.x < 0.0 || uvs.x > 1.0 || uvs.y < 0.0 || uvs.y > 1.0 )  {
						lalpha = 0.0;
					}
				}
				
				lalpha *= mask;

				calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
				accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));

				return col;
			}`),
    n =
      new Re(`vec3 triplanarTexture(vec3 normal, sampler2D tex, vec2 textureSize, float crop, mat3 mat, vec2 size, float blending, bool isMask, float mask, float alpha, int mode, out float calpha, out vec2 writeUvs0, out vec2 writeUvs1, out vec2 writeUvs2, out vec3 writeWeights) {
				vec3 p = position;
				vec2 uv0 = (1.0 + p.xy) / 2.0;     
				vec2 uv1 = (1.0 + p.zy) / 2.0;		
				vec2 uv2 = (1.0 + p.xz) / 2.0;		
	
				uv0 = (mat * vec3((uv0 * 2.0 - 1.0) / (size * 0.5), 1.0) / 2.0 + 0.5).xy;
				uv1 = (mat * vec3((uv1 * 2.0 - 1.0) / (size * 0.5), 1.0) / 2.0 + 0.5).xy;
				uv2 = (mat * vec3((uv2 * 2.0 - 1.0) / (size * 0.5), 1.0) / 2.0 + 0.5).xy;

				// Range from 3 to 128 seems to be good
				float exponent = (1.0 - blending) * 125.0 + 3.0;

				vec3 n = vObjectNormal;
				vec3 weights = abs(normalize(n));
				weights = pow(weights, vec3(exponent));
				weights /= dot(weights, vec3(1.0));

				// Write out all sets of UVs that we generated
				writeUvs0 = uv0;
				writeUvs1 = uv1;
				writeUvs2 = uv2;
				writeWeights = weights;

				// Derivatives for LOD
				vec2 df0 = fwidth(uv0);
				vec2 df1 = fwidth(uv1);
				vec2 df2 = fwidth(uv2);
				if (df0.x > 0.5) df0.x = 0.0;
				if (df1.x > 0.5) df1.x = 0.0;
				if (df2.x > 0.5) df2.x = 0.0;

				#ifdef GL_EXT_shader_texture_lod
                	vec4 tmp = 
						texture2DLodEXT(tex, uv0, log2(max(df0.x, df0.y)*min(textureSize.x, textureSize.y))) * weights.z + 
						texture2DLodEXT(tex, uv1, log2(max(df1.x, df1.y)*min(textureSize.x, textureSize.y))) * weights.x + 
						texture2DLodEXT(tex, uv2, log2(max(df2.x, df2.y)*min(textureSize.x, textureSize.y))) * weights.y;
				#else
                	vec4 tmp = 
						textureLod(tex, uv0, log2(max(df0.x, df0.y)*min(textureSize.x, textureSize.y))) * weights.z + 
						textureLod(tex, uv1, log2(max(df1.x, df1.y)*min(textureSize.x, textureSize.y))) * weights.x + 
						textureLod(tex, uv2, log2(max(df2.x, df2.y)*min(textureSize.x, textureSize.y))) * weights.y;
				#endif

				vec3 col = tmp.rgb;
				float lalpha = alpha * tmp.a;

				// Apply cropping across all 3 planes
				if ( crop > 0.5 ) {
					if ( uv0.x < 0.0 || uv0.x > 1.0 || uv0.y < 0.0 || uv0.y > 1.0 )  {
						lalpha = 0.0;
					}
					if ( uv1.x < 0.0 || uv1.x > 1.0 || uv1.y < 0.0 || uv1.y > 1.0 )  {
						lalpha = 0.0;
					}
					if ( uv2.x < 0.0 || uv2.x > 1.0 || uv2.y < 0.0 || uv2.y > 1.0 )  {
						lalpha = 0.0;
					}
				}

				lalpha *= mask;
				calpha =  lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0);
				accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));

				return col;//n * 0.5 + 0.5;
			}			
			`);
  return { cylindrical: t, spherical: e, uv: i, triplanar: n };
})();
var Go = class extends Gt {
    constructor(t, e, i, n, r, s, a, o, l, c, d, h) {
      super("v3"),
        (this.nodeType = "Depth"),
        (this.gradientType = t),
        (this.smooth = e),
        (this.near = i),
        (this.far = n),
        (this.isVector = r),
        (this.isWorldSpace = s),
        (this.origin = a),
        (this.direction = o),
        (this.colors = l),
        (this.steps = c),
        (this.isMask = h),
        (this.alpha = d),
        (this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`);
    }
    generate(t, e) {
      let i = `g${this.uuid.toString().replace(/-/g, "")}`,
        n = new Re(
          `vec3 ${i}_sdepth(float near, float far, vec3 origin, vec3 direction, vec4 colors[${i}_MAX_COLORS], float steps[${i}_MAX_COLORS], bool isMask, float mask, float alpha, out float calpha) {
               vec4 color = colors[0];
               #ifdef ${i}_IS_VECTOR
                   #ifdef ${i}_LINEAR
                       #ifdef ${i}_WORLDSPACE
                       float depth = vectorLinearWorldSpaceDepth(direction, origin, near, far);
                       #else
                       float depth = vectorLinearObjectSpaceDepth(direction, origin, near, far);
                       #endif
                   #else
                       #ifdef ${i}_WORLDSPACE
                           float depth = vectorSphericalWorldSpaceDepth(origin, near, far);
                       #else
                           float depth = vectorSphericalObjectSpaceDepth(origin, near, far);
                       #endif
                   #endif
               #else
                   float dist = length(vWPosition - cameraPosition);
			       float depth = ( dist - near ) / ( far - near );
               #endif


              float p;
              #ifdef ${i}_SMOOTH
				for ( int i = 1; i < ${i}_MAX_COLORS; i++ ) {
						p = clamp( ( depth - steps[i-1] ) / ( steps[i] - steps[i-1] ), 0.0, 1.0 );
						color = mix(color, colors[i], smoothstep(0.0, 1.0, p));
					}
              #else
                for ( int i = 1; i < ${i}_MAX_COLORS; i++ ) {
                   p = clamp(( depth - steps[i - 1] ) / ( steps[i] - steps[i - 1] ), 0.0, 1.0);
                   color = mix(color, colors[i], p);
                 }
              #endif

               float lalpha = alpha * color.a * mask;
               calpha = mix(lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0), lalpha, float(isMask));
			   accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));
			   
               return color.rgb;
			}`,
          [
            Go.Nodes.vectorLinearWorldSpaceDepth,
            Go.Nodes.vectorLinearObjectSpaceDepth,
            Go.Nodes.vectorSphericalObjectSpaceDepth,
            Go.Nodes.vectorSphericalWorldSpaceDepth,
          ]
        );
      if (t.isShader("fragment")) {
        t.define(`${i}_MAX_COLORS`, this.colors.value.length),
          this.smooth.value && t.define(`${i}_SMOOTH`),
          this.isVector.value > 0.5 && t.define(`${i}_IS_VECTOR`),
          this.gradientType.value === 0 && t.define(`${i}_LINEAR`),
          this.isWorldSpace.value > 0.5 && t.define(`${i}_WORLDSPACE`),
          t.require("worldPosition"),
          t.addFragmentVariable(this.calpha, "float");
        let r = t.include(n),
          s = [];
        return (
          s.push(this.near.build(t, "f")),
          s.push(this.far.build(t, "f")),
          s.push(this.origin.build(t, "v3")),
          s.push(this.direction.build(t, "v3")),
          s.push(this.colors.build(t, "v4[]")),
          s.push(this.steps.build(t, "f[]")),
          s.push(this.isMask.build(t, "b")),
          s.push(
            this.mask ? `luminance(${this.mask.flow(t, "v3").result})` : "1.0"
          ),
          s.push(this.alpha.build(t, "f")),
          s.push(this.calpha),
          t.format(r + "(" + s.join(",") + ")", this.getType(t), e)
        );
      } else
        return (
          console.warn(
            "DepthNode is not compatible with " + t.shader + " shader."
          ),
          t.format("vec3( 0.0 )", this.getType(t), e)
        );
    }
  },
  d1 = Go;
d1.Nodes = (function () {
  let t =
      new Re(`float vectorLinearWorldSpaceDepth(vec3 direction, vec3 origin, float near, float far) {
               vec3 n = normalize(direction);
               float dist = (n.x*(vWPosition.x - origin.x) + n.y*(vWPosition.y - origin.y) + n.z*(vWPosition.z - origin.z));
               return ( dist - near ) / ( far - near );
            }`),
    e =
      new Re(`float vectorLinearObjectSpaceDepth(vec3 direction, vec3 origin, float near, float far) {
               vec3 n = normalize(direction);
               float dist = (n.x*(position.x - origin.x) + n.y*(position.y - origin.y) + n.z*(position.z - origin.z));
               return ( dist - near ) / ( far - near );
            }`),
    i =
      new Re(`float vectorSphericalWorldSpaceDepth(vec3 origin, float near, float far) {
               float dist = length(vWPosition - origin);
               return ( dist - near ) / ( far - near );
            }`),
    n =
      new Re(`float vectorSphericalObjectSpaceDepth(vec3 origin, float near, float far) {
               float dist = length(position - origin);
               return ( dist - near ) / ( far - near );
            }`);
  return {
    vectorLinearWorldSpaceDepth: t,
    vectorLinearObjectSpaceDepth: e,
    vectorSphericalWorldSpaceDepth: i,
    vectorSphericalObjectSpaceDepth: n,
  };
})();
var SB = class extends Gt {
    constructor(t, e, i, n, r, s, a, o) {
      super("v3"),
        (this.nodeType = "Fresnel"),
        (this.color = t),
        (this.bias = e),
        (this.scale = i),
        (this.intensity = n),
        (this.factor = r),
        (this.isMask = o),
        (this.alpha = s),
        (this.mode = a),
        (this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`);
    }
    generate(t, e) {
      if (
        (t.require("vWorldViewDir"),
        t.require("worldNormal"),
        t.isShader("fragment"))
      ) {
        t.addFragmentVariable(this.calpha, "float");
        let i =
            new Re(`vec3 fresnel(vec3 color, float bias, float scale, float intensity, float factor, bool isMask, float mask, float alpha, int mode, out float calpha) {
					float fresnel = bias + scale * pow( abs( factor + dot( normalize( vWorldViewDir ), normalize( vWNormal ) ) ), intensity );

					float lalpha = clamp(fresnel, 0.0, 1.0) * alpha * mask;
					calpha = mix(lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0), lalpha, float(isMask));
					accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));

					return color;
				}`),
          n = t.include(i),
          r = [];
        return (
          r.push(this.color.build(t, "c")),
          r.push(this.bias.build(t, "f")),
          r.push(this.scale.build(t, "f")),
          r.push(this.intensity.build(t, "f")),
          r.push(this.factor.build(t, "f")),
          r.push(this.isMask.build(t, "b")),
          r.push(
            this.mask ? `luminance(${this.mask.flow(t, "v3").result})` : "1.0"
          ),
          r.push(this.alpha.build(t, "f")),
          r.push(this.mode.build(t, "i")),
          r.push(this.calpha),
          t.format(n + "(" + r.join(",") + ")", this.getType(t), e)
        );
      } else
        return (
          console.warn(
            "FresnelNode is not compatible with " + t.shader + " shader."
          ),
          t.format("vec3( 0.0 )", this.getType(t), e)
        );
    }
  },
  f1 = class extends Gt {
    constructor(t, e, i, n, r, s, a, o, l) {
      super("v3"),
        (this.nodeType = "Gradient"),
        (this.gradientType = t),
        (this.smooth = e),
        (this.colors = i),
        (this.steps = n),
        (this.offset = r),
        (this.morph = s),
        (this.angle = a),
        (this.isMask = l),
        (this.alpha = o),
        (this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`);
    }
    generate(t, e) {
      if (t.isShader("fragment")) {
        t.define("GRAD_MAX", 10),
          t.require("uv"),
          (t.requires.uv = [!0]),
          t.addFragmentVariable(this.calpha, "float");
        let i = t.include(f1.Nodes.gradient),
          n = [];
        return (
          n.push(this.gradientType.build(t, "i")),
          n.push(this.smooth.build(t, "b")),
          n.push(this.colors.build(t, "v4[]")),
          n.push(this.steps.build(t, "f[]")),
          n.push(this.offset.build(t, "v2")),
          n.push(this.morph.build(t, "v2")),
          n.push(this.angle.build(t, "f")),
          n.push(this.isMask.build(t, "b")),
          n.push(
            this.mask ? `luminance(${this.mask.flow(t, "v3").result})` : "1.0"
          ),
          n.push(this.alpha.build(t, "f")),
          n.push(this.calpha),
          t.format(i + "(" + n.join(",") + ")", this.getType(t), e)
        );
      } else
        return (
          console.warn(
            "GradientNode is not compatible with " + t.shader + " shader."
          ),
          t.format("vec3( 0.0 )", this.getType(t), e)
        );
    }
  },
  p1 = f1;
p1.Nodes = (function () {
  return {
    gradient:
      new Re(`vec3 gradient(int gradientType, bool smoothed, vec4 colors[GRAD_MAX], float steps[GRAD_MAX], vec2 offset, vec2 morph, float angle, bool isMask, float mask, float alpha, out float calpha) {
				vec4 color = colors[0];
				vec2 m = morph / vUv.xy;
				vec2 rot = vec2( 0.5 + m.x, m.y );
				vec2 dt = vec2(
					cos( angle ) * rot.x - sin( angle ) * rot.y,
					sin( angle ) * rot.x + cos( angle ) * rot.y
				);
				vec2 pt = ( vUv - 0.5 + offset ) / 2.0 + dt / 2.0;
				float t = dot( pt, dt ) / dot( dt, dt );
				if ( gradientType == 1 ) {
					t = distance (
						( vUv + morph ) * 3.0,
						( vUv + offset ) + 1.0
					) + angle;
				} else if ( gradientType == 2 ) {
					float polar = atan(
						vUv.x + morph.x - 0.5 + offset.x,
						vUv.y + morph.y - 0.5 + offset.y
					) * -1.0;
					t = fract( ( angle / PI / -2.0 ) + 0.5 * ( polar / PI ) );
				}

				float p;
				if (smoothed) {
					for ( int i = 1; i < GRAD_MAX; i++ ) {
						p = clamp( ( t - steps[i-1] ) / ( steps[i] - steps[i-1] ), 0.0, 1.0 );
						color = mix(color, colors[i], smoothstep(0.0, 1.0, p));
					}

				} else {
					for ( int i = 1; i < GRAD_MAX; i++ ) {
						p = clamp( ( t - steps[i-1] ) / ( steps[i] - steps[i-1] ), 0.0, 1.0 );
						color = mix(color, colors[i], p);
					}
				}

				float lalpha = alpha * color.a * mask;
				calpha = mix(lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0), lalpha, float(isMask));
				accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));
				
				return color.xyz;
			}`),
  };
})();
var m1 = class extends Gt {
    constructor(t, e, i, n) {
      super("v3"),
        (this.nodeType = "Matcap"),
        (this.texture = t),
        (this.isMask = n),
        (this.alpha = e),
        (this.mode = i),
        (this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`);
    }
    generate(t, e) {
      if (t.isShader("fragment")) {
        t.addFragmentVariable(this.calpha, "float");
        let i = t.include(m1.Nodes.matcap);
        t.require("normal"), (t.requires.normal = !0);
        let n = [];
        return (
          n.push(this.texture.generate(t, "t")),
          n.push("normal"),
          n.push(this.isMask.build(t, "b")),
          n.push(
            this.mask ? `luminance(${this.mask.flow(t, "v3").result})` : "1.0"
          ),
          n.push(this.alpha.build(t, "f")),
          n.push(this.mode.build(t, "i")),
          n.push(this.calpha),
          t.format(i + "(" + n.join(",") + ")", this.getType(t), e)
        );
      } else
        return (
          console.warn(
            "MatcapNode is not compatible with " + t.shader + " shader."
          ),
          t.format("vec3( 0.0 )", this.getType(t), e)
        );
    }
  },
  g1 = m1;
g1.Nodes = (function () {
  return {
    matcap:
      new Re(`vec3 matcap(sampler2D matcapTex, vec3 normal, bool isMask, float mask, float alpha, int mode, out float calpha) {
					vec3 viewDir = normalize( vViewPosition );
					vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
					vec3 y = cross( viewDir, x );
					vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5; // 0.495 to remove artifacts caused by undersized matcap disks
					vec4 matcapColor = texture2D( matcapTex, uv );

					float lalpha = alpha * mask;
					calpha = mix(lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0), lalpha, float(isMask));
					accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));
					
					return matcapColor.rgb;
            	}`),
  };
})();
var Gp = ((t) => (
    (t.SIMPLEX = "simplex3d"),
    (t.SIMPLEX_FRACTAL = "simplex3dFractal"),
    (t.ASHIMA = "simplexAshima"),
    (t.FBM = "fbm"),
    (t.PERLIN = "perlin"),
    (t.VORONOI = "voronoi"),
    t
  ))(Gp || {}),
  Ji = (function () {
    let t = new Re(`vec3 random3(vec3 c) {
			float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));
			vec3 r;
			r.z = fract(512.0*j);
			j *= .125;
			r.x = fract(512.0*j);
			j *= .125;
			r.y = fract(512.0*j);
			return r-0.5;
		}`),
      e = new Re(
        `float simplex3d(vec3 p) {
			 vec3 s = floor(p + dot(p, vec3(F3)));
			 vec3 x = p - s + dot(s, vec3(G3));
			 
			 vec3 e = step(vec3(0.0), x - x.yzx);
			 vec3 i1 = e*(1.0 - e.zxy);
			 vec3 i2 = 1.0 - e.zxy*(1.0 - e);
				
			 vec3 x1 = x - i1 + G3;
			 vec3 x2 = x - i2 + 2.0*G3;
			 vec3 x3 = x - 1.0 + 3.0*G3;
			 
			 vec4 w, d;
			 
			 w.x = dot(x, x);
			 w.y = dot(x1, x1);
			 w.z = dot(x2, x2);
			 w.w = dot(x3, x3);
			 
			 w = max(0.6 - w, 0.0);
			 
			 d.x = dot(random3(s), x);
			 d.y = dot(random3(s + i1), x1);
			 d.z = dot(random3(s + i2), x2);
			 d.w = dot(random3(s + 1.0), x3);
			 
			 w *= w;
			 w *= w;
			 d *= w;
			 
			 return dot(d, vec4(52.0));
		}`,
        [t]
      );
    (e.keywords.F3 = new kt("float F3 0.3333333")),
      (e.keywords.G3 = new kt("float G3 0.1666667"));
    let i = new Re(
        `float simplex3dFractal(vec3 m) {
			mat3 rot1 = mat3(-0.37, 0.36, 0.85,-0.14,-0.93, 0.34,0.92, 0.01,0.4);
			mat3 rot2 = mat3(-0.55,-0.39, 0.74, 0.33,-0.91,-0.24,0.77, 0.12,0.63);
			mat3 rot3 = mat3(-0.71, 0.52,-0.47,-0.08,-0.72,-0.68,-0.7,-0.45,0.56);
			return 0.5333333 * simplex3d(m * rot1)
				 + 0.2666667 * simplex3d(2.0 * m * rot2)
				 + 0.1333333 * simplex3d(4.0 * m * rot3)
				 + 0.0666667 * simplex3d(8.0 * m);
		}`,
        [e]
      ),
      n = new Re("vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}"),
      r = new Re(
        "vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}"
      ),
      s = new Re(
        `float simplexAshima(vec3 v) {
		  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
		  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);
		  vec3 i  = floor(v + dot(v, C.yyy) );
		  vec3 x0 =   v - i + dot(i, C.xxx) ;
		  vec3 g = step(x0.yzx, x0.xyz);
		  vec3 l = 1.0 - g;
		  vec3 i1 = min( g.xyz, l.zxy );
		  vec3 i2 = max( g.xyz, l.zxy );
		  vec3 x1 = x0 - i1 + 1.0 * C.xxx;
		  vec3 x2 = x0 - i2 + 2.0 * C.xxx;
		  vec3 x3 = x0 - 1. + 3.0 * C.xxx;
		  i = mod(i, 289.0 ); 
		  vec4 p = permute( permute( permute( 
					 i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
				   + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) 
				   + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
		  float n_ = 1.0/7.0; // N=7
		  vec3  ns = n_ * D.wyz - D.xzx;
		  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)
		  vec4 x_ = floor(j * ns.z);
		  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)
		  vec4 x = x_ *ns.x + ns.yyyy;
		  vec4 y = y_ *ns.x + ns.yyyy;
		  vec4 h = 1.0 - abs(x) - abs(y);
		  vec4 b0 = vec4( x.xy, y.xy );
		  vec4 b1 = vec4( x.zw, y.zw );
		  vec4 s0 = floor(b0)*2.0 + 1.0;
		  vec4 s1 = floor(b1)*2.0 + 1.0;
		  vec4 sh = -step(h, vec4(0.0));
		  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
		  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
		  vec3 p0 = vec3(a0.xy,h.x);
		  vec3 p1 = vec3(a0.zw,h.y);
		  vec3 p2 = vec3(a1.xy,h.z);
		  vec3 p3 = vec3(a1.zw,h.w);
		  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
		  p0 *= norm.x;
		  p1 *= norm.y;
		  p2 *= norm.z;
		  p3 *= norm.w;
		  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
		  m = m * m;
		  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), 
										dot(p2,x2), dot(p3,x3) ) );
		}`,
        [n, r]
      ),
      a = new Re(
        "vec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}"
      ),
      o = new Re("vec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}", [
        a,
      ]),
      l = new Re(
        `float noise(vec3 p){
			vec3 a = floor(p);
			vec3 d = p - a;
			d = d * d * (3.0 - 2.0 * d);
			vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);
			vec4 k1 = perm(b.xyxy);
			vec4 k2 = perm(k1.xyxy + b.zzww);
			vec4 c = k2 + a.zzzz;
			vec4 k3 = perm(c);
			vec4 k4 = perm(c + 1.0);
			vec4 o1 = fract(k3 * (1.0 / 41.0));
			vec4 o2 = fract(k4 * (1.0 / 41.0));
			vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);
			vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);
			return o4.y * d.y + o4.x * (1.0 - d.y);
		}`,
        [o]
      ),
      c = new Re(
        `float fbm(vec3 x) {
			float v = 0.0;
			float a = 0.5;
			vec3 shift = vec3(100);
			for (int i = 0; i < NUM_OCTAVES; ++i) {
				v += a * noise(x);
				x = x * 2.0 + shift;
				a *= 0.5;
			}
			return v;
		}`,
        [l]
      );
    c.keywords.NUM_OCTAVES = new kt("int NUM_OCTAVES 5");
    let d = new Re("vec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}"),
      h = new Re(
        `float perlin(vec3 P){
		  vec3 Pi0 = floor(P);
		  vec3 Pi1 = Pi0 + vec3(1.0);
		  Pi0 = mod(Pi0, 289.0);
		  Pi1 = mod(Pi1, 289.0);
		  vec3 Pf0 = fract(P);
		  vec3 Pf1 = Pf0 - vec3(1.0);
		  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
		  vec4 iy = vec4(Pi0.yy, Pi1.yy);
		  vec4 iz0 = Pi0.zzzz;
		  vec4 iz1 = Pi1.zzzz;
		  vec4 ixy = permute(permute(ix) + iy);
		  vec4 ixy0 = permute(ixy + iz0);
		  vec4 ixy1 = permute(ixy + iz1);
		  vec4 gx0 = ixy0 / 7.0;
		  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;
		  gx0 = fract(gx0);
		  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
		  vec4 sz0 = step(gz0, vec4(0.0));
		  gx0 -= sz0 * (step(0.0, gx0) - 0.5);
		  gy0 -= sz0 * (step(0.0, gy0) - 0.5);
		  vec4 gx1 = ixy1 / 7.0;
		  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;
		  gx1 = fract(gx1);
		  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
		  vec4 sz1 = step(gz1, vec4(0.0));
		  gx1 -= sz1 * (step(0.0, gx1) - 0.5);
		  gy1 -= sz1 * (step(0.0, gy1) - 0.5);
		  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
		  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
		  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
		  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
		  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
		  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
		  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
		  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);
		  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
		  g000 *= norm0.x;
		  g010 *= norm0.y;
		  g100 *= norm0.z;
		  g110 *= norm0.w;
		  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
		  g001 *= norm1.x;
		  g011 *= norm1.y;
		  g101 *= norm1.z;
		  g111 *= norm1.w;
		  float n000 = dot(g000, Pf0);
		  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
		  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
		  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
		  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
		  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
		  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
		  float n111 = dot(g111, Pf1);
		  vec3 fade_xyz = fade(Pf0);
		  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
		  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
		  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); 
		  return 2.2 * n_xyz;
		}`,
        [n, r, d]
      ),
      u = new Re(`float hashwithoutsine13(vec3 p3)
		{
			p3  = fract(p3 * .1031);
			p3 += dot(p3, p3.yzx + 33.33);
			return fract((p3.x + p3.y) * p3.z);
		}`),
      f = new Re(`vec3 hashwithoutsine33(vec3 p3)
		{
			p3 = fract(p3 * vec3(.1031, .1030, .0973));
			p3 += dot(p3, p3.yxz+33.33);
			return fract((p3.xxy + p3.yxx)*p3.zyx);
		}`),
      p = new Re(`float metric(in vec3 p)
		{
			// L2 
			return length(p);

			// Chebyshev 
			// vec3 a = abs(p);
			// return max(a.x, max(a.y, a.z));
		}`),
      v = new Re(`float smin( float a, float b, float k )
		{
			float h = smoothstep(0.0, 1.0, 0.5 + 0.5 * (b - a) / k);
			float correction = k * h * (1.0 - h);
			return mix(b, a, h) - correction;
		}`),
      g = new Re(`float smax( float a, float b, float k )
		{
			float h = smoothstep(1.0, 0.0, 0.5 + 0.5 * (a - b) / k);
			float correction = k * h * (1.0 - h);
			return mix(a, b, h) + correction;
		}`),
      m =
        new Re(`float remap(float value, float input_min, float input_max, float output_min, float output_max) {
			// Compute width of each interval
			float input_width = input_max - input_min;
			float output_width = output_max - output_min;
		
			// Convert input range into a 0-1 range 
			float scaled = (value - input_min) / input_width;
		
			// Convert the 0-1 range into a value in output range
			return output_min + (scaled * output_width);
		}`),
      x = new Re(
        `float voronoi(in vec3 x, in int style, in float smoothness, in float seed, in int quality) 
		{
			// Integer and fractional parts of this point's coordinates
			ivec3 p = ivec3(floor(x));
			vec3 f = fract(x);

			// Different variables that we will use to construct noise:
			//
			// f1: distance to the closest feature point
			// f2: distance to the second closest feature point
			// e: distance to the closest edge (cell boundary)
			//
			// We also compute "smooth" versions of all of the above quantites, essentially
			// replacing "hard" minimums with "smooth" minimums (described by IQ)
			float f1_smooth = 8.0;
			float f1 = 8.0;
			float f2_smooth = 8.0;
			float f2 = 8.0;
			float e_smooth = 8.0;
			float e = 8.0;

			// Variables stored from closest cell
			ivec3 mb;
			vec3 mr; 

			int steps = quality;
			
			for (int x = -steps; x <= steps; x++) 
			for (int y = -steps; y <= steps; y++)
			for (int z = -steps; z <= steps; z++)
			{
				ivec3 b = ivec3(x, y, z);
				vec3 r = vec3(b) + hashwithoutsine33(vec3(p + b) + seed) - f;
				float d = length(r);
				
				f1_smooth = smin(d, f1_smooth, smoothness);

				// Store un-smoothed distances too 
				if (d < f1) 
				{
					f2 = f1;
					f1 = d;

					mb = ivec3(x, y, z);
					mr = r;
				} 
				else if (d < f2) 
				{
					f2 = d;
				}
			}	
			
			float id = hashwithoutsine13(vec3(p + mb) + seed);

			// Second pass for edge distance  
			for (int x = -steps; x <= steps; x++) 
			for (int y = -steps; y <= steps; y++)
			for (int z = -steps; z <= steps; z++)
			{
				// Start search at the cell that contains the closest point to "x" (found in 1st pass)
				ivec3 b = mb + ivec3(x, y, z);
				vec3 r = vec3(b) + hashwithoutsine33(vec3(p + b) + seed) - f;
				float d1 = dot(0.5 * (mr + r), (r - mr)); 				// IQ normalizes "r - mr" but that breaks things for the smooth version?
				float d2 = dot(0.5 * (mr + r), normalize(r - mr));

				e_smooth = smin(d1, e_smooth, smoothness);

				e = min(e, d2);

				// Also compute a smooth version of F2 in this pass
				{
					ivec3 b = ivec3(x, y, z);
					if (b != mb) 
					{
						vec3 r = vec3(b) + hashwithoutsine33(vec3(p + b) + seed) - f;
						float d = length(r);

						f2_smooth = smin(d, f2_smooth, smoothness);
					}
				}
			}

			// Different visualization modes 
			if (style == 0) 
			{
				return f1_smooth;
			}
			if (style == 1) 
			{
				return f2_smooth;
			}
			if (style == 2) 
			{
				return f2_smooth - f1_smooth;
				
				// "Pebbles" also cool
				//return step(0.2, f2_smooth - f1_smooth);
			}
			if (style == 3) 
			{
				// This one is really good for rock / stone effects
				float a = f1; 
				float b = f2;
				float k = 3.0;
				float h = max(k - abs(a - b), 0.0) / k;
				float final = min(a, b) - h * h * k * (1.0 / 4.0);
				return final;
			}
			if (style == 4) 
			{
				// Some random adjustments to make this style stand out more 
				return exp(5.0 * e_smooth);
			}
			if (style == 5) 
			{
				return pow(f1_smooth, 3.0);
			}
			if (style == 6) 
			{				
				const float eps = 0.0125;

				// Thicker lines as the user increases the smoothness slider
				float thickness = smoothness * 0.25 + eps;

				// Blurrier lines as the user increases the smoothness slider
				float blur = pow(smoothness, 3.0) * 0.25 + eps;

				return smoothstep(
					thickness - thickness * blur, 
					thickness + thickness * blur, 
					e
				);
			}
			if (style == 7) 
			{
				return hashwithoutsine13(vec3(p + mb) + seed);
			}
		}
	`,
        [u, f, p, v, g, m]
      );
    return {
      simplex: e,
      simplexFractal: i,
      simplexAshima: s,
      fbm: c,
      perlin: h,
      voronoi: x,
    };
  })(),
  v1 = class extends Gt {
    constructor(t, e, i, n, r, s, a, o, l, c, d, h, u, f, p, v, g, m, x) {
      super("v3"),
        (this.nodeType = "Noise"),
        (this.scale = t),
        (this.size = e),
        (this.move = i),
        (this.fA = n),
        (this.fB = r),
        (this.distortion = s),
        (this.colorA = a),
        (this.colorB = o),
        (this.colorC = l),
        (this.colorD = c),
        (this.noiseType = h),
        (this.voronoiStyle = f),
        (this.highCut = p),
        (this.lowCut = v),
        (this.smoothness = g),
        (this.seed = m),
        (this.quality = x),
        (this.isMask = u),
        (this.alpha = d),
        (this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`);
    }
    generate(t, e, i, n, r) {
      t.require("uv"),
        (t.requires.uv = [!0]),
        t.addFragmentVariable(this.calpha, "float");
      let s = Object.values(Gp)[this.noiseType.value],
        a =
          s == "voronoi"
            ? `
		float v = ${s}(st + move, voronoiStyle, smoothness, seed, quality);

		// Apply clipping to colors
		v = remap(v, lowCut, highCut, 0.0, 1.0);
		v = smax(v, 0.0, smoothness * 0.25);
		v = smin(v, 1.0, smoothness * 0.25);

		// Note that the voronoi mode only uses colors "A" and "C" from the UI 
		vec4 color = mix(colorA, colorC, v); 
		`
            : `
		vec3 q = vec3(${s}(st),
					   ${s}(st + vec3(1.0)),
					   ${s}(st + vec3(1.0)));
		vec3 r = vec3(${s}(st + vec3(distortion, 1.0) * q + vec3(fA, 1.0) + move),
					  ${s}(st + vec3(distortion, 1.0) * q + vec3(fB, 1.0) + move), 
					  ${s}(st * q));
		float f = ${s}(st + r);
		vec4 color;
		color = mix(colorA, colorB, clamp((f * f) * 4.0, 0.0, 1.0));
		color = mix(color, colorC, clamp(length(q), 0.0, 1.0));
		color = mix(color, colorD, clamp(length(r.x), 0.0, 1.0));
		`,
        o = new Re(
          `vec3 ${s}customNoise(float scale, vec3 size, float move, vec2 fA, vec2 fB, vec2 distortion, vec4 colorA, vec4 colorB, vec4 colorC, vec4 colorD, int voronoiStyle, float highCut, float lowCut, float smoothness, float seed, int quality, bool isMask, float mask, float alpha, out float calpha) 
			{
                // Prevent scale of zero 
				scale = max(abs(scale), 0.001);

				vec3 st = position / size;
				st /= scale;

				${a}

				float lalpha = alpha * color.a * mask;
				calpha = mix(lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0), lalpha, float(isMask));
				accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));

				return clamp(color, 0.0, 1.0).rgb;
			}`,
          [
            Ji.simplex,
            Ji.simplexFractal,
            Ji.simplexAshima,
            Ji.fbm,
            Ji.perlin,
            Ji.voronoi,
          ]
        ),
        l = t.include(o),
        c = [];
      return (
        c.push(this.scale.build(t, "f")),
        c.push(this.size.build(t, "v3")),
        c.push(this.move.build(t, "f")),
        c.push(this.fA.build(t, "v2")),
        c.push(this.fB.build(t, "v2")),
        c.push(this.distortion.build(t, "v2")),
        c.push(this.colorA.build(t, "v4")),
        c.push(this.colorB.build(t, "v4")),
        c.push(this.colorC.build(t, "v4")),
        c.push(this.colorD.build(t, "v4")),
        c.push(this.voronoiStyle.build(t, "i")),
        c.push(this.highCut.build(t, "f")),
        c.push(this.lowCut.build(t, "f")),
        c.push(this.smoothness.build(t, "f")),
        c.push(this.seed.build(t, "f")),
        c.push(this.quality.build(t, "i")),
        c.push(this.isMask.build(t, "b")),
        c.push(
          this.mask ? `luminance(${this.mask.flow(t, "v3").result})` : "1.0"
        ),
        c.push(this.alpha.build(t, "f")),
        c.push(this.calpha),
        t.format(l + "(" + c.join(",") + ")", this.getType(t), e)
      );
    }
  };
v1.numOctaves = 5;
var y1 = class extends Gt {
    constructor(t, e, i, n, r, s, a, o, l, c, d, h, u, f, p, v) {
      super("v3"),
        (this.nodeType = "Outline"),
        (this.firstTime = !0),
        (this.outlineColor = t),
        (this.contourColor = e),
        (this.outlineWidth = i),
        (this.contourWidth = n),
        (this.contourThreshold = r),
        (this.outlineThreshold = s),
        (this.contourFrequency = a),
        (this.outlineSmoothing = o),
        (this.contourDirection = l),
        (this.positionalLines = c),
        (this.compensation = d),
        (this.resolution = h),
        (this.normalMap = u),
        (this.depthMap = f),
        (this.pixelRatio = p),
        (this.alpha = v),
        (this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`);
    }
    generate(t, e) {
      let i = `g${this.uuid.toString().replace(/-/g, "")}`;
      if (
        (t.require("vWorldViewDir"),
        t.require("worldNormal"),
        (t.extensions.derivatives = !0),
        this.compensation.value &&
          t.define("OUTLINE_COMPENSATION", `${i}_offset`),
        this.firstTime)
      ) {
        let n = this.outlineWidth.build(t, "f"),
          r = this.resolution.build(t, "v2"),
          s = this.compensation.build(t, "b"),
          a = this.pixelRatio.build(t, "f");
        t.addVertexParsVariable("randomColor", "attribute vec3"),
          t.addVertexParsVariable("extrudeNormal", "attribute vec3"),
          t.addVertexParsVariable(n, "uniform float"),
          t.addVertexParsVariable(r, "uniform vec2"),
          t.addVertexParsVariable(s, "uniform bool"),
          t.addVertexParsVariable(a, "uniform float"),
          t.addVertexParsVariable("vID", "flat out float"),
          t.addFragmentParsVariable("vID", "flat in float"),
          t.addVertexFinalCode(`
                vID = randomColor.r;
                vec2 ${i}_offset = vec2(0.0);
                if (${s}) {
                    vec4 ${i}_clipPosition = projectionMatrix * (modelViewMatrix * vec4(position, 1.0));
                    // NOTE: For certain shapes, like spheres, we get incorrect extrusion when the
                    // normals face the camera directly. So we hackily fix this by offsetting the normal
                    // by a tiny amount.
                    vec3 ${i}_clipNormal = mat3(projectionMatrix) * (mat3(modelViewMatrix) * extrudeNormal) + 0.0000001;
                    ${i}_offset = normalize(${i}_clipNormal.xy) / ${r} * (${n} / 2.0) * ${i}_clipPosition.w * 2.0 * ${a};
                    ${i}_clipPosition.xy += ${i}_offset;
                    // TODO(MAX): To handle multiple outline layers, we only want to extrude
                    // if this offset is the biggest of all the potential offsets
                    gl_Position = ${i}_clipPosition;
                }
            `);
      }
      if (t.isShader("fragment")) {
        t.require("uv"),
          (t.requires.uv = [!0]),
          t.addFragmentVariable(this.calpha, "float");
        let n = t.include(y1.Nodes.outline),
          r = [];
        return (
          r.push(this.outlineColor.build(t, "c")),
          r.push(this.contourColor.build(t, "c")),
          r.push(this.outlineWidth.build(t, "f")),
          r.push(this.contourWidth.build(t, "f")),
          r.push(this.contourThreshold.build(t, "f")),
          r.push(this.outlineThreshold.build(t, "f")),
          r.push(this.contourFrequency.build(t, "f")),
          r.push(this.outlineSmoothing.build(t, "f")),
          r.push(this.contourDirection.build(t, "v3")),
          r.push(this.positionalLines.build(t, "b")),
          r.push(this.resolution.build(t, "v2")),
          r.push(this.normalMap.getTexture(t, "t")),
          r.push(this.depthMap.getTexture(t, "t")),
          r.push(this.pixelRatio.build(t, "f")),
          r.push(this.compensation.build(t, "b")),
          r.push(
            this.mask ? `luminance(${this.mask.flow(t, "v3").result})` : "1.0"
          ),
          r.push(this.alpha.build(t, "f")),
          r.push(this.calpha),
          (this.firstTime = !this.firstTime),
          t.format(n + "(" + r.join(",") + ")", this.getType(t), e)
        );
      } else
        return (
          console.warn(
            "OutlineNode is not compatible with " + t.shader + " shader."
          ),
          ""
        );
    }
  },
  x1 = y1;
x1.Nodes = (function () {
  let t = new Re(`
float sobelSample(sampler2D t, sampler2D d, vec2 uv, vec2 resolution, float outlineWidth, float pixelRatio)
{
    vec2 halton = haltonSequence[frameIndex];
    float temporalOffset = getNoiseInterleavedGradient(gl_FragCoord.xy + halton);
    float temporalAngle  = temporalOffset * PI2;

    vec2 texelSize = (vec2(1.0) / resolution);
    vec2 offsetSize = texelSize * outlineWidth * pixelRatio;

    vec2 uvSamples[9];
    vec4 normalSamples[9];

	uvSamples[0] = uv + vec2( -offsetSize.x, -offsetSize.y) + (vogelDiskSample(0, 9, temporalAngle) * texelSize);
	uvSamples[1] = uv + vec2(0.0, -offsetSize.y) + (vogelDiskSample(1, 9, temporalAngle) * texelSize);
	uvSamples[2] = uv + vec2(  offsetSize.x, -offsetSize.y) + (vogelDiskSample(2, 9, temporalAngle) * texelSize);
	uvSamples[3] = uv + vec2( -offsetSize.x, 0.0) + (vogelDiskSample(3, 9, temporalAngle) * texelSize);
	uvSamples[4] = uv;
	uvSamples[5] = uv + vec2(  offsetSize.x, 0.0) + (vogelDiskSample(5, 9, temporalAngle) * texelSize);
	uvSamples[6] = uv + vec2( -offsetSize.x, offsetSize.y) + (vogelDiskSample(6, 9, temporalAngle) * texelSize);
	uvSamples[7] = uv + vec2(0.0, offsetSize.y) + (vogelDiskSample(7, 9, temporalAngle) * texelSize);
	uvSamples[8] = uv + vec2(  offsetSize.x, offsetSize.y) + (vogelDiskSample(8, 9, temporalAngle) * texelSize);


    normalSamples[0] = texture2D(t, uvSamples[0]);
    normalSamples[1] = texture2D(t, uvSamples[1]);
    normalSamples[2] = texture2D(t, uvSamples[2]);
    normalSamples[3] = texture2D(t, uvSamples[3]);
    normalSamples[4] = texture2D(t, uvSamples[4]);
    normalSamples[5] = texture2D(t, uvSamples[5]);
    normalSamples[6] = texture2D(t, uvSamples[6]);
    normalSamples[7] = texture2D(t, uvSamples[7]);
    normalSamples[8] = texture2D(t, uvSamples[8]);

    float depthBias = 0.0001;
    // TODO(MAX): Can we somehow reduce the number of conditionals here with MATH?!
    if (normalSamples[0].a != vID && normalSamples[0].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[0]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    if (normalSamples[1].a != vID && normalSamples[1].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[1]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    if (normalSamples[2].a != vID && normalSamples[2].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[2]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    if (normalSamples[3].a != vID && normalSamples[3].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[3]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }


    if (normalSamples[4].a != vID && normalSamples[4].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[4]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    if (normalSamples[5].a != vID && normalSamples[5].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[5]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    if (normalSamples[6].a != vID && normalSamples[6].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[6]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    if (normalSamples[7].a != vID && normalSamples[7].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[7]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    if (normalSamples[8].a != vID && normalSamples[8].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[8]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    vec3 sobel_edge_h = normalSamples[2].rgb + (2.0*normalSamples[5].rgb) + normalSamples[8].rgb - (normalSamples[0].rgb + (2.0*normalSamples[3].rgb) + normalSamples[6].rgb);
  	vec3 sobel_edge_v = normalSamples[0].rgb + (2.0*normalSamples[1].rgb) + normalSamples[2].rgb - (normalSamples[6].rgb + (2.0*normalSamples[7].rgb) + normalSamples[8].rgb);

    float edgeNormal = sqrt(dot(sobel_edge_h, sobel_edge_h) + dot(sobel_edge_v, sobel_edge_v));
    return edgeNormal;
}
`);
  return {
    outline: new Re(
      `vec3 outline(vec3 outlineColor, vec3 contourColor, float outlineWidth, float contourWidth, float outlineThreshold, float contourThreshold, float outlineSmoothing, float contourFrequency, vec3 contourDirection, bool positionalLines, vec2 resolution, sampler2D normalMap, sampler2D depthMap, float pixelRatio, bool compensation, float mask, float alpha, out float calpha) {
                vec3 result = outlineColor;
                float resultAlpha = 0.0;

                vec3 N = normalize(vWNormal);
                vec2 nuv = (gl_FragCoord.xy / resolution);
                float sobelSample = compensation ? sobelSample(normalMap, depthMap, nuv, resolution, outlineWidth / 2., pixelRatio) : sobelSample(normalMap, depthMap, nuv, resolution, outlineWidth, pixelRatio);
                resultAlpha = smoothstep(outlineThreshold - outlineSmoothing, outlineThreshold + outlineSmoothing, sobelSample);

                //resultAlpha = 1.0;
                //result = vec3(sobelSample);

                float t = 1.0 - contourThreshold;
                if(positionalLines) {
                    vec3 NDir = position * contourDirection;
                    float NT = NDir.x + NDir.y + NDir.z;
                    float f  = fract(NT * contourFrequency * 0.01);
                    float df = fwidth(NT * contourFrequency);

                    float g = smoothstep(df * (contourWidth * 0.01), df * (contourWidth * 0.01 * 2.0), f);
                    if (g < 1.0 && resultAlpha == 0.0) {
                        result = contourColor;
                        resultAlpha = 1.0;
                    }
                 }
                 else {
                    vec3 NDir = N * contourDirection;
                    float NT = NDir.x + NDir.y + NDir.z;
                    float df = fwidth(NT * contourThreshold);
                    float f = sin(NT * 1.0 * contourFrequency);
                    float g = smoothstep(0.0, df * contourWidth, 1.0 - f);

                    if (df > (t * 0.5) && g < 1.0 && resultAlpha == 0.0) {
                        result = contourColor;
                        resultAlpha = 1.0 - g;
                    }
                 }

                 float lalpha = alpha * resultAlpha * mask;
                 calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
                 accumAlpha += ( 1.0 - accumAlpha ) * lalpha;
				 
                 return result;
             }`,
      [t]
    ),
  };
})();
var Tr = class extends Gt {
    constructor(t, e, i, n, r, s, a, o, l, c, d, h, u, f, p, v, g, m) {
      super("v3"),
        (this.nodeType = "Pattern"),
        (this.style = t),
        (this.projection = e),
        (this.axis = i),
        (this.blending = n),
        (this.offset = r),
        (this.colorA = s),
        (this.colorB = a),
        (this.frequency = o),
        (this.size = l),
        (this.variation = c),
        (this.smoothness = d),
        (this.zigzag = h),
        (this.rotation = u),
        (this.vertical = f),
        (this.horizontal = p),
        (this.sides = v),
        (this.isMask = m),
        (this.alpha = g),
        (this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`);
    }
    generate(t, e) {
      if (t.isShader("fragment")) {
        t.require("position"),
          t.require("uv"),
          (t.requires.uv = [!0]),
          t.require("normal"),
          (t.requires.normal = !0),
          t.addFragmentVariable(this.calpha, "float");
        let i;
        switch (this.style.value) {
          case 0:
            i = "circle";
            break;
          case 1:
            i = "ring";
            break;
          case 2:
            i = "polygon";
            break;
          case 3:
            i = "xcross";
            break;
          case 4:
            i = "diamond";
            break;
          case 5:
            i = "checkerboard";
            break;
          case 6:
            i = "line";
            break;
          case 7:
            i = "wave";
            break;
          default:
            i = "circle";
            break;
        }
        let n = `g${this.uuid.toString().replace(/-/g, "")}`,
          r = new Re(`float hashwithoutsine12(vec2 p)
				{
					vec3 p3 = fract(vec3(p.xyx) * .1031);
					p3 += dot(p3, p3.yzx + 33.33);
					return fract((p3.x + p3.y) * p3.z);
				}`),
          s = new Re(`vec2 rotate_uv(in vec2 uv, float a, bool repeat) 
				{
					const float mid = 0.5;
					float radians = a * (PI / 180.0);
					vec2 rotated = vec2(
						cos(radians) * (uv.x - mid) + sin(radians) * (uv.y - mid) + mid,
						cos(radians) * (uv.y - mid) - sin(radians) * (uv.x - mid) + mid
					);
					return repeat ? fract(rotated): rotated;
				}`),
          a = "";
        if (this.projection.value === 4) {
          let d =
              this.style.value === 2
                ? `${i}(uv0, frequency, size, variation, smoothness_remapped, zigzag, rotation, sides)`
                : `${i}(uv0, frequency, size, variation, smoothness_remapped, zigzag, rotation)`,
            h =
              this.style.value === 2
                ? `${i}(uv1, frequency, size, variation, smoothness_remapped, zigzag, rotation, sides)`
                : `${i}(uv1, frequency, size, variation, smoothness_remapped, zigzag, rotation)`,
            u =
              this.style.value === 2
                ? `${i}(uv2, frequency, size, variation, smoothness_remapped, zigzag, rotation, sides)`
                : `${i}(uv2, frequency, size, variation, smoothness_remapped, zigzag, rotation)`;
          a = `
				vec3 p = position;
				float factor = 0.0125;
				vec2 uv0 = fract(p.xy * factor);
				vec2 uv1 = fract(p.zy * factor);
				vec2 uv2 = fract(p.xz * factor);
				
				uv0 = rotate_uv(uv0 + offset, rotation, true);
				uv1 = rotate_uv(uv1 + offset, rotation, true);
				uv2 = rotate_uv(uv2 + offset, rotation, true);
	
				float d0 = ${d};
				float d1 = ${h};
				float d2 = ${u};
				
				// Range from 3 to 128 seems to be good
				float exponent = (1.0 - blending) * 125.0 + 3.0;

				vec3 n = vObjectNormal;
				vec3 weights = abs(normalize(n));
				weights = pow(weights, vec3(exponent));
				weights /= dot(weights, vec3(1.0));
				d0 *= weights.z;
				d1 *= weights.x;
				d2 *= weights.y;
				float draw = d0 + d1 + d2;
	
				vec2 custom_uv = uv0 * weights.z + uv1 * weights.x + uv2 * weights.y;
				`;
        } else {
          let d =
              this.style.value === 2
                ? `${i}(custom_uv, frequency, size, variation, smoothness_remapped, zigzag, rotation, sides)`
                : `${i}(custom_uv, frequency, size, variation, smoothness_remapped, zigzag, rotation)`,
            h = "";
          this.axis.value === 0
            ? (h = `float radius = length(p);
					float theta = atan(p.y, p.z);
					float phi = acos(p.x / radius);`)
            : this.axis.value === 1
            ? (h = `float radius = length(p);
					float theta = atan(p.x, p.z);
					float phi = acos(p.y / radius);`)
            : (this.axis.value,
              (h = `float radius = length(p);
					float theta = atan(p.y, p.x);
					float phi = acos(p.z / radius);`));
          let u = "";
          switch (this.projection.value) {
            case 0:
              u = "custom_uv = vUv.st;";
              break;
            case 1:
              break;
            case 2:
              u = `
							vec3 p = position;
							${h}
							custom_uv = vec2(theta, phi);
							custom_uv /= PI;
							`;
              break;
          }
          a = `
				vec2 custom_uv;
				${u}
	
				custom_uv += offset;
				custom_uv = fract(custom_uv);
				custom_uv = rotate_uv(custom_uv, rotation, true);
	
				float draw = ${d};
				`;
        }
        let o = new Re(
            `vec3 ${n}_pattern(vec3 normal, float blending, int style, vec2 offset, vec4 colorA, vec4 colorB, vec2 frequency, float size, float variation, float smoothness, float zigzag, float rotation, vec2 vertical, vec2 horizontal, int sides, bool isMask, float mask, float alpha, out float calpha) {
					const float TWO_PI = PI * 2.0;
					float smoothness_remapped = pow(smoothness, 5.0);	

					${a}

					// Construct final output color
					vec4 color = mix(colorA, colorB, draw);
					color.a = clamp(color.a, 0.0, 1.0);

					// Apply cuts
					color.a *= 
						step(vertical.x, custom_uv.y) * 
						step(custom_uv.y, vertical.y);
					color.a *= 
						step(horizontal.x, abs(custom_uv.x)) * 
						step(abs(custom_uv.x), horizontal.y);

					// Accumulate alpha 
					float lalpha = alpha * clamp(color.a, 0.0, 1.0) * mask;
					calpha = mix(lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0), lalpha, float(isMask));
					accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));

					return clamp(color, 0.0, 1.0).rgb;
				}`,
            [
              s,
              r,
              Tr.DrawFunctions.circle,
              Tr.DrawFunctions.ring,
              Tr.DrawFunctions.polygon,
              Tr.DrawFunctions.cross,
              Tr.DrawFunctions.diamond,
              Tr.DrawFunctions.checkerboard,
              Tr.DrawFunctions.line,
              Tr.DrawFunctions.wave,
            ]
          ),
          l = t.include(o),
          c = [];
        return (
          c.push("normal"),
          c.push(this.blending.build(t, "f")),
          c.push(this.style.build(t, "i")),
          c.push(this.offset.build(t, "v2")),
          c.push(this.colorA.build(t, "v4")),
          c.push(this.colorB.build(t, "v4")),
          c.push(this.frequency.build(t, "v2")),
          c.push(this.size.build(t, "f")),
          c.push(this.variation.build(t, "f")),
          c.push(this.smoothness.build(t, "f")),
          c.push(this.zigzag.build(t, "f")),
          c.push(this.rotation.build(t, "f")),
          c.push(this.vertical.build(t, "v2")),
          c.push(this.horizontal.build(t, "v2")),
          c.push(this.sides.build(t, "i")),
          c.push(this.isMask.build(t, "b")),
          c.push(
            this.mask ? `luminance(${this.mask.flow(t, "v3").result})` : "1.0"
          ),
          c.push(this.alpha.build(t, "f")),
          c.push(this.calpha),
          t.format(l + "(" + c.join(",") + ")", this.getType(t), e)
        );
      } else
        return (
          console.warn(
            "PatterNode is not compatible with " + t.shader + " shader."
          ),
          t.format("vec3(0.0)", this.getType(t), e)
        );
    }
  },
  _1 = Tr;
_1.DrawFunctions = (function () {
  let t = new Re(`float hashwithoutsine12(vec2 p) {
				vec3 p3 = fract(vec3(p.xyx) * 0.1031);
				p3 += dot(p3, p3.yzx + 33.33);
				return fract((p3.x + p3.y) * p3.z);
			}`),
    e = new Re(
      `vec2 tile_and_center(in vec2 uv, in vec2 frequency, in float variation, in float zigzag, in float rotation) {
                // Create tiles in UV-space
                uv *= frequency;

                // Integer coords
                vec2 i = floor(uv);

                // Offset every other row based on zigzag param, then compute fractional coords
                float row_offset = mod(i.y, 2.0);
                uv.x += row_offset * zigzag;
                vec2 f = fract(uv);

				// Rotate the tile itself:
				// const float mid = 0.5;
				// f = vec2(
				// 	cos(rotation) * (f.x - mid) + sin(rotation) * (f.y - mid) + mid,
				// 	cos(rotation) * (f.y - mid) - sin(rotation) * (f.x - mid) + mid
				// );
				// f = fract(f);

                f = f * 2.0 - 1.0;

				// Recompute integer coords after shifting - then, random value per tile 
				i = floor(uv);
				float rand = (hashwithoutsine12(i) * 5.0 + 1.0);
				float jitter = mix(1.0, rand, variation);
				f *= jitter;

                return f;
            }`,
      [t]
    ),
    i = new Re(
      `float circle(in vec2 uv, in vec2 frequency, in float size, in float variation, in float smoothness, in float zigzag, in float rotation) {
                vec2 f = tile_and_center(uv, frequency, variation, zigzag, rotation);
                return smoothstep(
                    -smoothness, 
                     smoothness, 
                     length(f) - size
                );
            }`,
      [e]
    ),
    n = new Re(
      `float ring(in vec2 uv, in vec2 frequency, in float size, in float variation, in float smoothness, in float zigzag, in float rotation) {
                vec2 f = tile_and_center(uv, frequency, variation, zigzag, rotation);

				float d = length(f);
                const float inner_width = 0.5;

                float outer = smoothstep(-smoothness, smoothness, d - size);
                float inner = smoothstep(-smoothness, smoothness, d - size * inner_width);
				return outer + (1.0 - inner);   
            }`,
      [e]
    ),
    r = new Re(
      `float sdf_ngon(in vec2 p, in float r, in int n) {
                float an = (PI * 2.0) / float(n);
                float he = r * tan(0.5 * an);
                
                // Rotate to first sector
                p = -p.yx; 
                float bn = an * floor((atan(p.y, p.x) + 0.5 * an) / an);
                vec2  cs = vec2(cos(bn), sin(bn));
                p = mat2(cs.x, -cs.y, cs.y, cs.x)*p;
            
                // Side of polygon
                return length(p - vec2(r, clamp(p.y, -he, he))) * sign(p.x - r);
            }
            
            float polygon(in vec2 uv, in vec2 frequency, in float size, in float variation, in float smoothness, in float zigzag, in float rotation, in int sides) {
                vec2 f = tile_and_center(uv, frequency, variation, zigzag, rotation);
                return smoothstep(-smoothness, smoothness, sdf_ngon(f, size, sides));
            }`,
      [e]
    ),
    s = new Re(
      `float sdf_cross(in vec2 p, in vec2 b, float r ) {
                p = abs(p); 
				p = (p.y > p.x) ? p.yx : p.xy;
                vec2  q = p - b;
                float k = max(q.y, q.x);
                vec2  w = (k > 0.0) ? q : vec2(b.y - p.x, -k);
                return sign(k) * length(max(w, 0.0)) + r;
            }
            
            // Avoid namespace conflicts 
            float xcross(in vec2 uv, in vec2 frequency, in float size, in float variation, in float smoothness, in float zigzag, in float rotation) {
                vec2 f = tile_and_center(uv, frequency, variation, zigzag, rotation);
                return smoothstep(-smoothness, smoothness, sdf_cross(f, vec2(size, size * 0.25), smoothness));
            }`,
      [e]
    ),
    a = new Re(
      `float ndot(vec2 a, vec2 b) { 
                return a.x*b.x - a.y*b.y; 
            }
            
            float sdf_diamond(in vec2 p, in vec2 b) {
                p = abs(p);
                float h = clamp(ndot(b - 2.0 * p, b) / dot(b, b), -1.0, 1.0);
                float d = length(p - 0.5 * b * vec2(1.0 - h, 1.0 + h));
                return d * sign(p.x * b.y + p.y * b.x - b.x * b.y);
            }

            float diamond(in vec2 uv, in vec2 frequency, in float size, in float variation, in float smoothness, in float zigzag, in float rotation) {
                vec2 f = tile_and_center(uv, frequency, variation, zigzag, rotation);
	            return smoothstep(-smoothness, smoothness, sdf_diamond(f, vec2(size)));
            }`,
      [e]
    ),
    o =
      new Re(`float checkerboard(in vec2 uv, in vec2 frequency, in float size, in float variation, in float smoothness, in float zigzag, in float rotation) {
                uv *= frequency;
                vec2 i = floor(uv);

                float offset = mod(i.y, 2.0);

                uv.x += offset + zigzag * offset;
                float x = floor(uv.x);
                
                return mod(x, 2.0);
            }`),
    l = new Re(
      `float line(in vec2 uv, in vec2 frequency, in float size, in float variation, in float smoothness, in float zigzag, in float rotation) {
                vec2 f = tile_and_center(uv, frequency, 0.0, zigzag, rotation);
				
				// Different approach for variation param here
				float row = floor(uv * frequency).y;
				float rand = hashwithoutsine12(vec2(row));
				float s = mix(size, size * rand, variation);

				return smoothstep(
					s - smoothness, 
					s + smoothness, 
					abs(f.y)
				);
            }`,
      [e]
    ),
    c = new Re(`// Uses bisection 
            float udf_cos(in vec2 p, in float a, in float b, in float c, in float d) {
                // Convert all data to a primitive cosine wave
                p = c * (p - vec2(d, a));
                
                const float TWO_PI = PI * 2.0;

                // Reduce to principal half cycle
                p.x = mod(p.x, TWO_PI); 
                if (p.x > PI) {
                    p.x = TWO_PI - p.x;
                }
            
                // Find zero of derivative (minimize distance)
                float xa = 0.0;
                float xb = TWO_PI;

                // 24 bit precision
                for (int i = 0; i < 24; i++) {
                    float x = 0.5 * (xa + xb);
                    float y = x - p.x + b * c * sin(x) * (p.y - b * c * cos(x));
                    if (y < 0.0) xa = x; 
                    else xb = x;
                }
                float x = 0.5 * (xa + xb);
                
                // Compute distance    
                vec2 q = vec2(x, b * c * cos(x));
                return length(p - q) / c;
            }

            float wave(in vec2 uv, in vec2 frequency, in float size, in float variation, in float smoothness, in float zigzag, in float rotation) {
                float repeat = frequency.x;
                uv *= repeat;
                vec2 i = floor(uv);
                float row_offset = mod(i.y, 2.0);
                uv.x += row_offset * zigzag;
                vec2 f = vec2(uv.x, fract(uv.y));

                // Generalized cosine: y(x) = a + b * cos(cx + d)
                const float amplitude = 0.125;
                float wave_frequency = frequency.y * 0.1;
                float distance_estimate = udf_cos(f, 0.50, amplitude, wave_frequency * (2.0 * PI), 0.0);

				// Different approach for variation param here
				float rand = hashwithoutsine12(vec2(i.y));
				float s = mix(size, size * rand, variation);

                return smoothstep(-smoothness, smoothness, distance_estimate - s * 0.5);
            }`);
  return {
    tileAndCenter: e,
    circle: i,
    ring: n,
    polygon: r,
    cross: s,
    diamond: a,
    checkerboard: o,
    line: l,
    wave: c,
  };
})();
var b1 = class extends Gt {
    constructor(t, e, i, n, r, s, a, o) {
      super("v3"),
        (this.nodeType = "Rainbow"),
        (this.filmThickness = t),
        (this.movement = e),
        (this.wavelengths = i),
        (this.noiseStrength = n),
        (this.noiseScale = r),
        (this.offset = s),
        (this.isMask = o),
        (this.alpha = a),
        (this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`);
    }
    generate(t, e) {
      if (
        (t.require("vWorldViewDir"),
        t.require("worldNormal"),
        t.isShader("fragment"))
      ) {
        t.require("uv"),
          (t.requires.uv = [!0]),
          t.addFragmentVariable(this.calpha, "float");
        let i = t.include(b1.Nodes.rainbow),
          n = [];
        return (
          n.push(this.filmThickness.build(t, "f")),
          n.push(this.movement.build(t, "f")),
          n.push(this.wavelengths.build(t, "v3")),
          n.push(this.noiseStrength.build(t, "f")),
          n.push(this.noiseScale.build(t, "f")),
          n.push(this.offset.build(t, "v3")),
          n.push(this.isMask.build(t, "b")),
          n.push(
            this.mask ? `luminance(${this.mask.flow(t, "v3").result})` : "1.0"
          ),
          n.push(this.alpha.build(t, "f")),
          n.push(this.calpha),
          t.format(i + "(" + n.join(",") + ")", this.getType(t), e)
        );
      } else
        return (
          console.warn(
            "RainbowNode is not compatible with " + t.shader + " shader."
          ),
          t.format("vec3( 0.0 )", this.getType(t), e)
        );
    }
  },
  w1 = b1;
w1.Nodes = (function () {
  let t = new Re(
    `vec3 attenuation(vec3 wavelengths, float filmThickness, float movement, float noiseStrength, float noiseScale, vec3 offset) {
                 vec3 st = position / noiseScale;
				 vec3 q = vec3(simplex3d(st),
							  simplex3d(st + vec3(1.0)),
							  simplex3d(st + vec3(1.0)));

				 vec3 r = vec3(simplex3d(st + vec3(1.4, 1.3, 1.0) * q + vec3(1.7, 9.2, 1.0)),
							  simplex3d(st + vec3(2.0, 1.2, 1.0) * q + vec3(8.3, 2.8, 1.0)),
							  simplex3d(st * q));

                 float noise = simplex3d(st + r);

                 return .5 + .5 * cos((((filmThickness + (noise * noiseStrength)) / (vec3(wavelengths.r * 1.0, wavelengths.g * 0.8, wavelengths.b * 0.6) + 1.0)) * dot(normalize(vWorldViewDir + (offset * -0.001)), normalize(vWNormal))) + movement);
             }`,
    [Ji.simplex]
  );
  return {
    rainbow: new Re(
      `vec3 rainbow(float filmThickness, float movement, vec3 wavelengths, float noiseStrength, float noiseScale, vec3 offset, bool isMask, float mask, float alpha, out float calpha) {
				vec3 res = clamp(attenuation(wavelengths, filmThickness, movement, noiseStrength, noiseScale, offset), 0.0, 2.0);

				float rainbowContribution = clamp(res.r + res.g + res.b, 0.0, 1.0);

				float lalpha = alpha * rainbowContribution * mask;
				calpha = mix(lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0), lalpha, float(isMask));
				accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));

				return res;
             }`,
      [t]
    ),
  };
})();
var S1 = class extends Gt {
    constructor(t, e, i, n, r, s, a, o, l, c) {
      super("v3"),
        (this.nodeType = "Toon"),
        (this.positioning = t),
        (this.colors = e),
        (this.steps = i),
        (this.source = n),
        (this.isWorldSpace = r),
        (this.noiseStrength = s),
        (this.noiseScale = a),
        (this.shadowColor = o),
        (this.offset = l),
        (this.alpha = c),
        (this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`);
    }
    generate(t, e) {
      if (
        (t.require("worldNormal"),
        t.require("worldPosition"),
        t.isShader("fragment"))
      ) {
        t.define("COLORS_MAX", 10), t.addFragmentVariable(this.calpha, "float");
        let i = t.include(S1.Nodes.toon),
          n = [];
        return (
          n.push(this.positioning.build(t, "i")),
          n.push(this.colors.build(t, "v4[]")),
          n.push(this.steps.build(t, "f[]")),
          n.push(this.source.build(t, "v3")),
          n.push(this.isWorldSpace.build(t, "b")),
          n.push(this.noiseStrength.build(t, "f")),
          n.push(this.noiseScale.build(t, "f")),
          n.push(this.shadowColor.build(t, "v4")),
          n.push(this.offset.build(t, "v3")),
          n.push(
            this.mask ? `luminance(${this.mask.flow(t, "v3").result})` : "1.0"
          ),
          n.push(this.alpha.build(t, "f")),
          n.push(this.calpha),
          t.format(i + "(" + n.join(",") + ")", this.getType(t), e)
        );
      } else
        return (
          console.warn(
            "ToonNode is not compatible with " + t.shader + " shader."
          ),
          t.format("vec3( 0.0 )", this.getType(t), e)
        );
    }
  },
  M1 = S1;
M1.Nodes = (function () {
  let t = new Re(`float rand(float n) {
				return fract(sin(n) * 43758.5453123);
			}`),
    e = new Re(`float hash1(float p) { 
				p = fract(p * 0.011); 
				p *= p + 7.5; 
				p *= p + p; 
				return fract(p); 
			}`),
    i = new Re(
      `float valueNoise(vec3 x) {
				const vec3 step = vec3(110, 241, 171);
			
				vec3 i = floor(x);
				vec3 f = fract(x);
			 
				// For performance, compute the base input to a 1D hash from the integer part of the argument and the 
				// incremental change to the 1D based on the 3D -> 1D wrapping
				float n = dot(i, step);
			
				vec3 u = f * f * (3.0 - 2.0 * f);
				return mix(mix(mix( hash1(n + dot(step, vec3(0, 0, 0))), hash1(n + dot(step, vec3(1, 0, 0))), u.x),
							   mix( hash1(n + dot(step, vec3(0, 1, 0))), hash1(n + dot(step, vec3(1, 1, 0))), u.x), u.y),
						   mix(mix( hash1(n + dot(step, vec3(0, 0, 1))), hash1(n + dot(step, vec3(1, 0, 1))), u.x),
							   mix( hash1(n + dot(step, vec3(0, 1, 1))), hash1(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);
			}`,
      [e]
    ),
    n = new Re(`vec3 hash3(vec3 x) {
				x = vec3(dot(x,vec3(127.1, 311.7, 74.7)),
						 dot(x,vec3(269.5, 183.3, 246.1)),
						 dot(x,vec3(113.5, 271.9, 124.6)));
			
				return fract(sin(x)*43758.5453123);
			}`),
    r = new Re(
      `vec3 voronoiNoise(in vec3 x)
			{
				vec3 p = floor(x);
				vec3 f = fract(x);

				float id = 0.0;
				vec2 res = vec2(100.0);

				for(int k=-1; k<=1; k++)
				for(int j=-1; j<=1; j++)
				for(int i=-1; i<=1; i++)
				{
					vec3 b = vec3(float(i), float(j), float(k));

					// Comment out the "+ hash(p + b);" part below to get "square" cells
					vec3 r = vec3(b) - f + hash3(p + b);
					float d = dot(r, r);

					if (d < res.x)
					{
						id = dot(p + b, vec3(1.0, 57.0, 113.0));
						res = vec2(d, res.x);			
					}
					else if (d < res.y)
					{
						res.y = d;
					}
				}

				return vec3(sqrt(res), abs(id));
			}
			`,
      [n]
    );
  return {
    toon: new Re(
      `vec3 toon(int positioning, vec4 colors[COLORS_MAX], float steps[COLORS_MAX], vec3 source, bool isWorldSpace, float noiseStrength, float noiseScale, vec4 shadowColor, vec3 offset, float mask, float alpha, out float calpha) {
				float t = 0.0;
				float shadow = 1.0;

				if (positioning == 0) {

					// Can't do this mode if lighting is "none"
					#if (defined(PHONG) || defined(LAMBERT) || defined(STANDARD))

						// Algorithm from Chapter 10 of Graphics Shaders
						const vec3 weights = vec3(0.2125, 0.7154, 0.0721);
						vec3 lpos;
						vec3 l;
						float dproduct;

						#if (NUM_POINT_LIGHTS > 0)

							#if defined(USE_SHADOWMAP) && (NUM_POINT_LIGHT_SHADOWS > 0)
								PointLightShadow pointLightShadow;
							#endif 

							#pragma unroll_loop_start
							for (int i = 0; i < NUM_POINT_LIGHTS; i++) {
								// Light positions are in view-space for some reason?
								lpos = (inverse(viewMatrix) * vec4(pointLights[UNROLLED_LOOP_INDEX].position, 1.0)).xyz;
								l = normalize(lpos - worldPosition);
								
								dproduct = dot(l, normalize(worldNormal)) * 0.5 + 0.5;
								
								// TODO: we want to use "intensity" but it isn't available in the shader code
								//dproduct += dot(pointLights[UNROLLED_LOOP_INDEX].color, weights);

								t = max(t, dproduct);

								// Accumulate shadow contribution
								#if defined(USE_SHADOWMAP) && (UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS)
									pointLightShadow = pointLightShadows[UNROLLED_LOOP_INDEX];
									shadow *= getPointShadow( 
											pointShadowMap[UNROLLED_LOOP_INDEX], 
											pointLightShadow.shadowMapSize, 
											pointLightShadow.shadowBias, 
											pointLightShadow.shadowRadius,
											vPointShadowCoord[UNROLLED_LOOP_INDEX], 
											pointLightShadow.shadowCameraNear, 
											pointLightShadow.shadowCameraFar);
								#endif
							}
							#pragma unroll_loop_end

						#endif

						#if NUM_DIR_LIGHTS > 0 
							
							#if defined(USE_SHADOWMAP) && (NUM_DIR_LIGHT_SHADOWS > 0)
								DirectionalLightShadow directionalLightShadow;
							#endif 

							#pragma unroll_loop_start
							for (int i = 0; i < NUM_DIR_LIGHTS; i++) {
								// Use the direction vector for directional lights instead
								l = (inverse(viewMatrix) * vec4(directionalLights[UNROLLED_LOOP_INDEX].direction, 0.0)).xyz;
		
								dproduct = dot(l, normalize(worldNormal)) * 0.5 + 0.5;
								t = max(t, dproduct);

								// Accumulate shadow contribution
								#if defined(USE_SHADOWMAP) && (UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS)
									directionalLightShadow = directionalLightShadows[UNROLLED_LOOP_INDEX];
									shadow *= getShadow( 
										UNROLLED_LOOP_INDEX,
										directionalShadowMap[UNROLLED_LOOP_INDEX], 
										directionalLightShadow.shadowMapSize, 
										directionalLightShadow.shadowBias, 
										directionalLightShadow.shadowRadius, 
										vDirectionalShadowCoord[UNROLLED_LOOP_INDEX]);
								#endif
							}
							#pragma unroll_loop_end

						#endif

						#if NUM_SPOT_LIGHTS > 0 
							
							#if defined(USE_SHADOWMAP) && (NUM_SPOT_LIGHT_SHADOWS > 0)
								SpotLightShadow spotLightShadow;
							#endif 

							#pragma unroll_loop_start
							for (int i = 0; i < NUM_SPOT_LIGHTS; i++) {
								lpos = (inverse(viewMatrix) * vec4(spotLights[UNROLLED_LOOP_INDEX].position, 1.0)).xyz;
								l = normalize(lpos - worldPosition);
								
								dproduct = dot(l, normalize(worldNormal)) * 0.5 + 0.5;
								t = max(t, dproduct);

								// Accumulate shadow contribution
								#if defined(USE_SHADOWMAP) && (UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS)
									spotLightShadow = spotLightShadows[UNROLLED_LOOP_INDEX];
									shadow *= getShadow(
										UNROLLED_LOOP_INDEX,
										spotShadowMap[UNROLLED_LOOP_INDEX], 
										spotLightShadow.shadowMapSize, 
										spotLightShadow.shadowBias, 
										spotLightShadow.shadowRadius, 
										vSpotLightCoord[UNROLLED_LOOP_INDEX]);
								#endif
							}
							#pragma unroll_loop_end

						#endif

						t = clamp(t, 0.0, 1.0);
				
					#endif

				} else if (positioning == 1) {
					
					vec3 origin = mix(position, worldPosition, float(isWorldSpace));
					vec3 direction = normalize(source - origin);
					t = dot(direction, normalize(worldNormal)) * 0.5 + 0.5;	

				} else {

					vec3 origin = worldPosition;
					vec3 source = cameraPosition - offset;
					vec3 direction = normalize(source - origin);
					t = dot(direction, normalize(worldNormal)) * 0.5 + 0.5;	
					
				}

				if (noiseStrength > 0.0) {
					// Distort with noise
					vec3 st = position / noiseScale;
					
					// Voronoi "smooth" noise
					float noise = 1.0 - voronoiNoise(st).x;

					// Voronoi cellular noise
					//float noise = 1.0 - rand(voronoiNoise(st).z);

					// Position warp noise
					// vec3 offset = vec3(
					// 	simplex3d(st),
					// 	simplex3d(st + vec3(111.1, 143.89, 217.19)),
					// 	simplex3d(st + vec3(171.1, 247.89, 117.23))
					// );
					// st += offset;
					// float noise = valueNoise(st);

					t += noise * noiseStrength;
				}

				t = clamp(t, 0.0, 1.0);

				// Compute ramp color
				float p;
				vec4 color = colors[0];
				for (int i = 1; i < COLORS_MAX; i++) {
					p = clamp((t - steps[i-1]) / (steps[i] - steps[i-1]), 0.0, 1.0);
					color = mix(color, colors[i], smoothstep(0.0, 1.0, p));
				}

				// Incorporate custom shadow color
				if (positioning == 0) {

					vec3 blendedShadow = mix(color.rgb, shadowColor.rgb, shadowColor.a);
					color.rgb = mix(blendedShadow, color.rgb, shadow);
				
				}

				// Accumulate alpha as usual
				float lalpha = alpha * color.a * mask;
				calpha =  lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0);
				accumAlpha += (1.0 - accumAlpha) * lalpha;

				return color.xyz;

            }`,
      [Ji.simplex, t, i, r]
    ),
  };
})();
var MB = (function () {
  return {
    textureBicubic: new Re(`float w0( float a ) {
            return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
        }
    
        float w1( float a ) {
            return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
        }
    
        float w2( float a ){
            return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
        }
    
        float w3( float a ) {
            return ( 1.0 / 6.0 ) * ( a * a * a );
        }
    
        // g0 and g1 are the two amplitude functions
        float g0( float a ) {
            return w0( a ) + w1( a );
        }
    
        float g1( float a ) {
            return w2( a ) + w3( a );
        }
    
        // h0 and h1 are the two offset functions
        float h0( float a ) {
            return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
        }
    
        float h1( float a ) {
            return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
        }
    
        vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
            uv = uv * texelSize.zw + 0.5;
    
            vec2 iuv = floor( uv );
            vec2 fuv = fract( uv );
    
            float g0x = g0( fuv.x );
            float g1x = g1( fuv.x );
            float h0x = h0( fuv.x );
            float h1x = h1( fuv.x );
            float h0y = h0( fuv.y );
            float h1y = h1( fuv.y );
    
            vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
            vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
            vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
            vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
    
            return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) + 
                   g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
        }

        vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
            vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
            vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
            vec2 fLodSizeInv = 1.0 / fLodSize;
            vec2 cLodSizeInv = 1.0 / cLodSize;
            vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
            vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
            return mix( fSample, cSample, fract( lod ) );
        }`),
  };
})();
function EB(t, e) {
  return t >= e ? new J(e / t, 1) : new J(1, t / e);
}
var E1 = class extends Gt {
    constructor(t, e, i, n, r, s, a, o) {
      super("v3"),
        (this.nodeType = "Transmission"),
        (this.thickness = t),
        (this.ior = e),
        (this.roughness = i),
        (this.transmissionSamplerSize = n),
        (this.transmissionSamplerMap = r),
        (this.transmissionDepthMap = s),
        (this.aspectRatio = a),
        (this.alpha = o),
        (this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha`);
    }
    generate(t, e) {
      if (
        ((t.extensions.shaderTextureLOD = !0),
        (t.extensions.derivatives = !0),
        t.isShader("fragment"))
      ) {
        t.define("NUM_SAMPLES", 6),
          t.define("BLUR_SLOD", Math.pow(2, Tt.transmissionLod.value)),
          t.require("worldPosition"),
          (t.requires.worldNormal = !0),
          (t.requires.modelMatrix = !0),
          (t.requires.projectionMatrix = !0),
          t.addFragmentVariable(this.calpha, "float");
        let i = t.include(E1.Nodes.transmission),
          n = [];
        return (
          n.push(this.thickness.build(t, "f")),
          n.push(this.ior.build(t, "f")),
          n.push(this.roughness.build(t, "f")),
          n.push(this.transmissionSamplerSize.build(t, "v2")),
          n.push(this.transmissionSamplerMap.getTexture(t, "t")),
          n.push(this.transmissionDepthMap.getTexture(t, "t")),
          n.push(this.aspectRatio.build(t, "v2")),
          n.push("normal"),
          n.push(
            this.mask ? `luminance(${this.mask.flow(t, "v3").result})` : "1.0"
          ),
          n.push(this.alpha.build(t, "f")),
          n.push(this.calpha),
          t.format(i + "(" + n.join(",") + ")", this.getType(t), e)
        );
      } else
        return (
          console.warn(
            "TransmissionNode is not compatible with " + t.shader + " shader."
          ),
          t.format("vec3( 0.0 )", this.getType(t), e)
        );
    }
  },
  T1 = E1;
T1.Nodes = (function () {
  let t =
      new Re(`vec3 blur(sampler2D sp, vec2 U, vec2 scale, float lod, sampler2D dm, vec2 unrefractedU, vec2 aspectRatio) {
                // Slightly modified version of this:
                // https://www.shadertoy.com/view/ltScRG

				// Special case for blur == 0.0
				if (lod == 0.0) {
					#ifdef TEXTURE_LOD_EXT
					return texture2DLodEXT( sp, U, 0.0).rgb;
					#else
					return textureLod( sp, U, 0.0).rgb;
					#endif
				}
				
				vec2 texelSize = vec2(1.0) / resolution;
                vec2 halton = haltonSequence[frameIndex];
                float temporalOffset = getNoiseInterleavedGradient(gl_FragCoord.xy + halton);
                float temporalAngle  = temporalOffset * PI2;
				vec3 res = vec3(0.0);
                vec2 uv = vec2(0.0);
                vec2 offset = vec2(0.0);
                vec2 vogelSample = vec2(0.0);
                for (int i = 0; i < NUM_SAMPLES; i++) {
                    vogelSample =  vogelDiskSample(i, NUM_SAMPLES, temporalAngle) * texelSize;
                    offset = vogelSample * scale * (lod * 10.0); // TODO: used to be hardcoded to 20
                    uv = U + offset;
                    float opaqueDepth = unpackRGBAToDepth(textureLod(dm, uv, lod));
                    if (opaqueDepth != 0.0 && opaqueDepth < gl_FragCoord.z) {
                        uv = unrefractedU;
                        lod = lod > 4.0 ? lod : lod / 2.0;
                    }
                    res += textureLod(sp, uv, lod).rgb;
                }
                return res / float(NUM_SAMPLES);
            }`),
    e =
      new Re(`vec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {
		        // Direction of refracted light.
		        vec3 refractionVector = refract( -v,  n, 1.0 / ior );
		        
				// Compute rotation-independant scaling of the model matrix.
		        vec3 modelScale;
		        modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		        modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		        modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );

		        // The thickness is specified in local space
		        return normalize( refractionVector ) * thickness * modelScale;
	        }`),
    i = new Re(`float applyIorToRoughness( float roughness, float ior ) {
				// Scale roughness with IOR so that an IOR of 1.0 results in no microfacet refraction and
				// an IOR of 1.5 results in the default amount of microfacet refraction.
				return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
			}`),
    n = new Re(
      `vec3 getTransmissionSample( vec2 fragCoord, float roughness, float ior, vec2 transmissionSamplerSize, sampler2D transmissionSamplerMap, sampler2D transmissionDepthMap, vec2 unrefractedCoords, vec2 aspectRatio) {
				// Threejs exports do not pass a depth map to this shader, so we have to fallback to the "Threejs method of blurring" - see
				// also the code in convertTransmission.ts, which runs during export
				#ifdef IS_THREEJS_EXPORT
					float lod = log2(transmissionSamplerSize.x) * applyIorToRoughness(roughness / 5.0, ior);
					return textureBicubic(transmissionSamplerMap, fragCoord.xy, lod).rgb;
				#else
					float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
					float lod = applyIorToRoughness(roughness, ior);
					return blur(transmissionSamplerMap, fragCoord, vec2(lod), min(framebufferLod / 5.5, 8.5), transmissionDepthMap, unrefractedCoords, aspectRatio);
				#endif
			}`,
      [MB.textureBicubic, i, t]
    ),
    r = new Re(
      `vec3 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness, vec2 transmissionSamplerSize, sampler2D transmissionSamplerMap, sampler2D transmissionDepthMap, vec2 aspectRatio ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;

				// Project refracted vector on the framebuffer, while mapping to normalized device coordinates.
				vec4 ndcPos = projMatrix * viewMatrix *  vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;

				vec4 ndcPosUnrefracted = projMatrix * viewMatrix * vec4(position, 1.0 );
				vec2 unrefractedCoords = ndcPosUnrefracted.xy / ndcPosUnrefracted.w;
				unrefractedCoords += 1.0;
				unrefractedCoords /= 2.0;

				// Sample framebuffer to get pixel the refracted ray hits.
				return getTransmissionSample( refractionCoords, roughness, ior, transmissionSamplerSize, transmissionSamplerMap, transmissionDepthMap, unrefractedCoords, aspectRatio );
    		}`,
      [n, e]
    );
  return {
    transmission: new Re(
      `vec3 transmission(float thickness, float ior, float roughness, vec2 transmissionSamplerSize, sampler2D transmissionSamplerMap, sampler2D transmissionDepthMap, vec2 aspectRatio, vec3 normal, float mask, float alpha, out float calpha) {
                vec3 v = vec3(0.);
                if (isOrthographic) {
                    v = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
                } else {
                    v = normalize(vWPosition - cameraPosition);
                }
                vec3 transmission = getIBLVolumeRefraction(vWNormal, -v, roughness,  vWPosition, modelMatrix, viewMatrix, projectionMatrix, ior, thickness, transmissionSamplerSize, transmissionSamplerMap, transmissionDepthMap, aspectRatio );
                
				float lalpha = alpha * mask;
				calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
				accumAlpha += ( 1.0 - accumAlpha ) * alpha;

				return transmission;
            }`,
      [r]
    ),
  };
})();
var xf = ((t) => ((t.NOISE = "noise"), (t.MAP = "map"), t))(xf || {}),
  A1 = class extends Gt {
    constructor(t, e, i, n, r, s, a, o, l, c, d) {
      super("v3"),
        (this.displacementTypeIndex = new jt(0)),
        (this.nodeType = "VertexDisplacement"),
        (this.intensity = t),
        (this.movementOrTexture = e),
        Object.values(xf)[this.displacementTypeIndex.value] === "map" &&
          (this.mat = new l1(this.movementOrTexture.value.matrix)),
        (this.cropOrOffset = i),
        (this.scale = c),
        (this.noiseFunctionIndex = d),
        (this.voronoiStyle = n),
        (this.smoothness = r),
        (this.seed = s),
        (this.highCut = a),
        (this.lowCut = o),
        (this.quality = l);
    }
    generate(t, e) {
      if (t.isShader("vertex")) {
        t.define("USE_LAYER_DISPLACE");
        let i,
          n = [];
        switch (
          (n.push("displaced_position"),
          n.push("displaced_normal"),
          Object.values(xf)[this.displacementTypeIndex.value])
        ) {
          case "map": {
            (i = t.include(A1.Nodes.map)),
              n.push(this.movementOrTexture.getTexture(t, "t")),
              n.push("uv"),
              n.push(this.cropOrOffset.build(t, "f")),
              this.mat && n.push(this.mat.build(t, "mat3"));
            break;
          }
          case "noise": {
            let r = Object.values(Gp)[this.noiseFunctionIndex.value],
              s = new Re(`vec3 orthogonal(vec3 v) {
							return normalize(abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0) : vec3(0.0, -v.z, v.y));
						}`),
              a =
                r == "voronoi"
                  ? `
					float v = ${r}((p + offset) * scale * 0.001 + neighbour_offset + (movement * 0.1), voronoiStyle, smoothness, seed, quality);
					v = remap(v, lowCut, highCut, 0.0, 1.0);
					v = smax(v, 0.0, smoothness * 0.25);
					v = smin(v, 1.0, smoothness * 0.25);

					return p + n * v * intensity;
					`
                  : `
					return p + n * ${r}((p + offset) * scale * 0.001 + neighbour_offset + (movement * 0.1)) * intensity;
					`,
              o = new Re(
                `vec3 distorted(vec3 p, vec3 n, float scale, float intensity, vec3 offset, float neighbour_offset, float movement, int voronoiStyle, float smoothness, float seed, float highCut, float lowCut, int quality) {
							${a}
						}`,
                [
                  Ji.simplex,
                  Ji.simplexFractal,
                  Ji.simplexAshima,
                  Ji.fbm,
                  Ji.perlin,
                  Ji.voronoi,
                ]
              ),
              l = new Re(
                `vec3 vertexDisplacementNoise(vec3 position, vec3 normal, float scale, vec3 offset, float movement, int voronoiStyle, float smoothness, float seed, float highCut, float lowCut, int quality, float intensity, out vec3 displaced_normal) {
							vec3 displaced_position = distorted(position, normal, scale, intensity, offset, neighbor_offset, movement, voronoiStyle, smoothness, seed, highCut, lowCut, quality);
							vec3 tangent1 = orthogonal(normal);
							vec3 tangent2 = normalize(cross(normal, tangent1));

                            // TODO(Max): The distance to the neighbors was originally scaled by 0.1.
                            // This caused some small oval/circular visual artifacts in the lighting.
                            // For now, simply using neighbors further away betters the problem,
                            // but we should figure out the underlying cause when we have some time.
                            // Maybe its related to how we calculate the tangent and bitangent?
							vec3 nearby1 = position + tangent1;
							vec3 nearby2 = position + tangent2;
							vec3 distorted1 = distorted(nearby1, normal, scale, intensity, offset, neighbor_offset, movement, voronoiStyle, smoothness, seed, highCut, lowCut, quality);
							vec3 distorted2 = distorted(nearby2, normal, scale, intensity, offset, neighbor_offset, movement, voronoiStyle, smoothness, seed, highCut, lowCut, quality);
							displaced_normal = normalize(cross(distorted1 - displaced_position, distorted2 - displaced_position));
							return displaced_position;
						}`,
                [o, s]
              );
            (i = t.include(l)),
              n.push(this.scale.build(t, "f")),
              n.push(this.cropOrOffset.build(t, "v3")),
              n.push(this.movementOrTexture.build(t, "f")),
              n.push(this.voronoiStyle.build(t, "i")),
              n.push(this.smoothness.build(t, "f")),
              n.push(this.seed.build(t, "f")),
              n.push(this.highCut.build(t, "f")),
              n.push(this.lowCut.build(t, "f")),
              n.push(this.quality.build(t, "i"));
            break;
          }
        }
        return (
          n.push(this.intensity.build(t, "f")),
          n.push("displaced_normal"),
          t.format(i + "(" + n.join(",") + ")", this.getType(t), e)
        );
      } else
        return (
          console.warn(
            "VertexDisplacementNode is not compatible with " +
              t.shader +
              " shader."
          ),
          t.format("vec3( 0.0 )", this.getType(t), e)
        );
    }
  },
  C1 = A1;
C1.Nodes = (function () {
  let t = new Re(`vec3 orthogonal(vec3 v) {
				return normalize(abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0) : vec3(0.0, -v.z, v.y));
			}`),
    e =
      new Re(`float displacementMapTexture(sampler2D tex, float crop, vec2 uv, mat3 mat, vec2 offset) {
				vec2 uvs = (mat * vec3(uv * 2.0 - 1.0, 1.0) / 2.0 + 0.5).xy + offset;
				vec4 tmp = texture2D(tex, uvs);
				vec3 col = tmp.rgb;
				if (crop > 0.5) {
					if ( uvs.x < 0.0 || uvs.x > 1.0 || uvs.y < 0.0 || uvs.y > 1.0 )  {
						return 0.0;
					}
				}
				return col.r;
			}`);
  return {
    map: new Re(
      `vec3 vertexDisplacementMap(vec3 position, vec3 normal, sampler2D tex, vec2 uv, float crop, mat3 mat, float intensity, out vec3 displaced_normal) {
				vec3 displaced_position = position + normal * displacementMapTexture(tex, crop, uv, mat, vec2(0.0)) * intensity;
				vec3 tangent1 = normalize(orthogonal(normal));
				vec3 tangent2 = normalize(cross(normal, tangent1));
				vec3 nearby1 = position + tangent1 * 0.1;
				vec3 nearby2 = position + tangent2 * 0.1;
				vec3 distorted1 = nearby1 + normal * displacementMapTexture(tex, crop, uv, mat, vec2(neighbor_offset)) * intensity;
				vec3 distorted2 = nearby2 + normal * displacementMapTexture(tex, crop, uv, mat, vec2(neighbor_offset)) * intensity;
				displaced_normal = normalize(cross(distorted1 - displaced_position, distorted2 - displaced_position));
				return displaced_position;
			}`,
      [t, e]
    ),
  };
})();
var Tt = {
  normalRenderTarget: new Rr(),
  normalRenderTargetDepth: new Rr(),
  transmissionRenderTarget: new Rr(),
  aspectRatio: new Ci(),
  transmissionSize: new Ci(2048, 2048),
  transmissionRenderTargetDepth: new Rr(),
  aoRenderTarget: new Rr(),
  aoEnabled: new Wi(),
  pixelRatioNode: new ke(1),
  resolution: new Ci(),
  penumbraSize: new Ls(5, 0.5),
  frameIndex: new jt(0),
  transmissionLod: new jt(2),
};
for (let t of Object.values(Tt)) t.isRenderGlobal = !0;
var P1 = class extends xs {
    constructor() {
      super("basic"),
        (this.nodeType = "Basic"),
        (this.color = new ai(Tn)),
        (this.shadingAlpha = new ke(1)),
        (this.shadingBlend = new jt(0)),
        (this.previousModelViewMatrix = new dr()),
        (this.previouseProjectionMatrix = new dr());
    }
    get category() {
      return "phong";
    }
    generate(t) {
      let e;
      if (t.isShader("vertex")) {
        let i = this.position
          ? this.position.analyzeAndFlow(t, "v3", { cache: "position" })
          : void 0;
        t.mergeUniform({ frameIndex: Tt.frameIndex }),
          t.mergeUniform({ resolution: Tt.resolution }),
          t.mergeUniform({
            previousModelViewMatrix: this.previousModelViewMatrix,
          }),
          t.mergeUniform({
            previousProjectionMatrix: this.previouseProjectionMatrix,
          }),
          t.mergeUniform(un.merge([Pe.fog])),
          t.addParsCode(
            [
              "varying vec3 vViewPosition;",
              "varying vec3 vWPosition;",
              "#include <fog_pars_vertex>",
              "#include <normal_pars_vertex>",
            ].join(`
`)
          );
        let n = [
          "#include <beginnormal_vertex>",
          `
				#if !defined( USE_LAYER_DISPLACE )
					#include <defaultnormal_vertex>
				#endif

				vec3 displaced_position = position;
				vec3 displaced_normal = normal;

				#if defined( USE_LAYER_DISPLACE )
					vec3 transformed;
					vec3 transformedNormal;
				#endif
				`,
          "#include <normal_vertex>",
          `
				#if !defined( USE_LAYER_DISPLACE )
					#include <begin_vertex>
				#endif /* !USE_LAYER_DISPLACE */
				`,
        ];
        i &&
          n.push(
            i.code,
            i.result ? "displaced_position = " + i.result + ";" : ""
          ),
          n.push(
            "transformed = displaced_position;",
            "transformedNormal = normalMatrix * displaced_normal;",
            "#ifndef FLAT_SHADED",
            "	vNormal = transformedNormal;",
            "#endif"
          ),
          n.push(
            "#include <project_vertex>",
            "#include <fog_vertex>",
            "#include <clipping_planes_vertex>",
            "	vViewPosition = - mvPosition.xyz;",
            "#include <worldpos_vertex>"
          ),
          n.push(
            "vWPosition = ( modelMatrix * vec4( transformed, 1.0 ) ).xyz;"
          ),
          (e = n.join(`
`));
      } else {
        this.color === void 0 && (this.color = new ai(Tn)),
          this.color.analyze(t, { slot: "color" }),
          this.alpha && this.alpha.analyze(t),
          this.afterColor && this.afterColor.analyze(t, { slot: "afterColor" });
        let i = this.color.flow(t, "c", { slot: "color" }),
          n = this.alpha ? this.alpha.flow(t, "f") : void 0,
          r = this.alphaOverride ? this.alphaOverride.flow(t, "f") : void 0,
          s = this.afterColor
            ? this.afterColor.flow(t, "c", { slot: "afterColor" })
            : void 0;
        (t.requires.transparent = n !== void 0),
          t.addParsCode(
            [
              "varying vec3 vWPosition;",
              "#include <fog_pars_fragment>",
              "#include <dithering_pars_fragment>",
              "varying vec3 vViewPosition;",
              "#include <normal_pars_fragment>",
            ].join(`
`)
          );
        let a = ["#include <normal_fragment_begin>", i.code];
        n &&
          a.push(
            n.code,
            "#ifdef ALPHATEST",
            " if ( " + n.result + " <= ALPHATEST ) discard;",
            "#endif"
          ),
          s
            ? a.push(
                s.code,
                `vec3 outgoingLight = ${i.result};`,
                `vec3 finalColor = spe_blend(outgoingLight, ${s.result}, 1.0, SPE_BLENDING_NORMAL);`
              )
            : a.push(`vec3 finalColor = ${i.result};`);
        let o = "1.0";
        this.mask &&
          (this.mask.analyze(t),
          (o = `luminance(${this.mask.flow(t, "v3").result})`)),
          n
            ? a.push(
                `gl_FragColor = vec4( finalColor, accumAlpha * ${n.result} * ${o} );`
              )
            : a.push("gl_FragColor = vec4(" + i.result + ", 1.0 );"),
          r && a.push(`gl_FragColor.a *= ${r.result};`),
          a.push("#include <fog_fragment>", "#include <dithering_fragment>"),
          (e = a.join(`
`));
      }
      return e;
    }
  },
  TB = class extends xs {
    constructor() {
      super("lambert"),
        (this.nodeType = "Lambert"),
        (this.color = new ai(Tn)),
        (this.emissive = new ai(0)),
        (this.emissiveIntensity = new ke(1)),
        (this.previousModelViewMatrix = new dr()),
        (this.previouseProjectionMatrix = new dr()),
        (this.shadingAlpha = new ke(1)),
        (this.shadingBlend = new jt(0)),
        (this.occlusion = new Wi(!0));
    }
    get category() {
      return "lambert";
    }
    build(t) {
      let e;
      if (
        (t.define("LAMBERT"),
        (t.requires.lights = !0),
        (t.extensions.derivatives = !0),
        t.isShader("vertex"))
      ) {
        let i = this.position
          ? this.position.analyzeAndFlow(t, "v3", { cache: "position" })
          : void 0;
        t.mergeUniform({ frameIndex: Tt.frameIndex }),
          t.mergeUniform({ resolution: Tt.resolution }),
          t.mergeUniform({
            previousModelViewMatrix: this.previousModelViewMatrix,
          }),
          t.mergeUniform({
            previousProjectionMatrix: this.previouseProjectionMatrix,
          }),
          t.mergeUniform(un.merge([Pe.fog, Pe.lights])),
          t.addParsCode(
            [
              "varying vec3 vViewPosition;",
              "varying vec3 vWPosition;",
              "varying vec3 vLightFront;",
              "varying vec3 vIndirectFront;",
              "#ifndef DOUBLE_SIDED",
              "   #define DOUBLE_SIDED",
              "#endif",
              "#ifdef DOUBLE_SIDED",
              "	varying vec3 vLightBack;",
              "	varying vec3 vIndirectBack;",
              "#endif",
              "#include <bsdfs>",
              "#include <lights_pars_begin>",
              "#include <color_pars_vertex>",
              "#include <fog_pars_vertex>",
              "#include <normal_pars_vertex>",
              "#include <shadowmap_pars_vertex>",
              "#include <clipping_planes_pars_vertex>",
            ].join(`
`)
          );
        let n = [
          "#include <beginnormal_vertex>",
          `
				#ifndef USE_LAYER_DISPLACE
					#include <defaultnormal_vertex>
				#endif

				vec3 displaced_position = position;
				vec3 displaced_normal = normal;

				#ifdef USE_LAYER_DISPLACE
					vec3 transformed;
					vec3 transformedNormal;
				#endif
				`,
          "#include <normal_vertex>",
          `
				#ifndef USE_LAYER_DISPLACE
					#include <begin_vertex>
				#endif
				`,
        ];
        i &&
          n.push(
            i.code,
            i.result ? "displaced_position = " + i.result + ";" : ""
          ),
          n.push(
            "transformed = displaced_position;",
            "transformedNormal = normalMatrix * displaced_normal;",
            "#ifndef FLAT_SHADED",
            "    vNormal = transformedNormal;",
            "#endif"
          ),
          n.push(
            "	#include <project_vertex>",
            "	#include <clipping_planes_vertex>",
            "	vViewPosition = - mvPosition.xyz;",
            "	#include <worldpos_vertex>",
            `
					vec3 diffuse = vec3( 1.0 );
					GeometricContext geometry;
					geometry.position = mvPosition.xyz;
					geometry.normal = normalize( transformedNormal );
					geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );
				`
          ),
          n.push(
            `
					GeometricContext backGeometry;
					backGeometry.position = geometry.position;
					backGeometry.normal = -geometry.normal;
					backGeometry.viewDir = geometry.viewDir;
					vLightFront = vec3( 0.0 );
					vIndirectFront = vec3( 0.0 );
					#ifdef DOUBLE_SIDED
						vLightBack = vec3( 0.0 );
						vIndirectBack = vec3( 0.0 );
					#endif
					IncidentLight directLight;
					float dotNL;
					vec3 directLightColor_Diffuse;
					vIndirectFront += getAmbientLightIrradiance( ambientLightColor );
					vIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );
					#ifdef DOUBLE_SIDED
						vIndirectBack += getAmbientLightIrradiance( ambientLightColor );
						vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );
					#endif
					#if NUM_POINT_LIGHTS > 0
						#pragma unroll_loop_start
						for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
							getPointLightInfo( pointLights[ i ], geometry, directLight );
							dotNL = dot( geometry.normal, directLight.direction );
							directLightColor_Diffuse = directLight.color;
							vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
							#ifdef DOUBLE_SIDED
								vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
							#endif
						}
						#pragma unroll_loop_end
					#endif
					#if NUM_SPOT_LIGHTS > 0
						#pragma unroll_loop_start
						for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
							getSpotLightInfo( spotLights[ i ], geometry, directLight );
							dotNL = dot( geometry.normal, directLight.direction );
							directLightColor_Diffuse = directLight.color;
							vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
							#ifdef DOUBLE_SIDED
								vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
							#endif
						}
						#pragma unroll_loop_end
					#endif
					#if NUM_DIR_LIGHTS > 0
						#pragma unroll_loop_start
						for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
							getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );
							dotNL = dot( geometry.normal, directLight.direction );
							directLightColor_Diffuse = directLight.color;
							vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
							#ifdef DOUBLE_SIDED
								vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
							#endif
						}
						#pragma unroll_loop_end
					#endif
					#if NUM_HEMI_LIGHTS > 0
						#pragma unroll_loop_start
						for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
							vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
							#ifdef DOUBLE_SIDED
								vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );
							#endif
						}
						#pragma unroll_loop_end
					#endif
				`,
            "	#include <shadowmap_vertex>",
            "	#include <fog_vertex>"
          ),
          n.push(
            "vWPosition = ( modelMatrix * vec4( transformed, 1.0 ) ).xyz;"
          ),
          (e = n.join(`
`));
      } else {
        t.mergeUniform({ penumbraSize: Tt.penumbraSize }),
          t.mergeUniform({ frameIndex: Tt.frameIndex }),
          t.mergeUniform({ aoMap: Tt.aoRenderTarget }),
          t.mergeUniform({ aoEnabled: Tt.aoEnabled }),
          this.color === void 0 && (this.color = new ai(Tn)),
          this.color.analyze(t, { slot: "color" }),
          this.shadingAlpha.analyze(t),
          this.shadingBlend.analyze(t),
          this.afterColor && this.afterColor.analyze(t, { slot: "afterColor" }),
          this.alpha && this.alpha.analyze(t);
        let i = this.color.flow(t, "c", { slot: "color" }),
          n = this.emissive.flow(t, "c", { slot: "emissive" }),
          r = this.emissiveIntensity.flow(t, "f", { slot: "emissive" }),
          s = this.occlusion.flow(t, "b", { slot: "occlusion" }),
          a = this.shadingAlpha.flow(t, "f"),
          o = this.shadingBlend.flow(t, "i"),
          l = this.afterColor
            ? this.afterColor.flow(t, "c", { slot: "afterColor" })
            : void 0,
          c = this.alpha ? this.alpha.flow(t, "f") : void 0,
          d = this.alphaOverride ? this.alphaOverride.flow(t, "f") : void 0;
        (t.requires.transparent = c !== void 0),
          t.addParsCode(
            [
              "uniform float penumbraSize[5];",
              "uniform sampler2D aoMap;",
              "uniform bool aoEnabled;",
              "varying vec3 vViewPosition;",
              "varying vec3 vWPosition;",
              "varying vec3 vLightFront;",
              "varying vec3 vIndirectFront;",
              "#ifndef DOUBLE_SIDED",
              "   #define DOUBLE_SIDED",
              "#endif",
              "#include <normal_pars_fragment>",
              "#ifdef DOUBLE_SIDED",
              "	varying vec3 vLightBack;",
              "	varying vec3 vIndirectBack;",
              "#endif",
              "#include <bsdfs>",
              "#include <lights_pars_begin>",
              "#include <fog_pars_fragment>",
              "#include <shadowmap_pars_fragment>",
              "#include <shadowmask_pars_fragment>",
              "#include <clipping_planes_pars_fragment>",
              "#include <dithering_pars_fragment>",
            ].join(`
`)
          );
        let h = [
          "#include <normal_fragment_begin>",
          `
				// NOTE: gl_FrontFacing alternative using face normal estimation.
				vec3 viewdx = dFdx(vViewPosition);
				vec3 viewdy = dFdy(vViewPosition);
				vec3 faceNormal = normalize(cross(viewdx, viewdy));
				bool isFrontFacing = (dot(normal, faceNormal) >= 0.0);
				`,
          "#include <clipping_planes_fragment>",
        ];
        h.push(
          i.code,
          "vec3 diffuseColor = " + i.result + ";",
          "ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );"
        ),
          c &&
            h.push(
              c.code,
              "#ifdef ALPHATEST",
              "if ( " + c.result + " <= ALPHATEST ) discard;",
              "#endif"
            ),
          h.push(
            "#ifdef DOUBLE_SIDED",
            "	reflectedLight.indirectDiffuse += ( isFrontFacing ) ? vIndirectFront : vIndirectBack;",
            "#else",
            "	reflectedLight.indirectDiffuse += vIndirectFront;",
            "#endif",
            "#include <lightmap_fragment>",
            "reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );",
            "#ifdef DOUBLE_SIDED",
            "	reflectedLight.directDiffuse = ( isFrontFacing ) ? vLightFront : vLightBack;",
            "#else",
            "	reflectedLight.directDiffuse = vLightFront;",
            "#endif",
            "reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();"
          ),
          n &&
            h.push(
              n.code,
              "reflectedLight.directDiffuse += " +
                n.result +
                " * " +
                r.result +
                ";"
            ),
          h.push(
            "vec3 ao = aoEnabled && " +
              s.result +
              " ? tex2D(aoMap, gl_FragCoord.xy / resolution).rgb : vec3(1.0);",
            "vec3 outgoingLight = (reflectedLight.directDiffuse + reflectedLight.indirectDiffuse) ;"
          );
        let u = "1.0";
        this.mask &&
          (this.mask.analyze(t),
          (u = `luminance(${this.mask.flow(t, "v3").result})`)),
          h.push(`
				if (outgoingLight != diffuseColor) {
					float lightAccu = clamp( length( reflectedLight.directSpecular + reflectedLight.indirectSpecular ), 0.0, 1.0 );
					accumAlpha += ( 1.0 - accumAlpha ) * ${a.result} * ${u} * lightAccu;
					outgoingLight = spe_blend( diffuseColor, outgoingLight, ${a.result} * ${u}, ${o.result} );

					outgoingLight *= ao;
				}
				`),
          l &&
            h.push(
              l.code,
              `outgoingLight = spe_blend(outgoingLight, ${l.result}, 1.0, SPE_BLENDING_NORMAL);`
            ),
          c
            ? h.push(
                `gl_FragColor = vec4( outgoingLight, accumAlpha * ${c.result} );`
              )
            : h.push("gl_FragColor = vec4( outgoingLight, 1.0 );"),
          d && h.push(`gl_FragColor.a *= ${d.result};`),
          h.push(
            "#include <encodings_fragment>",
            "#include <fog_fragment>",
            "#include <dithering_fragment>"
          ),
          (e = h.join(`
`));
      }
      return e;
    }
  },
  so = (function () {
    let t =
        new Re(`vec2 dHdxy(sampler2D bumpMap, vec2 bumpMapUv, float bumpScale) {

            // Gradient of UVs w.r.t. X coordinate (in screen-space)
            vec2 dSTdx = dFdx(bumpMapUv);

            // Gradient of UVs w.r.t. Y coordinate (in screen-space)
            vec2 dSTdy = dFdy(bumpMapUv);
            
            // Forward differencing
            float Hll = bumpScale * luminance(texture(bumpMap, bumpMapUv).rgb);
            float dBx = bumpScale * luminance(texture(bumpMap, bumpMapUv + dSTdx).rgb) - Hll;
            float dBy = bumpScale * luminance(texture(bumpMap, bumpMapUv + dSTdy).rgb) - Hll;
            
            return vec2( dBx, dBy );
        }`),
      e =
        new Re(`vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
            vec3 vSigmaX = dFdx( surf_pos.xyz );
            vec3 vSigmaY = dFdy( surf_pos.xyz );
            vec3 vN = surf_norm; // normalized
            
            vN = normalize(vN);

            vec3 R1 = cross( vSigmaY, vN );
            vec3 R2 = cross( vN, vSigmaX );

            R1 = normalize(R1);
            R2 = normalize(R2);
    
            float fDet = dot( vSigmaX, R1 ) * faceDirection;
    
            vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
            return normalize( abs( fDet ) * vN - vGrad );
        }`);
    return { dHdxy: t, perturbNormalArb: e };
  })(),
  AB = class extends xs {
    constructor() {
      super("phong"),
        (this.nodeType = "Phong"),
        (this.color = new ai(Tn)),
        (this.specular = new ai(1118481)),
        (this.shininess = new ke(30)),
        (this.previousModelViewMatrix = new dr()),
        (this.previouseProjectionMatrix = new dr()),
        (this.shadingAlpha = new ke(1)),
        (this.shadingBlend = new jt(0)),
        (this.occlusion = new Wi(!0));
    }
    get category() {
      return "phong";
    }
    build(t) {
      let e;
      if (
        (t.define("PHONG"),
        (t.requires.lights = !0),
        (t.extensions.derivatives = !0),
        t.isShader("vertex"))
      ) {
        let i = this.position
          ? this.position.analyzeAndFlow(t, "v3", { cache: "position" })
          : void 0;
        t.mergeUniform({ frameIndex: Tt.frameIndex }),
          t.mergeUniform({ resolution: Tt.resolution }),
          t.mergeUniform({
            previousModelViewMatrix: this.previousModelViewMatrix,
          }),
          t.mergeUniform({
            previousProjectionMatrix: this.previouseProjectionMatrix,
          }),
          t.mergeUniform(un.merge([Pe.fog, Pe.lights])),
          t.addParsCode(
            [
              "varying vec3 vViewPosition;",
              "varying vec3 vWPosition;",
              "#include <fog_pars_vertex>",
              "#include <skinning_pars_vertex>",
              "#include <normal_pars_vertex>",
              "#include <shadowmap_pars_vertex>",
              "#include <clipping_planes_pars_vertex>",
            ].join(`
`)
          );
        let n = [
          "#include <beginnormal_vertex>",
          `
				#include <skinbase_vertex>
				#include <skinnormal_vertex>
				#ifndef USE_LAYER_DISPLACE
					#include <defaultnormal_vertex>
				#endif


				vec3 displaced_position = position;
				vec3 displaced_normal = objectNormal;

				#ifdef USE_LAYER_DISPLACE
					vec3 transformed;
					vec3 transformedNormal;
				#endif
				`,
          "#include <normal_vertex>",
          `
				#ifndef USE_LAYER_DISPLACE
					#include <begin_vertex>
				#endif
				`,
        ];
        i &&
          n.push(
            i.code,
            i.result ? "displaced_position = " + i.result + ";" : ""
          ),
          n.push(
            "transformed = displaced_position;",
            "#include <skinning_vertex>",
            "transformedNormal = normalMatrix * displaced_normal;",
            "#ifndef FLAT_SHADED",
            "    vNormal = transformedNormal;",
            "#endif"
          ),
          n.push(
            "	#include <project_vertex>",
            "	#include <clipping_planes_vertex>",
            "	vViewPosition = - mvPosition.xyz;",
            "	#include <worldpos_vertex>",
            "	#include <shadowmap_vertex>",
            "	#include <fog_vertex>"
          ),
          n.push(
            "vWPosition = ( modelMatrix * vec4( transformed, 1.0 ) ).xyz;"
          ),
          (e = n.join(`
`));
      } else {
        t.mergeUniform({ penumbraSize: Tt.penumbraSize }),
          t.mergeUniform({ frameIndex: Tt.frameIndex }),
          t.mergeUniform({ aoMap: Tt.aoRenderTarget }),
          t.mergeUniform({ aoEnabled: Tt.aoEnabled }),
          this.color === void 0 && (this.color = new ai(Tn)),
          this.color.analyze(t, { slot: "color" }),
          this.specular.analyze(t),
          this.shininess.analyze(t);
        let i = this.occlusion.flow(t, "b", { slot: "occlusion" });
        this.shadingAlpha.analyze(t),
          this.shadingBlend.analyze(t),
          this.afterColor && this.afterColor.analyze(t, { slot: "afterColor" }),
          this.alpha && this.alpha.analyze(t);
        let n = this.color.flow(t, "c", { slot: "color" }),
          r = this.specular.flow(t, "c"),
          s = this.shininess.flow(t, "f"),
          a = this.shadingAlpha.flow(t, "f"),
          o = this.shadingBlend.flow(t, "i"),
          l = this.afterColor
            ? this.afterColor.flow(t, "c", { slot: "afterColor" })
            : void 0,
          c = this.alpha ? this.alpha.flow(t, "f") : void 0,
          d = this.alphaOverride ? this.alphaOverride.flow(t, "f") : void 0;
        (t.requires.transparent = c !== void 0),
          t.addParsCode(
            [
              "varying vec3 vWPosition;",
              "uniform vec3 emissive;",
              "uniform float penumbraSize[5];",
              "uniform sampler2D aoMap;",
              "uniform bool aoEnabled;",
              "#include <normal_pars_fragment>",
              "#include <fog_pars_fragment>",
              "#include <bsdfs>",
              "#include <lights_pars_begin>",
              "#include <lights_phong_pars_fragment>",
              "#include <shadowmap_pars_fragment>",
              "#include <dithering_pars_fragment>",
            ].join(`
`)
          );
        let h = [
          "#include <normal_fragment_begin>",
          `
				// NOTE: gl_FrontFacing alternative using face normal estimation.
				vec3 viewdx = dFdx(vViewPosition);
				vec3 viewdy = dFdy(vViewPosition);
				vec3 faceNormal = normalize(cross(viewdx,viewdy));
				if (dot(normal, faceNormal) < 0.0) {
					normal *= -1.0;
				}
				`,
          "	BlinnPhongMaterial material;",
        ];
        if (this.bumpMap) {
          t.include(so.dHdxy), t.include(so.perturbNormalArb);
          let f = this.bumpMap.texture.flow(t, "t"),
            p = this.bumpMap.flow(t, "v3"),
            v = this.bumpMapIntensity
              ? this.bumpMapIntensity.flow(t, "f").result
              : "1.0",
            g = "";
          this.bumpMap.projection.value === 4
            ? (g = `
					vec3 bumpNormal = vec3(0.0);
					{
						vec2 uv0 = g${this.bumpMap.uuid.toString().replace(/-/g, "")}_writeUvs0;
						vec2 uv1 = g${this.bumpMap.uuid.toString().replace(/-/g, "")}_writeUvs1;
						vec2 uv2 = g${this.bumpMap.uuid.toString().replace(/-/g, "")}_writeUvs2;
						vec3 weights = g${this.bumpMap.uuid
              .toString()
              .replace(/-/g, "")}_triplanarWeights;

						vec2 grad0 = dHdxy(${f.result}, uv0, ${v});
						vec3 n0 = perturbNormalArb(-vViewPosition, normal, grad0, faceDirection);

						vec2 grad1 = dHdxy(${f.result}, uv1, ${v});
						vec3 n1 = perturbNormalArb(-vViewPosition, normal, grad1, faceDirection);

						vec2 grad2 = dHdxy(${f.result}, uv2, ${v});
						vec3 n2 = perturbNormalArb(-vViewPosition, normal, grad2, faceDirection);
						
						bumpNormal = n0 * weights.z + n1 * weights.x + n2 * weights.y;
						bumpNormal = normalize(bumpNormal);
					}

					normal = bumpNormal;
					`)
            : (g = `
					vec2 bumpMapCachedUv = g${this.bumpMap.uuid
            .toString()
            .replace(/-/g, "")}_writeUvs;
					vec2 grad = dHdxy(${f.result}, bumpMapCachedUv, ${v});
					normal = perturbNormalArb( - vViewPosition, normal, grad, faceDirection );
					`),
            h.push(`// Call the Texture Layer's function once here so that it writes out its procedural UV coordinates
					${p.result};
					${g}
					`);
        }
        h.push(
          n.code,
          "	vec3 diffuseColor = " + n.result + ";",
          "	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );",
          "	vec3 totalEmissiveRadiance = emissive;",
          r.code,
          "	vec3 specular = " + r.result + ";",
          s.code,
          "	float shininess = max( 0.0001, " + s.result + " );",
          "	float specularStrength = 1.0;"
        ),
          c &&
            h.push(
              c.code,
              "#ifdef ALPHATEST",
              "if ( " + c.result + " <= ALPHATEST ) discard;",
              "#endif"
            ),
          h.push("material.diffuseColor = diffuseColor;"),
          h.push(
            "material.specularColor = specular;",
            "material.specularShininess = shininess;",
            "material.specularStrength = specularStrength;",
            "#include <lights_fragment_begin>",
            "#include <lights_fragment_end>"
          ),
          h.push(
            "vec3 ao = aoEnabled && " +
              i.result +
              " ? tex2D(aoMap, gl_FragCoord.xy / resolution).rgb : vec3(1.0);",
            "vec3 outgoingLight = ((reflectedLight.directDiffuse + reflectedLight.indirectDiffuse)) + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;"
          );
        let u = "1.0";
        this.mask &&
          (this.mask.analyze(t),
          (u = `luminance(${this.mask.flow(t, "v3").result})`)),
          h.push(`
				if (outgoingLight != diffuseColor) {
					float lightAccu = clamp( length( reflectedLight.directSpecular + reflectedLight.indirectSpecular ), 0.0, 1.0 );
					accumAlpha += ( 1.0 - accumAlpha ) * ${a.result} * ${u} * lightAccu;
					outgoingLight = spe_blend( diffuseColor, outgoingLight, ${a.result} * ${u}, ${o.result} );
					
					outgoingLight *= ao;
				}
				`),
          l &&
            h.push(
              l.code,
              `outgoingLight = spe_blend(outgoingLight, ${l.result}, 1.0, SPE_BLENDING_NORMAL);`
            ),
          c
            ? h.push(
                `gl_FragColor = vec4( outgoingLight, accumAlpha * ${c.result});`
              )
            : h.push("gl_FragColor = vec4( outgoingLight, 1.0 );"),
          d && h.push(`gl_FragColor.a *= ${d.result};`),
          h.push(
            "#include <encodings_fragment>",
            "#include <fog_fragment>",
            "#include <dithering_fragment>"
          ),
          (e = h.join(`
`));
      }
      return e;
    }
  },
  CB = class extends xs {
    constructor() {
      super("standard"),
        (this.nodeType = "Standard"),
        (this.color = new ai(Tn)),
        (this.roughness = new ke(0.3)),
        (this.metalness = new ke(0)),
        (this.reflectivity = new ke(0.5)),
        (this.previousModelViewMatrix = new dr()),
        (this.previouseProjectionMatrix = new dr()),
        (this.shadingAlpha = new ke(1)),
        (this.shadingBlend = new jt(0)),
        (this.occlusion = new Wi(!0));
    }
    get category() {
      return "physical";
    }
    build(t) {
      let e;
      if (
        (t.define("STANDARD"),
        (t.requires.lights = !0),
        (t.extensions.derivatives = !0),
        (t.extensions.shaderTextureLOD = !0),
        t.isShader("vertex"))
      ) {
        let i = this.position
          ? this.position.analyzeAndFlow(t, "v3", { cache: "position" })
          : void 0;
        t.mergeUniform({ frameIndex: Tt.frameIndex }),
          t.mergeUniform({ resolution: Tt.resolution }),
          t.mergeUniform({
            previousModelViewMatrix: this.previousModelViewMatrix,
          }),
          t.mergeUniform({
            previousProjectionMatrix: this.previouseProjectionMatrix,
          }),
          t.mergeUniform(un.merge([Pe.fog, Pe.lights])),
          Pe.LTC_1 &&
            ((t.uniforms.ltc_1 = { value: void 0 }),
            (t.uniforms.ltc_2 = { value: void 0 })),
          t.addParsCode(
            [
              "varying vec3 vViewPosition;",
              "varying vec3 vWPosition;",
              "#include <fog_pars_vertex>",
              "#include <normal_pars_vertex>",
              "#include <shadowmap_pars_vertex>",
              "#include <clipping_planes_pars_vertex>",
            ].join(`
`)
          );
        let n = [
          "#include <beginnormal_vertex>",
          `
				#if !defined( USE_LAYER_DISPLACE )
					#include <defaultnormal_vertex>
				#endif

				vec3 displaced_position = position;
				vec3 displaced_normal = normal;

				#if defined( USE_LAYER_DISPLACE )
					vec3 transformed;
					vec3 transformedNormal;
				#endif
				`,
          "#include <normal_vertex>",
          `
				#if !defined( USE_LAYER_DISPLACE )
					#include <begin_vertex>
				#endif /* !USE_LAYER_DISPLACE */
				`,
        ];
        i &&
          n.push(
            i.code,
            i.result ? "displaced_position = " + i.result + ";" : ""
          ),
          n.push(
            "transformed = displaced_position;",
            "transformedNormal = normalMatrix * displaced_normal;",
            "#ifndef FLAT_SHADED",
            "    vNormal = transformedNormal;",
            "#endif"
          ),
          n.push(
            "#include <project_vertex>",
            "#include <fog_vertex>",
            "#include <clipping_planes_vertex>",
            "	vViewPosition = - mvPosition.xyz;",
            "#include <worldpos_vertex>",
            "#include <shadowmap_vertex>"
          ),
          n.push(
            "vWPosition = ( modelMatrix * vec4( transformed, 1.0 ) ).xyz;"
          ),
          (e = n.join(`
`));
      } else {
        t.mergeUniform({ penumbraSize: Tt.penumbraSize }),
          t.mergeUniform({ frameIndex: Tt.frameIndex }),
          t.mergeUniform({ aoMap: Tt.aoRenderTarget }),
          t.mergeUniform({ aoEnabled: Tt.aoEnabled });
        let i = { gamma: !0 };
        this.color === void 0 && (this.color = new ai(Tn)),
          this.color.analyze(t, { slot: "color", context: i }),
          this.roughness.analyze(t),
          this.metalness.analyze(t);
        let n = this.occlusion.flow(t, "b", { slot: "occlusion" });
        this.shadingAlpha.analyze(t),
          this.shadingBlend.analyze(t),
          this.afterColor && this.afterColor.analyze(t, { slot: "afterColor" }),
          this.alpha && this.alpha.analyze(t),
          this.reflectivity && this.reflectivity.analyze(t);
        let r = this.color.flow(t, "c", { slot: "color", context: i }),
          s = this.roughness.flow(t, "f"),
          a = this.metalness.flow(t, "f"),
          o = this.shadingAlpha.flow(t, "f"),
          l = this.shadingBlend.flow(t, "i"),
          c = this.afterColor
            ? this.afterColor.flow(t, "c", { slot: "afterColor" })
            : void 0,
          d = this.alpha ? this.alpha.flow(t, "f") : void 0,
          h = this.alphaOverride ? this.alphaOverride.flow(t, "f") : void 0,
          u = this.reflectivity ? this.reflectivity.flow(t, "f") : void 0;
        (t.requires.transparent = d !== void 0),
          t.addParsCode(
            [
              "varying vec3 vViewPosition;",
              "varying vec3 vWPosition;",
              "uniform float penumbraSize[5];",
              "uniform sampler2D aoMap;",
              "uniform bool aoEnabled;",
              "#include <normal_pars_fragment>",
              "#include <dithering_pars_fragment>",
              "#include <fog_pars_fragment>",
              "#include <bsdfs>",
              "#include <lights_pars_begin>",
              "#include <lights_physical_pars_fragment>",
              "#include <shadowmap_pars_fragment>",
            ].join(`
`)
          );
        let f = [
          "#include <clipping_planes_fragment>",
          "	#include <normal_fragment_begin>",
          `
				// NOTE: gl_FrontFacing alternative using face normal estimation.
				vec3 viewdx = dFdx(vViewPosition);
				vec3 viewdy = dFdy(vViewPosition);
				vec3 faceNormal = normalize(cross(viewdx,viewdy));
				if (dot(normal, faceNormal) < 0.0) {
					normal *= -1.0;
				}
				`,
          "	PhysicalMaterial material;",
          "	material.diffuseColor = vec3( 1.0 );",
        ];
        if (this.bumpMap) {
          t.include(so.dHdxy), t.include(so.perturbNormalArb);
          let v = this.bumpMap.texture.flow(t, "t"),
            g = this.bumpMap.flow(t, "v3"),
            m = this.bumpMapIntensity
              ? this.bumpMapIntensity.flow(t, "f").result
              : "1.0",
            x = "";
          this.bumpMap.projection.value === 4
            ? (x = `
					vec3 bumpNormal = vec3(0.0);
					{
						vec2 uv0 = g${this.bumpMap.uuid.toString().replace(/-/g, "")}_writeUvs0;
						vec2 uv1 = g${this.bumpMap.uuid.toString().replace(/-/g, "")}_writeUvs1;
						vec2 uv2 = g${this.bumpMap.uuid.toString().replace(/-/g, "")}_writeUvs2;
						vec3 weights = g${this.bumpMap.uuid
              .toString()
              .replace(/-/g, "")}_triplanarWeights;

						vec2 grad0 = dHdxy(${v.result}, uv0, ${m});
						vec3 n0 = perturbNormalArb(-vViewPosition, normal, grad0, faceDirection);

						vec2 grad1 = dHdxy(${v.result}, uv1, ${m});
						vec3 n1 = perturbNormalArb(-vViewPosition, normal, grad1, faceDirection);

						vec2 grad2 = dHdxy(${v.result}, uv2, ${m});
						vec3 n2 = perturbNormalArb(-vViewPosition, normal, grad2, faceDirection);
						
						bumpNormal = n0 * weights.z + n1 * weights.x + n2 * weights.y;
						bumpNormal = normalize(bumpNormal);
					}

					normal = bumpNormal;
					`)
            : (x = `
					vec2 bumpMapCachedUv = g${this.bumpMap.uuid
            .toString()
            .replace(/-/g, "")}_writeUvs;
					vec2 grad = dHdxy(${v.result}, bumpMapCachedUv, ${m});
					normal = perturbNormalArb( - vViewPosition, normal, grad, faceDirection );
					`),
            f.push(`// Call the Texture Layer's function once here so that it writes out its procedural UV coordinates
					${g.result};
					${x}
					`);
        }
        if (
          (f.push(
            r.code,
            "	vec3 diffuseColor = " + r.result + ";",
            "	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );",
            a.code,
            "	float metalnessFactor = " + a.result + ";"
          ),
          this.roughnessMap)
        ) {
          let v = this.roughnessMap.texture.flow(t, "t"),
            g = this.roughnessMap.flow(t, "v3"),
            m = "";
          this.roughnessMap.projection.value === 4
            ? (m = `
					float roughnessChange = 1.0;
					{
						vec2 uv0 = g${this.roughnessMap.uuid.toString().replace(/-/g, "")}_writeUvs0;
						vec2 uv1 = g${this.roughnessMap.uuid.toString().replace(/-/g, "")}_writeUvs1;
						vec2 uv2 = g${this.roughnessMap.uuid.toString().replace(/-/g, "")}_writeUvs2;
						vec3 weights = g${this.roughnessMap.uuid
              .toString()
              .replace(/-/g, "")}_triplanarWeights;

						float r0 = luminance(texture(${v.result}, uv0).rgb) * roughnessScale;
						float r1 = luminance(texture(${v.result}, uv1).rgb) * roughnessScale;
						float r2 = luminance(texture(${v.result}, uv2).rgb) * roughnessScale;

						roughnessChange = (r0 * weights.z + r1 * weights.x + r2 * weights.y);
					}
					float roughnessFactor = roughnessChange * ${s.result};
					`)
            : (m = `
					vec2 roughnessMapCachedUv = g${this.roughnessMap.uuid
            .toString()
            .replace(/-/g, "")}_writeUvs;

					vec4 vals = texture(${v.result},  roughnessMapCachedUv);
					float roughnessFactor = luminance(vals.rgb) * ${s.result};
					`),
            f.push(`// Call the Texture Layer's function once here so that it writes out its procedural UV coordinates
					${g.result};

					const float roughnessScale = 1.0;

					${m}
				`);
        } else f.push(s.code, "	float roughnessFactor = " + s.result + ";");
        d &&
          f.push(
            d.code,
            "#ifdef ALPHATEST",
            "	if ( " + d.result + " <= ALPHATEST ) discard;",
            "#endif"
          ),
          f.push(
            "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );",
            "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );"
          ),
          f.push(
            "material.diffuseColor = diffuseColor * ( 1.0 - metalnessFactor );",
            "material.roughness = max( roughnessFactor, 0.0525 );",
            "material.roughness += geometryRoughness;",
            "material.roughness = min( material.roughness, 1.0 );",
            "material.roughness = clamp( roughnessFactor, 0.04, 1.0 );"
          ),
          u
            ? f.push(
                u.code,
                "material.specularColor = mix( vec3( 0.16 * pow2( " +
                  u.result +
                  " ) ), diffuseColor, metalnessFactor );"
              )
            : f.push(
                "material.specularColor = mix( vec3( 0.04 ), diffuseColor, metalnessFactor );"
              ),
          f.push("#include <lights_fragment_begin>"),
          f.push("#include <lights_fragment_end>"),
          f.push(
            "vec3 ao = aoEnabled && " +
              n.result +
              " ? tex2D(aoMap, gl_FragCoord.xy / resolution).rgb : vec3(1.0);",
            "vec3 outgoingLight = ((reflectedLight.directDiffuse + reflectedLight.indirectDiffuse)) + reflectedLight.directSpecular + reflectedLight.indirectSpecular;"
          );
        let p = "1.0";
        this.mask &&
          (this.mask.analyze(t),
          (p = `luminance(${this.mask.flow(t, "v3").result})`)),
          f.push(`
				if (outgoingLight != diffuseColor) {
					float lightAccu = clamp( length( reflectedLight.directSpecular + reflectedLight.indirectSpecular ), 0.0, 1.0 );
					accumAlpha += ( 1.0 - accumAlpha ) * ${o.result} * ${p} * lightAccu;
					outgoingLight = spe_blend( diffuseColor, outgoingLight, ${o.result} * ${p}, ${l.result} );
					
					outgoingLight *= ao;
				}
				`),
          c &&
            f.push(
              c.code,
              `outgoingLight = spe_blend(outgoingLight, ${c.result}, 1.0, SPE_BLENDING_NORMAL);`
            ),
          d
            ? f.push(
                `gl_FragColor = vec4( outgoingLight, accumAlpha * ${d.result} );`
              )
            : f.push("gl_FragColor = vec4( outgoingLight, 1.0 );"),
          h && f.push(`gl_FragColor.a *= ${h.result};`),
          f.push(
            "#include <encodings_fragment>",
            "#include <fog_fragment>",
            "#include <dithering_fragment>"
          ),
          (e = f.join(`
`));
      }
      return e;
    }
  },
  PB = class extends xs {
    constructor() {
      super("toon"),
        (this.nodeType = "Toon"),
        (this.color = new ai(Tn)),
        (this.specular = new ai(1118481)),
        (this.shininess = new ke(30)),
        (this.previousModelViewMatrix = new dr()),
        (this.previouseProjectionMatrix = new dr()),
        (this.shadingAlpha = new ke(1)),
        (this.shadingBlend = new jt(0));
    }
    get category() {
      return "toon";
    }
    build(t) {
      let e;
      if (
        (t.define("TOON"),
        (t.requires.lights = !0),
        (t.extensions.derivatives = !0),
        t.isShader("vertex"))
      ) {
        let i = this.position
          ? this.position.analyzeAndFlow(t, "v3", { cache: "position" })
          : void 0;
        t.mergeUniform({ frameIndex: Tt.frameIndex }),
          t.mergeUniform({ resolution: Tt.resolution }),
          t.mergeUniform({
            previousModelViewMatrix: this.previousModelViewMatrix,
          }),
          t.mergeUniform({
            previousProjectionMatrix: this.previouseProjectionMatrix,
          }),
          t.mergeUniform(un.merge([Pe.fog, Pe.lights])),
          t.addParsCode(
            [
              "varying vec3 vViewPosition;",
              "varying vec3 vWPosition;",
              "#include <fog_pars_vertex>",
              "#include <normal_pars_vertex>",
              "#include <shadowmap_pars_vertex>",
              "#include <clipping_planes_pars_vertex>",
            ].join(`
`)
          );
        let n = [
          "#include <beginnormal_vertex>",
          `
				#ifndef USE_LAYER_DISPLACE
					#include <defaultnormal_vertex>
				#endif

				vec3 displaced_position = position;
				vec3 displaced_normal = normal;

				#ifdef USE_LAYER_DISPLACE
					vec3 transformed;
					vec3 transformedNormal;
				#endif
				`,
          "#include <normal_vertex>",
          `
				#ifndef USE_LAYER_DISPLACE
					#include <begin_vertex>
				#endif
				`,
        ];
        i &&
          n.push(
            i.code,
            i.result ? "displaced_position = " + i.result + ";" : ""
          ),
          n.push(
            "transformed = displaced_position;",
            "transformedNormal = normalMatrix * displaced_normal;",
            "#ifndef FLAT_SHADED",
            "    vNormal = transformedNormal;",
            "#endif"
          ),
          n.push(
            "	#include <project_vertex>",
            "	#include <fog_vertex>",
            "	#include <clipping_planes_vertex>",
            "	vViewPosition = - mvPosition.xyz;",
            "	#include <worldpos_vertex>",
            "	#include <shadowmap_vertex>",
            "	#include <fog_vertex>"
          ),
          n.push(
            "vWPosition = ( modelMatrix * vec4( transformed, 1.0 ) ).xyz;"
          ),
          (e = n.join(`
`));
      } else {
        t.mergeUniform({ penumbraSize: Tt.penumbraSize }),
          t.mergeUniform({ frameIndex: Tt.frameIndex }),
          t.mergeUniform({ aoMap: Tt.aoRenderTarget }),
          t.mergeUniform({ aoEnabled: Tt.aoEnabled }),
          this.color === void 0 && (this.color = new ai(Tn)),
          this.color.analyze(t, { slot: "color" }),
          this.specular.analyze(t),
          this.shininess.analyze(t),
          this.shadingAlpha.analyze(t),
          this.shadingBlend.analyze(t),
          this.afterColor && this.afterColor.analyze(t, { slot: "afterColor" }),
          this.alpha && this.alpha.analyze(t);
        let i = this.color.flow(t, "c", { slot: "color" }),
          n = this.specular.flow(t, "c"),
          r = this.shininess.flow(t, "f"),
          s = this.shadingAlpha.flow(t, "f"),
          a = this.shadingBlend.flow(t, "i"),
          o = this.afterColor
            ? this.afterColor.flow(t, "c", { slot: "afterColor" })
            : void 0,
          l = this.alpha ? this.alpha.flow(t, "f") : void 0,
          c = this.alphaOverride ? this.alphaOverride.flow(t, "f") : void 0;
        (t.requires.transparent = l !== void 0),
          t.addParsCode(
            [
              "uniform float penumbraSize[5];",
              "uniform sampler2D aoMap;",
              "uniform bool aoEnabled;",
              "varying vec3 vWPosition;",
              "#include <normal_pars_fragment>",
              "#include <gradientmap_pars_fragment>",
              "#include <fog_pars_fragment>",
              "#include <bsdfs>",
              "#include <lights_pars_begin>",
              "#include <dithering_pars_fragment>",
              `
					varying vec3 vViewPosition;
					struct ToonMaterial {
						vec3	diffuseColor;
						vec3	specularColor;
						float	specularShininess;
						float	specularStrength;
					};
					void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
						vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
			
						reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
						reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
					}
					void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
						reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
					}
					#define RE_Direct				RE_Direct_Toon
					#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
					#define Material_LightProbeLOD( material )	(0)
					`,
              "#include <shadowmap_pars_fragment>",
              "#include <bumpmap_pars_fragment>",
              "#include <normalmap_pars_fragment>",
            ].join(`
`)
          );
        let d = [
          "#include <normal_fragment_begin>",
          `
				// NOTE: gl_FrontFacing alternative using face normal estimation.
				vec3 viewdx = dFdx(vViewPosition);
				vec3 viewdy = dFdy(vViewPosition);
				vec3 faceNormal = normalize(cross(viewdx,viewdy));
				if (dot(normal, faceNormal) < 0.0) {
					normal *= -1.0;
				}
				`,
          "	ToonMaterial material;",
        ];
        if (this.bumpMap) {
          t.include(so.dHdxy), t.include(so.perturbNormalArb);
          let u = this.bumpMap.texture.flow(t, "t"),
            f = this.bumpMap.flow(t, "v3"),
            p = this.bumpMapIntensity
              ? this.bumpMapIntensity.flow(t, "f").result
              : "1.0",
            v = "";
          this.bumpMap.projection.value === 4
            ? (v = `
					vec3 bumpNormal = vec3(0.0);
					{
						vec2 uv0 = g${this.bumpMap.uuid.toString().replace(/-/g, "")}_writeUvs0;
						vec2 uv1 = g${this.bumpMap.uuid.toString().replace(/-/g, "")}_writeUvs1;
						vec2 uv2 = g${this.bumpMap.uuid.toString().replace(/-/g, "")}_writeUvs2;
						vec3 weights = g${this.bumpMap.uuid
              .toString()
              .replace(/-/g, "")}_triplanarWeights;

						vec2 grad0 = dHdxy(${u.result}, uv0, ${p});
						vec3 n0 = perturbNormalArb(-vViewPosition, normal, grad0, faceDirection);

						vec2 grad1 = dHdxy(${u.result}, uv1, ${p});
						vec3 n1 = perturbNormalArb(-vViewPosition, normal, grad1, faceDirection);

						vec2 grad2 = dHdxy(${u.result}, uv2, ${p});
						vec3 n2 = perturbNormalArb(-vViewPosition, normal, grad2, faceDirection);
						
						bumpNormal = n0 * weights.z + n1 * weights.x + n2 * weights.y;
						bumpNormal = normalize(bumpNormal);
					}

					normal = bumpNormal;
					`)
            : (v = `
					vec2 bumpMapCachedUv = g${this.bumpMap.uuid
            .toString()
            .replace(/-/g, "")}_writeUvs;
					vec2 grad = dHdxy(${u.result}, bumpMapCachedUv, ${p});
					normal = perturbNormalArb( - vViewPosition, normal, grad, faceDirection );
					`),
            d.push(`// Call the Texture Layer's function once here so that it writes out its procedural UV coordinates
					${f.result};
					${v}
					`);
        }
        d.push(
          i.code,
          "	vec3 diffuseColor = " + i.result + ";",
          "	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );",
          n.code,
          "	vec3 specular = " + n.result + ";",
          r.code,
          "	float shininess = max( 0.0001, " + r.result + " );",
          "	float specularStrength = 1.0;"
        ),
          l &&
            d.push(
              l.code,
              "#ifdef ALPHATEST",
              "if ( " + l.result + " <= ALPHATEST ) discard;",
              "#endif"
            ),
          d.push("material.diffuseColor = diffuseColor;"),
          d.push(
            "material.specularColor = specular;",
            "material.specularShininess = shininess;",
            "material.specularStrength = specularStrength;",
            "#include <lights_fragment_begin>",
            "#include <lights_fragment_end>"
          ),
          d.push(
            "vec3 ao = aoEnabled ? tex2D(aoMap, gl_FragCoord.xy / resolution).rgb : vec3(1.0);",
            "vec3 outgoingLight = ((reflectedLight.directDiffuse + reflectedLight.indirectDiffuse) * ao) + reflectedLight.directSpecular;"
          );
        let h = "1.0";
        this.mask &&
          (this.mask.analyze(t),
          (h = `luminance(${this.mask.flow(t, "v3").result})`)),
          d.push(`
				if (outgoingLight != diffuseColor) {
					float lightAccu = clamp( length( reflectedLight.directSpecular + reflectedLight.indirectSpecular ), 0.0, 1.0 );
					accumAlpha += ( 1.0 - accumAlpha ) * ${s.result} * ${h} * lightAccu;
					outgoingLight = spe_blend( diffuseColor, outgoingLight, ${s.result} * ${h}, ${a.result} );
				}
				`),
          o &&
            d.push(
              o.code,
              `outgoingLight = spe_blend(outgoingLight, ${o.result}, 1.0, SPE_BLENDING_NORMAL);`
            ),
          l
            ? d.push(
                `gl_FragColor = vec4( outgoingLight, accumAlpha * ${l.result} );`
              )
            : d.push("gl_FragColor = vec4( outgoingLight, 1.0 );"),
          c && d.push(`gl_FragColor.a *= ${c.result};`),
          d.push(
            "#include <encodings_fragment>",
            "#include <fog_fragment>",
            "#include <dithering_fragment>"
          ),
          (e = d.join(`
`));
      }
      return e;
    }
  },
  LB = class {
    constructor(t = 1e3 * 10) {
      (this.timeout = t),
        (this.cache = new Map()),
        (this.head = {
          data: null,
          time: 0,
          src: null,
          next: null,
          prev: null,
        }),
        (this.tail = {
          data: null,
          time: 1 / 0,
          src: null,
          next: null,
          prev: null,
        }),
        (this.hasClean = !1),
        (this.head.next = this.tail),
        (this.tail.prev = this.head);
    }
    log(...t) {}
    remove(t) {
      let e = this.cache.get(t);
      e &&
        (this.dispose(t, e.data),
        this.cache.delete(t),
        (e.prev.next = e.next),
        (e.next.prev = e.prev));
    }
    scheduleCleanup() {
      this.hasClean ||
        (this.log("scheduled cleanup"),
        (this.hasClean = !0),
        setTimeout(() => {
          (this.hasClean = !1), this.log("cleaning");
          let t = Date.now(),
            e = this.head.next;
          for (; e.time < t - this.timeout; )
            this.dispose(e.src, e.data),
              this.cache.delete(e.src),
              (e = e.next),
              (e.prev = this.head),
              (this.head.next = e);
          this.head.next !== this.tail
            ? this.scheduleCleanup()
            : this.log("no more cleanup");
        }, this.timeout + 1e3));
    }
    has(t) {
      var e;
      return (e = this.cache.get(t)) == null ? void 0 : e.data;
    }
    load(t) {
      let e = Date.now(),
        i = this.cache.get(t);
      return (
        i === void 0
          ? ((i = {
              data: this.create(t),
              src: t,
              time: e,
              next: null,
              prev: null,
            }),
            this.cache.set(t, i))
          : ((i.time = e), (i.prev.next = i.next), (i.next.prev = i.prev)),
        (i.prev = this.tail.prev),
        (i.next = this.tail),
        (this.tail.prev.next = i),
        (this.tail.prev = i),
        this.scheduleCleanup(),
        i.data
      );
    }
  },
  DB = class extends LB {
    create(t) {
      return URL.createObjectURL(new Blob([t]));
    }
    dispose(t, e) {
      URL.revokeObjectURL(e);
    }
  },
  ed;
function RB(t) {
  return typeof t == "string" ? t : (ed || (ed = new DB()), ed.load(t));
}
var OB = class {
    constructor(t, e) {
      (this.data = t), (this.cache = e), (this.refCount = 0);
    }
    deref() {
      this.refCount,
        (this.refCount -= 1),
        this.refCount === 0 && (this.cache.remove(this), this.dispose());
    }
    dispose() {
      this.refCount;
    }
  },
  IB = class {
    constructor() {
      this.cache = new Map();
    }
    remove(t) {
      this.cache.delete(t.data);
    }
    load(t) {
      let e = this.cache.get(t);
      return (
        e === void 0 && ((e = this.create(t)), this.cache.set(t, e)),
        (e.refCount += 1),
        e
      );
    }
  },
  L1 = class extends OB {
    constructor(t, e) {
      super(t, e.imageHolderCache),
        (this.data = t),
        (this.shared = e),
        (this.loaded = !1),
        (this.isVideo = !1),
        (this.isVideo = t.type === "video"),
        this.updateSrc(t.data);
    }
    async updateSrc(t) {
      if (typeof document > "u") return;
      this.disposeTextures(), (this.loaded = !1);
      let e = () => {
        this.loaded = !0;
        let n = [1e3, 1001, 1002];
        for (let r of n) {
          let s = this[r];
          s && ((s.image = this.img), (s.needsUpdate = !0));
        }
        this.shared.requestRender();
      };
      if (this.isVideo) {
        if (
          ((this.img = document.createElement("video")),
          (this.img.preload = "auto"),
          (this.img.playsInline = !0),
          (this.img.currentTime = 0.01),
          typeof t != "string")
        ) {
          var i = new FileReader();
          i.readAsDataURL(new Blob([t], { type: "video/mp4" }));
          let n;
          await new Promise((r) => {
            i.onloadend = (s) => {
              var a;
              (n = (a = s.target) == null ? void 0 : a.result), r(null);
            };
          }),
            (this.img.src = n);
        } else this.img.src = t;
        this.img.onloadeddata = () => {
          e();
        };
      } else
        (this.img = new Image()), (this.img.src = RB(t)), (this.img.onload = e);
    }
    getTexture(t) {
      let e = this[t];
      if (e) return e;
      {
        let i;
        return (
          this.isVideo
            ? (i = new nA(this.img, void 0, t, t))
            : (i = new Li(this.img, void 0, t, t)),
          this.loaded && (i.needsUpdate = !0),
          (this[t] = i),
          i
        );
      }
    }
    disposeTextures() {
      var t, e, i;
      (t = this[1e3]) == null || t.dispose(),
        (this[1e3] = void 0),
        (e = this[1001]) == null || e.dispose(),
        (this[1001] = void 0),
        (i = this[1002]) == null || i.dispose(),
        (this[1002] = void 0);
    }
    dispose() {
      super.dispose(), this.disposeTextures();
    }
  },
  Ns = class extends L1 {};
function qi(t, e) {
  return e.color(t);
}
function UB(t, e) {
  switch (t.type) {
    case "fresnel":
      return BB(t, e);
    case "gradient":
      return FB(t);
    case "depth":
      return kB(t);
    case "normal":
      return VB(t);
    case "noise":
      return HB(t, e);
    case "rainbow":
      return GB(t);
    case "toon":
      return jB(t, e);
    case "outline":
      return WB(t, e);
    case "transmission":
      return qB(t);
    case "color":
      return zB(t, e);
    case "pattern":
      return XB(t, e);
  }
}
function NB(t) {
  return { type: t.type };
}
function Zn(t) {
  let { alpha: e, mode: i, isMask: n } = t;
  return { ...NB(t), alpha: e, mode: i, isMask: n };
}
function zB(t, e) {
  return { ...Zn(t), color: qi(t.color, e) };
}
function BB(t, e) {
  let { bias: i, scale: n, intensity: r, factor: s, color: a, isMask: o } = t;
  return {
    ...Zn(t),
    color: qi(a, e),
    bias: i,
    scale: n,
    intensity: r,
    factor: s,
  };
}
function FB(t) {
  let {
    gradientType: e,
    smooth: i,
    colors: n,
    steps: r,
    angle: s,
    offset: a,
    morph: o,
  } = t;
  return {
    ...Zn(t),
    gradientType: e,
    smooth: i,
    colors: n.map((l) => new yt(l[0], l[1], l[2], l[3])),
    num: n.length,
    steps: r,
    offset: new J(...a),
    morph: new J(...o),
    angle: s,
  };
}
function kB(t) {
  let {
    gradientType: e,
    near: i,
    far: n,
    isVector: r,
    isWorldSpace: s,
    origin: a,
    direction: o,
    colors: l,
    steps: c,
    smooth: d,
  } = t;
  return {
    ...Zn(t),
    gradientType: e,
    near: i,
    far: n,
    isVector: r,
    isWorldSpace: s,
    origin: new A(...a),
    direction: o ? new A(...o) : new A(1, 0, 0),
    colors: l.map((h) =>
      h !== void 0 ? new yt(h[0], h[1], h[2], h[3]) : new yt(0, 0, 0, 0)
    ),
    steps: c.slice(0, l.length),
    smooth: d,
  };
}
function VB(t) {
  let { cnormal: e } = t;
  return { ...Zn(t), cnormal: new A(e[0], e[1], e[2]) };
}
function HB(t, e) {
  return {
    ...Zn(t),
    scale: t.scale,
    move: t.move,
    fA: new J(...t.fA),
    fB: new J(...t.fB),
    size: new A(...t.size),
    distortion: new J(...t.distortion),
    colorA: qi(t.colorA, e),
    colorB: qi(t.colorB, e),
    colorC: qi(t.colorC, e),
    colorD: qi(t.colorD, e),
    noiseType: t.noiseType,
    voronoiStyle: t.voronoiStyle,
    highCut: t.highCut,
    lowCut: t.lowCut,
    smoothness: t.smoothness,
    seed: t.seed,
    quality: t.quality,
  };
}
function GB(t) {
  return {
    ...Zn(t),
    filmThickness: t.filmThickness,
    movement: t.movement,
    wavelengths: new A(...t.wavelengths),
    noiseStrength: t.noiseStrength,
    noiseScale: t.noiseScale,
    offset: new A(...t.offset),
  };
}
function jB(t, e) {
  return {
    ...Zn(t),
    positioning: t.positioning,
    colors: t.colors.map((i) => new yt(i[0], i[1], i[2], i[3])),
    num: t.colors.length,
    steps: t.steps,
    source: new A(...t.source),
    isWorldSpace: t.isWorldSpace,
    noiseStrength: t.noiseStrength,
    noiseScale: t.noiseScale,
    shadowColor: qi(t.shadowColor, e),
    offset: new A(...t.offset),
  };
}
function WB(t, e) {
  return {
    ...Zn(t),
    outlineColor: qi(t.outlineColor, e),
    contourColor: qi(t.contourColor, e),
    outlineWidth: t.outlineWidth,
    contourWidth: t.contourWidth,
    outlineThreshold: t.outlineThreshold,
    contourThreshold: t.contourThreshold,
    outlineSmoothing: t.outlineSmoothing,
    contourFrequency: t.contourFrequency,
    contourDirection: new A(...t.contourDirection),
    positionalLines: t.positionalLines,
    compensation: t.compensation,
  };
}
function qB(t, e) {
  return {
    ...Zn(t),
    thickness: t.thickness,
    ior: t.ior,
    roughness: t.roughness,
  };
}
function XB(t, e) {
  return {
    ...Zn(t),
    style: t.style,
    projection: t.projection,
    axis: t.axis,
    blending: t.blending,
    offset: new J(...t.offset),
    colorA: qi(t.colorA, e),
    colorB: qi(t.colorB, e),
    frequency: new J(...t.frequency),
    size: t.size,
    variation: t.variation,
    smoothness: t.smoothness,
    zigzag: t.zigzag,
    rotation: t.rotation,
    vertical: new J(...t.vertical),
    horizontal: new J(...t.horizontal),
    sides: t.sides,
  };
}
var dh = class extends Wn {},
  D1 = {
    noise: ["noiseType"],
    texture: ["projection", "axis", "side"],
    video: ["projection", "axis", "side"],
    displace: ["noiseType"],
    light: ["roughnessMap", "bumpMap"],
    depth: ["smooth", "isWorldSpace", "gradientType", "isVector"],
    pattern: ["style", "projection", "axis"],
  },
  R1 = { depth: ["colors"] };
function $B(t, e, i) {
  var s, a;
  if (e === "isMask") return !0;
  let n = D1[t.type],
    r = R1[t.type];
  if (r !== void 0) {
    let o = t.color;
    if (r.includes(e)) {
      let l =
        (a = (s = o[e]) == null ? void 0 : s.value) == null ? void 0 : a.length;
      if (l !== void 0 && l !== i.length) return !0;
    }
  }
  return n !== void 0 ? n.includes(e) : !1;
}
function O1(t, e, i) {
  let n = i.uniforms[`f${i.id}_texture`];
  if (!n) return !1;
  let r = !1,
    s = t;
  if ("image" in s) {
    let a = s.image,
      o = e.image(a),
      l = n;
    l.image instanceof Ns || l.image.deref(), (l.image = o);
  }
  if ("video" in s) {
    let a = s.video,
      o = e.video(a),
      l = n;
    l.image instanceof Ns || l.image.deref(), (l.image = o);
  }
  if ("wrapping" in s) {
    let a = n;
    a.wrap = s.wrapping;
  }
  if ("repeat" in s || "offset" in s) {
    let a = "mat",
      o = i.uniforms[`f${i.id}_${a}`];
    "repeat" in s && (o.repeat = s.repeat),
      "offset" in s && (o.offset = s.offset),
      o.updateMatrix();
  }
  return r;
}
function YB(t, e, i, n) {
  let r = !1;
  for (let [s, a] of Object.entries(t)) {
    if (s === "bumpMap" || s === "roughnessMap") {
      r = !0;
      continue;
    }
    if (!s || a === void 0) continue;
    if (U1(s, i, n)) {
      s === "visible" && i.type === "light" && (r = !0);
      continue;
    }
    i.visible = n.visible;
    let o = i.uniforms[`f${i.id}_${s}`];
    if (o && !(o instanceof Vp))
      switch (((r = r || $B(i, s, a)), o.constructor)) {
        case ai:
          if (typeof a == "string") {
            let l = e.getColor(a);
            l && (o.value = l);
            break;
          } else {
            let l = a;
            o.value instanceof dh
              ? (o.value = new Wn(l.r, l.g, l.b, l.a))
              : o.setRGBA(l);
            break;
          }
        case Cr:
          if (typeof a == "string") {
            let l = e.getColor(a);
            l && (o.value = l);
            break;
          } else {
            let l = a;
            o.value instanceof dh
              ? (o.value = new Wn(l.r, l.g, l.b, l.a))
              : o.value.setRGBA(l.r, l.g, l.b, l.a);
            break;
          }
        case Ci: {
          let l = a;
          o.value.setX(l[0]), o.value.setY(l[1]);
          break;
        }
        case yn: {
          let l = a;
          o.value.setX(l[0]), o.value.setY(l[1]), o.value.setZ(l[2]);
          break;
        }
        case Rr: {
          O1(a, e, i);
          break;
        }
        case Ds: {
          o.value = a.map((l) => new yt(...l));
          break;
        }
        default: {
          o.value = a;
          break;
        }
      }
  }
  return r;
}
var Vs = class {
    constructor(t, e, i, n) {
      (this.id = t), (this.uuid = e), (this.data = i), (this.uniforms = {});
      for (let r in n) this.uniforms[`f${this.id}_${r}`] = n[r];
      for (let r in i) U1(r, this, i);
    }
    get type() {
      return this.data.type;
    }
    static create(t, e, i, n) {
      if (i.type === "light") return Pr.createLigherLayer(t, e, i, n);
      if (i.type === "texture" || i.type === "video") {
        let r =
            i.type === "texture"
              ? n.image(i.texture.image)
              : n.video(i.texture.video),
          s = new vf(r, i.texture.wrapping),
          a = new bB(r),
          o = new wB(i.texture.repeat, i.texture.offset),
          l = new ke(i.crop ? 1 : 0),
          c = new jt(i.projection ?? 0),
          d = new jt(["x", "y", "z"].indexOf(i.axis) ?? 0),
          h = new jt(i.side ?? 0),
          u = new Ci(i.size ? new J(i.size[0], i.size[1]) : new J(100, 100)),
          f = new ke(i.blending ?? 0),
          p = new ke(i.alpha ?? 1),
          v = new jt(i.mode ?? 0),
          g = new Wi(i.isMask ?? !1),
          m = new Hp(s, a, l, c, d, h, u, f, o, p, v, g),
          x = new Xt(m.calpha, "f");
        return new ii(
          t,
          e,
          i,
          {
            texture: s,
            textureSize: a,
            crop: l,
            projection: c,
            axis: d,
            side: h,
            size: u,
            blending: f,
            mat: o,
            alpha: p,
            mode: v,
            isMask: g,
          },
          m,
          v,
          x,
          g
        );
      } else if (i.type === "matcap") {
        let r = n.image(i.texture.image),
          s = new vf(r, i.texture.wrapping),
          a = new ke(i.alpha ?? 1),
          o = new jt(i.mode ?? 0),
          l = new Wi(i.isMask ?? !1),
          c = new g1(s, a, o, l),
          d = new Xt(c.calpha, "f");
        return new ii(
          t,
          e,
          i,
          { texture: s, alpha: a, mode: o, isMask: l },
          c,
          o,
          d,
          l
        );
      } else if (i.type === "displace")
        if (i.displacementType === "noise") {
          let r = new yn(new A(...i.offset)),
            s = new ke(i.scale ?? 10),
            a = new ke(i.intensity ?? 8),
            o = new ke(i.movement ?? 1),
            l = new jt(i.noiseType ?? 0),
            c = new jt(i.voronoiStyle ?? 0),
            d = new ke(i.smoothness ?? 0.5),
            h = new ke(i.seed ?? 0),
            u = new ke(i.highCut ?? 1),
            f = new ke(i.lowCut ?? 0),
            p = new jt(i.quality ?? 1),
            v = new C1(a, o, r, c, d, h, u, f, p, s, l);
          return new I1(
            t,
            e,
            i,
            {
              offset: r,
              scale: s,
              intensity: a,
              movement: o,
              noiseType: l,
              voronoiStyle: c,
              smoothness: d,
              seed: h,
              highCut: u,
              lowCut: f,
              quality: p,
            },
            v
          );
        } else throw new Error();
      else return JB(t, e, i, n);
    }
    updateByOp(t, e, i) {
      let n = t;
      if (n.path[0] === void 0) {
        if (n.type === 0)
          return "type" in n.props ||
            "category" in n.props ||
            "visible" in n.props
            ? (i.scene.markNeedsUpdateRendererDirty(), !0)
            : YB(n.props, i.shared, this, e);
      } else if (n.path[0] === "texture")
        return "texture" in e || "video" in e
          ? O1(n.props, i.shared, this)
          : !0;
      return !1;
    }
    dispose() {
      if (ZB(this)) {
        let t = this.uniforms[`f${this.id}_texture`];
        if (!t) return !1;
        let e = t;
        e.image instanceof Ns || e.image.deref();
      }
    }
    hasValueByKey(t) {
      return this.uniforms[t] !== void 0;
    }
    hasValue(t) {
      return this.hasValueByKey(`f${this.id}_${t}`);
    }
    setValue(t, e) {
      let i = `f${this.id}_${t}`;
      this.hasValueByKey(i) && e !== void 0 && (this.uniforms[i].value = e);
    }
    getNode(t) {
      let e = `f${this.id}_${t}`;
      if (this.hasValueByKey(e)) return this.uniforms[e];
    }
    getValue(t) {
      let e = `f${this.id}_${t}`;
      if (this.hasValueByKey(e)) return this.uniforms[e].value;
    }
    getName(t) {
      let e = /f\d+_(.*)/.exec(t);
      if (e && e.length > 1) return e[1];
      console.log(`Layer.getName: error ${t}`);
    }
    getNames() {
      let t = [];
      for (let e in this.uniforms) {
        let i = this.getName(e);
        i && t.push(i);
      }
      return t;
    }
  },
  ii = class extends Vs {
    constructor(t, e, i, n, r, s, a, o) {
      super(t, e, i, n),
        (this.params = n),
        (this.color = r),
        (this.mode = s),
        (this.alpha = a),
        (this.isMask = o);
    }
  },
  I1 = class extends Vs {
    constructor(t, e, i, n, r) {
      super(t, e, i, n), (this.position = r);
    }
  },
  Pr = class extends Vs {
    constructor(t, e, i, n, r) {
      super(t, e, i, r), (this.node = n);
    }
    static createLigherLayer(t, e, i, n) {
      let r,
        s = new ke(i.alpha),
        a = new jt(i.mode),
        o = new ke(i.bumpMapIntensity),
        l = new ke(i.alphaOverride),
        c;
      if (!i.visible) (r = new P1()), (c = {});
      else if (i.category === "lambert") {
        r = new TB();
        let d = new ai(n.color(i.emissive) ?? 0),
          h = new Wi(i.occlusion ?? !0);
        (c = { emissive: d, occlusion: h }),
          (r.emissive = d),
          (r.occlusion = h);
      } else if (i.category === "toon") {
        r = new PB();
        let d = new ke(i.shininess ?? 30),
          h = new ai(n.color(i.specular) ?? 1118481);
        (c = { shininess: d, specular: h }),
          (r.shininess = d),
          (r.specular = h);
      } else if (i.category === "physical") {
        r = new CB();
        let d = new ke(i.roughness ?? 0.3),
          h = new ke(i.metalness ?? 0),
          u = new ke(i.reflectivity ?? 0.5),
          f = new Wi(i.occlusion ?? !0);
        (c = { roughness: d, metalness: h, reflectivity: u, occlusion: f }),
          (r.roughness = d),
          (r.metalness = h),
          (r.reflectivity = u),
          (r.occlusion = f);
      } else {
        r = new AB();
        let d = new ke(i.shininess ?? 30),
          h = new ai(
            i.specular !== void 0 ? n.color(i.specular) ?? 1118481 : 1118481
          ),
          u = new Wi(i.occlusion ?? !0);
        (c = { shininess: d, specular: h, occlusion: u }),
          (r.shininess = d),
          (r.specular = h),
          (r.occlusion = u);
      }
      return (
        (r.alpha = new ke(1)),
        (r.shadingAlpha = s),
        (r.shadingBlend = a),
        (r.bumpMapIntensity = o),
        (r.alphaOverride = l),
        (c.alpha = r.shadingAlpha),
        (c.mode = r.shadingBlend),
        (c.bumpMapIntensity = r.bumpMapIntensity),
        (c.alphaOverride = r.alphaOverride),
        new Pr(t, e, i, r, c)
      );
    }
    get category() {
      return this.node.category;
    }
  };
function ZB(t) {
  let e = t instanceof Vs ? t.type : t;
  return (
    e === "texture" || e === "video" || e === "displace_map" || e === "matcap"
  );
}
function gn(t) {
  return {
    alpha: new ke(t.alpha ?? 1),
    mode: new jt(t.mode ?? 0),
    isMask: new Wi(t.isMask ?? !1),
  };
}
function KB(t, e, i, n) {
  switch (t.type) {
    case "color": {
      let r = new ai(n.color ?? Tn),
        s = gn(n),
        a = new yf(r, s.alpha),
        o = new Xt(a.calpha, "f");
      return new ii(e, i, t, { color: r, ...s }, a, s.mode, o, s.isMask);
    }
    case "fresnel": {
      let r = new ai(n.color ?? 16777215),
        s = new ke(n.bias ?? 0.1),
        a = new ke(n.scale ?? 1),
        o = new ke(n.intensity ?? 2),
        l = new ke(n.factor ?? 1),
        c = gn(n),
        d = new SB(r, s, a, o, l, c.alpha, c.mode, c.isMask),
        h = new Xt(d.calpha, "f");
      return new ii(
        e,
        i,
        t,
        { color: r, bias: s, scale: a, intensity: o, factor: l, ...c },
        d,
        c.mode,
        h,
        c.isMask
      );
    }
    case "rainbow": {
      let r = new ke(n.filmThickness ?? 30),
        s = new ke(n.movement ?? 0),
        a = new yn(n.wavelengths ?? new A(0, 0, 0)),
        o = new ke(n.noiseStrength ?? 0),
        l = new ke(n.noiseScale ?? 1),
        c = new yn(n.offset ?? new A(0, 0, 0)),
        d = gn(n),
        h = new w1(r, s, a, o, l, c, d.alpha, d.isMask),
        u = new Xt(h.calpha, "f");
      return new ii(
        e,
        i,
        t,
        {
          filmThickness: r,
          movement: s,
          wavelengths: a,
          noiseStrength: o,
          noiseScale: l,
          offset: c,
          ...d,
        },
        h,
        d.mode,
        u,
        d.isMask
      );
    }
    case "transmission": {
      let r = new ke(n.thickness ?? 10),
        s = new ke(n.ior ?? 1.5),
        a = new ke(n.roughness ?? 0.5),
        o = Tt.transmissionSize,
        l = Tt.transmissionRenderTarget,
        c = Tt.transmissionRenderTargetDepth,
        d = window.innerWidth,
        h = window.innerHeight,
        u = d >= h ? new Ci(h / d, 1) : new Ci(1, d / h),
        f = gn(n),
        p = new T1(r, s, a, o, l, c, u, f.alpha),
        v = new Xt(p.calpha, "f");
      return new ii(
        e,
        i,
        t,
        { thickness: r, ior: s, roughness: a, aspectRatio: u, ...f },
        p,
        f.mode,
        v,
        f.isMask
      );
    }
    case "toon": {
      let r = new jt(n.positioning ?? 0),
        s;
      n.colors
        ? (s = new Ds(n.colors.length, n.colors))
        : ((s = new Ds(10, new yt(0, 0, 0, 1))),
          (s.value[1] = new yt(1, 1, 1, 1)));
      let a;
      n.steps
        ? (a = new Ls(n.steps.length, n.steps))
        : ((a = new Ls(10, 1)), (a.value[0] = 0));
      let o = new yn(n.source ?? new A(0, 0, 0)),
        l = new Wi(n.isWorldSpace ?? !0),
        c = new ke(n.noiseStrength ?? 0),
        d = new ke(n.noiseScale ?? 1),
        h = new Cr(n.shadowColor),
        u = new yn(n.offset ?? new A(0, 0, 0)),
        f = gn(n),
        p = new M1(r, s, a, o, l, c, d, h, u, f.alpha),
        v = new Xt(p.calpha, "f");
      return new ii(
        e,
        i,
        t,
        {
          positioning: r,
          colors: s,
          steps: a,
          source: o,
          isWorldSpace: l,
          noiseStrength: c,
          noiseScale: d,
          shadowColor: h,
          offset: u,
          ...f,
        },
        p,
        f.mode,
        v,
        f.isMask
      );
    }
    case "outline": {
      let r = new ai(n.outlineColor ?? 16777215),
        s = new ai(n.contourColor ?? 16777215),
        a = new ke(n.outlineWidth ?? 0.1),
        o = new ke(n.contourWidth ?? 0.1),
        l = new ke(n.outlineThreshold ?? 0.1),
        c = new ke(n.contourThreshold ?? 0.1),
        d = new ke(n.outlineSmoothing ?? 0.1),
        h = new ke(n.contourFrequency ?? 0.1),
        u = new yn(n.contourDirection ?? new A(0, 1, 0)),
        f = new Wi(n.positionalLines ?? !1),
        p = new Wi(n.compensation ?? !0),
        v = Tt.normalRenderTarget,
        g = Tt.normalRenderTargetDepth,
        m = Tt.pixelRatioNode,
        x = Tt.resolution,
        y = gn(n),
        _ = new x1(r, s, a, o, l, c, d, h, u, f, p, x, v, g, m, y.alpha),
        M = new Xt(_.calpha, "f");
      return new ii(
        e,
        i,
        t,
        {
          outlineColor: r,
          contourColor: s,
          outlineWidth: a,
          contourWidth: o,
          outlineThreshold: l,
          contourThreshold: c,
          outlineSmoothing: d,
          contourFrequency: h,
          contourDirection: u,
          positionalLines: f,
          compensation: p,
          ...y,
        },
        _,
        y.mode,
        M,
        y.isMask
      );
    }
    case "depth": {
      let r = new jt(n.gradientType ?? 0),
        s = new Wi(n.smooth ?? !1),
        a = new ke(n.near ?? 50),
        o = new ke(n.far ?? 200),
        l = new ke(n.isVector ?? 1),
        c = new ke(n.isWorldSpace ?? 0),
        d = new yn(n.origin ?? new A()),
        h = new yn(n.direction ?? new A()),
        u;
      n.colors
        ? (u = new Ds(n.colors.length, n.colors))
        : ((u = new Ds(2, new yt(0, 0, 0, 1))),
          (u.value[1] = new yt(1, 1, 1, 1)));
      let f;
      n.steps
        ? (f = new Ls(n.steps.length, n.steps))
        : ((f = new Ls(2, 1)), (f.value[0] = 0));
      let p = gn(n),
        v = new d1(r, s, a, o, l, c, d, h, u, f, p.alpha, p.isMask),
        g = new Xt(v.calpha, "f");
      return new ii(
        e,
        i,
        t,
        {
          gradientType: r,
          smooth: s,
          near: a,
          far: o,
          isVector: l,
          isWorldSpace: c,
          origin: d,
          direction: h,
          colors: u,
          steps: f,
          ...p,
        },
        v,
        p.mode,
        g,
        p.isMask
      );
    }
    case "noise": {
      let r = new ke(n.scale ?? 1),
        s = new yn(n.size ?? new A(100, 100, 100)),
        a = new ke(n.move ?? 1),
        o = new Ci(n.fA ?? new J(1.7, 9.2)),
        l = new Ci(n.fB ?? new J(8.3, 2.8)),
        c = new Ci(n.distortion ?? new J(1, 1)),
        d = new Cr(n.colorA),
        h = new Cr(n.colorB),
        u = new Cr(n.colorC),
        f = new Cr(n.colorD),
        p = new jt(n.noiseType ?? 0),
        v = new jt(n.voronoiStyle ?? 0),
        g = new ke(n.highCut ?? 1),
        m = new ke(n.lowCut ?? 0),
        x = new ke(n.smoothness ?? 0.5),
        y = new ke(n.seed ?? 0.5),
        _ = new jt(n.quality ?? 1),
        M = gn(n),
        b = new v1(
          r,
          s,
          a,
          o,
          l,
          c,
          d,
          h,
          u,
          f,
          M.alpha,
          p,
          M.isMask,
          v,
          g,
          m,
          x,
          y,
          _
        ),
        E = new Xt(b.calpha, "f");
      return new ii(
        e,
        i,
        t,
        {
          scale: r,
          size: s,
          move: a,
          fA: o,
          fB: l,
          distortion: c,
          colorA: d,
          colorB: h,
          colorC: u,
          colorD: f,
          noiseType: p,
          ...M,
          voronoiStyle: v,
          highCut: g,
          lowCut: m,
          smoothness: x,
          seed: y,
          quality: _,
        },
        b,
        M.mode,
        E,
        M.isMask
      );
    }
    case "normal": {
      let r = new yn(n.cnormal ?? new A(1, 1, 1)),
        s = gn(n),
        a = new u1(r, s.alpha),
        o = new Xt(a.calpha, "f");
      return new ii(e, i, t, { cnormal: r, ...s }, a, s.mode, o, s.isMask);
    }
    case "gradient": {
      let r = new jt(n.gradientType ?? 0),
        s = new Wi(n.smooth ?? !1),
        a;
      n.colors
        ? (a = new Ds(n.colors.length, n.colors))
        : ((a = new Ds(10, new yt(0, 0, 0, 1))),
          (a.value[1] = new yt(1, 1, 1, 1)));
      let o;
      n.steps
        ? (o = new Ls(n.steps.length, n.steps))
        : ((o = new Ls(10, 1)), (o.value[0] = 0));
      let l = new Ci(n.offset ?? new J(0, 0)),
        c = new Ci(n.morph ?? new J(0, 0)),
        d = new ke(n.angle ?? 0),
        h = gn(n),
        u = new p1(r, s, a, o, l, c, d, h.alpha, h.isMask),
        f = new Xt(u.calpha, "f");
      return new ii(
        e,
        i,
        t,
        {
          gradientType: r,
          smooth: s,
          colors: a,
          steps: o,
          offset: l,
          morph: c,
          angle: d,
          ...h,
        },
        u,
        h.mode,
        f,
        h.isMask
      );
    }
    case "pattern": {
      let r = new jt(n.style ?? 0),
        s = new jt(n.projection ?? 0),
        a = new jt(["x", "y", "z"].indexOf(n.axis) ?? 0),
        o = new ke(n.blending ?? 0),
        l = new Ci(n.offset ?? new J(0, 0)),
        c = new Cr(n.colorA),
        d = new Cr(n.colorB),
        h = new Ci(n.frequency ?? new J(10, 10)),
        u = new ke(n.size ?? 0.5),
        f = new ke(n.variation ?? 0),
        p = new ke(n.smoothness ?? 0.5),
        v = new ke(n.zigzag ?? 0),
        g = new ke(n.rotation ?? 0),
        m = new Ci(n.vertical ?? new J(0, 1)),
        x = new Ci(n.horizontal ?? new J(0, 1)),
        y = new jt(n.sides ?? 6),
        _ = gn(n),
        M = new _1(
          r,
          s,
          a,
          o,
          l,
          c,
          d,
          h,
          u,
          f,
          p,
          v,
          g,
          m,
          x,
          y,
          _.alpha,
          _.isMask
        ),
        b = new Xt(M.calpha, "f");
      return new ii(
        e,
        i,
        t,
        {
          style: r,
          projection: s,
          axis: a,
          blending: o,
          offset: l,
          colorA: c,
          colorB: d,
          frequency: h,
          size: u,
          variation: f,
          smoothness: p,
          zigzag: v,
          rotation: g,
          vertical: m,
          horizontal: x,
          sides: y,
          ..._,
        },
        M,
        _.mode,
        b,
        _.isMask
      );
    }
    default: {
      let r = new ai(1, 0, 0, 1),
        s = gn(n),
        a = new yf(r, s.alpha),
        o = new Xt(a.calpha, "f");
      return new ii(e, i, t, { color: r, ...s }, a, s.mode, o, s.isMask);
    }
  }
}
function JB(t, e, i, n) {
  let r = UB(i, n);
  return KB(i, t, e, r);
}
function U1(t, e, i) {
  if (i.type === "displace" && (t === "intensity" || t === "visible")) {
    let n = e.uniforms[`f${e.id}_intensity`];
    return n ? ((n.value = i.intensity * (i.visible ? 1 : 0)), n) : void 0;
  }
  if (i.type !== "displace" && (t === "alpha" || t === "visible")) {
    let n = e.uniforms[`f${e.id}_alpha`];
    if (!n) return;
    if (
      ((n.value = i.alpha * (i.visible ? 1 : 0)),
      i.type === "outline" && t === "visible")
    ) {
      let r = e.uniforms[`f${e.id}_compensation`];
      r && (r.value = i.compensation && i.visible);
    }
    return n;
  }
}
function Lv(t, e) {
  let i = 0,
    n = t.layers.find((r) => r.data.type === "light");
  if (n && n.data.alphaOverride < 1) return !0;
  for (let r of t.layers) {
    if (r.data.type !== "displace" && r.data.isMask) return !0;
    if (
      r.data.type !== "displace" &&
      "alpha" in r.data &&
      r.data.type !== "light" &&
      r.data.type !== "fresnel" &&
      r.data.type !== "texture" &&
      r.data.type !== "matcap" &&
      r.data.type !== "rainbow" &&
      r.data.type !== "outline" &&
      r.data.type !== "pattern"
    ) {
      let s = r.data.visible ? r.data.alpha : 0;
      if ((s === 1 && r.data.type === "depth") || r.data.type === "gradient") {
        for (let a of r.data.colors)
          if (a[3] < 1) {
            s = a[3];
            break;
          }
      } else if (s === 1 && r.data.type === "noise") {
        let a = e.color(r.data.colorA).a,
          o = e.color(r.data.colorB).a,
          l = e.color(r.data.colorC).a,
          c = e.color(r.data.colorD).a,
          d = Math.min(a, Math.min(o, Math.min(l, c)));
        d < 1 && (s = d);
      }
      i += (1 - i) * s;
    }
  }
  return i < 1;
}
var ms = class extends Ti {
    constructor() {
      super(void 0),
        (this.flatShading = !1),
        (this.needsJitter = !0),
        (this.cacheKey = ""),
        (this.fog = !0),
        (this.dithering = !0),
        (this.vertexColors = !0),
        (this.transparent = !0);
    }
    customProgramCacheKey() {
      return this.cacheKey;
    }
  },
  QB = class extends ms {
    constructor(t, e, i, n) {
      super(),
        (this.flatShading = t),
        (this.side = e),
        (this.wireframe = i),
        (this.root = n);
    }
    updateAfterBuild() {
      let t = this.root;
      (this.lights = t.lights),
        (this.vertexShader = t.vertexShader),
        (this.fragmentShader = t.fragmentShader),
        (this.defines = t.defines),
        (this.uniforms = t.uniforms),
        (this.extensions = t.extensions),
        (this.transparent = t.transparent),
        (this.cacheKey =
          t.customProgramCacheKey() + "flat" + this.flatShading + this.side);
    }
    onBeforeCompile(t, e) {
      this.root.onBeforeCompile(t);
    }
    get data() {
      return this.root.data;
    }
    get category() {
      return this.root.category;
    }
    get hasAO() {
      return this.root.hasAO;
    }
    getFlavor(t, e, i) {
      return this.root.getFlavor(t, e, i);
    }
    get layers() {
      return this.root.layers;
    }
    get fragment() {
      return this.root.fragment;
    }
    getLayersOfType(t) {
      return this.root.getLayersOfType(t);
    }
    getLayerByUuid(t) {
      return this.root.getLayerByUuid(t);
    }
    updateByOp(t, e, i) {
      this.root.updateByOp(t, e, i);
    }
    nodeMaterialDispose() {
      this.root.nodeMaterialDispose();
    }
  },
  N1 = class extends ms {
    constructor(t, e) {
      super(),
        (this.data = t),
        (this.layerIdGen = 0),
        (this.flavors = []),
        (this.masks = {}),
        (this.type = "NodeMaterial"),
        (this.updaters = []),
        this.reset0(t, e);
    }
    get nodeMaterial() {
      return this;
    }
    getFlavor(t, e, i) {
      let n = i ? 6 : (t ? 3 : 0) + e;
      if (n === 0) return this;
      this.flavors === void 0 && (this.flavors = []), (n -= 1);
      let r = this.flavors[n];
      return (
        r === void 0 &&
          ((r = new QB(t, e, i, this)),
          (this.flavors[n] = r),
          (r.flatShading = t),
          (r.side = e),
          r.updateAfterBuild()),
        r
      );
    }
    get fragment() {
      return this.lightLayer.node;
    }
    get category() {
      return this.lightLayer.category;
    }
    get hasAO() {
      var t;
      return (
        ((t = this.lightLayer.getNode("occlusion")) == null
          ? void 0
          : t.value) ?? !1
      );
    }
    reset(t, e) {
      this.data !== t && this.reset0(t, e);
    }
    reset0(t, e) {
      this.data = t;
      let i = t.layers ?? fn.defaultTwoLayerData("phong").layers;
      try {
        this.layers = i.map((n) =>
          Vs.create(this.layerIdGen++, n.id, n.data, e.shared)
        );
      } catch {
        this.layers = [];
      }
      this.layers.reverse(),
        (this.name = t.name ?? "Untitled Material"),
        this.onUpdate(),
        (this.transparent = Lv(t, e.shared));
    }
    getLayersOfType(t) {
      return this.layers.filter((e) => e.type === t);
    }
    getLayerByUuid(t) {
      return this.layers.find((e) => e.uuid === t);
    }
    onUpdate() {
      (this.cacheKey = this.computeCacheKey()),
        (this.lightLayer = this.layers.find((t) => t instanceof Pr)),
        this.lightLayer === void 0 &&
          (this.lightLayer = new Pr(
            0,
            "",
            { ..._n.defaultData("light", "phong"), visible: !1 },
            new P1(),
            {}
          )),
        this.dispose();
      for (let t of this.flavors) t && t.dispose();
      this.applyTextureMaps(),
        this.applyMasks(),
        this.blendColors(),
        this.blendAfterColors(),
        this.blendPositions();
    }
    applyTextureMaps() {
      let t = this.layers.find((r) => r instanceof Pr);
      if (!t) return;
      let e = t.data,
        i = e.bumpMap,
        n = e.roughnessMap;
      (t.node.bumpMap = void 0), (t.node.roughnessMap = void 0);
      for (let r = 0; r < this.layers.length; ++r) {
        let s = this.layers[r];
        s instanceof ii &&
          s.color instanceof Hp &&
          (s.uuid === i && (t.node.bumpMap = s.color),
          s.uuid === n && (t.node.roughnessMap = s.color));
      }
    }
    updateByOp(t, e, i) {
      if (
        (e !== void 0 ? (this.data = e) : (e = this.data),
        (this.transparent = Lv(e, i.shared)),
        t.path[0] === "layers")
      ) {
        this.data = e;
        let n = i.shared,
          r = t.path[1];
        if (r === void 0) {
          if ((this.layers.reverse(), t.type === 4)) {
            let s = Vs.create(this.layerIdGen++, t.id, t.data, i.shared);
            this.layers.splice(t.localIndex, 0, s),
              i.scene.markNeedsUpdateRendererDirty();
          } else if (t.type === 5)
            this.layers.splice(t.localIndex, 1)[0].dispose(),
              i.scene.markNeedsUpdateRendererDirty();
          else if (t.type === 6) {
            let s = this.layers.findIndex((o) => o.uuid === t.id),
              a = this.layers[s];
            this.layers.splice(s, 1),
              this.layers.splice(t.localIndex, 0, a),
              i.scene.markNeedsUpdateRendererDirty();
          }
          this.layers.reverse(), this.onUpdate();
        } else {
          t.type === 0 &&
            t.props.occlusion !== void 0 &&
            i.scene.markNeedsUpdateRendererDirty();
          let s = this.layers.find((a) => a.uuid === r);
          if (s) {
            let a = e.layers.data(r);
            if (s.updateByOp({ ...t, path: t.path.slice(2) }, a, i)) {
              let o = Vs.create(this.layerIdGen++, r, a, n);
              this.layers.splice(
                this.layers.findIndex((l) => l.uuid === r),
                1,
                o
              ),
                this.onUpdate();
            }
          }
        }
      } else this.reset(e, i);
    }
    applyMasks() {
      for (let t = 0; t < this.layers.length; ++t) {
        let e = this.layers[t];
        e instanceof ii
          ? (e.color.mask = void 0)
          : e instanceof Pr && (e.node.mask = void 0);
      }
      for (let t = 0; t < this.layers.length; ++t) {
        let e = this.layers[t];
        if (e instanceof ii && e.isMask.value && e.data.visible && t > 0) {
          let i = t - 1,
            n = this.layers[i];
          n instanceof Pr
            ? (n.node.mask = new Yi(e.color, e.alpha, Yi.MUL))
            : n instanceof ii &&
              (n.isMask.value ||
                (n.color.mask = new Yi(e.color, e.alpha, Yi.MUL)));
        }
      }
    }
    blendColors() {
      let t = this.layers.findIndex((i) => i instanceof ii),
        e = this.layers.findIndex((i) => i instanceof Pr);
      if (t !== -1 && t < e) {
        let i = this.layers[t].color;
        for (let n = t + 1; n < e; ++n) {
          let r = this.layers[n];
          if (r instanceof ii) {
            if (r.isMask.value) continue;
            i = new Pv(i, r.color, r.alpha, r.mode);
          }
        }
        this.fragment.color = i;
      } else this.fragment.color = void 0;
    }
    blendAfterColors() {
      let t = new Xt("outgoingLight", "f"),
        e = this.layers.findIndex((i) => i instanceof Pr);
      if (this.layers.length > e + 1) {
        for (let i = e + 1; i < this.layers.length; ++i) {
          let n = this.layers[i];
          if (n instanceof ii) {
            if (n.isMask.value) continue;
            t = new Pv(t, n.color, n.alpha, n.mode);
          }
        }
        this.fragment.afterColor = t;
      } else this.fragment.afterColor = void 0;
    }
    blendPositions() {
      let t = this.layers.filter((e) => e instanceof I1);
      if (t.length > 0) {
        let e = t[0].position;
        for (let i = 1; i < t.length; ++i)
          t[i] &&
            ((e = new Yi(e, t[i].position, Yi.ADD)),
            (e = new Yi(e, new ke(0.5).setReadonly(!0), Yi.MUL)));
        this.fragment.position = e;
      } else this.fragment.position = void 0;
    }
    getDefines() {
      return this.defines;
    }
    getUniforms() {
      return this.uniforms;
    }
    getVertexShader() {
      return this.vertexShader;
    }
    getFragmentShader() {
      return this.fragmentShader;
    }
    onBeforeCompile(t) {
      this.build(),
        (t.defines = this.defines),
        (t.uniforms = this.uniforms),
        (t.vertexShader = this.vertexShader),
        (t.fragmentShader = this.fragmentShader),
        (t.extensionDerivatives = this.extensions.derivatives === !0),
        (t.extensionFragDepth = this.extensions.fragDepth === !0),
        (t.extensionDrawBuffers = this.extensions.drawBuffers === !0),
        (t.extensionShaderTextureLOD = this.extensions.shaderTextureLOD === !0);
    }
    clampUniformsForPreview(t, e) {
      let i = (n, r, s) => Math.min(Math.max(n, r), s);
      for (let n of this.layers)
        if (n.type === "displace") {
          let r = i(n.uniforms[`f${n.id}_intensity`].value, t, e);
          n.uniforms[`f${n.id}_intensity`].value = r;
        }
    }
    computeCacheKey() {
      let t = "[";
      for (let { data: e } of this.data.layers)
        if (e.type === "light")
          t += `"${e.visible ? e.category.toUpperCase() : "Basic"}"`;
        else {
          let i = (D1[e.type] ?? []).map((o) => e[o]),
            n = (R1[e.type] ?? []).map((o) => {
              var l;
              return ((l = e[o]) == null ? void 0 : l.length) ?? 0;
            }),
            r = [...i, ...n],
            s = "isMask" in e && e.isMask,
            a = `"${e.type}-${e.visible}-${s}"`;
          r.length ? (t += `[${a}, "${r.join('","')}"],`) : (t += a);
        }
      return (t = t.slice(0, -1) + "]"), t;
    }
    updateFrame(t) {
      for (let e = 0; e < this.updaters.length; ++e)
        t.updateNode(this.updaters[e]);
    }
    build() {
      let t = new _B();
      (t.needsJitter = this.needsJitter),
        (this.lights = this.lightLayer.data.visible),
        t.build(this.fragment, this.fragment),
        (this.vertexShader = t.getCode("vertex")),
        (this.fragmentShader = t.getCode("fragment")),
        (this.defines = t.defines),
        (this.uniforms = t.uniforms),
        (this.extensions = t.extensions),
        (this.updaters = t.updaters);
      for (let e of this.flavors) e && e.updateAfterBuild();
      return this;
    }
    nodeMaterialDispose() {
      this.layers.forEach((t) => t.dispose()), super.dispose();
      for (let t of this.flavors) t && t.dispose();
    }
    assetsLoaded() {
      for (let t of this.layers)
        if (t instanceof ii) {
          let e = t.params.texture;
          if (e instanceof vf && !e.image.loaded) return !1;
        }
      return !0;
    }
    getHash() {
      let t = "{";
      return (t += '"fragment":' + this.fragment.getHash()), (t += "}"), t;
    }
  };
Object.defineProperties(ms.prototype, {
  properties: {
    get: function () {
      return this.fragment.properties;
    },
  },
});
var _f = class extends N1 {},
  eF = wl(mC()),
  Dv = new Map();
function tF(t) {
  if (typeof t == "string") return t;
  let e = Dv.get(t);
  return (
    e || ((e = { url: URL.createObjectURL(new Blob([t])) }), Dv.set(t, e)),
    e.url
  );
}
var xc = class {
    constructor({ src: t, volume: e, delay: i, loop: n }) {
      (this._volume = 1),
        (this.delay = 0),
        (this._loop = 1),
        (this.loopsRemaining = 0),
        (this._status = "stopped"),
        (this.onEnd = () => {
          this.loopsRemaining === 1 / 0
            ? this.replay()
            : this.loopsRemaining > 1
            ? (this.replay(), this.loopsRemaining--)
            : ((this._status = "stopped"), (this.loopsRemaining = this._loop));
        });
      let r;
      typeof t == "string"
        ? (r = { src: t })
        : (r = { src: tF(t), format: "wav" }),
        (this.sound = new eF.Howl(r)),
        this.sound.on("end", this.onEnd),
        (this.src = t),
        e !== void 0 && (this.volume = e),
        i !== void 0 && (this.delay = i),
        n !== void 0 && (this.loop = n);
    }
    get status() {
      return this._status;
    }
    get volume() {
      return this._volume;
    }
    set volume(t) {
      (this._volume = t), this.sound.volume(t);
    }
    get loop() {
      return this._loop;
    }
    set loop(t) {
      (this._loop = t), (this.loopsRemaining = t);
    }
    replay() {
      this.clearDelay(),
        (this.delayTimerId = window.setTimeout(() => {
          this.sound.play(), this.clearDelay();
        }, this.delay));
    }
    fade(t, e = 1e3) {
      t
        ? (this.sound.volume(this._volume),
          this.clearFade(),
          (this.fadeTimerId = window.setTimeout(() => {
            this.sound.fade(this._volume, 0, e), this.clearFade();
          }, t)))
        : this.sound.fade(this._volume, 0, e);
    }
    on(t, e, i) {
      this.sound.on(t, e, i);
    }
    off(t, e, i) {
      this.sound.off(t, e, i);
    }
    play() {
      this._status === "playing" ||
        this.sound.playing() ||
        (this._status === "paused"
          ? (this.sound.seek() === 0 ? this.replay() : this.sound.play(),
            (this._status = "playing"))
          : this._status === "stopped" &&
            (this.replay(), (this._status = "playing")));
    }
    pause() {
      this._status === "playing" &&
        (this.sound.pause(),
        this.clearFade(),
        this.clearDelay(),
        (this._status = "paused"));
    }
    stop() {
      this.sound.stop(),
        (this.loopsRemaining = this._loop),
        this.clearFade(),
        this.clearDelay(),
        (this._status = "stopped");
    }
    clearFade() {
      this.fadeTimerId &&
        (clearTimeout(this.fadeTimerId), delete this.fadeTimerId);
    }
    clearDelay() {
      this.delayTimerId &&
        (clearTimeout(this.delayTimerId), delete this.delayTimerId);
    }
    dispose(t = !1) {
      this.off(), this.stop(), this.clearFade(), this.clearDelay();
    }
  },
  iF = class {
    constructor() {
      (this.type = "ShapePath"),
        (this.color = new tt()),
        (this.subPaths = []),
        (this.currentPath = null);
    }
    moveTo(t, e) {
      return (
        (this.currentPath = new Vc()),
        this.subPaths.push(this.currentPath),
        this.currentPath.moveTo(t, e),
        this
      );
    }
    lineTo(t, e) {
      var i;
      return (i = this.currentPath) == null || i.lineTo(t, e), this;
    }
    quadraticCurveTo(t, e, i, n) {
      var r;
      return (
        (r = this.currentPath) == null || r.quadraticCurveTo(t, e, i, n), this
      );
    }
    bezierCurveTo(t, e, i, n, r, s) {
      var a;
      return (
        (a = this.currentPath) == null || a.bezierCurveTo(t, e, i, n, r, s),
        this
      );
    }
    splineThru(t) {
      var e;
      return (e = this.currentPath) == null || e.splineThru(t), this;
    }
    toShapes() {
      let t = {
          ORIGIN: 0,
          DESTINATION: 1,
          BETWEEN: 2,
          LEFT: 3,
          RIGHT: 4,
          BEHIND: 5,
          BEYOND: 6,
        },
        e = { loc: t.ORIGIN, t: 0 };
      function i(f, p, v, g) {
        let m = f.x,
          x = p.x,
          y = v.x,
          _ = g.x,
          M = f.y,
          b = p.y,
          E = v.y,
          T = g.y,
          S = (_ - y) * (M - E) - (T - E) * (m - y),
          w = (x - m) * (M - E) - (b - M) * (m - y),
          C = (T - E) * (x - m) - (_ - y) * (b - M),
          L = S / C,
          P = w / C;
        if ((C === 0 && S !== 0) || L <= 0 || L >= 1 || P < 0 || P > 1)
          return null;
        if (S === 0 && C === 0) {
          for (let R = 0; R < 2; R++)
            if ((n(R === 0 ? v : g, f, p), e.loc === t.ORIGIN)) {
              let I = R === 0 ? v : g;
              return { x: I.x, y: I.y, t: e.t };
            } else if (e.loc === t.BETWEEN) {
              let I = +(m + e.t * (x - m)).toPrecision(10),
                W = +(M + e.t * (b - M)).toPrecision(10);
              return { x: I, y: W, t: e.t };
            }
          return null;
        } else {
          for (let W = 0; W < 2; W++)
            if ((n(W === 0 ? v : g, f, p), e.loc === t.ORIGIN)) {
              let N = W === 0 ? v : g;
              return { x: N.x, y: N.y, t: e.t };
            }
          let R = +(m + L * (x - m)).toPrecision(10),
            I = +(M + L * (b - M)).toPrecision(10);
          return { x: R, y: I, t: L };
        }
      }
      function n(f, p, v) {
        let g = v.x - p.x,
          m = v.y - p.y,
          x = f.x - p.x,
          y = f.y - p.y,
          _ = g * y - x * m;
        if (f.x === p.x && f.y === p.y) {
          (e.loc = t.ORIGIN), (e.t = 0);
          return;
        }
        if (f.x === v.x && f.y === v.y) {
          (e.loc = t.DESTINATION), (e.t = 1);
          return;
        }
        if (_ < -Number.EPSILON) {
          e.loc = t.LEFT;
          return;
        }
        if (_ > Number.EPSILON) {
          e.loc = t.RIGHT;
          return;
        }
        if (g * x < 0 || m * y < 0) {
          e.loc = t.BEHIND;
          return;
        }
        if (Math.sqrt(g * g + m * m) < Math.sqrt(x * x + y * y)) {
          e.loc = t.BEYOND;
          return;
        }
        let M;
        g !== 0 ? (M = x / g) : (M = y / m), (e.loc = t.BETWEEN), (e.t = M);
      }
      function r(f, p) {
        let v = [],
          g = [];
        for (let m = 1; m < f.length; m++) {
          let x = f[m - 1],
            y = f[m];
          for (let _ = 1; _ < p.length; _++) {
            let M = p[_ - 1],
              b = p[_],
              E = i(x, y, M, b);
            E !== null &&
              v.find(
                (T) =>
                  T.t <= E.t + Number.EPSILON && T.t >= E.t - Number.EPSILON
              ) === void 0 &&
              (v.push(E), g.push(new J(E.x, E.y)));
          }
        }
        return g;
      }
      function s(f, p, v) {
        let g = new J();
        p.getCenter(g);
        let m = [];
        return (
          v.forEach((x) => {
            x.boundingBox.containsPoint(g) &&
              r(f, x.points).forEach((y) => {
                m.push({ identifier: x.identifier, isCW: x.isCW, point: y });
              });
          }),
          m.sort((x, y) => x.point.x - y.point.x),
          m
        );
      }
      function a(f, p, v, g, m) {
        (m == null || m === "") && (m = "nonzero");
        let x = new J();
        f.boundingBox.getCenter(x);
        let y = [new J(v, x.y), new J(g, x.y)],
          _ = s(y, f.boundingBox, p);
        _.sort((w, C) => w.point.x - C.point.x);
        let M = [],
          b = [];
        _.forEach((w) => {
          w.identifier === f.identifier ? M.push(w) : b.push(w);
        });
        let E = M[0].point.x,
          T = [],
          S = 0;
        for (; S < b.length && b[S].point.x < E; )
          T.length > 0 && T[T.length - 1] === b[S].identifier
            ? T.pop()
            : T.push(b[S].identifier),
            S++;
        if ((T.push(f.identifier), m === "evenodd")) {
          let w = T.length % 2 === 0,
            C = T[T.length - 2];
          return { identifier: f.identifier, isHole: w, for: C };
        } else if (m === "nonzero") {
          let w = !0,
            C = null,
            L = null;
          for (let P = 0; P < T.length; P++) {
            let R = T[P];
            p[R] &&
              (w
                ? ((L = p[R].isCW), (w = !1), (C = R))
                : L !== p[R].isCW && ((L = p[R].isCW), (w = !0)));
          }
          return { identifier: f.identifier, isHole: w, for: C };
        } else
          console.warn('fill-rule: "' + m + '" is currently not implemented.');
      }
      let o = 0,
        l = 999999999,
        c = -999999999,
        d = [];
      this.subPaths.forEach((f) => {
        let p = f.getPoints(),
          v = -999999999,
          g = 999999999,
          m = -999999999,
          x = 999999999;
        for (let y = 0; y < p.length; y++) {
          let _ = p[y];
          _.y > v && (v = _.y),
            _.y < g && (g = _.y),
            _.x > m && (m = _.x),
            _.x < x && (x = _.x);
        }
        c <= m && (c = m + 1),
          l >= x && (l = x - 1),
          p.length &&
            d.push({
              curves: f.curves,
              points: p,
              isCW: Jf.isClockWise(p),
              identifier: o++,
              boundingBox: new GA(new J(x, g), new J(m, v)),
            });
      });
      let h = d.map((f) => {
          var p;
          return a(
            f,
            d,
            l,
            c,
            (p = this.userData) == null ? void 0 : p.style.fillRule
          );
        }),
        u = [];
      return (
        d.forEach((f) => {
          let p = h[f.identifier];
          if (p && !p.isHole) {
            let v = new Hc();
            (v.curves = f.curves),
              h
                .filter(
                  (g) =>
                    (g == null ? void 0 : g.isHole) && g.for === f.identifier
                )
                .forEach((g) => {
                  if (g) {
                    let m = d[g.identifier],
                      x = new Vc();
                    (x.curves = m.curves), v.holes.push(x);
                  }
                }),
              u.push(v);
          }
        }),
        u
      );
    }
  },
  z1,
  Rv = new Promise((t) => {
    z1 = t;
  }),
  Ov = !1,
  _c;
function nF() {
  if (Ov) return;
  if (_c) return _c;
  async function t() {
    let e = await Tf(
      () => import("../chunks/opentype.d77fd7e6.js"),
      [],
      import.meta.url
    );
    z1(e), (Ov = !0);
  }
  return (_c = t()), _c;
}
var rF = class {
  async load(t, e, i = () => {}) {
    let { load: n } = await Rv;
    n(t, (r, s) => {
      r || !s ? i(r ?? "Something went wrong") : e(s);
    });
  }
  async parse(t) {
    let { parse: e, Bidi: i } = await Rv;
    try {
      let n = e(t),
        r = new i(),
        s = (a) => n.charToGlyphIndex(a.char);
      return (
        r.registerModifier("glyphIndex", null, s),
        r.applyFeatures(n, n.defaultRenderOptions.features),
        { font: n, bidi: r }
      );
    } catch (n) {
      console.error(n);
    }
  }
};
async function sF(t) {
  return await (await fetch(t)).arrayBuffer();
}
var aF = new rF();
async function Iv(t) {
  let e,
    i,
    n = !1;
  if (
    (t.url
      ? ((e = await sF(t.url)), (i = t.url), (n = t.url.startsWith("/")))
      : t.data && (e = t.data.buffer),
    e)
  ) {
    let r = await aF.parse(e);
    if (r)
      return { font: r.font, url: i, intercepted: n, arr: e, bidi: r.bidi };
  }
}
function oF(t, e) {
  return (
    e.state.glyphIndex === t ||
    e.state.fina === t ||
    e.state.medi === t ||
    e.state.init === t
  );
}
var lF = class {
  constructor(t) {
    (this._arrayBuffer = new ArrayBuffer(1)),
      (this._isLoaded = !1),
      (this._intercepted = !1),
      (this._isUserFont = t.isUserFont ?? !1),
      (this._loadingPromise = Iv(t).then((e) => {
        e &&
          ((this._arrayBuffer = e.arr),
          (this._url = e.url),
          (this.font = e.font),
          (this._intercepted = e.intercepted),
          (this._isLoaded = !0),
          (this._bidi = e.bidi));
      }));
  }
  update(t) {
    (this._isLoaded = !1),
      (this._isUserFont = t.isUserFont ?? !1),
      (this._loadingPromise = Iv(t).then((e) => {
        e &&
          ((this._arrayBuffer = e.arr),
          (this._url = e.url),
          (this.font = e.font),
          (this._intercepted = e.intercepted),
          (this._isLoaded = !0),
          (this._bidi = e.bidi));
      }));
  }
  get url() {
    return this._url;
  }
  get intercepted() {
    return this._intercepted;
  }
  get isLoaded() {
    return this._isLoaded;
  }
  get loadingPromise() {
    return this._loadingPromise;
  }
  reverseLigaturesTable(t, e, i) {
    if (!this._bidi) return [];
    let n = this._bidi;
    n.getTextGlyphs(e);
    let r = n.tokenizer.tokens,
      s = [],
      a = 0,
      o = i.length === r.length;
    for (let l = 0; l < i.length; l++) {
      let c = i[l].index,
        d = String.fromCharCode(i[l].unicode),
        h = r[a];
      if (oF(c, h) || o)
        s.push({
          char: d,
          index: c,
          replacements: [h.state.glyphIndex],
          replacementChars: [h.char],
        }),
          a++;
      else {
        let u = h.char,
          f = "",
          p = [h.state.glyphIndex],
          v = [],
          g = !1;
        for (; !g; )
          a++,
            (f = e.charAt(a)),
            (u += f),
            p.push(t.charToGlyphIndex(f)),
            (v = t.stringToGlyphs(u)),
            v.length === 1 && v[0].index === c && (g = !0),
            a > e.length && (g = !0);
        s.push({
          char: d,
          index: c,
          replacements: p,
          replacementChars: Array.from(u),
        }),
          a++;
      }
    }
    return s;
  }
  generateShapes(t, e) {
    if (!this._isLoaded) return;
    let i = this.font,
      n = e.fontSize / this.unitsPerEm,
      r = e.fontSize * e.lineHeight,
      s = t.map((m) => this.getTextWidth(m, e)),
      a = e.width,
      o = this.getCharWidth(
        `
`,
        e
      ),
      l = e.horizontalAlign === 1 ? o : 0,
      c = this.computeSpaceWidthForLine(t, 0, e),
      d = this.getLineInitialOffsetX(s[0], a, e.horizontalAlign, t[0], o),
      h = this.getLineInitialOffsetY(r, t.length, e.height, n, e.verticalAlign),
      u = [],
      f = t.map((m) => []),
      p = t.map((m) => []),
      v;
    for (let m = 0; m < t.length; m++) {
      let x = t[m],
        y = { features: { liga: !0 } },
        _ = [];
      try {
        _ = i.stringToGlyphs(x, y);
      } catch (b) {
        console.warn(b);
      }
      d = this.getLineInitialOffsetX(s[m], a, e.horizontalAlign, x, o);
      let M = [];
      try {
        M = this.reverseLigaturesTable(i, x, _);
      } catch (b) {
        console.warn(b);
      }
      c = this.computeSpaceWidthForLine(t, m, e);
      for (let b = 0; b < _.length; b++) {
        let E = _[b],
          T =
            E.index === 0
              ? `
`
              : E.unicode
              ? String.fromCharCode(E.unicode)
              : void 0,
          S = M[b],
          w = 0,
          C = 0;
        b === 0 &&
          e.horizontalAlign === 2 &&
          E.leftSideBearing !== void 0 &&
          (C = -E.leftSideBearing * n),
          v && (w = i.getKerningValue(E, v) * n),
          (d += C + w);
        let L = 0;
        if (
          T ===
          `
`
        )
          L = l;
        else if (T === " ") L = c;
        else {
          let P = this.createPath(E, n, d, h, e);
          P && ((L = P.offsetX - (w + C)), u.push(P.path));
        }
        if (S.replacements.length === 1) p[m].push([d, h]), f[m].push(L);
        else {
          let P = S.replacements.map(
              (N) => (i.glyphs.get(N).advanceWidth ?? 0) * n
            ),
            R = P.reduce((N, U) => (N += U), 0),
            I = P.map((N) => N / R),
            W = d;
          for (let N = 0; N < I.length; N++) {
            let U = L * I[N];
            p[m].push([W, h]), f[m].push(U), (W += U);
          }
        }
        (d += L), (v = E);
      }
      h -= r;
    }
    let g = [];
    for (let m = 0, x = u.length; m < x; m++) g.push(...u[m].toShapes());
    return { shapes: g, charWidths: f, lineWidths: s, charCoords: p };
  }
  get isUserFont() {
    return this._isUserFont;
  }
  get arrayBuffer() {
    return this._arrayBuffer;
  }
  get ascender() {
    var t;
    return ((t = this.font) == null ? void 0 : t.ascender) ?? 0;
  }
  get descender() {
    var t;
    return ((t = this.font) == null ? void 0 : t.descender) ?? 0;
  }
  get familyName() {
    var t;
    return ((t = this.font) == null ? void 0 : t.names.fontFamily) ?? "";
  }
  get subfamilyName() {
    var t;
    return ((t = this.font) == null ? void 0 : t.names.fontSubfamily) ?? "";
  }
  get unitsPerEm() {
    var t;
    return ((t = this.font) == null ? void 0 : t.unitsPerEm) ?? 1;
  }
  getLineInitialOffsetX(t, e, i, n, r) {
    return (
      (i === 3 || i === 2) &&
        n.indexOf(`
`) >= 0 &&
        (t -= r),
      i === 3 ? e * 0.5 - t * 0.5 : i === 2 ? e - t : 0
    );
  }
  getLineInitialOffsetY(t, e, i, n, r) {
    let s = e * t,
      a = Math.abs(this.ascender - this.descender) * n,
      o = t - a,
      l = -this.ascender * n - o / 2;
    return r === 3 ? -(i - s - l) : r === 2 ? -(i * 0.5 - s * 0.5 - l) : l;
  }
  createPath(t, e, i, n, r) {
    var l;
    let s = t.getPath(i, -n, r.fontSize, {
      kerning: !1,
      letterSpacing: r.letterSpacing,
    });
    if (!s) {
      console.error(
        'THREE.Font: character "' +
          t +
          '" does not exists in font family ' +
          this.familyName +
          "."
      );
      return;
    }
    let a = new iF(),
      o = (t.advanceWidth ?? 1) * e;
    if (t)
      for (let c of s.commands) {
        let d = (l = a.currentPath) == null ? void 0 : l.currentPoint;
        if (!(d && c.type !== "Z" && d.x === c.x && -d.y === c.y))
          switch (c.type) {
            case "M":
              a.moveTo(c.x, -c.y);
              break;
            case "L":
              a.lineTo(c.x, -c.y);
              break;
            case "Q":
              a.quadraticCurveTo(c.x1, -c.y1, c.x, -c.y);
              break;
            case "C":
              a.bezierCurveTo(c.x1, -c.y1, c.x2, -c.y2, c.x, -c.y);
              break;
          }
      }
    return (
      a.subPaths.forEach((c) => {
        let d = cF(c.curves);
        d !== void 0 && c.currentPoint.distanceTo(d) > 0 && c.lineTo(d.x, d.y);
      }),
      { offsetX: o + r.fontSize * r.letterSpacing, path: a }
    );
  }
  getCharWidth(t, e) {
    var i;
    return (
      ((i = this.font) == null
        ? void 0
        : i.getAdvanceWidth(t, e.fontSize, {
            kerning: !0,
            letterSpacing: e.letterSpacing,
          })) ?? 0
    );
  }
  getTextWidth(t, e) {
    var i;
    return (
      ((i = this.font) == null
        ? void 0
        : i.getAdvanceWidth(t, e.fontSize, {
            kerning: !0,
            letterSpacing: e.letterSpacing,
          })) ?? 0
    );
  }
  computeSpaceWidthForLine(t, e, i) {
    let n = this.getCharWidth(" ", i),
      r = t[e];
    if (r) {
      let s = this.countSpaces(r.trimEnd());
      if (i.horizontalAlign === 4 && e < t.length - 1 && s) {
        let a = i.width,
          o = this.getTextWidth(r, i);
        return (a - (o - s * n)) / s;
      }
    }
    return n;
  }
  countSpaces(t) {
    return (t.match(/ /g) || []).length;
  }
};
function cF(t) {
  if (t.length) {
    let e = t[0];
    if (e instanceof jn) return e.v1;
    if (e instanceof kn || e instanceof fs) return e.v0;
  }
}
var hF = class {
    constructor() {
      (this.objects = new Map()), (this.unreachable = new Set());
    }
    getCached(t) {
      return this.objects.get(t);
    }
    get size() {
      return this.objects.size;
    }
    get(t, e) {
      let i = this.objects.get(t);
      return (
        i === void 0
          ? ((i = this.createObject(t, e)), this.objects.set(t, i))
          : (i.isShared = !0),
        i
      );
    }
    mutateIfUnique(t, e) {
      let i = this.objects.get(t);
      if (i && i.isShared !== !0)
        return this.objects.delete(t), this.objects.set(e, i), i;
    }
    startGc() {
      this.unreachable = new Set(this.objects.keys());
    }
    markAsReachable(t, e) {
      let i = this.objects.get(t);
      e === i && this.unreachable.delete(t);
    }
    endGc() {
      this.unreachable.forEach((t) => {
        this.disposeObject(this.objects.get(t)), this.objects.delete(t);
      }),
        this.unreachable.clear();
    }
    dispose() {
      this.objects.forEach((t) => {
        this.disposeObject(t);
      }),
        this.objects.clear();
    }
  },
  Uv = class extends hF {
    constructor(t) {
      super(), (this.flatShading = t);
    }
    disposeObject(t) {
      t.dispose();
    }
    createObject(t, e) {
      let i = uh(t, e, this.flatShading);
      return i.computeBoundingSphere(), i;
    }
  },
  uF = { markNeedsUpdateRendererDirty: () => {} },
  dF = class extends IB {
    constructor(t) {
      super(), (this.shared = t);
    }
    create(t) {
      return new L1(t, this.shared);
    }
  },
  jp = class {
    constructor(t, e = {}) {
      if (
        ((this.geometryCache = new Uv(!0)),
        (this.geometryCache2 = new Uv(!1)),
        (this.imageHolderCache = new dF(this)),
        (this.thisContext = { scene: uF, shared: this }),
        (this.deletedMaterial = new _f(
          fn.defaultTwoLayerData("phong"),
          this.thisContext
        )),
        (this.deletedImage = new Ns(ch.emptyImage, this)),
        (this.deletedVideo = new Ns(ih.defaultVideo, this)),
        (this.materials = {}),
        (this.images = {}),
        (this.videos = {}),
        (this.colors = {}),
        (this.audios = {}),
        (this.fonts = {}),
        (this.requestRender = () => {
          this._requestRender && this._requestRender();
        }),
        e.images)
      )
        for (let [i, n] of Object.entries(e.images)) this.addImage(i, n);
      if (e.videos)
        for (let [i, n] of Object.entries(e.videos)) this.addVideo(i, n);
      if (e.audios)
        for (let [i, n] of Object.entries(e.audios)) this.addAudio(i, n.data);
      this.reset(t);
    }
    setRequestRender(t) {
      this._requestRender = t;
    }
    reset(t) {
      for (let [e, i] of Object.entries(t.images)) this.addImage(e, i);
      for (let [e, i] of Object.entries(t.videos)) this.addVideo(e, i);
      for (let [e, i] of Object.entries(t.colors)) this.addColor(e, i);
      for (let [e, i] of Object.entries(t.materials))
        this.addMaterial(e, new _f(i, this.thisContext));
      for (let [e, i] of Object.entries(t.audios)) this.addAudio(e, i.data);
      for (let [e, i] of Object.entries(t.fonts)) this.addFont(e, i);
    }
    addMaterial(t, e) {
      (e.uuid = t),
        this.materials[t]
          ? (this.materials[t].reset(e.data, this.thisContext), e.dispose())
          : (this.materials[t] = e);
    }
    deleteMaterial(t) {
      this.materials[t] &&
        (this.materials[t].nodeMaterialDispose(), delete this.materials[t]);
    }
    getMaterial(t) {
      return this.materials[t];
    }
    getMaterialOrDeletedPlaceholder(t) {
      return this.materials[t] ?? this.deletedMaterial;
    }
    material(t) {
      return typeof t == "string"
        ? this.getMaterialOrDeletedPlaceholder(t)
        : t == null
        ? (console.error("material is undefined or null"), this.deletedMaterial)
        : new N1(t, this.thisContext);
    }
    getMaterials() {
      return this.materials;
    }
    addImage(t, e) {
      return this.images[t]
        ? (this.onColorOrImageUpdate && this.onColorOrImageUpdate(),
          this.images[t].updateSrc(e.data),
          !0)
        : ((this.images[t] = new Ns(e, this)), !1);
    }
    deleteImage(t) {
      let e = this.images[t];
      e && (e.dispose(), delete this.images[t]);
    }
    getDefaultImage() {
      return this.images.image_0;
    }
    getImage(t) {
      return this.images[t] ?? this.deletedImage;
    }
    image(t) {
      return typeof t == "string"
        ? this.getImage(t)
        : this.imageHolderCache.load(t);
    }
    addVideo(t, e) {
      return this.videos[t]
        ? (this.videos[t].updateSrc(e.data), !0)
        : ((this.videos[t] = new Ns(e, this)), !1);
    }
    deleteVideo(t) {
      let e = this.videos[t];
      e && (e.dispose(), delete this.videos[t]);
    }
    getVideo(t) {
      return this.videos[t] ?? this.deletedVideo;
    }
    video(t) {
      return typeof t == "string"
        ? this.getVideo(t)
        : this.imageHolderCache.load(t);
    }
    addColor(t, e) {
      return this.colors[t]
        ? (this.onColorOrImageUpdate && this.onColorOrImageUpdate(),
          "a" in e
            ? this.colors[t].setRGBA(e.r, e.g, e.b, e.a)
            : this.colors[t].setRGBA(e.r, e.g, e.b, 1),
          !0)
        : ("a" in e
            ? (this.colors[t] = new dh(e.r, e.g, e.b, e.a))
            : (this.colors[t] = new dh(e.r, e.g, e.b, 1)),
          !1);
    }
    updateColor(t, e) {
      if (this.colors[t]) {
        this.onColorOrImageUpdate && this.onColorOrImageUpdate();
        let i = this.colors[t];
        return (
          (this.colors[t].r = e.r ?? i.r),
          (this.colors[t].g = e.g ?? i.g),
          (this.colors[t].b = e.b ?? i.b),
          (this.colors[t].a = e.a ?? i.a),
          !0
        );
      }
      return !1;
    }
    deleteColor(t) {
      this.colors[t] && delete this.colors[t];
    }
    getColor(t) {
      return this.colors[t];
    }
    color(t) {
      let e;
      if (typeof t == "string") {
        let i = this.getColor(t);
        i
          ? (e = i)
          : (console.warn(
              "Tried to create color layer params with a color key that does not exist in the assets manager"
            ),
            (e = new Wn(0, 0, 0, 0)));
      } else
        return "a" in t ? new Wn(t.r, t.g, t.b, t.a) : new Wn(t.r, t.g, t.b, 1);
      return e;
    }
    addAudio(t, e) {
      this.audios[t] = e;
    }
    getAudio(t) {
      let e = this.audios[t];
      if (e instanceof xc) return e;
      {
        let i = new xc({ src: e });
        return (this.audios[t] = i), i;
      }
    }
    deleteAudio(t) {
      let e = this.audios[t];
      e && (e instanceof xc && e.dispose(), delete this.audios[t]);
    }
    addFont(t, e) {
      (this.fonts[t] = new lF(e)),
        this.fonts[t].loadingPromise.then(() => this.requestRender());
    }
    getFont(t) {
      return this.fonts[t];
    }
    deleteFont(t) {
      this.fonts[t] && delete this.fonts[t];
    }
    dispose() {
      Object.keys(this.materials).forEach((t) => this.deleteMaterial(t)),
        (this._requestRender = void 0),
        Object.values(this.audios).forEach((t) => {
          t instanceof xc && t.dispose();
        }),
        (this.audios = {}),
        this.geometryCache.dispose(),
        this.geometryCache2.dispose();
    }
  },
  fF = new jp(sf.emptyData()),
  ia = class extends ps {
    updateByPatchedOp(t, e, i) {
      if (
        (super.updateByPatchedOp(t, e, i),
        hU(t.path, ["materials"]) !== null &&
          t.type === 0 &&
          Array.isArray(this.material))
      )
        for (let [n, r] of Object.entries(t.props)) {
          let s = i.shared.material(r);
          this.material[Number(n)] = s;
        }
      else if (Sn(t.path, ["material"]) && this.material instanceof ms)
        "material" in e &&
          typeof e.material != "string" &&
          this.material.updateByOp(dn.drop(t, 1), e.material, i);
      else if (Sn(t.path, ["materials", "*"]) && Array.isArray(this.material)) {
        let n = t.path[1];
        if ("materials" in e && n < this.material.length) {
          let r = e.materials[n];
          typeof r != "string" &&
            this.material[n].updateByOp(dn.drop(t, 2), r, i);
        }
      }
    }
    get needsAO() {
      return this.material !== void 0
        ? (Array.isArray(this.material) ? this.material[0] : this.material)
            .hasAO
        : !1;
    }
    updateState(t, e) {
      var n, r;
      super.updateState(t, e),
        t.castShadow !== void 0 && (this.castShadow = t.castShadow),
        t.receiveShadow !== void 0 && (this.receiveShadow = t.receiveShadow);
      let i = this.dataPatched;
      if (
        (((n = t.geometry) == null ? void 0 : n.type) !==
          "NonParametricGeometry" &&
          "material" in t &&
          t.material !== void 0 &&
          (this.disposeMaterial(),
          (this.material = e.shared
            .material(t.material)
            .getFlavor(i.flatShading, i.side, i.wireframe)),
          e.scene.markNeedsUpdateRendererDirty()),
        ((r = t.geometry) == null ? void 0 : r.type) ===
          "NonParametricGeometry" &&
          ("materials" in t && t.materials !== void 0
            ? (this.disposeMaterial(),
              (this.material = t.materials.map((s) =>
                e.shared
                  .material(s)
                  .getFlavor(i.flatShading, i.side, i.wireframe)
              )),
              e.scene.markNeedsUpdateRendererDirty())
            : "material" in t &&
              t.material !== void 0 &&
              (this.disposeMaterial(),
              (this.material = [
                e.shared
                  .material(t.material)
                  .getFlavor(i.flatShading, i.side, i.wireframe),
              ]),
              e.scene.markNeedsUpdateRendererDirty())),
        t.flatShading !== void 0 || t.wireframe !== void 0 || t.side !== void 0)
      )
        if (Array.isArray(this.material))
          for (let s = 0; s < this.material.length; s++)
            this.material[s] = this.material[s].getFlavor(
              i.flatShading,
              i.side,
              i.wireframe
            );
        else
          this.material = this.material.getFlavor(
            i.flatShading,
            i.side,
            i.wireframe
          );
    }
    disposeMaterial() {
      this.material &&
        Dx(this.material).forEach((t) => {
          t instanceof ms && (t instanceof _f || t.nodeMaterialDispose());
        });
    }
    dispose() {
      this.disposeMaterial(), super.dispose();
    }
  },
  Nv = new A(),
  zv = new yt(),
  Bv = new yt(),
  pF = new A(),
  Fv = new ze(),
  ur = class extends ia {
    constructor(t, e, i) {
      super(t, e),
        (this.data = e),
        (this.localGeometry = void 0),
        e.bindMode &&
          e.bindMatrix &&
          ((this.isSkinnedMesh = !0),
          (this.bindMode = e.bindMode),
          (this.bindMatrix = new ze().fromArray(e.bindMatrix)),
          (this.bindMatrixInverse = new ze()));
    }
    chooseGeoemtryCache(t) {
      return t.geometryCache;
    }
    markGeometryAsReachable(t) {
      this.geometryCreateDeleyed instanceof st &&
        this.chooseGeoemtryCache(t).markAsReachable(
          this.dataPatched.geometry,
          this.geometryCreateDeleyed
        );
    }
    get geometry() {
      if (this.localGeometry !== void 0) return this.localGeometry;
      if (this.geometryCreateDeleyed instanceof jp) {
        let t = this.geometryCreateDeleyed,
          e = this.chooseGeoemtryCache(t);
        this.geometryCreateDeleyed = e.get(this.dataPatched.geometry, t);
      }
      return this.geometryCreateDeleyed;
    }
    set geometry(t) {
      this.localGeometry = t;
    }
    get is2DAndNoDepth() {
      let t = this.dataPatched.geometry;
      return sh.is2DParametricMesh(t.type) && t.depth === 0;
    }
    get is2DType() {
      return sh.is2DParametricMesh(this.geometry.userData.type);
    }
    get isNonParametric() {
      return this.geometry.userData.type === "NonParametricGeometry";
    }
    updateByPatchedOp(t, e, i) {
      super.updateByPatchedOp(t, e, i),
        Sn(t.path, ["geometry"]) &&
          this.updateByPatchedOpGeometry(dn.drop(t, 1), e.geometry, i);
    }
    removeInteractionGeometry() {
      var t;
      (t = this.localGeometry) == null || t.dispose(),
        (this.localGeometry = void 0);
    }
    updateGeometryInteractions(t, e) {
      var n;
      this.invalidateDownstreamBooleanData();
      let i = this.data.geometry.type;
      if (i === "NonParametricGeometry" || i === "SubdivGeometry") {
        let r = t;
        if (this.localGeometry === void 0) {
          let c = { ...this.data.geometry, ...r };
          this.localGeometry = uh(c, e, this.data.flatShading);
        }
        let s, a, o;
        r.scaleBaked
          ? ([s, a, o] = r.scaleBaked)
          : ({ width: s, height: a, depth: o } = r);
        let l = this.localGeometry.userData;
        l.sxPrev !== void 0 &&
          mf(
            this.localGeometry.attributes,
            s / l.sxPrev,
            a / l.syPrev,
            o / l.szPrev
          ),
          (l.sxPrev = s),
          (l.syPrev = a),
          (l.szPrev = o);
      } else {
        let r = { ...this.data.geometry, ...t };
        (n = this.localGeometry) == null || n.dispose(),
          (this.localGeometry = uh(r, e, this.data.flatShading));
      }
    }
    refreshAttachedCloners(t) {
      for (let e of this.attachedSurfaceCloners)
        t.scene.addPendingUpdateCloner(e.object);
    }
    refreshAttachedPaths(t) {
      for (let e of this.attachedPaths)
        t.scene.addPendingCommand(() => e.updateShape());
    }
    createGeometryDelayed(t) {
      (this.geometryCreateDeleyed = t.shared),
        this.refreshAttachedCloners(t),
        this.refreshAttachedPaths(t);
    }
    updateByPatchedOpGeometry(t, e, i) {
      var r;
      let n = !1;
      t.type === 0 &&
        t.path.length === 0 &&
        a_(["scaleBaked"], Object.keys(t.props)) &&
        this.geometryCreateDeleyed instanceof Gi &&
        this.chooseGeoemtryCache(i.shared).mutateIfUnique(
          this.geometryCreateDeleyed.data,
          e
        ) === this.geometryCreateDeleyed &&
        ((n = !0),
        this.geometryCreateDeleyed.mutateDirectlyScaleBaked(
          e,
          t.props.scaleBaked
        ),
        this.refreshAttachedCloners(i),
        this.refreshAttachedPaths(i)),
        n ||
          ((r = i.scene) == null || r.markGeometryCacheDirty(),
          this.createGeometryDelayed(i)),
        this.resetBBoxNeedsUpdate(),
        this.invalidateDownstreamBooleanData();
    }
    updateGeometryOnStateUpdate(t, e) {
      this.createGeometryDelayed(e);
    }
    updateState(t, e) {
      t.geometry !== void 0 && this.updateGeometryOnStateUpdate(t.geometry, e),
        super.updateState(t, e);
    }
    updateGeometryGroupsIfNeeded() {
      var t;
      Array.isArray(this.material) &&
        this.geometry.groups.length === 0 &&
        this.geometry.addGroup(
          0,
          Math.max(
            ((t = this.geometry.getIndex()) == null ? void 0 : t.count) ?? 0,
            this.geometry.getAttribute("position").count
          ),
          0
        );
    }
    updateEntityBoxSize(t, e) {
      let i = this.geometry.userData.parameters;
      this.is2DType
        ? t.set(0, 0, i.depth * 0.5)
        : this.isNonParametric
        ? (t.setScalar(0),
          this.geometry.boundingSphere &&
            t.copy(this.geometry.boundingSphere.center),
          e.set(i.width, i.height, i.depth ?? 0).multiplyScalar(0.5))
        : t.setScalar(0),
        e.set(i.width, i.height, i.depth ?? 0).multiplyScalar(0.5);
    }
    updateMatrixWorld(t) {
      super.updateMatrixWorld(t),
        this.bindMode === "attached"
          ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
          : this.bindMode === "detached" &&
            this.bindMatrixInverse.copy(this.bindMatrix).invert();
    }
    bind(t, e) {
      (this.skeleton = t),
        e === void 0 &&
          (this.updateMatrixWorld(!0),
          this.skeleton.calculateInverses(),
          (e = this.matrixWorld)),
        this.bindMatrix.copy(e),
        this.bindMatrixInverse.copy(e).invert();
    }
    pose() {
      this.skeleton.pose();
    }
    normalizeSkinWeights(t) {
      let e = new yt(),
        i = this.geometry.attributes.skinWeight;
      for (let n = 0, r = i.count; n < r; n++) {
        e.fromBufferAttribute(i, n);
        let s = 1 / e.manhattanLength();
        s !== 1 / 0 ? e.multiplyScalar(s) : e.set(1, 0, 0, 0),
          i.setXYZW(n, e.x, e.y, e.z, e.w);
      }
    }
    boneTransform(t, e) {
      let i = this.skeleton;
      if (i === void 0) return;
      let n = this.geometry;
      zv.fromBufferAttribute(n.attributes.skinIndex, t),
        Bv.fromBufferAttribute(n.attributes.skinWeight, t),
        Nv.copy(e).applyMatrix4(this.bindMatrix),
        e.set(0, 0, 0);
      for (let r = 0; r < 4; r++) {
        let s = Bv.getComponent(r);
        if (s !== 0) {
          let a = zv.getComponent(r);
          Fv.multiplyMatrices(i.bones[a].matrixWorld, i.boneInverses[a]),
            e.addScaledVector(pF.copy(Nv).applyMatrix4(Fv), s);
        }
      }
      return e.applyMatrix4(this.bindMatrixInverse);
    }
  };
function mF(t) {
  var a, o;
  if (
    t.geometry.attributes.extrudeNormal ||
    !t.geometry.attributes.position ||
    !t.geometry.attributes.normal
  )
    return;
  let e = new Map(),
    i = t.geometry.attributes,
    n = i.position.array,
    r = i.normal.array,
    s = new Float32Array(n.length);
  for (let l = 0; l < n.length; l += 3) {
    let c = `${n[l]}_${n[l + 1]}_${n[l + 2]}`,
      d = new A(r[l], r[l + 1], r[l + 2]);
    e.has(c)
      ? (a = e.get(c)) == null || a.normals.push(d)
      : e.set(c, { normals: [d], result: new A() });
  }
  e.forEach((l, c) => {
    for (let d of l.normals) l.result.add(d);
    l.result.divideScalar(l.normals.length);
  });
  for (let l = 0; l < n.length; l += 3) {
    let c = `${n[l]}_${n[l + 1]}_${n[l + 2]}`,
      d = (o = e.get(c)) == null ? void 0 : o.result;
    d && ((s[l] = d.x), (s[l + 1] = d.y), (s[l + 2] = d.z));
  }
  t.geometry.setAttribute("extrudeNormal", new We(s, 3));
}
function gF(t) {
  if (t.geometry.attributes.extrudeNormals || !t.geometry.attributes.position)
    return;
  let e = t.geometry.attributes.position.array,
    i = new Float32Array(e.length),
    n = new A();
  for (let r = 0; r < e.length; r += 3)
    n.set(e[r], e[r + 1], e[r + 2]).normalize(),
      (i[r] = n.x),
      (i[r + 1] = n.y),
      (i[r + 2] = n.z);
  t.geometry.setAttribute("extrudeNormal", new We(i, 3));
}
function Wp(t) {
  if (Array.isArray(t.material)) {
    for (let e of t.material)
      if (e.getLayersOfType("outline").length === 0) return;
  } else if (
    !(t.material instanceof ms) ||
    t.material.getLayersOfType("outline").length === 0
  )
    return;
  t instanceof ur && t.is2DAndNoDepth ? gF(t) : mF(t);
}
function qp(t) {
  if (!t.geometry.attributes.position) return;
  let e = t.geometry.attributes.position.array,
    i = new Float32Array(e.length),
    n = parseInt(t.uuid.replace(/\D/g, "")),
    r = [
      Jt.seededRandom(n),
      Jt.seededRandom(n + 1e4),
      Jt.seededRandom(n + 2e4),
    ];
  for (let s = 0; s < e.length; s++) i[s] = r[s % 3];
  t.geometry.setAttribute("randomColor", new pt(i, 3));
}
Bp.then((t) => {});
var ir = new An(),
  Uo = new A();
function vF(t) {
  let e = !1;
  return (
    t.scene.objects.traverse((i, n) => {
      n.type === "Mesh" && n.geometry.type === "SubdivGeometry" && (e = !0);
    }),
    e
  );
}
var bf = class extends ur {
    constructor(t, e, i) {
      super(t, e, i),
        (this.data = e),
        (this.hiddenMatrixOld = new ze()),
        (this.smoothShading = !0),
        (this.skipReactionUpdate = !1);
    }
    chooseGeoemtryCache(t) {
      return this.dataPatched.flatShading ? t.geometryCache : t.geometryCache2;
    }
    get subdivPointerNew() {
      return this.localGeometry !== void 0
        ? this.subdivPointer
        : this.geometry.ensureSubdivPointer();
    }
    get originalGeometryNew() {
      return this.localGeometry !== void 0
        ? this.originalGeometry
        : this.geometry.originalGeometry;
    }
    get phongAngle() {
      return this.data.geometry.phongAngle ?? 45;
    }
    updateEntityBoxSize(t, e) {
      let i = this.geometry.userData.parameters;
      t.copy(this.originalGeometryNew.boundingSphere.center),
        e.set(i.width, i.height, i.depth ?? 0).multiplyScalar(0.5);
    }
    createGeometryByControls(t) {
      var s, a, o;
      if (this.skipReactionUpdate === !0) return;
      let e = (s = this.localGeometry) == null ? void 0 : s.uuid,
        {
          originalGeometry: i,
          subdividedGeometry: n,
          subdivPointer: r,
        } = Gi.build(
          t,
          this.subdivPointer,
          this.smoothShading,
          this.hasNonUniformScale ? this.shearScale : void 0
        );
      (this.subdivPointer = r),
        i !== void 0 &&
          ((a = this.originalGeometry) == null || a.dispose(),
          (this.originalGeometry = i)),
        n !== void 0 &&
          ((o = this.subdividedGeometry) == null || o.dispose(),
          (this.subdividedGeometry = n ?? void 0)),
        (this.localGeometry = this.subdividedGeometry ?? this.originalGeometry),
        Wp(this),
        qp(this),
        this.calcBoundingBox(),
        e && (this.localGeometry.uuid = e);
    }
    updateState(t, e) {
      if ((super.updateState(t, e), t.flatShading !== void 0)) {
        let i = this.material;
        (this.material = i.getFlavor(!1, i.side, i.wireframe)),
          (this.smoothShading = !t.flatShading),
          this.createGeometryDelayed(e);
      }
    }
    updateMesh(t = !1) {
      Gi.buildLevel(
        this.subdivPointer,
        !0,
        this.smoothShading ? this.phongAngle : -1,
        this.originalGeometry,
        t && this.hasNonUniformScale ? this.shearScaleInv : void 0
      ),
        this.subdividedGeometry &&
          Gi.buildLevel(
            this.subdivPointer,
            !1,
            this.smoothShading ? this.phongAngle : -1,
            this.subdividedGeometry,
            t && this.hasNonUniformScale ? this.shearScaleInv : void 0
          );
    }
    updateTopology() {
      this.originalGeometry.dispose(),
        (this.originalGeometry = Gi.buildLevel(
          this.subdivPointer,
          !0,
          this.smoothShading ? this.phongAngle : -1
        )),
        this.subdividedGeometry &&
          (this.subdividedGeometry.dispose(),
          (this.subdividedGeometry = Gi.buildLevel(
            this.subdivPointer,
            !1,
            this.smoothShading ? this.phongAngle : -1
          ))),
        (this.localGeometry = this.subdividedGeometry ?? this.originalGeometry);
    }
    raycast(t, e) {
      let i = this.localGeometry;
      (this.localGeometry = this.originalGeometryNew),
        ps.prototype.raycast.call(this, t, e),
        (this.localGeometry = i);
    }
    activateSVDCompensation() {
      !this.hasNonUniformScale ||
        (this.matrix.copy(this.matrixWorldRigid),
        this.hiddenMatrixOld.copy(this.hiddenMatrix),
        this.hiddenMatrix.copy(this.parent.matrixWorld).invert());
    }
    deactivateSVDCompensation() {
      !this.hasNonUniformScale ||
        (this.updateMatrix(),
        (this.hasNonUniformScale = void 0),
        this.hiddenMatrix.copy(this.hiddenMatrixOld));
    }
    calcBoundingBox() {
      let t = this.originalGeometry;
      t.boundingSphere === null &&
        ((t.boundingSphere = new Xn()),
        this.subdividedGeometry &&
          (this.subdividedGeometry.boundingSphere = t.boundingSphere));
      let e = t.attributes.position,
        i = t.boundingSphere.center;
      ir.setFromBufferAttribute(e),
        ir.getCenter(i),
        (t.boundingSphere.radius = i.distanceTo(ir.max)),
        isNaN(t.boundingSphere.radius) &&
          console.error(
            'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
            this
          ),
        ir.getSize(Uo),
        this.hasNonUniformScale && Uo.divide(this.scale);
      let n = { width: Uo.x, height: Uo.y, depth: Uo.z };
      return (this.geometry.userData.parameters = n), n;
    }
    updateBoundingSphere(t) {
      let e = this.originalGeometry;
      ir.min.set(t[0], t[2], t[4]),
        ir.max.set(t[1], t[3], t[5]),
        this.hasNonUniformScale &&
          (ir.min.applyMatrix4(this.shearScaleInv),
          ir.max.applyMatrix4(this.shearScaleInv)),
        e.boundingSphere === null && (e.boundingSphere = new Xn());
      let i = e.boundingSphere.center;
      ir.getCenter(i), (e.boundingSphere.radius = i.distanceTo(ir.max));
    }
    freeSubdivPointer() {
      var t, e;
      this.subdivPointer &&
        (Gi.freeSubdivPointer(this.subdivPointer), (this.subdivPointer = 0)),
        (this.localGeometry = void 0),
        (t = this.originalGeometry) == null || t.dispose(),
        (e = this.subdividedGeometry) == null || e.dispose();
    }
    dispose() {
      super.dispose(), this.freeSubdivPointer();
    }
    updateByPatchedOpGeometry(t, e, i) {
      super.updateByPatchedOpGeometry(t, e, i),
        this.localGeometry && this.createGeometryByControls(e);
    }
  },
  kv = -1,
  yF = 1,
  xF = {
    x: [1, 0, 0],
    "-x": [-1, 0, 0],
    y: [0, 1, 0],
    "-y": [0, -1, 0],
    z: [0, 0, 1],
    "-z": [0, 0, -1],
  },
  _F = { polygon_center: 0, edge: 1, vertex: 2 },
  bc = (t, e) => (i, n) => !e || i === 0 || t === 0 ? 0 : (t * n) / 100,
  lt = (t, e) => {
    let i = Math.abs(e),
      n = i * -1;
    return ((t - kv) * (i - n)) / (yF - kv) + n;
  };
function bF(t) {
  let e = [],
    i = {};
  for (var n = 0, r = t.length; n < r; n++) {
    var s = JSON.stringify(t[n].pos.map((a) => Math.round(a * 1e4) / 1e4));
    i[s] || (e.push(t[n]), (i[s] = !0));
  }
  return e;
}
var wF = new A(),
  wc = new A(),
  SF = new A(),
  MF = new A();
function Xa(t, e) {
  let i = SF.fromArray(t),
    n = MF.fromArray(e);
  wc.copy(n).sub(i);
  let r = wc.length();
  return wc.normalize().multiplyScalar(r * 0.5), wF.copy(i).add(wc).toArray();
}
var bn = new Ki(),
  Sc = new A(),
  fh = new A(),
  Us = new A();
function EF(t) {
  let e = [];
  for (let i = 0; i <= t.index.count; i++)
    if (
      (Sc.fromArray(t.index.array, i * 3),
      bn.setFromAttributeAndIndices(t.attributes.position, Sc.x, Sc.y, Sc.z),
      bn.getNormal(fh),
      bn.getMidpoint(Us),
      !(isNaN(Us.x) || isNaN(Us.y) || isNaN(Us.z)))
    ) {
      let { a: n, b: r, c: s } = bn,
        a = n.toArray(),
        o = r.toArray(),
        l = s.toArray(),
        c = n.distanceTo(r),
        d = r.distanceTo(s),
        h = s.distanceTo(n),
        u = Xa(a, o),
        f = Xa(o, l),
        p = Xa(l, a),
        v = [c, d, h],
        g = Math.max(...v),
        m = v.filter((_) => Math.round(_) === Math.round(g)).length > 1,
        x = [],
        y = bn.getMidpoint(Us).toArray();
      g === c && !m && ((x = [f, p, p]), (y = u)),
        g === d && !m && ((x = [u, p, p]), (y = f)),
        g === h && !m && ((x = [u, f, f]), (y = p)),
        m && (x = [u, f, p]),
        e.push({
          vertices: [a, o, l],
          faceCenters: x,
          midpoint: y,
          norm: bn.getNormal(fh).toArray(),
        });
    }
  return e;
}
function TF(t) {
  let e = [],
    { position: i } = t.attributes;
  for (let n = 0; n < i.count; n++) {
    bn.setFromAttributeAndIndices(i, n * 3, n * 3 + 1, n * 3 + 2),
      bn.getNormal(fh),
      bn.getMidpoint(Us);
    let r = bn.a.toArray(),
      s = bn.b.toArray(),
      a = bn.c.toArray();
    e.push({
      vertices: [r, s, a],
      faceCenters: [Xa(r, s), Xa(s, a), Xa(a, r)],
      midpoint: Us.toArray(),
      norm: fh.toArray(),
    });
  }
  return e;
}
var AF = 4,
  CF = 0.5,
  td = (t) => 0.5 * (1 - Math.cos(t * Math.PI)),
  PF = class {
    constructor() {
      this.perlin = new Array(4095 + 1);
    }
    noise(t, e = 0, i = 0) {
      if (this.perlin == null) {
        this.perlin = new Array(4095 + 1);
        for (let g = 0; g < 4095 + 1; g++) this.perlin[g] = Math.random();
      }
      t < 0 && (t = -t), e < 0 && (e = -e), i < 0 && (i = -i);
      let n = Math.floor(t),
        r = Math.floor(e),
        s = Math.floor(i),
        a = t - n,
        o = e - r,
        l = i - s,
        c,
        d,
        h = 0,
        u = 0.5,
        f,
        p,
        v;
      for (let g = 0; g < AF; g++) {
        let m = n + (r << 4) + (s << 8);
        (c = td(a)),
          (d = td(o)),
          (f = this.perlin[m & 4095]),
          (f += c * (this.perlin[(m + 1) & 4095] - f)),
          (p = this.perlin[(m + 16) & 4095]),
          (p += c * (this.perlin[(m + 16 + 1) & 4095] - p)),
          (f += d * (p - f)),
          (m += 256),
          (p = this.perlin[m & 4095]),
          (p += c * (this.perlin[(m + 1) & 4095] - p)),
          (v = this.perlin[(m + 16) & 4095]),
          (v += c * (this.perlin[(m + 16 + 1) & 4095] - v)),
          (p += d * (v - p)),
          (f += td(l) * (p - f)),
          (h += f * u),
          (u *= CF),
          (n <<= 1),
          (a *= 2),
          (r <<= 1),
          (o *= 2),
          (s <<= 1),
          (l *= 2),
          a >= 1 && (n++, a--),
          o >= 1 && (r++, o--),
          l >= 1 && (s++, l--);
      }
      return h;
    }
    noiseSeed(t) {
      let e = (() => {
        let i, n;
        return {
          setSeed(r) {
            n = i = (r ?? Math.random() * 4294967296) >>> 0;
          },
          getSeed() {
            return i;
          },
          rand() {
            return (
              (n = (1664525 * n + 1013904223) % 4294967296), n / 4294967296
            );
          },
        };
      })();
      e.setSeed(t), (this.perlin = new Array(4095 + 1));
      for (let i = 0; i < 4095 + 1; i++) this.perlin[i] = e.rand();
    }
  },
  LF = PF,
  Vv = new A(),
  Hv = new ze(),
  Gv = new oo();
function DF(t) {
  let e = !1;
  return (
    t.scene.objects.traverse((i, n) => {
      n.type === "Mesh" && n.geometry.type === "TextGeometry" && (e = !0);
    }),
    e
  );
}
var B1 = class extends ur {
    constructor(t, e, i) {
      super(t, e, i), (this.data = e);
    }
    get textGeometry() {
      return this.geometry;
    }
    get charWidths() {
      return this.textGeometry.charWidths;
    }
    get charCoords() {
      return this.textGeometry.charCoords;
    }
    get wrappedText() {
      return this.textGeometry.wrappedText;
    }
    get font() {
      return this.textGeometry.font;
    }
    get initialOffsetY() {
      var e;
      let t = this.dataPatched;
      return (
        ((e = this.font) == null
          ? void 0
          : e.getLineInitialOffsetY(
              this.lineHeight,
              this.wrappedText.length,
              t.geometry.height,
              this.fontScale,
              t.geometry.verticalAlign
            )) ?? 0
      );
    }
    get fontScale() {
      let t = this.dataPatched;
      return this.font ? t.geometry.fontSize / this.font.unitsPerEm : 1;
    }
    get AD() {
      return Math.abs(this.ascender - this.descender);
    }
    get ascender() {
      var t;
      return (
        (((t = this.font) == null ? void 0 : t.ascender) ?? 1) * this.fontScale
      );
    }
    get descender() {
      var t;
      return (
        (((t = this.font) == null ? void 0 : t.descender) ?? 1) * this.fontScale
      );
    }
    get lineHeight() {
      let t = this.dataPatched;
      return t.geometry.fontSize * t.geometry.lineHeight;
    }
    raycast(t, e) {
      let { matrixWorld: i } = this;
      if (
        !(
          isNaN(t.ray.origin.x) ||
          this.scale.x === 0 ||
          this.scale.y === 0 ||
          this.scale.z === 0
        ) &&
        (Hv.copy(i).invert(),
        Gv.copy(t.ray).applyMatrix4(Hv),
        Gv.intersectBox(this.singleBBox, Vv))
      ) {
        let n = Vv.applyMatrix4(i),
          r = t.ray.origin.distanceTo(n);
        e.push({ distance: r, point: n.clone(), object: this });
      }
    }
  },
  Bi = 1e-4,
  nr,
  F1,
  k1,
  V1,
  jv = new A(),
  Wv = new A();
Bp.then((t) => {
  (nr = t),
    (F1 = [nr.get_face_center, nr.get_edge_midpoint, nr.get_vertex_position]),
    (k1 = [nr.get_face_normal, nr.get_edge_normal, nr.get_vertex_normal]),
    (V1 = [nr.face_count, nr.edge_count, nr.vertex_count]);
});
var RF = new ze(),
  OF = new ze(),
  Wr = new A(),
  As = new A(),
  No = new A(),
  id = new A(),
  IF = new A(),
  UF = new A(),
  Sr = new LF(),
  H1 = class extends Lp(Ht) {
    constructor(t, e) {
      super(),
        (this.parameters = e),
        (this.objectForSample = void 0),
        (this._pendingMediaLoad = !1),
        (this.object = t);
    }
    resetOnMove() {
      this.removeFromParent(), (this.parent = null);
    }
    expandClones(t) {
      if (this.parent === null) this.updateState(this.parameters, t);
      else for (let e of this.children) e instanceof Fo && e.expand();
    }
    invalidateTransform(t) {
      (this.matrixWorldNeedsUpdate = !0),
        this.traverse((e) => {
          e instanceof Fo && e.object === t && (e.matrixWorldNeedsUpdate = !0);
        });
    }
    onObjUpdateMatrix() {
      this.parameters.type !== "toObject" && (this.matrixWorldNeedsUpdate = !0);
    }
    update() {
      switch ((this._updateCount(), this.parameters.type)) {
        case "radial":
          this._updateRadial(this.parameters);
          break;
        case "linear":
          this._updateLinear(this.parameters);
          break;
        case "grid":
          this._updateGrid(this.parameters);
          break;
        case "toObject":
          this._updateToObject(this.parameters);
      }
      for (let t of this.children)
        t.updateMatrix(),
          t.hasNonUniformScale &&
            (t.updateMatrixWorld(), t.updateMatrixWorldSVD());
    }
    _updateCount(t) {
      let e;
      if (
        (t !== void 0
          ? (e = t)
          : (e =
              this.parameters.type === "grid"
                ? Math.round(this.parameters.grid.count[0]) *
                  Math.round(this.parameters.grid.count[1]) *
                  Math.round(this.parameters.grid.count[2])
                : this.parameters.count),
        this.parameters.type === "toObject" &&
          !this.parameters.toObject.object &&
          (e = 0),
        this.parameters.type === "toObject" && this.objectForSample)
      ) {
        for (let n = 0, r = this.children.length; n < r; ++n)
          this.remove(this.children[0]);
        let i = this.children;
        if (i.length === e) return;
        if (i.length < e)
          for (let n = 0, r = e - i.length; n < r; ++n) {
            let s = new Fo(this.object);
            s.expand(), this.add(s);
          }
        else for (let n = 0, r = i.length - e; n < r; ++n) this.remove(i[n]);
      } else {
        if (this.children.length === e) return;
        if (this.children.length < e)
          for (let i = 0, n = e - this.children.length; i < n; ++i) {
            let r = new Fo(this.object);
            r.expand(), this.add(r);
          }
        else
          for (let i = 0, n = this.children.length - e; i < n; ++i)
            this.remove(this.children[0]);
      }
    }
    _updateRadial(t) {
      let e = t.radial,
        i = e.start * Jt.DEG2RAD,
        n = e.end * Jt.DEG2RAD,
        r = i - n,
        s = new as(e.rotation[0], e.rotation[1], e.rotation[2]),
        a;
      switch (e.axis) {
        case "z":
          a = new A(0, 0, 1);
          break;
        case "y":
          a = new A(0, 1, 0);
          break;
        default:
        case "x":
          a = new A(1, 0, 0);
          break;
      }
      let o = t.randomnessObject ?? Qr.defaultData([1, 1, 1]).randomnessObject,
        l = o.noiseType === "perlin";
      Sr.noiseSeed(o.seed);
      let c = Fu((0, Po.default)(o.seed)),
        d = bc(o.strength, this.parameters.randomness);
      for (let [h, u] of this.children.entries()) {
        let f = h * (o.freqScale / 10) + o.movement,
          p = l ? Sr.noise(f) : c(f, f),
          v = h + 1;
        (u.scale.x = e.scale[0] + d(v, lt(p, o.scale[0])) || Bi),
          (u.scale.y = e.scale[1] + d(v, lt(p, o.scale[1])) || Bi),
          (u.scale.z = e.scale[2] + d(v, lt(p, o.scale[2])) || Bi),
          u.position.setScalar(0);
        let g = (r / t.count) * h - i;
        switch (e.axis) {
          case "x":
            u.rotation.set(0, g, 0);
            break;
          case "y":
            u.rotation.set(0, 0, g);
            break;
          case "z":
            u.rotation.set(g, 0, 0);
            break;
        }
        u.translateOnAxis(a, e.radius),
          (u.position.x += e.position[0] + d(v, lt(p, o.position[0]))),
          (u.position.y += e.position[1] + d(v, lt(p, o.position[1]))),
          (u.position.z += e.position[2] + d(v, lt(p, o.position[2])));
        let m = d(v, lt(p, o.rotation[0])),
          x = d(v, lt(p, o.rotation[1])),
          y = d(v, lt(p, o.rotation[2]));
        e.alignment === !0
          ? ((u.rotation.x += s.x + m),
            (u.rotation.y += s.y + x),
            (u.rotation.z += s.z + y))
          : u.rotation.set(s.x + m, s.y + x, s.z + y);
      }
    }
    _updateLinear(t) {
      if (t.type !== "linear") throw new Error();
      let e = t.linear,
        i = new as(e.rotation[0], e.rotation[1], e.rotation[2]),
        n = t.randomnessObject ?? Qr.defaultData([1, 1, 1]).randomnessObject,
        r = n.noiseType === "perlin";
      Sr.noiseSeed(n.seed);
      let s = Fu((0, Po.default)(n.seed)),
        a = bc(n.strength, this.parameters.randomness);
      for (let [o, l] of this.children.entries()) {
        let c = o * (n.freqScale / 10) + n.movement,
          d = r ? Sr.noise(c) : s(c, c),
          h = o + 1,
          u = a(h, lt(d, n.rotation[0])),
          f = a(h, lt(d, n.rotation[1])),
          p = a(h, lt(d, n.rotation[2]));
        (l.scale.x = 1 + (e.scale[0] - 1) * o + a(h, lt(d, n.scale[0])) || Bi),
          (l.scale.y =
            1 + (e.scale[1] - 1) * o + a(h, lt(d, n.scale[1])) || Bi),
          (l.scale.z =
            1 + (e.scale[2] - 1) * o + a(h, lt(d, n.scale[2])) || Bi),
          (l.rotation.x = i.x * o + u),
          (l.rotation.y = i.y * o + f),
          (l.rotation.z = i.z * o + p),
          (l.position.x = e.position[0] * o + a(h, lt(d, n.position[0]))),
          (l.position.y = e.position[1] * o + a(h, lt(d, n.position[1]))),
          (l.position.z = e.position[2] * o + a(h, lt(d, n.position[2])));
      }
    }
    _updateGrid(t) {
      let e = 0,
        i = t.grid,
        n = t.randomnessObject ?? Qr.defaultData([1, 1, 1]).randomnessObject,
        r = bc(n.strength, this.parameters.randomness),
        s = n.noiseType === "perlin";
      Sr.noiseSeed(n.seed);
      let a = bN((0, Po.default)(n.seed));
      if (i.useCenter === !0) {
        let o = {
            x: i.count[0] % 2 === 0 ? 2 : 1,
            y: i.count[1] % 2 === 0 ? 2 : 1,
            z: i.count[2] % 2 === 0 ? 2 : 1,
          },
          l = new A(
            i.size[0] * (i.count[0] - o.x) * 0.5,
            i.size[1] * (i.count[1] - o.y) * 0.5,
            i.size[2] * (i.count[2] - o.z) * 0.5
          );
        for (let c = 0; c < i.count[0]; c++)
          for (let d = 0; d < i.count[1]; d++)
            for (let h = 0; h < i.count[2]; h++) {
              let u = [
                  (c + 1) * (n.freqScale / 10) + n.movement,
                  (d + 1) * (n.freqScale / 10) + n.movement,
                  (h + 1) * (n.freqScale / 10) + n.movement,
                ],
                f = s ? Sr.noise(...u) : a(...u),
                p = this.children[e++];
              (p.scale.x = 1 + r(e, lt(f, n.scale[0])) || Bi),
                (p.scale.y = 1 + r(e, lt(f, n.scale[1])) || Bi),
                (p.scale.z = 1 + r(e, lt(f, n.scale[2])) || Bi);
              let v = r(e, lt(f, n.rotation[0])),
                g = r(e, lt(f, n.rotation[1])),
                m = r(e, lt(f, n.rotation[2]));
              p.rotation.set(v, g, m),
                (p.position.x =
                  i.size[0] * c - l.x + r(e, lt(f, n.position[0]))),
                (p.position.y =
                  i.size[1] * d - l.y + r(e, lt(f, n.position[1]))),
                (p.position.z =
                  i.size[2] * h - l.z + r(e, lt(f, n.position[2])));
            }
      } else
        for (let o = 0; o < i.count[0]; o++)
          for (let l = 0; l < i.count[1]; l++)
            for (let c = 0; c < i.count[2]; c++) {
              let d = [
                  (o + 1) * (n.freqScale / 10) + n.movement,
                  (l + 1) * (n.freqScale / 10) + n.movement,
                  (c + 1) * (n.freqScale / 10) + n.movement,
                ],
                h = s ? Sr.noise(...d) : a(...d),
                u = this.children[e++];
              (u.scale.x = 1 + r(e, lt(h, n.scale[0])) || Bi),
                (u.scale.y = 1 + r(e, lt(h, n.scale[1])) || Bi),
                (u.scale.z = 1 + r(e, lt(h, n.scale[2])) || Bi);
              let f = r(e, lt(h, n.rotation[0])),
                p = r(e, lt(h, n.rotation[1])),
                v = r(e, lt(h, n.rotation[2]));
              u.rotation.set(f, p, v),
                (u.position.x = i.size[0] * o + r(e, lt(h, n.position[0]))),
                (u.position.y = -i.size[1] * l + r(e, lt(h, n.position[1]))),
                (u.position.z = -i.size[2] * c + r(e, lt(h, n.position[2])));
            }
    }
    _updateToObject(t) {
      var v;
      if (t.type !== "toObject") throw new Error();
      let { toObject: e } = t,
        i = new as(e.rotation[0], e.rotation[1], e.rotation[2]),
        n = t.randomnessObject ?? Qr.defaultData([1, 1, 1]).randomnessObject,
        r = n.noiseType === "perlin";
      Sr.noiseSeed(n.seed);
      let s = Fu((0, Po.default)(n.seed)),
        a = bc(n.strength, this.parameters.randomness);
      if (!e.object) {
        for (let [, g] of this.children.entries())
          g.position.set(0, 0, 0),
            g.scale.setScalar(1),
            g.rotation.set(0, 0, 0);
        this.objectForSample = void 0;
        return;
      }
      if (!this.objectForSample) return;
      if (this.objectForSample instanceof B1)
        if (
          !((v = this.objectForSample.font) != null && v.isLoaded) ||
          this.objectForSample.geometry.attributes.position === void 0
        ) {
          this._pendingMediaLoad = !0;
          return;
        } else this._pendingMediaLoad = !1;
      if (
        this.objectForSample.geometry === void 0 &&
        this.objectForSample.isAncestorOf(this.object.uuid)
      ) {
        console.warn(
          `Oh no! The object "${this.object.name}" (${this.object.uuid}) seem to be a child/descendant of the object it's being cloned to. Please re-parent it so that they are siblings instead.`
        );
        return;
      }
      let o = this.getSubdivData(),
        l = [],
        c = (g) => {
          let m = g.length,
            x = g.map((M) => M[0]).reduce((M, b) => M + b, 0),
            y = g.map((M) => M[1]).reduce((M, b) => M + b, 0),
            _ = g.map((M) => M[2]).reduce((M, b) => M + b, 0);
          return [x / m, y / m, _ / m];
        },
        d = (g) => Math.round(g * 1e6) / 1e6;
      o.forEach((g) => {
        let m = o.filter(
          (x) =>
            d(g.pos[0]) === d(x.pos[0]) &&
            d(g.pos[1]) === d(x.pos[1]) &&
            d(g.pos[2]) === d(x.pos[2])
        );
        m.length > 1
          ? l.push({ pos: g.pos, norm: c(m.map((x) => x.norm)) })
          : l.push(g);
      });
      let h = bF(l);
      if (o.length > 0) {
        let g = Math.round((h.length * e.count) / 100);
        this._updateCount(g);
      }
      this.objectForSample.updateMatrixWorld();
      let u = new wN(this.objectForSample).build(),
        f = xF[e.axis],
        p = this.children;
      u.setRandomGenerator((0, Po.default)(this.object.uuid + e.seed));
      for (let [g, m] of p.entries()) {
        let x = g * (n.freqScale / 10) + n.movement,
          y = r ? Sr.noise(x) : s(x, x),
          _ = g + 1,
          M = a(_, lt(y, n.rotation[0])),
          b = a(_, lt(y, n.rotation[1])),
          E = a(_, lt(y, n.rotation[2]));
        e.spreadType === "random"
          ? u.sample(No, id)
          : (h.length && (No.fromArray(h[g].pos), id.fromArray(h[g].norm)),
            this.objectForSample instanceof bf &&
              No.applyMatrix4(
                RF.copy(this.objectForSample.matrixWorld).invert()
              )),
          No.applyMatrix4(this.object.hiddenMatrix.clone().invert()),
          m.position.copy(No),
          Wr.fromArray(f);
        let T = e.align === "normal" ? id : this.object.getWorldDirection(UF),
          S = As.fromArray(e.position);
        (As.x += As.x + a(_, lt(y, n.position[0]))),
          (As.y += As.y + a(_, lt(y, n.position[1]))),
          (As.z += As.z + a(_, lt(y, n.position[2])));
        let w = Math.acos(T.dot(Wr)),
          C = IF.crossVectors(Wr, T).normalize(),
          L = OF.makeRotationAxis(C, w),
          P = T.clone().cross(this.object.up).normalize(),
          R = P.clone().cross(T).normalize(),
          I = new ze().makeBasis(P, T, R),
          W = new A(Wr.y, Wr.z, Wr.x).normalize(),
          N = W.clone().cross(Wr).normalize(),
          U = new ze().makeBasis(W, Wr, N).invert(),
          G = new ze().multiplyMatrices(I, U);
        m.rotation.setFromRotationMatrix(G),
          S.applyMatrix4(L),
          m.position.add(S),
          (m.rotation.x = m.rotation.x + i.x + M),
          (m.rotation.y = m.rotation.y + i.y + b),
          (m.rotation.z = m.rotation.z + i.z + E),
          m.scale.setScalar(1),
          (m.scale.x = m.scale.x + e.scale[0] + a(_, lt(y, n.scale[0])) || Bi),
          (m.scale.y = m.scale.y + e.scale[1] + a(_, lt(y, n.scale[1])) || Bi),
          (m.scale.z = m.scale.z + e.scale[2] + a(_, lt(y, n.scale[2])) || Bi),
          m.scale.multiply(this.object.scale),
          (m.hiddenMatrix = this.object.hiddenMatrix);
      }
    }
    getSubdivData() {
      if (!this.objectForSample) return [];
      let t = this.parameters.toObject.spreadType;
      if (t === "random") return [];
      if (this.objectForSample instanceof bf) {
        let e = this.objectForSample,
          i = _F[t],
          n = V1[i],
          r = F1[i],
          s = k1[i],
          a = [],
          o = n(e.subdivPointerNew);
        for (let l = 0; l <= o - 1; l++) {
          let c = r(e.subdivPointerNew, l),
            d = s(e.subdivPointerNew, l);
          jv.fromArray(c).applyMatrix4(e.matrixWorld),
            Wv.fromArray(d),
            a.push({ pos: jv.toArray(), norm: Wv.toArray() });
        }
        return a;
      } else
        return (
          this.objectForSample.geometry.index
            ? EF(this.objectForSample.geometry)
            : TF(this.objectForSample.geometry)
        )
          .map((e, i) =>
            t === "polygon_center"
              ? { pos: e.midpoint, norm: e.norm }
              : t === "vertex"
              ? [
                  { pos: e.vertices[0], norm: e.norm },
                  { pos: e.vertices[1], norm: e.norm },
                  { pos: e.vertices[2], norm: e.norm },
                ]
              : t === "edge"
              ? [
                  { pos: e.faceCenters[0], norm: e.norm },
                  { pos: e.faceCenters[1], norm: e.norm },
                  { pos: e.faceCenters[2], norm: e.norm },
                ]
              : []
          )
          .flat();
    }
    updateState(t, e) {
      var i;
      if (((this.parameters = Oh(t)), this.parameters.type !== "toObject"))
        (this.parent === null || this.parent !== this.object) &&
          (this.removeFromParent(),
          (i = this.object.parent) == null || i.add(this),
          (this.matrix = this.object.matrix),
          (this.hiddenMatrix = this.object.hiddenMatrix),
          (this.matrixWorldNeedsUpdate = !0),
          (this.matrixAutoUpdate = !1));
      else if (
        this.parent === null ||
        this.parent.uuid !== this.parameters.toObject.object
      ) {
        this.removeFromParent();
        let n = e.find(this.parameters.toObject.object);
        n instanceof ps
          ? (this.objectForSample = n)
          : (this.objectForSample = void 0),
          (this.matrix = new ze()),
          (this.hiddenMatrix = new ze()),
          (this.matrixWorldNeedsUpdate = !0),
          (this.matrixAutoUpdate = !1),
          n && n.add(this);
      }
      this.update();
    }
    get pendingMediaLoad() {
      return this._pendingMediaLoad;
    }
  },
  El = (t) => {
    var e;
    return (e = class extends t {}), (e.geometryHelper = new $n(30, 30, 30)), e;
  },
  Mc = new oo(),
  nd = new Xn(),
  qv = new ze(),
  Tl = (t, e, i, n, r = !1) => {
    let s = e,
      a = t.matrixWorld;
    if (
      (s.boundingSphere === null && s.computeBoundingSphere(),
      nd.copy(s.boundingSphere),
      nd.applyMatrix4(a),
      i.ray.intersectsSphere(nd) === !1 ||
        (qv.copy(a).invert(),
        Mc.copy(i.ray).applyMatrix4(qv),
        s.boundingBox !== null && Mc.intersectsBox(s.boundingBox) === !1))
    )
      return;
    let o,
      l,
      c,
      d,
      h = s.index,
      u = s.attributes.position,
      f = s.drawRange,
      p,
      v;
    if (r === !1) {
      let m = Math.max(0, f.start),
        x = Math.min(h.count, f.start + f.count);
      for (p = m, v = x; p < v; p += 3)
        if (
          ((l = h.getX(p)),
          (c = h.getX(p + 1)),
          (d = h.getX(p + 2)),
          (o = g(t, i, Mc, u, l, c, d)),
          o)
        ) {
          (o.faceIndex = Math.floor(p / 3)), n.push(o);
          return;
        }
    } else {
      let m = s.attributes.position,
        x = new A(),
        y = new A(),
        _ = new A(),
        M = new A(),
        b = 2,
        E = 1 / ((t.scale.x + t.scale.y + t.scale.z) / 3),
        T = E * E,
        S = Math.max(0, f.start),
        w = Math.min(m.count, f.start + f.count);
      for (let C = S, L = w - 1; C < L; C += b) {
        if (
          (x.fromBufferAttribute(m, C),
          y.fromBufferAttribute(m, C + 1),
          Mc.distanceSqToSegment(x, y, M, _) > T)
        )
          continue;
        M.applyMatrix4(t.matrixWorld);
        let P = i.ray.origin.distanceTo(M);
        P < i.near ||
          P > i.far ||
          n.push({
            distance: P,
            point: _.clone().applyMatrix4(t.matrixWorld),
            object: t,
          });
      }
    }
    function g(m, x, y, _, M, b, E) {
      let T = new A(),
        S = new A(),
        w = new A(),
        C = new A(),
        L = new A();
      if (
        (T.fromBufferAttribute(_, M),
        S.fromBufferAttribute(_, b),
        w.fromBufferAttribute(_, E),
        y.intersectTriangle(T, S, w, !1, C) === null)
      )
        return null;
      L.copy(C), L.applyMatrix4(m.matrixWorld);
      let P = x.ray.origin.distanceTo(L);
      return P < x.near || P > x.far
        ? null
        : { faceIndex: 1, distance: P, point: L.clone(), object: m };
    }
  },
  Ec = new A(),
  vn = new vl(),
  NF = class extends xl {
    constructor(t) {
      let e = new st(),
        i = new Ks({ color: 16777215, vertexColors: !0, toneMapped: !1 }),
        n = [],
        r = [],
        s = {},
        a = new tt(15711266),
        o = new tt(15711266),
        l = new tt(2857471);
      c("n1", "n2", a),
        c("n2", "n4", a),
        c("n4", "n3", a),
        c("n3", "n1", a),
        c("f1", "f2", a),
        c("f2", "f4", a),
        c("f4", "f3", a),
        c("f3", "f1", a),
        c("n1", "f1", a),
        c("n2", "f2", a),
        c("n3", "f3", a),
        c("n4", "f4", a),
        c("p", "n1", o),
        c("p", "n2", o),
        c("p", "n3", o),
        c("p", "n4", o),
        c("u1", "u2", l),
        c("u2", "u3", l),
        c("u3", "u1", l);
      function c(h, u, f) {
        d(h, f), d(u, f);
      }
      function d(h, u) {
        n.push(0, 0, 0),
          r.push(u.r, u.g, u.b),
          s[h] === void 0 && (s[h] = []),
          s[h].push(n.length / 3 - 1);
      }
      e.setAttribute("position", new We(n, 3)),
        e.setAttribute("color", new We(r, 3)),
        super(e, i),
        (this.type = "CameraHelper"),
        (this.camera = t),
        this.camera.updateProjectionMatrix &&
          this.camera.updateProjectionMatrix(),
        (this.matrix = t.matrixWorld),
        (this.matrixAutoUpdate = !1),
        (this.pointMap = s),
        this.update();
    }
    update() {
      let t = this.geometry,
        e = this.pointMap;
      vn.projectionMatrixInverse.elements = [
        0.5112609807824982, -0, -0, -0, -0, 0.41421356237309503, -0, -0, -0, -0,
        -0, -0.099999, -0, -0, -1.0000000000000002, 0.100001,
      ];
      let i = 1,
        n = 1,
        r = 0.8;
      Un("n1", e, t, vn, -i, -n, r),
        Un("n2", e, t, vn, i, -n, r),
        Un("n3", e, t, vn, -i, n, r),
        Un("n4", e, t, vn, i, n, r);
      let s = r;
      Un("f1", e, t, vn, -i, -n, s),
        Un("f2", e, t, vn, i, -n, s),
        Un("f3", e, t, vn, -i, n, s),
        Un("f4", e, t, vn, i, n, s);
      let a = s,
        o = 0.5;
      Un("u1", e, t, vn, i * 0.7 * o, n * 1.1, a),
        Un("u2", e, t, vn, -i * 0.7 * o, n * 1.1, a),
        Un("u3", e, t, vn, 0, n * (1.1 + 0.9 * o), a),
        (t.getAttribute("position").needsUpdate = !0);
    }
    dispose() {
      this.geometry.dispose(), this.material.dispose();
    }
  };
function Un(t, e, i, n, r, s, a) {
  Ec.set(r, s, a).unproject(n);
  let o = e[t];
  if (o !== void 0) {
    let l = i.getAttribute("position");
    for (let c = 0, d = o.length; c < d; c++) l.setXYZ(o[c], Ec.x, Ec.y, Ec.z);
  }
}
var zF = class extends El(NF) {
    constructor(t) {
      super(t),
        (this.object = t),
        (this.object = t),
        (this.name = `CombinedCameraHelper: ${t.uuid}`);
    }
    updateMatrixWorld(t) {
      super.updateMatrixWorld(t), this.updateTarget();
    }
    updateTarget() {
      let t = this.object.getTarget();
      this.updateWorldMatrix(!0, !1), this.worldToLocal(t);
    }
    raycast(t, e) {
      Tl(this.object, this.geometry, t, e, !0);
    }
  },
  wf;
((t) => (t.is = (e) => "objectHelper" in e))(wf || (wf = {}));
var Al = (t, e) =>
    class extends Dp(t) {
      constructor() {
        super(...arguments),
          (this.objectHelper = new e(this)),
          (this.gizmos = {});
      }
      get geometryHelper() {
        return e.geometryHelper;
      }
      raycast(i, n) {
        this.objectHelper.raycast(i, n);
      }
      showGizmos() {
        for (let i in this.gizmos) {
          let n = this.gizmos[i];
          n instanceof Wc && (n.visible = !0);
        }
      }
      updateEntityBoxSize(i, n) {
        this.objectHelper.visible && this.geometryHelper instanceof $n
          ? (i.setScalar(0),
            n
              .set(
                this.geometryHelper.parameters.width,
                this.geometryHelper.parameters.height,
                this.geometryHelper.parameters.height
              )
              .multiplyScalar(0.5))
          : super.updateEntityBoxSize(i, n);
      }
      hideGizmos() {
        for (let i in this.gizmos) {
          let n = this.gizmos[i];
          n instanceof Wc && (n.visible = !1);
        }
      }
    },
  Tc = 790,
  Sa = new A(),
  rd = new A(),
  sd = new Zs(),
  ad = new A(),
  zo = new A(),
  od = new A(),
  Xp = class extends Al(vl, zF) {
    constructor(t = "", e = { ...pl.defaultData, name: "" }) {
      super(),
        (this._cameraType = "OrthographicCamera"),
        (this.targetOffset = to.DefaultTargetOffset),
        (this.isUpVectorFlipped = !1),
        (this.angleOffsetFromUp = 0),
        (this.wasMovedByUser = !1),
        (this.wasMovedBySwitchCameraAction = !1),
        this.super_Entity(t, e),
        (this.previousProjectionMatrix = new ze()),
        (this.matrixAutoUpdate = !0),
        (this.width = window.innerWidth),
        (this.height = window.innerHeight);
      let i = this.width,
        n = this.height;
      (this.orthoCamera = new _h(
        i * -0.5,
        i * 0.5,
        n * 0.5,
        n * -0.5,
        -5e4,
        1e4
      )),
        (this.perspCamera = new ji(45, i / n, 50, 1e4)),
        (this.left = this.orthoCamera.left),
        (this.right = this.orthoCamera.right),
        (this.top = this.orthoCamera.top),
        (this.bottom = this.orthoCamera.bottom),
        (this.far = this.orthoCamera.far),
        (this.view = this.orthoCamera.view),
        (this.aspect = this.perspCamera.aspect),
        (this.focus = this.perspCamera.focus),
        (this.filmGauge = this.perspCamera.filmGauge),
        (this.filmOffset = this.perspCamera.filmOffset),
        this.objectHelper.update();
    }
    get isPerspectiveCamera() {
      return this.cameraType === "PerspectiveCamera";
    }
    get isOrthographicCamera() {
      return !this.isPerspectiveCamera;
    }
    get cameraType() {
      return this._cameraType;
    }
    set fov(t) {
      this.perspCamera.fov = t;
    }
    get fov() {
      return this.perspCamera.fov;
    }
    setNear(t, e) {
      t === "PerspectiveCamera"
        ? (this.perspCamera.near = e)
        : (this.orthoCamera.near = e);
    }
    setZoom(t, e) {
      e >= 0 &&
        (t === "PerspectiveCamera"
          ? (this.perspCamera.zoom = e)
          : (this.orthoCamera.zoom = e));
    }
    set cameraType(t) {
      t === "PerspectiveCamera"
        ? this.toPerspective()
        : t === "OrthographicCamera" && this.toOrthographic();
    }
    get near() {
      return this._cameraType === "PerspectiveCamera"
        ? this.perspCamera.near
        : this.orthoCamera.near;
    }
    set near(t) {
      this._cameraType === "PerspectiveCamera"
        ? (this.perspCamera.near = t)
        : (this.orthoCamera.near = t);
    }
    get zoom() {
      return this._cameraType === "PerspectiveCamera"
        ? this.perspCamera.zoom
        : this.orthoCamera.zoom;
    }
    set zoom(t) {
      t >= 0 &&
        (this._cameraType === "PerspectiveCamera"
          ? (this.perspCamera.zoom = t)
          : (this.orthoCamera.zoom = t));
    }
    lookAt(t, e, i) {
      typeof t == "number" && (t = new A(t, e, i)),
        super.lookAt(t),
        this.getWorldPosition(Sa),
        (this.targetOffset = Sa.distanceTo(t));
    }
    getTarget(t = new A()) {
      return (
        this.getWorldDirection(rd),
        this.getWorldPosition(Sa),
        rd.multiplyScalar(this.targetOffset),
        t.copy(Sa).add(rd),
        t
      );
    }
    getDistanceToTarget() {
      let t = this.getTarget();
      return this.getWorldPosition(Sa), Sa.distanceTo(t);
    }
    updateUp() {
      this.getWorldQuaternion(sd),
        ad.set(0, 0, 1).applyQuaternion(sd),
        zo.copy(Ht.DEFAULT_UP),
        this.isUpVectorFlipped && zo.negate(),
        zo.applyQuaternion(sd),
        od.copy(Ht.DEFAULT_UP).projectOnPlane(ad),
        (this.angleOffsetFromUp = od.angleTo(zo)),
        (this.angleOffsetFromUp *= od.cross(zo).dot(ad) >= 0 ? 1 : -1);
    }
    updateTransformState(t) {
      let e = super.updateTransformState(t);
      return (
        t.isUpVectorFlipped !== void 0 &&
          (this.isUpVectorFlipped = t.isUpVectorFlipped),
        this.updateUp(),
        e
      );
    }
    getViewFrontToObject(t) {
      let e = t.getWorldPosition(new A()),
        i = t.getWorldDirection(new A()).multiplyScalar(this.targetOffset);
      return { position: e.clone().add(i), target: e };
    }
    getViewToTarget(t) {
      let e = this.getWorldDirection(new A()).multiplyScalar(this.targetOffset);
      return { position: t.clone().sub(e), target: t };
    }
    getViewToObject(t) {
      let e = new A();
      return t.getWorldPosition(e), this.getViewToTarget(e);
    }
    setViewplaneSize(t, e, i = !1) {
      if (((this.aspect = t / e), i)) {
        let n = t > e ? this.aspect : 1,
          r = t > e ? 1 : this.aspect;
        (this.left = -Tc * 0.5 * n),
          (this.right = Tc * 0.5 * n),
          (this.top = Tc * 0.5 * (1 / r)),
          (this.bottom = -Tc * 0.5 * (1 / r));
      } else
        (this.left = -t * 0.5),
          (this.right = t * 0.5),
          (this.top = e * 0.5),
          (this.bottom = -e * 0.5);
      this.updateProjectionMatrix();
    }
    copyViewPlaneSize(t) {
      (this.aspect = t.aspect),
        (this.left = t.left),
        (this.right = t.right),
        (this.top = t.top),
        (this.bottom = t.bottom),
        this.updateProjectionMatrix();
    }
    toOrthographic() {
      (this.orthoCamera.left = this.left),
        (this.orthoCamera.right = this.right),
        (this.orthoCamera.top = this.top),
        (this.orthoCamera.bottom = this.bottom),
        (this.orthoCamera.view = this.view),
        (this.orthoCamera.far = this.far),
        this.orthoCamera.updateProjectionMatrix(),
        (this.projectionMatrix = this.orthoCamera.projectionMatrix),
        (this.projectionMatrixInverse =
          this.orthoCamera.projectionMatrixInverse),
        (this._cameraType = "OrthographicCamera"),
        this.objectHelper && this.objectHelper.update();
    }
    toPerspective() {
      (this.perspCamera.aspect = this.aspect),
        (this.perspCamera.fov = this.fov),
        (this.perspCamera.view = this.view),
        (this.perspCamera.far = this.far),
        this.perspCamera.updateProjectionMatrix(),
        (this.projectionMatrix = this.perspCamera.projectionMatrix),
        (this.projectionMatrixInverse =
          this.perspCamera.projectionMatrixInverse),
        (this._cameraType = "PerspectiveCamera"),
        this.objectHelper && this.objectHelper.update();
    }
    setFocalLength(t) {
      this.perspCamera.setFocalLength(t), this.toPerspective();
    }
    getFocalLength() {
      return this.perspCamera.getFocalLength();
    }
    getEffectiveFOV() {
      return this.perspCamera.getEffectiveFOV();
    }
    getFilmWidth() {
      return this.perspCamera.getFilmWidth();
    }
    getFilmHeight() {
      return this.perspCamera.getFilmHeight();
    }
    setViewOffset(t, e, i, n, r, s) {
      this._cameraType === "PerspectiveCamera"
        ? this.perspCamera.setViewOffset(t, e, i, n, r, s)
        : this.orthoCamera.setViewOffset(t, e, i, n, r, s);
    }
    clearViewOffset() {
      this._cameraType === "PerspectiveCamera"
        ? (this.perspCamera.clearViewOffset(), this.toPerspective())
        : (this.orthoCamera.clearViewOffset(), this.toOrthographic());
    }
    copyHistory() {
      this.previousProjectionMatrix &&
        this.previousProjectionMatrix.copy(this.projectionMatrix);
    }
    updateProjectionMatrix() {
      this._cameraType === "PerspectiveCamera"
        ? this.toPerspective()
        : this._cameraType === "OrthographicCamera" && this.toOrthographic();
    }
    updateMatrixWorld(t) {
      super.updateMatrixWorld(t),
        this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
    updateWorldMatrix(t, e) {
      super.updateWorldMatrix(t, e),
        this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
    copy(t, e) {
      return (
        super.copy(t, e),
        (this.parent = t.parent),
        this.orthoCamera.copy(t.orthoCamera),
        this.perspCamera.copy(t.perspCamera),
        (this.left = t.left),
        (this.right = t.right),
        (this.top = t.top),
        (this.bottom = t.bottom),
        (this.far = t.far),
        (this.view = t.view === null ? null : Object.assign({}, t.view)),
        (this._cameraType = t._cameraType),
        (this.aspect = t.aspect),
        (this.fov = t.fov),
        (this.focus = t.focus),
        (this.filmGauge = t.filmGauge),
        (this.filmOffset = t.filmOffset),
        (this.targetOffset = t.targetOffset),
        this.updateProjectionMatrix(),
        this
      );
    }
    toCameraState(t = []) {
      let e = {
        type: this.cameraType,
        far: this.far,
        orthographic: {
          near: this.orthoCamera.near,
          zoom: this.orthoCamera.zoom,
        },
        perspective: {
          near: this.perspCamera.near,
          fov: this.perspCamera.fov,
          zoom: this.perspCamera.zoom,
        },
        up: this.up.toArray(),
        targetOffset: this.targetOffset,
        isUpVectorFlipped: this.isUpVectorFlipped,
      };
      return Ld(e, t);
    }
    updateCameraSubtype(t, e) {
      let i = t === "perspective" ? "PerspectiveCamera" : "OrthographicCamera";
      e.zoom !== void 0 && this.setZoom(i, e.zoom),
        e.near !== void 0 && this.setNear(i, e.near),
        e.fov !== void 0 && i === "PerspectiveCamera" && (this.fov = e.fov);
    }
    updateState(t, e) {
      this.updateCameraState(t, e);
    }
    updateCameraState(t, e) {
      this.updateState_Entity(t, e),
        t.far !== void 0 && (this.far = t.far),
        t.orthographic !== void 0 &&
          this.updateCameraSubtype("orthographic", t.orthographic),
        t.perspective !== void 0 &&
          this.updateCameraSubtype("perspective", t.perspective),
        t.type !== void 0 && (this.cameraType = t.type),
        t.up !== void 0 && this.up.fromArray(t.up),
        t.targetOffset !== void 0 && (this.targetOffset = t.targetOffset),
        t.isUpVectorFlipped !== void 0 &&
          (this.isUpVectorFlipped = t.isUpVectorFlipped),
        this.updateProjectionMatrix();
    }
    updateByPatchedOp(t, e, i) {
      super.updateByPatchedOp(t, e, i),
        t.path.length === 1 &&
          t.type === 0 &&
          this.updateCameraSubtype(t.path[0], t.props);
    }
    toState(t) {
      return {
        ...super.toState(t),
        ...this.toCameraState(t),
        type: this.cameraType,
      };
    }
  },
  Ma = new ze(),
  BF = new ze(),
  ao = class extends ia {
    constructor(t, e, i) {
      super(t, e),
        (this.data = e),
        (this.meshSetAddresses = []),
        (this.needsTransformForDownstream = !1),
        (this.geometry = new st()),
        (this.onAfterRender = (n, r, s, a, o, l) => {
          super.onAfterRender(n, r, s, a, o, l), this.recomputeBoolean();
        }),
        (this.geometry.userData.parameters = { width: 0, height: 0, depth: 0 });
    }
    get booleanOp() {
      return this.data.geometry.operation;
    }
    get phongAngle() {
      return this.data.geometry.phongAngle ?? 45;
    }
    get isLOD() {
      return this.recomputeBoolean(), !1;
    }
    updateByPatchedOp(t, e, i) {
      super.updateByPatchedOp(t, e, i),
        t.path.length === 1 &&
          t.path[0] === "geometry" &&
          t.type === 0 &&
          t.props.operation !== void 0 &&
          (this.freeBooleanPointer(), this.resetBBoxNeedsUpdate());
    }
    freeBooleanPointer() {
      super.freeBooleanPointer(), this.geometry.dispose();
    }
    recomputeBoolean(t, e = !0) {
      var n;
      if (this.booleanMeshSetAddress !== -1 && !t) return;
      for (let r = 0; r < this.children.length; r++) {
        let s = this.children[r];
        s instanceof ao &&
          s.dataPatched.visible === !0 &&
          s.recomputeBoolean(t === !0, e);
      }
      this.meshSetAddresses = [];
      for (let r = 0; r < this.children.length; r++) {
        let s = this.children[r];
        if (
          s instanceof ps &&
          s.dataPatched.visible === !0 &&
          ((n = s.geometry.attributes.position) == null ? void 0 : n.count) >
            0 &&
          s.geometry.drawRange.count > 0
        ) {
          if (
            (Ma.multiplyMatrices(s.hiddenMatrix, s.matrix),
            s.booleanMeshSetAddress === -1)
          ) {
            if (
              ((s.geometry.index ?? s.geometry.getAttribute("position")).count /
                3 <
                15e5 &&
                (s.booleanMeshSetAddress = Ar.getMeshSet(
                  s.geometry,
                  t === !0,
                  e
                )),
              s.booleanMeshSetAddress === -1)
            )
              return;
            Ar.transformMeshSet(s.booleanMeshSetAddress, Ma),
              s.booleanMatrixInvOld.copy(Ma).invert(),
              (s.booleanWasTransformed = !1);
          } else
            s instanceof ao && s.needsTransformForDownstream === !0
              ? (Ar.transformMeshSet(s.booleanMeshSetAddress, Ma),
                (s.needsTransformForDownstream = !1))
              : s.booleanWasTransformed === !0 &&
                (Ar.transformMeshSet(
                  s.booleanMeshSetAddress,
                  BF.multiplyMatrices(Ma, s.booleanMatrixInvOld)
                ),
                s.booleanMatrixInvOld.copy(Ma).invert(),
                (s.booleanWasTransformed = !1));
          Ar.hasOpenEdges(s.booleanMeshSetAddress) === !1 ||
          (r === this.children.length - 1 && this.booleanOp === 2)
            ? (this.meshSetAddresses.push(s.booleanMeshSetAddress),
              (s.geometry.userData.wasFilteredFromBoolean = !1))
            : (s.geometry.userData.wasFilteredFromBoolean = !0);
        }
      }
      if (this.meshSetAddresses.length === 0) {
        this.geometry.setAttribute("position", new We([], 0)),
          this.geometry.setDrawRange(0, 0);
        return;
      }
      if (t === !0)
        return Ar.calcBooleanTopological(this.meshSetAddresses, this.booleanOp);
      let i = this.geometry;
      i.dispose(),
        (this.geometry = new st()),
        (this.geometry.userData = i.userData),
        (this.geometry.boundingSphere = i.boundingSphere);
      try {
        this.booleanMeshSetAddress = Ar.calcBoolean(
          this.meshSetAddresses,
          this.booleanOp,
          this.geometry,
          this.phongAngle
        );
      } catch (r) {
        (this.booleanMeshSetAddress = 0), console.error(r);
      }
      this.booleanMatrixInvOld.copy(this.matrix).invert(),
        (this.needsTransformForDownstream = !0),
        Wp(this),
        qp(this);
    }
    dispose() {
      super.dispose(), this.geometry.dispose();
    }
  },
  Xv;
((t) => {
  function e(i) {
    return Bt.is(i) && i instanceof bl;
  }
  t.is = e;
})(Xv || (Xv = {}));
var $p = (t, e) =>
    class extends Al(t, e) {
      updateState_Light(i, n) {
        this.updateState_Entity(i, n),
          i.color !== void 0 && (this.color = n.shared.color(i.color)),
          i.intensity !== void 0 && (this.intensity = i.intensity),
          i.depth !== void 0 &&
            ((this.shadow.camera.far = i.depth),
            (this.shadow.needsUpdate = !0)),
          i.shadows !== void 0 && (this.castShadow = i.shadows);
      }
    },
  Ca = (t) => t instanceof ps,
  Ac = (t) => t !== null && t instanceof ao,
  Sf = (t) => wf.is(t),
  Vh = class extends El(XA) {
    constructor(t, e = 15) {
      super(e),
        (this.object = t),
        this.object.updateMatrixWorld(),
        (this.name = `EmptyObjectHelper: ${t.uuid}`),
        (this.matrix = t.matrixWorld),
        (this.matrixAutoUpdate = !1),
        this.object.isBone && (this.visible = !1);
    }
    raycast(t, e) {
      Tl(this.object, Vh.geometryHelper, t, e);
    }
    update() {}
  },
  $v = class extends Al(Da, Vh) {
    constructor(t, e) {
      super(), this.super_Entity(t, e), this.objectHelper.update();
    }
    updateState(t, e) {
      this.updateState_Entity(t, e);
    }
  },
  FF = (t) => `

// PCSS implementation based on:
// https://www.gamedev.net/articles/programming/graphics/contact-hardening-soft-shadows-made-fast-r4906/
// NOTE: This number affects how big the shadow blur can
// possibly get. Bigger number == bigger blur, but less precise results

const float  gPenumbraFilterSize = 80.0;
const int   gPenumbraSamples = ${t};
const int gShadowSamples = ${t};
const float gShadowSamplesRpc = 1.0f / float(gShadowSamples);

#ifdef USE_SHADOWMAP
    #if NUM_DIR_LIGHT_SHADOWS > 0

        uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
        varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];

        struct DirectionalLightShadow {
            float shadowBias;
            float shadowNormalBias;
            float shadowRadius;
            vec2 shadowMapSize;
        };

        uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];

    #endif

    #if NUM_SPOT_LIGHT_SHADOWS > 0

        uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
        varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_SHADOWS ];

        struct SpotLightShadow {
            float shadowBias;
            float shadowNormalBias;
            float shadowRadius;
            vec2 shadowMapSize;
        };

        uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];

    #endif

    #if NUM_POINT_LIGHT_SHADOWS > 0

        uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
        varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];

        struct PointLightShadow {
            float shadowBias;
            float shadowNormalBias;
            float shadowRadius;
            vec2 shadowMapSize;
            float shadowCameraNear;
            float shadowCameraFar;
        };

        uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];

    #endif

    /*
    #if NUM_RECT_AREA_LIGHTS > 0

        // TODO (abelnation): create uniforms for area light shadows

    #endif
    */

float computePenumbra(int index, sampler2D shadowMap, float temporalAngle, float texelSize, vec2 uv, float compare, float texelScalar, float shadowRadius)
{
    float penumbra = 1.0;
    float blockerDepthAvg = 0.0;
    float blockerCount = 0.0;

    #pragma unroll_loop_start
    for(int i = 0; i < gPenumbraSamples; i ++)
    {
        vec2 offset = (vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize) * texelScalar;
        float depth = unpackRGBAToDepth( texture2D( shadowMap, uv + offset ) );

        if(depth < compare + 0.0001)
        {
            blockerDepthAvg += depth;
            blockerCount++;
        }
    }
    #pragma unroll_loop_end

    if (blockerCount > 0.0)
    {
        blockerDepthAvg /= blockerCount;

        // Compute penumbra
        penumbra = (compare - blockerDepthAvg) / (blockerDepthAvg);
        penumbra *= penumbra;
        penumbra *= 200.0 * penumbraSize[min(index, 5 - 1)]; // Magic number that affects how quickly the penumbra grows

        return clamp(penumbra, 0.00, 1.0);
    }
    return 0.0;
}

float vogelShadow(int index, sampler2D shadowMap, vec2 uv, float texelSize, float compare, float shadowRadius)
{
    float shadow         = 0.0f;

    // NOTE: When using TAA, we should use screen space interleaved gradient noise
    vec2 halton = haltonSequence[frameIndex];
    float temporalOffset = getNoiseInterleavedGradient(gl_FragCoord.xy + halton);
    float temporalAngle  = temporalOffset * PI2;

    float texelScalar = (gPenumbraFilterSize) / (texelSize * 1024.);
    float penumbra = computePenumbra(index, shadowMap, temporalAngle, texelSize, uv, compare, texelScalar, shadowRadius);
    if (penumbra == -1.0) {
        return 1.0;
    }

    #pragma unroll_loop_start
    for (int i = 0; i < gShadowSamples; i++)
    {
        vec2 vogelSample =  vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize;
        // Overall blurring offset
        vec2 offset = vogelSample * (shadowRadius * 2.);

        // Penumbra offset
        offset += vogelSample * (penumbra * texelScalar);

        shadow += step( compare, unpackRGBAToDepth( texture2D( shadowMap, uv + offset ) ) );
    }
    #pragma unroll_loop_end

    return shadow * gShadowSamplesRpc;
}


    float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {

        return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );

    }

    vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {

        return unpackRGBATo2Half( texture2D( shadow, uv ) );

    }

    float VSMShadow (sampler2D shadow, vec2 uv, float compare ){

        float occlusion = 1.0;

        vec2 distribution = texture2DDistribution( shadow, uv );

        float hard_shadow = step( compare , distribution.x ); // Hard Shadow

        if (hard_shadow != 1.0 ) {

            float distance = compare - distribution.x ;
            float variance = max( 0.00000, distribution.y * distribution.y );
            float softness_probability = variance / (variance + distance * distance ); // Chebeyshevs inequality
            softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 ); // 0.3 reduces light bleed
            occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );

        }
        return occlusion;

    }

    float getShadow( int i, sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {

        float shadow = 1.0;

        shadowCoord.xyz /= shadowCoord.w;
        shadowCoord.z += shadowBias;

        // if ( something && something ) breaks ATI OpenGL shader compiler
        // if ( all( something, something ) ) using this instead

        bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
        bool inFrustum = all( inFrustumVec );

        bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );

        bool frustumTest = all( frustumTestVec );

        if ( frustumTest ) {

        #if defined( SHADOWMAP_TYPE_PCF )

            vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
            return vogelShadow(i, shadowMap, shadowCoord.xy, texelSize.x, shadowCoord.z, shadowRadius );

        #elif defined( SHADOWMAP_TYPE_PCF_SOFT )

            vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
            float dx = texelSize.x;
            float dy = texelSize.y;

            vec2 uv = shadowCoord.xy;
            vec2 f = fract( uv * shadowMapSize + 0.5 );
            uv -= f * texelSize;

            shadow = (
                texture2DCompare( shadowMap, uv, shadowCoord.z ) +
                texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
                texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
                texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
                mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
                     texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
                     f.x ) +
                mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
                     texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
                     f.x ) +
                mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
                     texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
                     f.y ) +
                mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
                     texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
                     f.y ) +
                mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
                          texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
                          f.x ),
                     mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
                          texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
                          f.x ),
                     f.y )
            ) * ( 1.0 / 9.0 );

        #elif defined( SHADOWMAP_TYPE_VSM )

            shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );

        #else // no percentage-closer filtering:

            shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );

        #endif

        }

        return shadow;

    }

    // cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D
    // vector suitable for 2D texture mapping. This code uses the following layout for the
    // 2D texture:
    //
    // xzXZ
    //  y Y
    //
    // Y - Positive y direction
    // y - Negative y direction
    // X - Positive x direction
    // x - Negative x direction
    // Z - Positive z direction
    // z - Negative z direction
    //
    // Source and test bed:
    // https://gist.github.com/tschw/da10c43c467ce8afd0c4

    vec2 cubeToUV( vec3 v, float texelSizeY ) {

        // Number of texels to avoid at the edge of each square

        vec3 absV = abs( v );

        // Intersect unit cube

        float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
        absV *= scaleToCube;

        // Apply scale to avoid seams

        // two texels less per square (one texel will do for NEAREST)
        v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );

        // Unwrap

        // space: -1 ... 1 range for each square
        //
        // #X##         dim    := ( 4 , 2 )
        //  # #         center := ( 1 , 1 )

        vec2 planar = v.xy;

        float almostATexel = 1.5 * texelSizeY;
        float almostOne = 1.0 - almostATexel;

        if ( absV.z >= almostOne ) {

            if ( v.z > 0.0 )
                planar.x = 4.0 - v.x;

        } else if ( absV.x >= almostOne ) {

            float signX = sign( v.x );
            planar.x = v.z * signX + 2.0 * signX;

        } else if ( absV.y >= almostOne ) {

            float signY = sign( v.y );
            planar.x = v.x + 2.0 * signY + 2.0;
            planar.y = v.z * signY - 2.0;

        }

        // Transform to UV space

        // scale := 0.5 / dim
        // translate := ( center + 0.5 ) / dim
        return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );

    }

    float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {

        float shadow = 1.0;
        vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );

        // for point lights, the uniform @vShadowCoord is re-purposed to hold
        // the vector from the light to the world-space position of the fragment.
        vec3 lightToPosition = shadowCoord.xyz;

        // dp = normalized distance from light to fragment position
        float compare = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear ); // need to clamp?
        compare += shadowBias;

        // bd3D = base direction 3D
        vec3 bd3D = normalize( lightToPosition );

        vec2 halton = haltonSequence[frameIndex];
        float temporalOffset = getNoiseInterleavedGradient(gl_FragCoord.xy + halton);
        float temporalAngle  = temporalOffset * PI2;

        #if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_VSM )
            for (int i = 0; i < gShadowSamples; i++) {
                vec2 vogelSample = vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize;

                // Overall blurring offset
                vec3 offset = vec3(vogelSample.x, vogelSample.y, -vogelSample.x) * (shadowRadius + 5.);

                // NOTE: Removed for now
                // Penumbra offset
                //offset += vec3(vogelSample.x, vogelSample.y, vogelSample.y)  * (penumbra * gPenumbraFilterSize);

                shadow += texture2DCompare( shadowMap, cubeToUV( bd3D + offset, texelSize.y ), compare );

            }
            return shadow * gShadowSamplesRpc;

        #elif defined( SHADOWMAP_TYPE_PCF_SOFT )
            for (int i = 0; i < 16; i++) {
                vec2 vogelSample = vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize;

                // Overall blurring offset
                vec3 offset = vec3(vogelSample.x, vogelSample.y, -vogelSample.x) * (shadowRadius + 5.);

                shadow += texture2DCompare( shadowMap, cubeToUV( bd3D + offset, texelSize.y ), compare );

            }
            return shadow * (1.0 / 16.0);
        #else // no percentage-closer filtering

            return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), compare );

        #endif

    }

#endif
`,
  kF = ct.lights_fragment_begin,
  VF = ct.shadowmask_pars_fragment,
  Yv = null,
  HF = (t) => {
    switch (t) {
      case "low":
        return 8;
      case "medium":
        return 16;
      case "high":
        return 32;
      default:
        return 16;
    }
  },
  GF = (t = "medium") => {
    if (Yv === t) return !1;
    Yv = t;
    let e = HF(t);
    ct.shadowmap_pars_fragment = FF(e);
    let i = kF.slice();
    (i = i.replace(
      "getShadow( spotShadowMap[ i ]",
      "getShadow( UNROLLED_LOOP_INDEX + 3, spotShadowMap[ i ]"
    )),
      (i = i.replace(
        "getShadow( directionalShadowMap[ i ]",
        "getShadow( UNROLLED_LOOP_INDEX, directionalShadowMap[ i ]"
      )),
      (ct.lights_fragment_begin = i);
    let n = VF.slice();
    return (
      (n = n.replaceAll("getShadow(", "getShadow( UNROLLED_LOOP_INDEX, ")),
      (ct.shadowmask_pars_fragment = n),
      !0
    );
  },
  G1 = class extends El(qA) {
    constructor(t, e = 15, i = 10066329) {
      super(t, e, i),
        (this.object = t),
        (this.added = !1),
        (this.name = `DirectionalLightHelper: ${t.uuid}`);
    }
    raycast(t, e) {
      Tl(this.object, G1.geometryHelper, t, e);
    }
  },
  j1 = class extends El(Cx) {
    constructor(t, e = 15, i = 6710886) {
      super(t, e, i),
        (this.object = t),
        (this.name = `PointLightHelper: ${t.uuid}`);
    }
    raycast(t, e) {
      Tl(this.object, j1.geometryHelper, t, e);
    }
  },
  Mf = class extends El(WA) {
    constructor(t, e = 6710886) {
      super(t, e),
        (this.object = t),
        (this.name = `SpotLightHelper: ${t.uuid}`);
    }
    raycast(t, e) {
      Tl(this.object, Mf.geometryHelper, t, e);
    }
    update() {
      if (this.object !== void 0) {
        let t = Mf._vector,
          e = this.object.distance ? this.object.distance : 1e3,
          i = e * Math.tan(this.object.angle);
        this.cone.scale.set(i, i, e),
          t.setFromMatrixPosition(this.object.target.matrixWorld),
          this.cone.lookAt(t);
        let n = this.color !== void 0 ? this.color : this.light.color;
        if (this.cone.material instanceof Array)
          for (let r = 0, s = this.cone.material.length; r < s; r++)
            this.cone.material[r].color.set(n);
        else this.cone.material.color.set(n);
      }
    }
  },
  W1 = Mf;
W1._vector = new A();
function jF(t, e) {
  (t.shadow.camera.right = e / 2),
    (t.shadow.camera.left = -e / 2),
    (t.shadow.camera.top = e / 2),
    (t.shadow.camera.bottom = -e / 2),
    (t.shadow.needsUpdate = !0);
}
var q1 = class extends $p(kA, G1) {
    constructor(t, e, i) {
      super(),
        this.super_Entity(t, e),
        (this.castShadow = !0),
        (this.shadow.mapSize.width = 2048),
        (this.shadow.mapSize.height = 2048),
        (this.shadow.normalBias = 1),
        this.layers.enable(3);
      let n = this.shadow.camera;
      (n.top = 1250),
        (n.bottom = -1250),
        (n.right = 1250),
        (n.left = -1250),
        (n.near = -1e4),
        (n.far = 2500);
      let r = new jc(this.shadow.camera);
      (r.visible = !1), (this.gizmos.shadowmap = r);
    }
    update() {
      this.shadow.camera.updateProjectionMatrix();
      for (let t in this.gizmos) {
        let e = this.gizmos[t];
        e instanceof jc && e.update();
      }
    }
    updateMatrixWorld(t) {
      super.updateMatrixWorld(t),
        this.objectHelper && this.objectHelper.update();
    }
    updateState(t, e) {
      this.updateState_Light(t, e);
      let i =
        (t.depth !== void 0 && t.depth !== this.shadow.camera.far) ||
        (t.size !== void 0 && t.size / 2 !== this.shadow.camera.right);
      t.size !== void 0 && jF(this, t.size),
        t.shadowRadius !== void 0 && (this.shadow.radius = t.shadowRadius),
        t.shadowResolution !== void 0 &&
          (this.shadow.mapSize.set(t.shadowResolution, t.shadowResolution),
          this.shadow.map &&
            (this.shadow.map.dispose(), (this.shadow.map = null))),
        t.penumbraSize !== void 0 && e.scene.markPenumbraSizeDirty(),
        i && this.update();
    }
  },
  Zv = new A(),
  Kv = new A(),
  Jv = new Zs(),
  X1 = class extends $p(zA, W1) {
    constructor(t, e, i) {
      super(),
        this.super_Entity(t, e),
        (this.castShadow = !0),
        (this.shadow.mapSize.width = 1024),
        (this.shadow.mapSize.height = 1024),
        (this.shadow.normalBias = 1),
        this.layers.enable(3);
      let n = this.shadow.camera;
      (n.fov = Jt.RAD2DEG * 2 * this.angle),
        (n.aspect = 1),
        (n.near = 100),
        (n.far = 2500);
      let r = new jc(this.shadow.camera);
      (r.visible = !1), (this.gizmos.shadowmap = r), this.update();
    }
    update() {
      this.shadow.camera.updateProjectionMatrix();
      for (let t in this.gizmos) {
        let e = this.gizmos[t];
        e instanceof jc && e.update();
      }
    }
    updateMatrixWorld(t) {
      super.updateMatrixWorld(t),
        Kv.setFromMatrixPosition(this.matrixWorld),
        Jv.setFromRotationMatrix(this.matrixWorld),
        Zv.copy(this.up)
          .applyQuaternion(Jv)
          .negate()
          .multiplyScalar(this.distance),
        this.target.position.copy(Kv).add(Zv),
        this.target.updateMatrixWorld(),
        this.objectHelper && this.objectHelper.update();
    }
    updateState(t, e) {
      this.updateState_Light(t, e),
        t.distance !== void 0 && (this.distance = t.distance),
        t.decay !== void 0 && (this.decay = t.decay),
        t.angle !== void 0 && (this.angle = t.angle),
        t.penumbra !== void 0 && (this.penumbra = t.penumbra),
        t.shadowRadius !== void 0 && (this.shadow.radius = t.shadowRadius),
        t.penumbraSize !== void 0 && e.scene.markPenumbraSizeDirty(),
        t.shadowResolution !== void 0 &&
          (this.shadow.mapSize.set(t.shadowResolution, t.shadowResolution),
          this.shadow.map &&
            (this.shadow.map.dispose(), (this.shadow.map = null)));
    }
  },
  Uc = class extends Dp(qf) {
    constructor(t, e) {
      super(),
        (this.data = e),
        (this.bgColor = new Wn(1, 1, 1, 1)),
        (this.fog = null),
        (this.backupFog = new Wf(16777215, 0.1, 2e3)),
        (this.fogUseBGColor = !1),
        (this.isActive = !1),
        (this.aoColor = new tt()),
        (this.penumbraSizeArrayCache = null),
        this.super_Entity(t, e),
        (this.personalCamera = new Xp(Fh, {
          ...pl.defaultData,
          ...e.camera,
          name: "Personal Camera",
        })),
        (this.personalCamera.objectHelper.visible = !1),
        this.add(this.personalCamera),
        (this.activeCamera = this.personalCamera),
        (this.ambientLight = new UA(13882323, 8553090, 0.75)),
        (this.ambientLight.name = "Default Ambient Light"),
        this.ambientLight.layers.enable(3),
        this.ambientLight.removeFromParent(),
        this.add(this.ambientLight);
    }
    get scene() {
      return this.parent;
    }
    get postprocessing() {
      return this.data.postprocessing;
    }
    updateVisible() {}
    setBackgroundColor(t) {
      (this.bgColor = t),
        this.fogUseBGColor === !0 && (this.backupFog.color = t);
    }
    updateAmbientLight(t, e) {
      t.color !== void 0 && (this.ambientLight.color = qi(t.color, e)),
        t.intensity !== void 0 && (this.ambientLight.intensity = t.intensity),
        t.enabled !== void 0 &&
          (t.enabled
            ? this.add(this.ambientLight)
            : this.remove(this.ambientLight));
    }
    onDeactive() {
      this.isActive = !1;
    }
    onActive(t) {
      (this.isActive = !0),
        (t.fog = this.fog),
        this.updateShadow(this.data.shadow);
    }
    forceMaterialsUpdate() {
      this.traverseEntity((t) => {
        if (t instanceof ia)
          if (Array.isArray(t.material))
            for (let e of t.material) e.needsUpdate = !0;
          else (t.material.needsUpdate = !0), t.material.dispose();
      });
    }
    updateShadow(t) {
      t.softShadowQuality !== void 0 &&
        this.isActive &&
        GF(t.softShadowQuality) &&
        this.forceMaterialsUpdate();
    }
    updateFog(t, e) {
      if (
        (t.enabled ? (this.fog = this.backupFog) : (this.fog = null),
        this.isActive)
      ) {
        let i = this.scene;
        i.fog = this.fog;
      }
      (this.fogUseBGColor = t.useBackgroundColor),
        t.useBackgroundColor
          ? this.backupFog.color.set(this.bgColor)
          : (this.backupFog.color = qi(t.color, e)),
        (this.backupFog.near = t.near),
        (this.backupFog.far = t.far);
    }
    updateAo(t, e) {
      t.aoColor !== void 0 && (this.aoColor = qi(t.aoColor, e));
    }
    updateByOp(t, e, i, n) {
      super.updateByOp(t, e, i, n);
      let r = e;
      Sn(t.path, ["fog"])
        ? this.updateFog(r.fog, i.shared)
        : Sn(t.path, ["ao"])
        ? this.updateAo(r.ao, i.shared)
        : Sn(t.path, ["ambient"])
        ? this.updateAmbientLight(r.ambient, i.shared)
        : Sn(t.path, ["shadow"]) && this.updateShadow(r.shadow);
    }
    updateState(t, e) {
      this.updateState_Entity(t, e),
        t.backgroundColor !== void 0 &&
          this.setBackgroundColor(qi(t.backgroundColor, e.shared)),
        t.fog !== void 0 && this.updateFog(t.fog, e.shared),
        t.ambient !== void 0 && this.updateAmbientLight(t.ambient, e.shared),
        t.ao !== void 0 && this.updateAo(t.ao, e.shared),
        t.shadow !== void 0 && this.updateShadow(t.shadow);
    }
    raycast(t, e) {
      super.raycast(t, e);
    }
    switchActiveCamera(t) {
      t &&
        t.isDescendantOf(this) &&
        (this.activeCamera !== this.personalCamera &&
          (this.activeCamera.objectHelper.visible = !0),
        (this.activeCamera = t),
        (t.objectHelper.visible = !1));
    }
    get playCamera() {
      var t;
      return (
        ((t = this.scene) == null
          ? void 0
          : t.find(this.data.publish.playCamera)) ?? this.personalCamera
      );
    }
    switchToPlayCamera() {
      this.switchActiveCamera(this.playCamera);
    }
    get penumbraSizeArray() {
      return (
        this.penumbraSizeArrayCache === null && this.updatePenumbraSizeArray(),
        this.penumbraSizeArrayCache
      );
    }
    updatePenumbraSizeArray() {
      this.penumbraSizeArrayCache = new Array(5).fill(0.5);
      let t = 0,
        e = 0;
      this.traverseEntity((i) => {
        if (!i.visible) return !0;
        i instanceof q1 &&
          i.visible &&
          t < 3 &&
          ((this.penumbraSizeArrayCache[t] = i.data.penumbraSize), (t += 1)),
          i instanceof X1 &&
            i.visible &&
            t < 5 - 3 &&
            ((this.penumbraSizeArrayCache[3 + e] = i.data.penumbraSize),
            (e += 1));
      });
    }
    raycastWithClones(t) {
      let e = [],
        i = (n) => {
          for (let r of n.children) {
            let s = r.cloner;
            Bt.is(r) &&
              (r.visible || (s != null && s.object.data.visible)) &&
              ((Ca(r) ||
                (Sf(r) &&
                  this.scene.enableHelpers &&
                  r.objectHelper.visible)) &&
                (t.intersectObject(r, !1, e), Ef(r, t, e, !0)),
              i(r));
          }
        };
      return i(this), e;
    }
  },
  WF = class extends $p(Ex, j1) {
    constructor(t, e, i) {
      super(),
        this.super_Entity(t, e),
        (this.castShadow = !0),
        (this.shadow.mapSize.width = 1024),
        (this.shadow.mapSize.height = 1024),
        (this.shadow.normalBias = 1),
        this.layers.enable(3);
      let n = this.shadow.camera;
      (n.fov = 90), (n.aspect = 1), (n.near = 100), (n.far = 2500);
      let r = new A(
          -n.far + this.position.x,
          -n.far + this.position.y,
          -n.far + this.position.z
        ),
        s = new A(
          n.far + this.position.x,
          n.far + this.position.y,
          n.far + this.position.z
        ),
        a = new An(r, s),
        o = new Wc(a, new tt(16755200));
      (o.visible = !1), (this.gizmos.shadowmap = o), this.update();
    }
    update() {
      if (
        this.shadow &&
        (this.shadow.camera.updateProjectionMatrix(), this.gizmos)
      )
        for (let t in this.gizmos) {
          let e = this.gizmos[t];
          if (e instanceof Wc) {
            let i = this.shadow.camera,
              n = new A(
                -i.far + this.position.x,
                -i.far + this.position.y,
                -i.far + this.position.z
              ),
              r = new A(
                i.far + this.position.x,
                i.far + this.position.y,
                i.far + this.position.z
              );
            e.box.set(n, r), e.updateMatrixWorld(!0);
          }
        }
    }
    updateMatrixWorld(t) {
      super.updateMatrixWorld(t),
        this.objectHelper && this.objectHelper.update();
    }
    updateState(t, e) {
      this.updateState_Light(t, e),
        t.distance !== void 0 && (this.distance = t.distance),
        t.decay !== void 0 && (this.decay = t.decay),
        t.shadowRadius !== void 0 && (this.shadow.radius = t.shadowRadius),
        t.shadowResolution !== void 0 &&
          (this.shadow.mapSize.set(t.shadowResolution, t.shadowResolution),
          this.shadow.map &&
            (this.shadow.map.dispose(), (this.shadow.map = null)));
    }
  },
  qF = class extends ur {
    get forceComputeSize() {
      return !0;
    }
    get shape() {
      return this.geometry.userData.shape;
    }
    updateEntityBoxSize(t, e) {
      let i = this.geometry.getAttribute("position");
      i !== void 0
        ? Fp(
            i,
            this.geometry.drawRange.start,
            this.geometry.drawRange.count < 1 / 0
              ? this.geometry.drawRange.count
              : i.count,
            t,
            e
          )
        : super.updateEntityBoxSize(t, e);
    }
  },
  $1 = class extends ur {
    constructor(t, e, i) {
      super(t, e, i), (this._shapeId = null), (this._context = i);
    }
    updateState(t, e) {
      super.updateState(t, e), this.updateShape();
    }
    updateShape() {
      var n;
      let t = this.data.geometry.extrusion.shape,
        e;
      if (t.type === "Custom") {
        let r = t.shapeId;
        if ((r !== this._shapeId && this.detachShape(), r)) {
          this._shapeId = r;
          let s = this._context.scene.find(r);
          s != null &&
            s.data &&
            (s.attachedPaths.add(this),
            (e = (n = s.geometry.userData) == null ? void 0 : n.shape)),
            e ||
              this._context.scene.addPendingCommand(() => this.updateShape());
        }
      } else {
        let r;
        switch (t.type) {
          case "Rectangle":
            r = Y_;
            break;
          case "Ellipse":
            r = zp;
            break;
          case "Polygon":
            r = $_;
            break;
          case "Star":
            r = Z_;
            break;
          default:
            throw new Error(`Unknown shape type: ${t.type}`);
        }
        e = r.create({ parameters: t }).userData.shape;
      }
      let i = this.geometry;
      e &&
        i.inputs &&
        ((i.inputs.shapeData = e),
        i.build(),
        this.attachedSurfaceCloners.forEach((r) => r.update()));
    }
    detachShape() {
      var t;
      this._shapeId !== null &&
        ((t = this._context.scene.find(this._shapeId)) == null ||
          t.attachedPaths.delete(this));
    }
    createGeometryDelayed(t) {
      (this.geometryCreateDeleyed = t.shared),
        this.updateShape(),
        this.refreshAttachedPaths(t);
    }
    updateTransformState(t) {
      return super.updateTransformState(t);
    }
    updateGeometryInteractions(t, e) {
      super.updateGeometryInteractions(t, e), this.updateShape();
    }
    updateEntityBoxSize(t, e) {
      let i = this.geometry.getAttribute("position");
      i !== void 0
        ? Fp(
            i,
            this.geometry.drawRange.start,
            this.geometry.drawRange.count < 1 / 0
              ? this.geometry.drawRange.count
              : i.count,
            t,
            e
          )
        : super.updateEntityBoxSize(t, e);
    }
  },
  el = class extends Al(Da, Vh) {
    constructor(t, e, i) {
      super(),
        e.type === "Instance" &&
          typeof t == "string" &&
          (e = this.transformAssignData(e, i)),
        this.super_Entity(t, e),
        this.objectHelper.update();
    }
    get isComponentRoot() {
      return this.data.type === "Component" && typeof this.identity == "string";
    }
    get isInstanceRoot() {
      return this.data.type === "Instance" && typeof this.identity == "string";
    }
    transformAssignData(t, e) {
      let i = e.scene.data.objects.get(t.component);
      if (i) {
        let n, r;
        for (let s of es.rootOverrideProps)
          t[s] === void 0
            ? (n === void 0 && (n = { ...t }), (n[s] = i.data[s]))
            : (r === void 0 && (r = {}),
              (r[s] = t[s]),
              n === void 0 && (n = { ...t }),
              (n[s] = ls.apply(i.data[s], t[s])));
        return (this.overrideData = r), n;
      } else
        return {
          ...Xi.defaultData,
          ...t,
          ...os(Xi.defaultData, es.rootOverrideProps),
        };
    }
    updateByOp(t, e, i, n) {
      let r;
      if (this.isInstanceRoot && !n) {
        if (
          ((e = this.transformAssignData(e, i)),
          t.type === 0 && t.path.length === 0 && this.component)
        )
          for (let s of es.rootOverrideProps)
            s in t.props &&
              t.props[s] === void 0 &&
              (r === void 0 && (r = { ...t, props: { ...t.props } }),
              (r.props[s] = this.component.data[s]));
        else if (
          t.type === 0 &&
          t.path.length > 0 &&
          es.rootOverrideProps.includes(t.path[0])
        ) {
          let s = t.path[0];
          r === void 0 && (r = { ...t, path: [], props: { [s]: e[s] } });
        }
      }
      super.updateByOp(r ?? t, e, i, n);
    }
    updateState(t, e) {
      this.updateState_Entity(t, e);
    }
    expandInstanceChildren(t) {
      let e = this.data;
      if (this.component === void 0) {
        let i = t.scene.find(e.component) ?? null,
          n = !1;
        if (i !== this.oldComponent) {
          if (this.oldComponent) {
            let r = 0;
            for (let s of this.children)
              if (Bt.is(s))
                t.scene.disposeAndUnregisterEntityRecursivelyIfNotReregistered(
                  s
                ),
                  Yp(s),
                  (r += 1);
              else break;
            this.children.splice(0, r);
          }
          n = !0;
        }
        if (i) {
          let r = {};
          Y1(t, [this.uuid], e.overrides, this, i, i, 0, n, r);
          for (let s of this.children)
            if (Bt.is(s)) {
              let a = s.data;
              a.type === "Empty" &&
                a.animations &&
                s.traverseEntity((o) => {
                  if (o instanceof ur && o.isSkinnedMesh) {
                    let l = o.dataPatched;
                    if (l.bones && l.boneInverses) {
                      let c = l.bones.map((u) => t.scene.find(r[u])),
                        d = l.boneInverses.map((u) => new ze().fromArray(u)),
                        h = new wh(c, d);
                      o.bind(h, o.bindMatrix);
                    }
                  } else o.matrixAutoUpdate = !0;
                });
            }
        }
        this.oldComponent = this.component;
      }
    }
  };
function Yp(t) {
  if (t.component) {
    let e = t.component.instances.indexOf(t);
    e >= 0 && t.component.instances.splice(e, 1);
    for (let i of t.children) Bt.is(i) && Yp(i);
  }
}
function Qv(t, e, i, n) {
  return t.component === e && a_(t.identity, n)
    ? t.overrideData === i
      ? 2
      : 1
    : 0;
}
function Y1(t, e, i, n, r, s, a, o, l) {
  if (a > 50) return !1;
  if (n.component !== r) {
    if (n.component) {
      let d = n.component.instances.indexOf(n);
      d >= 0 && n.component.instances.splice(d, 1);
    }
    r.instances.push(n), (n.component = r);
  }
  r instanceof el && r.isInstanceRoot && r.expandInstanceChildren(t);
  let c = 0;
  for (let d of r.children)
    if (Bt.is(d)) {
      let h = [
          ...e,
          ...(typeof d.identity == "string" ? [d.identity] : d.identity),
        ],
        u = oh.resolve(i, h, 1);
      u != null &&
        !(u instanceof xi) &&
        (Object.setPrototypeOf(u, xi.prototype),
        console.error("wrong prototype"));
      let f = null,
        p;
      if (!o) {
        let v = n.children[c];
        if (((f = Bt.is(v) ? v : null), f !== null)) {
          let g = Qv(f, d, u, h);
          (p = g >= 1 ? f.stateSelection : void 0), g !== 2 && (f = null);
        }
        if (f === null && ((f = t.scene.findInstance(h) ?? null), f !== null)) {
          let g = Qv(f, d, u, h);
          if (((p = g >= 1 ? f.stateSelection : void 0), g !== 2)) f = null;
          else {
            let m = f.parent.children.indexOf(f);
            f.parent.children.splice(m, 1),
              n.children.splice(c, 0, f),
              f.parent === n
                ? m <= c && console.error("not possible")
                : ((f.parent = n),
                  (f.matrixWorldNeedsUpdate = !0),
                  f.resetBBoxNeedsUpdate(),
                  f.updateVisible(),
                  t.pendingDeletes.delete(f));
          }
        }
      }
      if (f === null) {
        let v = u ? ls.apply(d.data, u) : d.data;
        $s.is(v.type) && (v = { ...v, type: "Empty" }),
          (f = ts.createEntity(h, v, t)),
          (f.overrideData = u),
          n.add(f),
          n.children.splice(n.children.length - 1, 1),
          n.children.splice(c, 0, f),
          f.updateState(f.data, t),
          p && f.changeSelectedState(p, t),
          t.scene.registerInstanceAndSetUuid(f);
      }
      if (f.isBone) {
        let v = f.identity[f.identity.length - 1];
        l[v] = f.uuid;
      }
      (c += 1), Y1(t, e, i, f, d, s, a + 1, o, l);
    }
  if (!o) {
    let d = c;
    for (;;) {
      let h = n.children[c];
      if (Bt.is(h)) t.pendingDeletes.add(h);
      else break;
      c += 1;
    }
    n.children.splice(d, c - d);
  }
  return !0;
}
var XF = class extends Al(vx, Vh) {
  constructor(t, e) {
    super(),
      this.super_Entity(t, e),
      this.objectHelper.update(),
      (this.matrixAutoUpdate = !0);
  }
  updateState(t, e) {
    this.updateState_Entity(t, e);
  }
};
function $F(t, e, i) {
  let n;
  return e.geometry.type === "TextGeometry"
    ? new B1(t, e, i)
    : (e.geometry.type === "SubdivGeometry"
        ? (n = new bf(t, e, i))
        : e.geometry.type === "PathGeometry"
        ? (n = new $1(t, e, i))
        : e.geometry.type === "VectorGeometry"
        ? (n = new qF(t, e, i))
        : e.geometry.type === "BooleanGeometry"
        ? (n = new ao(t, e, i))
        : (n = new ur(t, e, i)),
      n);
}
function Zp(t, e, i) {
  return e.type === "Mesh"
    ? $F(t, e, i)
    : e.type === "Empty"
    ? new $v(t, e)
    : e.type === "Bone"
    ? new XF(t, e)
    : e.type === "Page"
    ? new Uc(t, e)
    : e.type === "PointLight"
    ? new WF(t, e, i)
    : e.type === "SpotLight"
    ? new X1(t, e, i)
    : e.type === "DirectionalLight"
    ? new q1(t, e, i)
    : e.type === "Component" || e.type === "Instance"
    ? new el(t, e, i)
    : $s.is(e.type)
    ? new Xp(t, e)
    : (console.error(e), new $v(t, e));
}
ts.createEntity = Zp;
function YF(t, e, i) {
  let n = Zp(t.identity, e, i),
    r = t.children,
    s = t.attachedPaths,
    a = t.parent,
    o = t.component,
    l = t.instances,
    c = t.overrideData,
    d = t.uuid,
    h = t.stateSelection;
  t.dispose();
  for (let u of Object.keys(t)) delete t[u];
  Object.setPrototypeOf(t, Object.getPrototypeOf(n));
  for (let u of Object.keys(n)) t[u] = n[u];
  (t.children = [...t.children, ...r]),
    (t.attachedPaths = s),
    (t.parent = a),
    (t.component = o),
    (t.instances = l),
    (t.uuid = d),
    (t.overrideData = c),
    t.updateState(t.data, i),
    h && t.changeSelectedState(h, i),
    t.resetBBoxNeedsUpdate();
}
ts.changeEntityProptotype = YF;
ts.Cloner = H1;
function ZF(t, e, i, n) {
  t.updateByOp(e, i, n, !1);
}
function ey(t, e) {
  let i = !1,
    n = e.getLayersOfType("transmission"),
    r = e.getLayersOfType("outline");
  return (
    r.length > 0 &&
      (t.layers.set(8),
      n.length > 0 && t.layers.enable(3),
      (i = !0),
      qp(t),
      Wp(t)),
    n.length === 0 && r.length === 0 && t.layers.set(0),
    t instanceof ia && t.needsAO && t.layers.enable(5),
    i
  );
}
function ty(t, e) {
  if (!e.layers) return !1;
  let i = !1,
    n = e.getLayersOfType("transmission").filter((s) => s.data.visible),
    r = e.getLayersOfType("outline").filter((s) => s.data.visible);
  return (
    n.length > 0 &&
      (t.layers.set(3), r.length > 0 && t.layers.enable(8), (i = !0)),
    n.length === 0 && r.length === 0 && t.layers.set(0),
    t.needsAO && t.layers.enable(5),
    i
  );
}
function KF(t) {
  let e = !1;
  return (
    t.traverseEntity((i) => {
      if (i instanceof ia)
        if (Array.isArray(i.material))
          for (let n = 0; n < i.material.length; n++)
            ey(i, i.material[n]) && (e = !0);
        else ey(i, i.material) && (e = !0);
    }),
    e
  );
}
function JF(t) {
  let e = !1;
  return (
    t.traverseEntity((i) => {
      if (i instanceof ia)
        if (Array.isArray(i.material))
          for (let n = 0; n < i.material.length; n++)
            ty(i, i.material[n]) && (e = !0);
        else ty(i, i.material) && (e = !0);
    }),
    e
  );
}
var QF = new Ax(),
  ek = new ze(),
  tk = new oo();
function Ef(t, e, i, n = !1) {
  let r = t.cloner;
  if (r)
    for (let s of r.children) {
      let a = ek.copy(s.matrixWorld).invert(),
        o = tk.copy(e.ray).applyMatrix4(a),
        l = t.matrixWorld;
      o.applyMatrix4(l);
      let c = QF;
      c.set(o.origin, o.direction), (c.near = e.near), (c.far = e.far);
      let d = c.intersectObject(t, !1);
      d.length > 0 && i.push({ ...d[0], object: n ? s : t });
    }
}
var ik = class {
    constructor() {
      this._constraints = new Map();
    }
    setConstraint(t, e) {
      e === null ? this._constraints.delete(t) : this._constraints.set(t, e);
    }
    removeDependencies(t) {
      this._constraints.delete(t);
    }
    applyConstraints(t) {
      let e = new Set();
      this._constraints.forEach((i, n) => {
        let r = [n, i],
          s = i;
        for (; this._constraints.has(s); )
          (s = this._constraints.get(s)), e.has(s) || r.push(s);
        for (let a = r.length - 2; a >= 0; a--)
          if (!e.has(r[a])) {
            let o = t.find(r[a]);
            o ? o.applyPathSnapping(t) : console.warn(`missing entity ${r[a]}`),
              e.add(r[a]);
          }
      });
    }
    findDependency(t, e) {
      let i = t;
      for (; this._constraints.has(i); )
        if (((i = this._constraints.get(i)), i === e)) return !0;
      return !1;
    }
  },
  nk = new co();
nk.wireframe = !0;
var iy = new A(),
  rk = class extends qf {
    constructor(t, e) {
      super(),
        (this.data = t),
        (this.enableHelpers = !1),
        (this.wireframeState = !1),
        (this.needsTransmissionDirty = !0),
        (this.needsNormalDirty = !0),
        (this._needsTransmission = !1),
        (this._needsNormal = !1),
        (this.geometryCacheChanged = !1),
        (this.entityByUuid = {}),
        (this.entityIdentityToEntity = {}),
        (this.toExpandCloner = new Set()),
        (this.toUpdateCloner = new Set()),
        (this.pendingCommands = []),
        (this.pathConstraints = new ik()),
        (this.errorPage = new Uc("fdasfa", { ...ro.defaultData, name: "" })),
        (this.needsRecomputeInstances = !1),
        this.init(t, e),
        (this.matrixAutoUpdate = !1);
    }
    markGeometryCacheDirty() {
      this.geometryCacheChanged = !0;
    }
    markNeedsUpdateRendererDirty() {
      (this.needsTransmissionDirty = !0), (this.needsNormalDirty = !0);
    }
    needsTransmission() {
      return (
        this.needsTransmissionDirty &&
          ((this._needsTransmission = JF(this)),
          (this.needsTransmissionDirty = !1)),
        this._needsTransmission
      );
    }
    needsNormal() {
      return (
        this.needsNormalDirty &&
          ((this._needsNormal = KF(this)), (this.needsNormalDirty = !1)),
        this._needsNormal
      );
    }
    registerInstanceAndSetUuid(t) {
      let e = t.identity.join("-"),
        i = this.entityIdentityToEntity[e];
      i && (t.uuid = i.uuid),
        (this.entityIdentityToEntity[e] = t),
        (this.entityByUuid[t.uuid] = t);
    }
    markPenumbraSizeDirty() {
      for (let t of this.children)
        t instanceof Uc && (t.penumbraSizeArrayCache = null);
    }
    findInstance(t) {
      return this.entityIdentityToEntity[t.join("-")];
    }
    get bgColor() {
      return this.activePage.bgColor;
    }
    get postprocessing() {
      return this.activePage.data.postprocessing;
    }
    getWithSortKey(t) {
      let e = this.find(t);
      if (e === void 0) return;
      let i = [],
        n = e;
      for (; n !== this; ) {
        let r = n;
        n = n.parent;
        let s = n.children.indexOf(r);
        i.splice(0, 0, s);
      }
      return { entity: e, sortKey: i };
    }
    getAllSorted(t) {
      let e = [];
      for (let i of t) {
        let n = this.getWithSortKey(i.id);
        n !== void 0 && e.push(n);
      }
      return e.sort((i, n) => yC(i.sortKey, n.sortKey)), e.map((i) => i.entity);
    }
    nonExistOrDescendantOf(t, e) {
      let i = this.find(t);
      if (i === void 0) return !0;
      for (; i; ) {
        if (i.uuid === e) return !0;
        i = i.parent;
      }
      return !1;
    }
    find(t) {
      if (this.activePage && this.activePage.personalCamera.parent) {
        if (t === "f23858d0-4a3b-4bd8-8173-66ed0af7f6fb-personalCamera")
          return this.activePage.personalCamera;
        if (t === Fh) return this.activePage.personalCamera;
      }
      if (t === "" || t === void 0) return;
      let e = this.entityByUuid[t];
      return e === void 0 ? this.getObjectByProperty("uuid", t) : e;
    }
    debugEnsureEntity(t) {
      let e = this.find(t);
      if (e) {
        if (
          Array.isArray(e.identity) &&
          this.findInstance(e.identity) === void 0
        ) {
          console.error("not found instance");
          debugger;
        }
      } else {
        console.error("not found");
        debugger;
      }
    }
    addPendingExpandCloner(t) {
      this.toExpandCloner.add(t);
    }
    addPendingUpdateCloner(t) {
      this.toUpdateCloner.add(t);
    }
    markToExpandCloner(t) {
      this.toExpandCloner.add(t),
        t.traverseEntityAncestors((e) => {
          this.toExpandCloner.add(e);
        });
    }
    doPendingExpandCloner() {
      this.toExpandCloner.forEach((t) => {
        t.expandCloner(this);
      }),
        this.toExpandCloner.clear();
    }
    doPendingUpdateCloner() {
      this.toUpdateCloner.forEach((t) => {
        var e;
        (e = t.cloner) == null || e.update();
      }),
        this.toUpdateCloner.clear();
    }
    doPendingUpdates() {
      this.doPendingExpandCloner(),
        this.doPendingUpdateCloner(),
        this.applyPendingCommands();
    }
    addPendingCommand(t) {
      this.pendingCommands.push(t);
    }
    applyPendingCommands() {
      this.pendingCommands.forEach((t) => t()),
        (this.pendingCommands.length = 0);
    }
    updateTreeByOp(t, e) {
      var i;
      if (t.path.length === 0 && t.type === 7) {
        let n = t.parent === null ? this : this.find(t.parent);
        if (n === void 0) throw new Error("unexpected");
        let r = this.createObject(t.id, t.data, t.children, n, t.localIndex, e);
        r.updateVisible(),
          r.resetBBoxNeedsUpdate(),
          Ca(r) &&
            Ac(r.parent) &&
            (r.invalidateUpstreamBooleanData(),
            r.parent.invalidateDownstreamBooleanData().recomputeBoolean()),
          this.markNeedsRecomputeInstancesForAncessors(n),
          this.markNeedsRecomputeInstancesForChildren(r),
          this.markToExpandCloner(r),
          this.markPenumbraSizeDirty();
      } else if (t.path.length === 0 && t.type === 8) {
        let n = this.find(t.id);
        if (n === void 0) throw new Error("unexpected");
        this.markToExpandCloner(n),
          n.resetBBoxNeedsUpdate(),
          this.unregisterObject(n);
        let r = n.parent;
        this.markNeedsRecomputeInstancesForAncessors(r),
          this.markNeedsRecomputeInstancesForChildren(n),
          this.markPenumbraSizeDirty(),
          n.parent.remove(n),
          Ac(n.parent) &&
            (n.parent.invalidateUpstreamBooleanData(),
            n.parent.invalidateDownstreamBooleanData().recomputeBoolean()),
          Ca(n) &&
            (n.freeBooleanPointer(),
            r instanceof ao &&
              r.invalidateDownstreamBooleanData().recomputeBoolean()),
          n instanceof $1 && n.detachShape(),
          this.disposeAndUnregisterEntityRecursivelyIfNotReregistered(n),
          this.pathConstraints.removeDependencies(n.uuid);
      } else if (t.path.length === 0 && t.type === 9) {
        let n = this.find(t.id);
        if (n === void 0) throw new Error("unexpected");
        this.markNeedsRecomputeInstancesForChildren(n);
        let r = n.parent;
        this.markNeedsRecomputeInstancesForAncessors(r),
          (i = n.cloner) == null || i.resetOnMove(),
          this.markToExpandCloner(n);
        let s = t.parent === null ? this : this.find(t.parent);
        if (s === void 0) throw new Error("unexpected");
        s.add(n),
          this.markNeedsRecomputeInstancesForAncessors(s),
          this.markToExpandCloner(n),
          n.invalidateClonerTransform(n),
          n.updateVisible(),
          n.resetBBoxNeedsUpdate(),
          this.markPenumbraSizeDirty();
        let a = t.localIndex;
        s.children.splice(a, 0, s.children.pop()),
          Ca(n) &&
            (n.invalidateUpstreamBooleanData(),
            Ac(n.parent)
              ? n.parent.invalidateDownstreamBooleanData().recomputeBoolean()
              : r instanceof ao &&
                r.invalidateDownstreamBooleanData().recomputeBoolean());
      }
      this.markNeedsUpdateRendererDirty(), this.markGeometryCacheDirty();
    }
    get playPage() {
      return this.find(this.data.publish.playPage) ?? this.errorPage;
    }
    updatePage(t) {
      this.activePage && this.activePage.onDeactive(),
        (this.activePage = this.errorPage);
      for (let e of this.children)
        e instanceof Uc &&
          ((e.visible = e.uuid === t),
          e.visible && ((this.activePage = e), this.activePage.onActive(this)));
    }
    updateEntityByOp(t, e, i, n) {
      if (e.type === 0) {
        if (
          (("overrides" in e.props || "component" in e.props) &&
            this.markNeedsRecomputeInstances(),
          "visible" in e.props && this.markPenumbraSizeDirty(),
          e.path.includes("overrides") && "states" in e.props)
        ) {
          let { rest: s } = e.props;
          (e = { ...e, props: s }), this.markNeedsRecomputeInstances();
        }
        e.path[0] === "pathSnapping" &&
          e.props.pathId !== void 0 &&
          this.pathConstraints.setConstraint(t, e.props.pathId);
      }
      let r = this.find(t);
      if (r)
        try {
          ZF(r, e, i, { scene: this, shared: n }),
            r instanceof ur && r.updateGeometryGroupsIfNeeded();
        } catch (s) {
          console.error(s);
        }
    }
    get activeCamera() {
      return this.activePage.activeCamera;
    }
    switchActiveCamera(t) {
      this.activePage.switchActiveCamera(t);
    }
    init(t, e) {
      this.createChildrenObjects(t.objects, this, e),
        this.updatePage(t.publish.playPage),
        this.activePage.switchToPlayCamera(),
        this.expandInstances(e, !0),
        this.traverseEntity((i) => {
          Ac(i) && i.recomputeBoolean(), i instanceof Xp && i.updateUp();
        }),
        this.doPendingExpandCloner(),
        this.applyPendingCommands();
    }
    markNeedsRecomputeInstances() {
      this.needsRecomputeInstances = !0;
    }
    markNeedsRecomputeInstancesForChildren(t) {
      t.traverseEntity((e) => {
        (e.data.type === "Component" || e.data.type === "Instance") &&
          this.markNeedsRecomputeInstances();
      });
    }
    markNeedsRecomputeInstancesForAncessors(t) {
      Bt.is(t) &&
        (t.data.type === "Component" && this.markNeedsRecomputeInstances(),
        t.traverseAncestors((e) => {
          Bt.is(e) &&
            e.data.type === "Component" &&
            this.markNeedsRecomputeInstances();
        }));
    }
    relativeizeInner(t, e, i, n, r, s, a) {
      if (t) {
        let o = n.find(t);
        o &&
          o !== n &&
          r.forInstancesRec((l) => {
            l.data = Qc(l.data, (c) => {
              let d = c.events.data(a.id),
                h = l.goUp(s);
              if (h) {
                let u = [...Dx(h.identity), t].join("-"),
                  f = this.entityIdentityToEntity[u];
                if (f) {
                  let p = f.uuid,
                    v = hr.zoom(d, e);
                  v[i] = p;
                } else console.warn("cannot find instance");
              }
            }).data;
          });
      }
    }
    rewriteActions(t, e, i, n, r, s) {
      t.forEach((a) => {
        a.data.type === "Transition"
          ? this.relativeizeInner(
              a.data.object,
              [...e, a.id],
              "object",
              i,
              n,
              r,
              s
            )
          : a.data.type === "Animation" &&
            this.relativeizeInner(
              a.data.object,
              [...e, a.id],
              "object",
              i,
              n,
              r,
              s
            );
      });
    }
    rewriteEventsBeforeGoToPlayMode() {
      this.traverseEntity((t) => {
        if (
          t instanceof el &&
          typeof t.identity == "string" &&
          t.data.type === "Component"
        )
          return (
            t.traverseEntity((e, i) => {
              e.data.events.forEach((n) => {
                if (n.data.type === "GameControl") {
                  let r = !1;
                  if (
                    (e.forInstancesRec((s) => {
                      s.data = Qc(s.data, (a) => {
                        s.isInstanceRoot || (a.events.delete(n.id), (r = !0));
                      }).data;
                    }),
                    r === !1)
                  )
                    for (let s of af.list)
                      this.rewriteActions(
                        n.data.gameActions[s],
                        ["gameActions", s],
                        t,
                        e,
                        i,
                        n
                      );
                } else
                  n.data.type === "Conditional"
                    ? (n.data.condition.type === "Distance"
                        ? (this.relativeizeInner(
                            n.data.condition.fromObject,
                            ["condition"],
                            "fromObject",
                            t,
                            e,
                            i,
                            n
                          ),
                          this.relativeizeInner(
                            n.data.condition.toObject,
                            ["condition"],
                            "toObject",
                            t,
                            e,
                            i,
                            n
                          ))
                        : n.data.condition.type === "State"
                        ? this.relativeizeInner(
                            n.data.condition.object,
                            ["condition"],
                            "object",
                            t,
                            e,
                            i,
                            n
                          )
                        : n.data.condition.type === "Comparison" &&
                          (n.data.condition.lOperand.type === "Property" &&
                            this.relativeizeInner(
                              n.data.condition.lOperand.value[0],
                              ["condition", "lOperand", "value"],
                              0,
                              t,
                              e,
                              i,
                              n
                            ),
                          n.data.condition.rOperand.type === "Property" &&
                            this.relativeizeInner(
                              n.data.condition.rOperand.value[0],
                              ["condition", "rOperand", "value"],
                              0,
                              t,
                              e,
                              i,
                              n
                            )),
                      this.rewriteActions(
                        n.data.inActions,
                        ["inActions"],
                        t,
                        e,
                        i,
                        n
                      ),
                      this.rewriteActions(
                        n.data.outActions,
                        ["outActions"],
                        t,
                        e,
                        i,
                        n
                      ))
                    : "actions" in n.data &&
                      this.rewriteActions(
                        n.data.actions,
                        ["actions"],
                        t,
                        e,
                        i,
                        n
                      );
              });
            }),
            !0
          );
      });
    }
    expandInstances(t, e, i) {
      let n = new Set();
      this.traverseEntity((r) => {
        if (r instanceof el && r.isInstanceRoot)
          return (
            r.expandInstanceChildren({
              scene: this,
              shared: t,
              pendingDeletes: n,
            }),
            e || r.resetBBoxNeedsUpdate(),
            i &&
              r.traverseEntity((s) => {
                i.addClip(s);
              }),
            !0
          );
      });
      for (let r of n)
        this.disposeAndUnregisterEntityRecursivelyIfNotReregistered(r), Yp(r);
    }
    recomputeInstances(t, e) {
      this.needsRecomputeInstances &&
        ((this.needsRecomputeInstances = !1),
        this.traverseEntity((i) => {
          i instanceof el && i.isInstanceRoot && (i.component = void 0);
        }),
        this.expandInstances(t, !1, e));
    }
    disposeAndUnregisterEntityRecursivelyIfNotReregistered(t) {
      t.traverseEntity((e) => {
        let i =
          typeof e.identity == "string" ? e.identity : e.identity.join("-");
        this.entityIdentityToEntity[i] === e &&
          (delete this.entityByUuid[e.uuid],
          delete this.entityIdentityToEntity[i]),
          e.dispose();
      });
    }
    clearScene() {
      for (let t of this.children) Bt.is(t) && t.disposeRecursively();
      this.children.length = 0;
    }
    resetAfterClear(t, e) {
      this.init(t, e);
    }
    raycast(t) {
      return this.raycast1(t, !1);
    }
    raycast1(t, e) {
      let i = [],
        n = (r) => {
          for (let s of r.children) {
            let a = s.cloner;
            if (
              Bt.is(s) &&
              !s.raycastLock &&
              (s.visible || (a != null && a.object.data.visible))
            )
              if (e === !0 && s.isInstanceRoot) {
                let o = [];
                if ((t.intersectObject(s, !0, o), o.length)) {
                  let l = o[0];
                  (l.object = s), l.point.applyMatrix4(l.object.matrixWorld);
                  let c = s.matrixWorld.clone().invert();
                  l.point.applyMatrix4(c), i.push(l);
                }
              } else
                (Ca(s) ||
                  (Sf(s) && this.enableHelpers && s.objectHelper.visible)) &&
                  (t.intersectObject(s, !1, i), Ef(s, t, i)),
                  n(s);
          }
        };
      return n(this), i;
    }
    raycastWithClones(t) {
      let e = [],
        i = (n) => {
          for (let r of n.children) {
            let s = r.cloner;
            Bt.is(r) &&
              (r.visible || (s != null && s.object.data.visible)) &&
              ((Ca(r) ||
                (Sf(r) && this.enableHelpers && r.objectHelper.visible)) &&
                (t.intersectObject(r, !1, e), Ef(r, t, e, !0)),
              i(r));
          }
        };
      return i(this), e;
    }
    forEachEntity(t) {
      for (let e of this.children) Bt.is(e) && t(e);
    }
    traverseConcreteEntity(t) {
      for (let e of this.children)
        Bt.is(e) && e.isConcreteEntity && e.traverseEntity(t);
    }
    traverseEntity(t) {
      for (let e of this.children) Bt.is(e) && e.traverseEntity(t);
    }
    traverseObject(t) {
      for (let e of this.children) ml.is(e) && e.traverseObject(t);
    }
    traverseVisibleEntity(t) {
      for (let e of this.children)
        Bt.is(e) && e.visible && e.traverseVisibleEntity(t);
    }
    dispose() {
      this.clearScene();
    }
    createChildrenObjects(t, e, i) {
      let n = 0;
      for (let r of t)
        this.createObject(r.id, r.data, r.children, e, n, i), (n += 1);
    }
    registerObjectCreatedInLegacy(t) {
      this.entityByUuid[t.uuid] = t;
    }
    unregisterObject(t) {
      delete this.entityByUuid[t.uuid];
      for (let e of t.children) this.unregisterObject(e);
    }
    createObject(t, e, i, n, r, s) {
      var l;
      let a = { scene: this, shared: s },
        o = Zp(t, e, a);
      return (
        o &&
          ((this.entityByUuid[t] = o),
          n.add(o),
          n.children.splice(r, 0, n.children.pop()),
          i.length > 0 &&
            (o.isInstanceRoot
              ? console.error("instance should not have children!")
              : this.createChildrenObjects(i, o, s)),
          o.updateState(e, a),
          o instanceof ur && o.updateGeometryGroupsIfNeeded(),
          o.updateVisible(),
          o.cloner && this.toExpandCloner.add(o),
          (l = e.pathSnapping) != null &&
            l.pathId &&
            this.pathConstraints.setConstraint(t, e.pathSnapping.pathId)),
        e.type === "Empty" &&
          e.animations &&
          o.traverseEntity((c) => {
            if (c instanceof ur && c.isSkinnedMesh) {
              let d = c.dataPatched;
              if (d.bones && d.boneInverses) {
                let h = d.bones.map((p) => this.find(p)),
                  u = d.boneInverses.map((p) => new ze().fromArray(p)),
                  f = new wh(h, u);
                c.bind(f, c.bindMatrix);
              }
            } else c.matrixAutoUpdate = !0;
          }),
        o
      );
    }
    getCenter(t) {
      let e = [];
      for (let n = 0, r = t.length; n < r; ++n) {
        let { id: s, recursive: a } = t[n],
          o = this.find(s),
          l = a ? o.recursiveBBox : o.singleBBox;
        e.push(...l.vertices);
      }
      let i = new An();
      return i.setFromPoints(e), i.getCenter(iy), iy;
    }
    copyMatrixWorld(t, e) {
      if (t === null) {
        e.identity();
        return;
      }
      let i = this.find(t);
      i ? e.copy(i.matrixWorld) : e.identity();
    }
    copyParentMatrixWorld(t, e) {
      var n;
      if (t === null) {
        e.identity();
        return;
      }
      let i = (n = this.find(t)) == null ? void 0 : n.parent;
      i ? e.copy(i.matrixWorld) : e.identity();
    }
    traverseMaterial(t) {
      this.traverseEntity((e) => {
        if (e instanceof ps)
          if (Array.isArray(e.material))
            for (let i = 0; i < e.material.length; i++)
              e.material[i] instanceof ms && t(e.material[i]);
          else e.material instanceof ms && t(e.material);
      });
    }
    updateCanvasSize(t, e, i = !1) {
      this.activeCamera.setViewplaneSize(t, e, i);
    }
  },
  ns;
function sk() {
  return (
    ns ||
      ((ns = new iC()),
      ns
        .setDecoderPath(
          "https://www.gstatic.com/draco/versioned/decoders/1.5.2/"
        )
        .preload()),
    ns.decoderPending
  );
}
async function ak(t) {
  if (ns) {
    let e = {
        attributeIDs: ns.defaultAttributeIDs,
        attributeTypes: ns.defaultAttributeTypes,
        useUniqueIDs: !1,
      },
      i;
    try {
      i = await ns.decodeGeometry(new Int8Array(t).buffer, e);
    } catch (n) {
      console.error(n);
    }
    if (i)
      return {
        index: i.index ? { array: i.index.array } : void 0,
        attributes: Object.entries(i.attributes).map(([n, r]) => ({
          name: n,
          itemSize: r.itemSize,
          array: r.array,
        })),
      };
  }
  return null;
}
async function ok(t, e) {
  let [i, n] = p_(Nd.deserialize(new Uint8Array(t)));
  yN(i);
  let r = [];
  i.scene.objects.traverse((s, a) => {
    a.type === "Mesh" &&
      a.geometry.type === "NonParametricGeometry" &&
      a.geometry.data.draco !== void 0 &&
      r.push(a);
  }),
    r.length && (await sk());
  for (let s of r) {
    let a = await ak(Ai(s.geometry.data.draco));
    if (a) {
      a.index &&
        (s.geometry.data.index = {
          array: a.index.array,
          itemSize: 1,
          normalized: !1,
          type: "Uint32Array",
        });
      let o = {};
      a.attributes.forEach(({ name: l, array: c, itemSize: d }) => {
        o[l] = { array: c, itemSize: d, type: "Float32Array", normalized: !1 };
      }),
        (s.geometry.data.attributes = o),
        (s.geometry.data.draco = void 0);
    }
  }
  return e && e(i), n.result().data;
}
function lk(t) {
  let e;
  if (t.index)
    for (let i = 0; i < t.index.array.length; i += 3)
      (e = t.index.array[i]),
        (t.index.array[i] = t.index.array[i + 2]),
        (t.index.array[i + 2] = e);
}
function ck(t) {
  let e = new Set();
  return (
    t.traverse((i) => {
      if (i instanceof ia)
        if (Yn(i.material))
          i.material.forEach((n) => {
            let r = n;
            e.has(r) || e.add(r);
          });
        else {
          let n = i.material;
          e.has(n) || e.add(n);
        }
    }),
    e.forEach((i) => {
      if (i instanceof Array) return;
      let n = i.onBeforeCompile.bind(i);
      if (hk(i)) {
        Object.assign(i, {
          isMeshStandardMaterial: !0,
          isMeshPhysicalMaterial: !0,
          transmission: 1,
          attenuationColor: new tt(),
          specularColor: new tt(),
        });
        let r = 0;
        i.onBeforeCompile = (s, a) => {
          n && n(s, a),
            (s.uniforms = Object.assign({}, Nn.physical.uniforms, s.uniforms)),
            i.getLayersOfType("transmission").forEach((o) => {
              if (s.uniforms.transmissionSamplerMap.value) {
                let l = o.color;
                l &&
                  ((l.transmissionSamplerMap.value =
                    s.uniforms.transmissionSamplerMap.value),
                  (l.transmissionSamplerSize.value =
                    s.uniforms.transmissionSamplerSize.value),
                  (l.aspectRatio.value = EB(
                    window.innerWidth,
                    window.innerHeight
                  )),
                  (i.defines.IS_THREEJS_EXPORT = !0));
              } else r++, r < 2 && (i.needsUpdate = !0);
            });
        };
      } else
        uk(i) ||
          (i.onBeforeCompile = (r, s) => {
            n && n(r, s), (i.transparent = !1);
          });
    }),
    t
  );
}
function hk(t) {
  return t.getLayersOfType("transmission").length > 0;
}
function uk(t) {
  let e = 0;
  for (let i of t.layers) {
    if (i.data.type !== "displace" && i.data.isMask) return !0;
    if (i.type !== "light" && i.type !== "fresnel") {
      let n = i.uniforms["f" + i.id + "_alpha"];
      n && (e += (1 - e) * n.value);
    }
  }
  return e < 1;
}
function dk(t) {
  return (
    t.traverse((e) => {
      if (e.type === "Camera") {
        let i = e;
        i.type = i.cameraType;
      }
    }),
    t
  );
}
function fk(t) {
  let e = [],
    i = (n, r = 0) => {
      let s = r > 0 ? n + r : n;
      return e.includes(s) ? i(n, r + 1) : s;
    };
  return (
    t.traverse((n) => {
      if (e.includes(n.name)) {
        let r = n.name,
          s = i(n.name);
        if (((n.name = s), n.isMesh)) {
          let a = n;
          a.material instanceof Array
            ? a.material.forEach((o) => {
                o.name = o.name.replace(r, s);
              })
            : a.material.isAsset ||
              (a.material.name = a.material.name.replace(r, s));
        }
      }
      e.push(n.name);
    }),
    t
  );
}
function pk(t) {
  let e = [];
  return (
    t.traverse((i) => {
      i instanceof H1 && e.push(i);
    }),
    e.forEach((i) => {
      let n = i.object,
        r = [
          ...i.children
            .map((s) => {
              s.updateMatrix();
              let a;
              if (s.geometry !== void 0)
                try {
                  a = s.geometry.clone().applyMatrix4(s.matrix);
                } catch (o) {
                  console.error(o);
                }
              return a !== void 0 && s.matrix.determinant() < 0 && lk(a), a;
            })
            .filter((s) => s !== void 0),
        ];
      if (
        (!i.parameters.hideBase && n instanceof ps && r.unshift(n.geometry),
        r.length)
      ) {
        let s = Lx(r);
        n instanceof ps && (n.geometry = s);
      }
      i.removeFromParent(),
        n.setFromClonerState(null, { scene: t, shared: fF });
    }),
    t
  );
}
function mk(t) {
  return (
    t.traverse((e) => {
      e.matrixAutoUpdate = !0;
    }),
    t
  );
}
function gk(t) {
  Object.values(t.shared.materials).forEach((e) => {
    ld(e);
  }),
    t.scene.objects.traverse((e, i) => {
      "material" in i
        ? ld(i.material)
        : "materials" in i &&
          i.materials.forEach((n) => {
            ld(n);
          });
    });
}
function ld(t) {
  if (typeof t == "string") return;
  let e = [];
  t.layers.forEach((i, n) => {
    i.type === "outline" && e.push(n);
  }),
    e.reverse().forEach((i) => {
      t.layers.delete(i);
    }),
    e.length &&
      console.warn(
        "The Spline Loader currently does not support the outline layer."
      );
}
var vk = wl(gC(), 1);
function yk(t) {
  return (
    t.traverseMaterial((e) => {
      e.needsJitter = !1;
    }),
    t
  );
}
var ny =
    "The SplineLoader only accepts .splinecode files that are generated from Spline export panel.",
  xk = class extends _l {
    load(t, e, i, n = console.error) {
      let r = new Gc(this.manager);
      r.setPath(this.path),
        r.setResponseType("arraybuffer"),
        r.setRequestHeader(this.requestHeader),
        r.setWithCredentials(this.withCredentials),
        t.endsWith(".spline")
          ? console.warn(
              ny + " The .spline files are only meant to be used by the Editor."
            )
          : t.endsWith(".splinecode") || console.warn(ny),
        r.load(
          t,
          async (s) => {
            try {
              if (typeof s == "string")
                throw new Error("The .spline file is not binary!");
              let a = await this.parse(s);
              e(a);
            } catch (a) {
              n(a);
            }
          },
          i,
          n
        );
    }
    async parse(t) {
      let e = await ok(t, gk);
      e.version &&
        (0, vk.default)(e.version, "0.9.425") > 0 &&
        console.warn(
          "Your .splinecode file is more recent than the library. Please upgrade @splinetool/loader to the latest version."
        ),
        await Promise.all([vF(e) && Xz(), DF(e) && nF()].filter(Boolean));
      let i = new jp(e.shared);
      Object.values(i.getMaterials()).forEach((s) =>
        Object.assign(s, { isAsset: !0 })
      );
      let n = new rk(e.scene, i),
        r = n.activeCamera;
      return (
        r && Object.assign(r, { makeDefault: !0 }),
        (n = pk(n)),
        (n = ck(n)),
        (n = dk(n)),
        (n = fk(n)),
        (n = mk(n)),
        (n = yk(n)),
        n
      );
    }
  };
function _k(t) {
  let e;
  return {
    c() {
      (e = he("div")), this.h();
    },
    l(i) {
      (e = ue(i, "DIV", { class: !0 })), Oe(e).forEach(fe), this.h();
    },
    h() {
      Q(e, "class", "three-canvas");
    },
    m(i, n) {
      Mt(i, e, n), t[4](e);
    },
    p: Ei,
    i: Ei,
    o: Ei,
    d(i) {
      i && fe(e), t[4](null);
    },
  };
}
function bk(t, e, i) {
  let n;
  Af(t, Pc, (u) => i(7, (n = u)));
  let { isLoading: r = !1 } = e;
  function s(u, f, p, v, g) {
    let m = Math.sin((u - p * 2) / u) * g,
      x = Math.sin((f - v * 2) / f) * g;
    return new A(m, 0, x);
  }
  let { isHover: a = !1 } = e,
    { scrollProgress: o = 0 } = e,
    l;
  const c = new AbortController();
  let d;
  tl(async () => {
    localStorage.getItem("standtv");
    function u() {
      return [
        /Android/i,
        /webOS/i,
        /iPhone/i,
        /iPad/i,
        /iPod/i,
        /BlackBerry/i,
        /Windows Phone/i,
      ].some((N) => navigator.userAgent.match(N));
    }
    let f = window.innerWidth,
      p = window.innerHeight,
      v = u(),
      g = new Mx();
    new J();
    let m = new J(),
      x = new Ax();
    new A();
    let y = new ji(60, f / p, 0.1, 5e3),
      _ = new qf(),
      M = new gx({ antialias: !v });
    M.setSize(f, p),
      (M.shadowMap.enabled = !0),
      (M.shadowMap.type = By),
      l == null || l.appendChild(M.domElement);
    let b = new A(290, -400, 1400),
      E = new A(0, 0.540353936417444, 0),
      T = new A(0.4, 0.540353936417444, 0),
      S = new A(-696, -524, -58);
    y.position.set(b.x, b.y, b.z),
      y.rotation.set(E.x, E.y, E.z),
      i(1, (r = !0)),
      new xk(g).load(
        "https://prod.spline.design/eT-odXHjbLjvN6uT/scene.splinecode",
        (W) => {
          _.add(W);
        },
        (W) => {
          Pc.set((W.loaded / W.total) * 100);
        },
        (W) => {
          Cc({ message: xy(W.message), type: "error" }), eb(Pc, (n = 100), n);
        }
      ),
      (g.onLoad = function () {});
    let C = new Ex(16777215, 1, 5e3);
    new Cx(C, 100),
      C.position.set(-200, -200, 0),
      (C.castShadow = !1),
      (C.shadow.mapSize.width = 512),
      (C.shadow.mapSize.height = 512),
      (C.shadow.camera.near = 0.5),
      (C.shadow.camera.far = 5e3),
      _.add(C);
    let L = new ZA(M);
    L.addPass(new QA(_, y));
    const P = new Lr(_, y, f, p);
    (P.kernelRadius = 16),
      L.addPass(P),
      L.addPass(new Za(new J(f, p), 1.5, 0.4, 0));
    let R = new Px(JA);
    L.addPass(R),
      window.addEventListener(
        "mousemove",
        (W) => {
          new J(W.clientX, W.clientY),
            s(f, p, W.x, W.y, 0.1),
            (m.x = (W.clientX / window.innerWidth) * 2 - 1),
            (m.y = -(W.clientY / window.innerHeight) * 2 + 1),
            x.setFromCamera(m, y);
          const N = x.intersectObjects(_.children, !0);
          a &&
            C.position.set(
              N[0].point.x + 100,
              N[0].point.y + 100,
              N[0].point.z + 100
            );
        },
        { signal: c.signal }
      ),
      window.addEventListener(
        "resize",
        () => {
          (f = window.innerWidth),
            (p = window.innerHeight),
            (y.aspect = f / p),
            y.updateProjectionMatrix(),
            M.setSize(f, p),
            L.setSize(f, p);
        },
        { signal: c.signal }
      ),
      window.addEventListener(
        "scroll",
        (W) => {
          if (!l) return;
          let N = new A().lerpVectors(b, S, o),
            U = new A().lerpVectors(E, T, o);
          y.position.set(N.x, N.y, N.z),
            y.rotation.set(U.x, U.y, U.z),
            i(0, (l.style.opacity = `${1 - o}`), l);
        },
        { signal: c.signal }
      );
    function I() {
      M.render(_, y), (d = requestAnimationFrame(I));
    }
    I();
  }),
    tb(() => {
      c.abort(), cancelAnimationFrame(d);
    });
  function h(u) {
    Ia[u ? "unshift" : "push"](() => {
      (l = u), i(0, l);
    });
  }
  return (
    (t.$$set = (u) => {
      "isLoading" in u && i(1, (r = u.isLoading)),
        "isHover" in u && i(2, (a = u.isHover)),
        "scrollProgress" in u && i(3, (o = u.scrollProgress));
    }),
    [l, r, a, o, h]
  );
}
class wk extends vs {
  constructor(e) {
    super(),
      ys(this, e, bk, _k, gs, { isLoading: 1, isHover: 2, scrollProgress: 3 });
  }
}
function ry(t) {
  let e,
    i =
      '<span class="head-span w-full rounded-xl bg-base-content p-4 text-2xl text-base-300 shadow-lg">3 กันยายน 2566</span> <span class="divider svelte-9k8jjg"></span> <div class="item svelte-9k8jjg"><div class="sub-item svelte-9k8jjg"><div class="title svelte-9k8jjg"><span class="child-span">13:00 น. – 18:00 น.</span> <h2 class="text-3xl">ลงทะเบียน/เข้าที่พัก ติดตั้งโปสเตอร์และนำส่งไฟล์นำเสนอ</h2></div> <div class="info svelte-9k8jjg"><div class="svelte-9k8jjg"><span>สถานที่</span> <span>อาคารหอสมุดและแหล่งเรียนรู้</span></div></div></div></div> <span class="divider svelte-9k8jjg"></span> <div class="item svelte-9k8jjg"><div class="sub-item svelte-9k8jjg"><div class="title svelte-9k8jjg"><span class="child-span">18:00 น. – 19:00 น.</span> <h2 class="text-3xl">รับประทานอาหารเย็น</h2></div> <div class="info svelte-9k8jjg"><div class="svelte-9k8jjg"><span>สถานที่</span> <span>โรงอาหาร</span></div></div></div></div> <span class="divider svelte-9k8jjg"></span> <div class="item svelte-9k8jjg"><div class="sub-item svelte-9k8jjg"><div class="title svelte-9k8jjg"><span class="child-span">19:00 น. – 20:00 น.</span> <h2 class="text-3xl">ชี้แจงกิจกรรม</h2></div> <div class="info svelte-9k8jjg"><div class="svelte-9k8jjg"><span>สถานที่</span> <span>โรงยิม</span></div></div></div></div>',
    n,
    r,
    s;
  return {
    c() {
      (e = he("div")), (e.innerHTML = i), this.h();
    },
    l(a) {
      (e = ue(a, "DIV", { class: !0, ["data-svelte-h"]: !0 })),
        ht(e) !== "svelte-qbxksr" && (e.innerHTML = i),
        this.h();
    },
    h() {
      Q(e, "class", "items-container flex flex-col svelte-9k8jjg");
    },
    m(a, o) {
      Mt(a, e, o), (s = !0);
    },
    p(a, o) {},
    i(a) {
      s ||
        (a &&
          ph(() => {
            s &&
              (r && r.end(1),
              (n = mh(e, us, {
                axis: "y",
                delay: 0,
                duration: 300,
                easing: hs,
              })),
              n.start());
          }),
        (s = !0));
    },
    o(a) {
      n && n.invalidate(),
        a &&
          (r = gh(e, us, { axis: "y", delay: 0, duration: 300, easing: hs })),
        (s = !1);
    },
    d(a) {
      a && fe(e), a && r && r.end();
    },
  };
}
function sy(t) {
  let e,
    i = `<span class="head-span w-full rounded-xl bg-base-content p-4 text-2xl text-base-300 shadow-lg">4 กันยายน 2566</span> <span class="divider svelte-9k8jjg"></span> <div class="item svelte-9k8jjg"><div class="sub-item svelte-9k8jjg"><div class="title svelte-9k8jjg"><span class="child-span">7:00 น. – 8:00 น.</span> <h2 class="text-3xl">รับประทานอาหารเช้า</h2></div> <div class="info svelte-9k8jjg"><div class="svelte-9k8jjg"><span>สถานที่</span> <span>โรงอาหาร</span></div></div></div></div> <span class="divider svelte-9k8jjg"></span> <div class="item svelte-9k8jjg"><div class="sub-item svelte-9k8jjg"><div class="title svelte-9k8jjg"><span class="child-span">8:00 น. – 10:20 น.</span> <h2 class="text-3xl">พิธีเปิด</h2> <ul class="list-inside list-disc"><li>การแสดงพิธีเปิด</li> <li>กิจกรรมบรรยายสร้างแรงบัลดาลใจในการทำโครงงาน โดย ดร.สุพรรณ ยอดยิ่งยง</li></ul></div> <div class="info svelte-9k8jjg"><div class="svelte-9k8jjg"><span>สถานที่</span> <span>หอประชุมแคแสด</span></div></div></div></div> <span class="divider svelte-9k8jjg"></span> <div class="item svelte-9k8jjg"><div class="sub-item svelte-9k8jjg"><div class="title svelte-9k8jjg"><span class="child-span">10:30 น. – 10:45 น.</span> <h2 class="text-3xl">รับประทานอาหารว่าง</h2></div> <div class="info svelte-9k8jjg"><div class="svelte-9k8jjg"><span>สถานที่</span> <span>หอสมุด</span></div></div></div></div> <span class="divider svelte-9k8jjg"></span> <div class="item svelte-9k8jjg"><div class="sub-item-full svelte-9k8jjg"><div class="title svelte-9k8jjg"><span class="child-span">10:45 น. – 12:00 น.</span> <h2 class="text-3xl">นำเสนอโครงงาน</h2> <div class="svelte-9k8jjg"><a href="/schedule" class="btn-outline btn-sm btn">ดูรายละเอียดเพิ่มเติม</a> <div class="mt-4 svelte-9k8jjg"><div class="collapse-arrow collapse rounded-b-none border-b border-gray-500 bg-base-200/70 shadow-sm svelte-9k8jjg"><input type="checkbox" id="collapse-oral"/> <label class="collapse-title font-display" for="collapse-oral">นำเสนอโครงงานแบบปากเปล่า</label> <table class="collapse-content table dark:[&amp;_tr]:border-white/20"><thead><tr><th>สาขา</th> <th>สถานที่</th></tr></thead> <tbody><tr><td>ฟิสิกส์และดาราศาสตร์</td> <td><ul><li>ห้องฟิสิกส์ 1 (Oral Eng) (223)
															<a href="/schedule#PHYS-OE">ตาราง</a></li> <li>ห้องฟิสิกส์ 2 (Oral Thai) (212)

															<a href="/schedule#PHYS-OT">ตาราง</a></li></ul></td></tr> <tr><td>เคมีและวัสดุศาสตร์</td> <td><ul><li>ห้องเคมี 1 (Oral Eng) (224)
															<a href="/schedule#CHEM-OE">ตาราง</a></li> <li>ห้องเคมี 2 (Oral Thai) (213)
															<a href="/schedule#CHEM-OT">ตาราง</a></li></ul></td></tr> <tr><td>ชีววิทยา และสิ่งแวดล้อม</td> <td><ul><li>ห้องชีววิทยา 1 (Oral Eng) (225)
															<a href="/schedule#BIOL-OE">ตาราง</a></li> <li>ห้องชีววิทยา 2 (Oral Thai) (214)
															<a href="/schedule#BIOL-OT">ตาราง</a></li></ul></td></tr> <tr><td>คณิตศาสตร์</td> <td><ul><li>ห้องคณิตศาสตร์ 1 (Oral Eng) (226)
															<a href="/schedule#MATS-OE">ตาราง</a></li> <li>ห้องคณิตศาสตร์ 2 (Oral Thai) (216)
															<a href="/schedule#MATS-OT">ตาราง</a></li></ul></td></tr> <tr><td>คอมพิวเตอร์</td> <td><ul><li>ห้องคอมพิวเตอร์ 1 (Oral Eng) (227)
															<a href="/schedule#COMP-OE">ตาราง</a></li> <li>ห้องคอมพิวเตอร์ 2 (Oral Thai) (217)
															<a href="/schedule#COMP-OT">ตาราง</a></li></ul></td></tr> <tr><td>วิศวกรรมศาสตร์</td> <td><ul><li>ห้องวิศวกรรม 1 (Oral Eng) (228)
															<a href="/schedule#ENGI-OE">ตาราง</a></li> <li>ห้องวิศวกรรม 2 (Oral Thai) (218)
															<a href="/schedule#ENGI-OT">ตาราง</a></li></ul></td></tr></tbody></table></div> <div class="collapse-arrow collapse rounded-t-none bg-base-200/70 shadow-sm svelte-9k8jjg"><input type="checkbox" id="collapse-poster"/> <h3 class="collapse-title">นำเสนอโครงงานแบบโปสเตอร์</h3> <table class="collapse-content table dark:[&amp;_tr]:border-white/20"><thead><tr><th>สาขา</th> <th>สถานที่</th></tr></thead> <tbody><tr><td>ทุกสาขา</td> <td>ลานกิจกรรมห้องสมุด</td></tr></tbody></table></div></div></div></div></div></div> <span class="divider svelte-9k8jjg"></span> <div class="item svelte-9k8jjg"><div class="sub-item svelte-9k8jjg"><div class="title svelte-9k8jjg"><span class="child-span">12:00 น. – 13:00 น.</span> <h2 class="text-3xl">รับประทานอาหาร</h2></div> <div class="info svelte-9k8jjg"><div class="svelte-9k8jjg"><span>สถานที่</span> <span>โรงอาหาร</span></div></div></div></div> <span class="divider svelte-9k8jjg"></span> <div class="item svelte-9k8jjg"><div class="sub-item svelte-9k8jjg"><div class="title svelte-9k8jjg"><span class="child-span">13:00 น. – 16:30 น.</span> <h2 class="text-3xl">นักเรียนนำเสนอผลงานโครงงาน (ต่อ)</h2></div> <div class="info svelte-9k8jjg"><div class="svelte-9k8jjg"><span>สถานที่</span> <span>ตามที่ได้รับแจ้ง</span></div></div></div></div> <span class="divider svelte-9k8jjg"></span> <div class="item svelte-9k8jjg"><div class="sub-item svelte-9k8jjg"><div class="title svelte-9k8jjg"><span class="child-span">17:00 น. – 18:00 น.</span> <h2 class="text-3xl">พักผ่อนตามอัธยาศัย</h2></div></div></div> <span class="divider svelte-9k8jjg"></span> <div class="item svelte-9k8jjg"><div class="sub-item svelte-9k8jjg"><div class="title svelte-9k8jjg"><span class="child-span">18:00 น. – 21:00 น.</span> <h2 class="text-3xl">กิจกรรมกลุ่มสัมพันธ์</h2></div> <div class="info svelte-9k8jjg"><div class="svelte-9k8jjg"><span>สถานที่</span> <span>หอประชุมแคแสด</span></div></div></div></div>`,
    n,
    r,
    s;
  return {
    c() {
      (e = he("div")), (e.innerHTML = i), this.h();
    },
    l(a) {
      (e = ue(a, "DIV", { class: !0, ["data-svelte-h"]: !0 })),
        ht(e) !== "svelte-1mhb947" && (e.innerHTML = i),
        this.h();
    },
    h() {
      Q(e, "class", "items-container flex flex-col svelte-9k8jjg");
    },
    m(a, o) {
      Mt(a, e, o), (s = !0);
    },
    p(a, o) {},
    i(a) {
      s ||
        (a &&
          ph(() => {
            s &&
              (r && r.end(1),
              (n = mh(e, us, {
                axis: "y",
                delay: 0,
                duration: 300,
                easing: hs,
              })),
              n.start());
          }),
        (s = !0));
    },
    o(a) {
      n && n.invalidate(),
        a &&
          (r = gh(e, us, { axis: "y", delay: 0, duration: 300, easing: hs })),
        (s = !1);
    },
    d(a) {
      a && fe(e), a && r && r.end();
    },
  };
}
function ay(t) {
  let e,
    i =
      '<span class="head-span w-full rounded-xl bg-base-content p-4 text-2xl text-base-300 shadow-lg">5 กันยายน 2566</span> <span class="divider svelte-9k8jjg"></span> <div class="item svelte-9k8jjg"><div class="sub-item svelte-9k8jjg"><div class="title svelte-9k8jjg"><span class="child-span">7:00 น. – 8:30 น.</span> <h2 class="text-3xl">รับประทานอาหารเช้า</h2></div> <div class="info svelte-9k8jjg"><div class="svelte-9k8jjg"><span>สถานที่</span> <span>โรงอาหาร</span></div></div></div></div> <span class="divider svelte-9k8jjg"></span> <div class="item svelte-9k8jjg"><div class="sub-item svelte-9k8jjg"><div class="title svelte-9k8jjg"><span class="child-span">8:30 น. – 12:00 น.</span> <h2 class="text-3xl">กิจกรรมทัศนศึกษาแหล่งเรียนรู้นอกสถานที่</h2></div> <div class="info svelte-9k8jjg"><div class="svelte-9k8jjg"><span>สถานที่</span> <span>จังหวัดบุรีรัมย์</span></div></div></div></div> <span class="divider svelte-9k8jjg"></span> <div class="item svelte-9k8jjg"><div class="sub-item svelte-9k8jjg"><div class="title svelte-9k8jjg"><span class="child-span">12:00 น. – 13:00 น.</span> <h2 class="text-3xl">รับประทานอาหาร</h2></div> <div class="info svelte-9k8jjg"><div class="svelte-9k8jjg"><span>สถานที่</span> <span>นอกสถานที่</span></div></div></div></div> <span class="divider svelte-9k8jjg"></span> <div class="item svelte-9k8jjg"><div class="sub-item svelte-9k8jjg"><div class="title svelte-9k8jjg"><span class="child-span">13:00 น. – 16:00 น.</span> <h2 class="text-3xl">กิจกรรมทัศนศึกษาแหล่งเรียนรู้นอกสถานที่ (ต่อ)</h2></div> <div class="info svelte-9k8jjg"><div class="svelte-9k8jjg"><span>สถานที่</span> <span>จังหวัดบุรีรัมย์</span></div></div></div></div> <span class="divider svelte-9k8jjg"></span> <div class="item svelte-9k8jjg"><div class="sub-item svelte-9k8jjg"><div class="title svelte-9k8jjg"><span class="child-span">16:00 น. – 17:00 น.</span> <h2 class="text-3xl">จัดเตรียมการแสดงแลกเปลี่ยนทางวัฒนธรรม</h2></div> <div class="info svelte-9k8jjg"><div class="svelte-9k8jjg"><span>สถานที่</span> <span>ตามห้อง STUDY แต่ละหอ</span></div></div></div></div> <span class="divider svelte-9k8jjg"></span> <div class="item svelte-9k8jjg"><div class="sub-item svelte-9k8jjg"><div class="title svelte-9k8jjg"><span class="child-span">17:00 น. – 18:00 น.</span> <h2 class="text-3xl">รับประทานอาหารเย็น</h2></div> <div class="info svelte-9k8jjg"><div class="svelte-9k8jjg"><span>สถานที่</span> <span>โรงอาหาร</span></div></div></div></div> <span class="divider svelte-9k8jjg"></span> <div class="item svelte-9k8jjg"><div class="sub-item svelte-9k8jjg"><div class="title svelte-9k8jjg"><span class="child-span">18:00 น. – 22:00 น.</span> <h2 class="text-3xl">แลกเปลี่ยนทางวัฒนธรรมการแสดงของทั้ง 12 จ.ภ.</h2></div> <div class="info svelte-9k8jjg"><div class="svelte-9k8jjg"><span>สถานที่</span> <span>หอประชุมแคแสด</span></div></div></div></div>',
    n,
    r,
    s;
  return {
    c() {
      (e = he("div")), (e.innerHTML = i), this.h();
    },
    l(a) {
      (e = ue(a, "DIV", { class: !0, ["data-svelte-h"]: !0 })),
        ht(e) !== "svelte-tw8giu" && (e.innerHTML = i),
        this.h();
    },
    h() {
      Q(e, "class", "items-container flex flex-col svelte-9k8jjg");
    },
    m(a, o) {
      Mt(a, e, o), (s = !0);
    },
    p(a, o) {},
    i(a) {
      s ||
        (a &&
          ph(() => {
            s &&
              (r && r.end(1),
              (n = mh(e, us, {
                axis: "y",
                delay: 0,
                duration: 300,
                easing: hs,
              })),
              n.start());
          }),
        (s = !0));
    },
    o(a) {
      n && n.invalidate(),
        a &&
          (r = gh(e, us, { axis: "y", delay: 0, duration: 300, easing: hs })),
        (s = !1);
    },
    d(a) {
      a && fe(e), a && r && r.end();
    },
  };
}
function oy(t) {
  let e,
    i =
      '<span class="head-span w-full rounded-xl bg-base-content p-4 text-2xl text-base-300 shadow-lg">6 กันยายน 2566</span> <span class="divider svelte-9k8jjg"></span> <div class="item svelte-9k8jjg"><div class="sub-item svelte-9k8jjg"><div class="title svelte-9k8jjg"><span class="child-span">7:00 น. – 8:00 น.</span> <h2 class="text-3xl">รับประทานอาหารเช้า</h2></div> <div class="info svelte-9k8jjg"><div class="svelte-9k8jjg"><span>สถานที่</span> <span>โรงอาหาร</span></div></div></div></div> <span class="divider svelte-9k8jjg"></span> <div class="item svelte-9k8jjg"><div class="sub-item svelte-9k8jjg"><div class="title svelte-9k8jjg"><span class="child-span">8:30 น. – 10:00 น.</span> <h2 class="text-3xl">นักเรียนและครูเข้ารับฟังสรุปภาพรวมของโครงงานสาขาต่าง ๆ โดยผู้ทรงคุณวุฒิ</h2></div> <div class="info svelte-9k8jjg"><div class="svelte-9k8jjg"><span>สถานที่</span> <span>หอประชุมแคแสด</span></div></div></div></div> <span class="divider svelte-9k8jjg"></span> <div class="item svelte-9k8jjg"><div class="sub-item svelte-9k8jjg"><div class="title svelte-9k8jjg"><span class="child-span">10:00 น. – 10:30 น.</span> <h2 class="text-3xl">กล่าวสรุปงานประมวลภาพกิจกรรม</h2></div> <div class="info svelte-9k8jjg"><div class="svelte-9k8jjg"><span>สถานที่</span> <span>หอประชุมแคแสด</span></div></div></div></div> <span class="divider svelte-9k8jjg"></span> <div class="item svelte-9k8jjg"><div class="sub-item svelte-9k8jjg"><div class="title svelte-9k8jjg"><span class="child-span">10:30 น. – 12:00 น.</span> <h2 class="text-3xl">พิธีปิดและประกาศผลนำเสนอโครงงาน มอบโล่รางวัล รางวัล พร้อมเกียรติบัตร</h2></div> <div class="info svelte-9k8jjg"><div class="svelte-9k8jjg"><span>สถานที่</span> <span>หอประชุมแคแสด</span></div></div></div></div> <span class="divider svelte-9k8jjg"></span> <div class="item svelte-9k8jjg"><div class="sub-item svelte-9k8jjg"><div class="title svelte-9k8jjg"><span class="child-span">12:30 น. – 13:00 น.</span> <h2 class="text-3xl">รับประทานอาหารและเดินทางกลับโดยสวัสดิภาพ</h2></div> <div class="info svelte-9k8jjg"><div class="svelte-9k8jjg"><span>สถานที่</span> <span>โรงอาหาร</span></div></div></div></div>',
    n,
    r,
    s;
  return {
    c() {
      (e = he("div")), (e.innerHTML = i), this.h();
    },
    l(a) {
      (e = ue(a, "DIV", { class: !0, ["data-svelte-h"]: !0 })),
        ht(e) !== "svelte-s34136" && (e.innerHTML = i),
        this.h();
    },
    h() {
      Q(e, "class", "items-container flex flex-col svelte-9k8jjg");
    },
    m(a, o) {
      Mt(a, e, o), (s = !0);
    },
    p(a, o) {},
    i(a) {
      s ||
        (a &&
          ph(() => {
            s &&
              (r && r.end(1),
              (n = mh(e, us, {
                axis: "y",
                delay: 0,
                duration: 300,
                easing: hs,
              })),
              n.start());
          }),
        (s = !0));
    },
    o(a) {
      n && n.invalidate(),
        a &&
          (r = gh(e, us, { axis: "y", delay: 0, duration: 300, easing: hs })),
        (s = !1);
    },
    d(a) {
      a && fe(e), a && r && r.end();
    },
  };
}
function Sk(t) {
  let e,
    i,
    n,
    r,
    s,
    a,
    o,
    l,
    c,
    d,
    h,
    u,
    f,
    p,
    v,
    g,
    m,
    x,
    y,
    _,
    M,
    b,
    E,
    T,
    S = t[1] == 0 && ry(),
    w = t[1] == 1 && sy(),
    C = t[1] === 2 && ay(),
    L = t[1] === 3 && oy();
  return {
    c() {
      (e = he("div")),
        (i = he("div")),
        (n = he("button")),
        (r = Ii("3 กันยายน")),
        (a = Ie()),
        (o = he("button")),
        (l = Ii("4 กันยายน")),
        (d = Ie()),
        (h = he("button")),
        (u = Ii("5 กันยายน")),
        (p = Ie()),
        (v = he("button")),
        (g = Ii("6 กันยายน")),
        (x = Ie()),
        S && S.c(),
        (y = Ie()),
        w && w.c(),
        (_ = Ie()),
        C && C.c(),
        (M = Ie()),
        L && L.c(),
        this.h();
    },
    l(P) {
      e = ue(P, "DIV", { class: !0 });
      var R = Oe(e);
      i = ue(R, "DIV", { class: !0 });
      var I = Oe(i);
      n = ue(I, "BUTTON", { class: !0 });
      var W = Oe(n);
      (r = Ui(W, "3 กันยายน")),
        W.forEach(fe),
        (a = Ue(I)),
        (o = ue(I, "BUTTON", { class: !0 }));
      var N = Oe(o);
      (l = Ui(N, "4 กันยายน")),
        N.forEach(fe),
        (d = Ue(I)),
        (h = ue(I, "BUTTON", { class: !0 }));
      var U = Oe(h);
      (u = Ui(U, "5 กันยายน")),
        U.forEach(fe),
        (p = Ue(I)),
        (v = ue(I, "BUTTON", { class: !0 }));
      var G = Oe(v);
      (g = Ui(G, "6 กันยายน")),
        G.forEach(fe),
        I.forEach(fe),
        (x = Ue(R)),
        S && S.l(R),
        (y = Ue(R)),
        w && w.l(R),
        (_ = Ue(R)),
        C && C.l(R),
        (M = Ue(R)),
        L && L.l(R),
        R.forEach(fe),
        this.h();
    },
    h() {
      Q(n, "class", (s = "btn " + (t[1] == 0 ? "btn-accent" : ""))),
        Q(o, "class", (c = "btn " + (t[1] == 1 ? "btn-accent" : ""))),
        Q(h, "class", (f = "btn " + (t[1] == 2 ? "btn-accent" : ""))),
        Q(v, "class", (m = "btn " + (t[1] == 3 ? "btn-accent" : ""))),
        Q(i, "class", "date-select my-4 justify-center svelte-9k8jjg"),
        Q(
          e,
          "class",
          (b = "main-container flex flex-col " + t[0] + " svelte-9k8jjg")
        );
    },
    m(P, R) {
      Mt(P, e, R),
        $(e, i),
        $(i, n),
        $(n, r),
        $(i, a),
        $(i, o),
        $(o, l),
        $(i, d),
        $(i, h),
        $(h, u),
        $(i, p),
        $(i, v),
        $(v, g),
        $(e, x),
        S && S.m(e, null),
        $(e, y),
        w && w.m(e, null),
        $(e, _),
        C && C.m(e, null),
        $(e, M),
        L && L.m(e, null),
        E ||
          ((T = [
            Pa(n, "click", t[3]),
            Pa(o, "click", t[4]),
            Pa(h, "click", t[5]),
            Pa(v, "click", t[6]),
          ]),
          (E = !0));
    },
    p(P, [R]) {
      R & 2 &&
        s !== (s = "btn " + (P[1] == 0 ? "btn-accent" : "")) &&
        Q(n, "class", s),
        R & 2 &&
          c !== (c = "btn " + (P[1] == 1 ? "btn-accent" : "")) &&
          Q(o, "class", c),
        R & 2 &&
          f !== (f = "btn " + (P[1] == 2 ? "btn-accent" : "")) &&
          Q(h, "class", f),
        R & 2 &&
          m !== (m = "btn " + (P[1] == 3 ? "btn-accent" : "")) &&
          Q(v, "class", m),
        P[1] == 0
          ? S
            ? (S.p(P, R), R & 2 && Be(S, 1))
            : ((S = ry()), S.c(), Be(S, 1), S.m(e, y))
          : S &&
            (ki(),
            Xe(S, 1, 1, () => {
              S = null;
            }),
            Vi()),
        P[1] == 1
          ? w
            ? (w.p(P, R), R & 2 && Be(w, 1))
            : ((w = sy()), w.c(), Be(w, 1), w.m(e, _))
          : w &&
            (ki(),
            Xe(w, 1, 1, () => {
              w = null;
            }),
            Vi()),
        P[1] === 2
          ? C
            ? (C.p(P, R), R & 2 && Be(C, 1))
            : ((C = ay()), C.c(), Be(C, 1), C.m(e, M))
          : C &&
            (ki(),
            Xe(C, 1, 1, () => {
              C = null;
            }),
            Vi()),
        P[1] === 3
          ? L
            ? (L.p(P, R), R & 2 && Be(L, 1))
            : ((L = oy()), L.c(), Be(L, 1), L.m(e, null))
          : L &&
            (ki(),
            Xe(L, 1, 1, () => {
              L = null;
            }),
            Vi()),
        R & 1 &&
          b !==
            (b = "main-container flex flex-col " + P[0] + " svelte-9k8jjg") &&
          Q(e, "class", b);
    },
    i(P) {
      Be(S), Be(w), Be(C), Be(L);
    },
    o(P) {
      Xe(S), Xe(w), Xe(C), Xe(L);
    },
    d(P) {
      P && fe(e),
        S && S.d(),
        w && w.d(),
        C && C.d(),
        L && L.d(),
        (E = !1),
        yy(T);
    },
  };
}
function Mk(t, e, i) {
  let { class: n = "" } = e,
    r = 0;
  const s = {
    "September 3, 2023": 0,
    "September 4, 2023": 1,
    "September 5, 2023": 2,
    "September 6, 2023": 3,
  };
  function a(h) {
    i(1, (r = h)), localStorage.setItem("tab", h.toString());
  }
  tl(() => {
    const u = new Date().toDateString();
    if (u in s) i(1, (r = s[u]));
    else {
      const f = localStorage.getItem("tab");
      f && i(1, (r = parseInt(f)));
    }
  });
  const o = () => a(0),
    l = () => a(1),
    c = () => a(2),
    d = () => a(3);
  return (
    (t.$$set = (h) => {
      "class" in h && i(0, (n = h.class));
    }),
    [n, r, a, o, l, c, d]
  );
}
class Ek extends vs {
  constructor(e) {
    super(), ys(this, e, Mk, Sk, gs, { class: 0 });
  }
}
function Tk(t) {
  let e,
    i,
    n,
    r,
    s,
    a = "การนำเสนอ ONSITE",
    o,
    l,
    c,
    d,
    h =
      '<span class=" svelte-xu70ka">17–25</span> <span class="svelte-xu70ka">กรกฎาคม</span>',
    u,
    f,
    p,
    v = "ลงทะเบียนและส่งบทคัดย่อ",
    g,
    m,
    x = `ลงทะเบียนแข้าสู่ระบบ ยืนยัน ส่งบทคัดย่อ และส่งบทความหลังได้รับคำเชิญในระบบ ภายในวันที่
						25 กรกฎาคม ผ่านทางเว็บไซต์ <a class="link" href="https://3rdpss2023.pcshsbr.ac.th">https://3rdpss2023.pcshsbr.ac.th</a>`,
    y,
    _,
    M,
    b,
    E,
    T,
    S = `<div class="d-date svelte-xu70ka"><span class=" svelte-xu70ka">4–6</span> <span class="svelte-xu70ka">กันยายน</span></div> <div class="d-info svelte-xu70ka"><h1 class="svelte-xu70ka">The 3<sup>rd</sup> PCSHS Science symposium 2023</h1> <p class="svelte-xu70ka">งาน The 3<sup>rd</sup> PCSHS Science symposium 2023 จะจัดขึ้นในวันที่ 4–6 กันยายน 2566 ณ
						โรงเรียนวิทยาศาสตร์จุฬาภรณราชวิทยาลัย บุรีรัมย์ โดยสามารถดูตารางกิจกรรมได้ด้านล่าง</p></div>`,
    w,
    C,
    L,
    P,
    R,
    I = "การนำเสนอ ONLINE",
    W,
    N,
    U,
    G,
    k =
      '<span class=" svelte-xu70ka">17-31</span> <span class="svelte-xu70ka">กรกฎาคม</span>',
    B,
    V,
    X,
    H = "ลงทะเบียนการนำเสนอแบบ Online",
    j,
    Y,
    ee = `นักเรียนที่นำเสนอรูปแบบออนไลน์ (ไม่ได้เดินทาง)
						สามารถลงทะเบียนได้ผ่านเว็บไซต์แยกสำหรับกรณีออนไลน์ที่ <a href="https://www.pcshsbr.ac.th/pcshs_symposium2023_vdo/" class="link" target="_blank">https://www.pcshsbr.ac.th/pcshs_symposium2023_vdo/</a>`,
    Z,
    K,
    me,
    re,
    F,
    Te,
    be =
      '<div class="d-date svelte-xu70ka"><span class=" svelte-xu70ka">14-18</span> <span class="svelte-xu70ka">สิงหาคม</span></div> <div class="d-info svelte-xu70ka"><h1 class="svelte-xu70ka">ส่งวีดีโอนำเสนอ</h1> <p class="svelte-xu70ka">อัพโหลดบทความและคลิปวิดีโอผ่านช่อง YouTube ของโรงเรียน ภายในวันที่ 14–18 สิงหาคม</p></div>',
    oe,
    Me,
    Ae =
      '<div class="d-date svelte-xu70ka"><span class=" svelte-xu70ka">26</span> <span class="svelte-xu70ka">สิงหาคม</span></div> <div class="d-info svelte-xu70ka"><h1 class="svelte-xu70ka">ประกาศผลการตัดสิน</h1> <p class="svelte-xu70ka">คณะกรรมการรวบรวมคะแนนและดำเนินการประกาศผลการตัดสิน</p></div>',
    ye,
    _e;
  return (
    (b = new ni({ props: { icon: "mdi:open-in-new" } })),
    (me = new ni({ props: { icon: "mdi:open-in-new" } })),
    {
      c() {
        (e = he("div")),
          (i = he("div")),
          (n = he("input")),
          (r = Ie()),
          (s = he("div")),
          (s.textContent = a),
          (o = Ie()),
          (l = he("div")),
          (c = he("div")),
          (d = he("div")),
          (d.innerHTML = h),
          (u = Ie()),
          (f = he("div")),
          (p = he("h1")),
          (p.textContent = v),
          (g = Ie()),
          (m = he("p")),
          (m.innerHTML = x),
          (y = Ie()),
          (_ = he("a")),
          (M = Ii(`เข้าสู่ระบบ
						`)),
          At(b.$$.fragment),
          (E = Ie()),
          (T = he("div")),
          (T.innerHTML = S),
          (w = Ie()),
          (C = he("div")),
          (L = he("input")),
          (P = Ie()),
          (R = he("div")),
          (R.textContent = I),
          (W = Ie()),
          (N = he("div")),
          (U = he("div")),
          (G = he("div")),
          (G.innerHTML = k),
          (B = Ie()),
          (V = he("div")),
          (X = he("h1")),
          (X.textContent = H),
          (j = Ie()),
          (Y = he("p")),
          (Y.innerHTML = ee),
          (Z = Ie()),
          (K = he("a")),
          At(me.$$.fragment),
          (re = Ii("ลงทะเบียน")),
          (F = Ie()),
          (Te = he("div")),
          (Te.innerHTML = be),
          (oe = Ie()),
          (Me = he("div")),
          (Me.innerHTML = Ae),
          this.h();
      },
      l(Ee) {
        e = ue(Ee, "DIV", { class: !0 });
        var Le = Oe(e);
        i = ue(Le, "DIV", { class: !0 });
        var it = Oe(i);
        (n = ue(it, "INPUT", { type: !0 })),
          (r = Ue(it)),
          (s = ue(it, "DIV", { class: !0, ["data-svelte-h"]: !0 })),
          ht(s) !== "svelte-14xq1jc" && (s.textContent = a),
          (o = Ue(it)),
          (l = ue(it, "DIV", { class: !0 }));
        var O = Oe(l);
        c = ue(O, "DIV", { class: !0 });
        var D = Oe(c);
        (d = ue(D, "DIV", { class: !0, ["data-svelte-h"]: !0 })),
          ht(d) !== "svelte-1pqfx3z" && (d.innerHTML = h),
          (u = Ue(D)),
          (f = ue(D, "DIV", { class: !0 }));
        var ne = Oe(f);
        (p = ue(ne, "H1", { class: !0, ["data-svelte-h"]: !0 })),
          ht(p) !== "svelte-ixsicl" && (p.textContent = v),
          (g = Ue(ne)),
          (m = ue(ne, "P", { class: !0, ["data-svelte-h"]: !0 })),
          ht(m) !== "svelte-jn5q3w" && (m.innerHTML = x),
          (y = Ue(ne)),
          (_ = ue(ne, "A", { href: !0, class: !0 }));
        var pe = Oe(_);
        (M = Ui(
          pe,
          `เข้าสู่ระบบ
						`
        )),
          Ct(b.$$.fragment, pe),
          pe.forEach(fe),
          ne.forEach(fe),
          D.forEach(fe),
          (E = Ue(O)),
          (T = ue(O, "DIV", { class: !0, ["data-svelte-h"]: !0 })),
          ht(T) !== "svelte-1vqr76c" && (T.innerHTML = S),
          O.forEach(fe),
          it.forEach(fe),
          (w = Ue(Le)),
          (C = ue(Le, "DIV", { class: !0 }));
        var xe = Oe(C);
        (L = ue(xe, "INPUT", { type: !0 })),
          (P = Ue(xe)),
          (R = ue(xe, "DIV", { class: !0, ["data-svelte-h"]: !0 })),
          ht(R) !== "svelte-x7gjlh" && (R.textContent = I),
          (W = Ue(xe)),
          (N = ue(xe, "DIV", { class: !0 }));
        var we = Oe(N);
        U = ue(we, "DIV", { class: !0 });
        var Fe = Oe(U);
        (G = ue(Fe, "DIV", { class: !0, ["data-svelte-h"]: !0 })),
          ht(G) !== "svelte-dva4fg" && (G.innerHTML = k),
          (B = Ue(Fe)),
          (V = ue(Fe, "DIV", { class: !0 }));
        var Se = Oe(V);
        (X = ue(Se, "H1", { class: !0, ["data-svelte-h"]: !0 })),
          ht(X) !== "svelte-1qtawl" && (X.textContent = H),
          (j = Ue(Se)),
          (Y = ue(Se, "P", { class: !0, ["data-svelte-h"]: !0 })),
          ht(Y) !== "svelte-1nwv7p2" && (Y.innerHTML = ee),
          (Z = Ue(Se)),
          (K = ue(Se, "A", { href: !0, target: !0, class: !0 }));
        var le = Oe(K);
        Ct(me.$$.fragment, le),
          (re = Ui(le, "ลงทะเบียน")),
          le.forEach(fe),
          Se.forEach(fe),
          Fe.forEach(fe),
          (F = Ue(we)),
          (Te = ue(we, "DIV", { class: !0, ["data-svelte-h"]: !0 })),
          ht(Te) !== "svelte-1edqyx1" && (Te.innerHTML = be),
          (oe = Ue(we)),
          (Me = ue(we, "DIV", { class: !0, ["data-svelte-h"]: !0 })),
          ht(Me) !== "svelte-1xpg5q7" && (Me.innerHTML = Ae),
          we.forEach(fe),
          xe.forEach(fe),
          Le.forEach(fe),
          this.h();
      },
      h() {
        Q(n, "type", "checkbox"),
          Q(s, "class", "collapse-title text-xl font-medium"),
          Q(d, "class", "d-date svelte-xu70ka"),
          Q(p, "class", "svelte-xu70ka"),
          Q(m, "class", "svelte-xu70ka"),
          Q(_, "href", "/login"),
          Q(_, "class", "btn float-right"),
          Q(f, "class", "d-info svelte-xu70ka"),
          Q(c, "class", "item svelte-xu70ka"),
          Q(T, "class", "item svelte-xu70ka"),
          Q(l, "class", "collapse-content"),
          Q(
            i,
            "class",
            "collapse-arrow collapse mb-4 bg-base-200/70 shadow-sm"
          ),
          Q(L, "type", "checkbox"),
          Q(R, "class", "collapse-title text-xl font-medium"),
          Q(G, "class", "d-date svelte-xu70ka"),
          Q(X, "class", "svelte-xu70ka"),
          Q(Y, "class", "svelte-xu70ka"),
          Q(K, "href", "https://www.pcshsbr.ac.th/pcshs_symposium2023_vdo/"),
          Q(K, "target", "_blank"),
          Q(K, "class", "btn float-right"),
          Q(V, "class", "d-info svelte-xu70ka"),
          Q(U, "class", "item svelte-xu70ka"),
          Q(Te, "class", "item svelte-xu70ka"),
          Q(Me, "class", "item svelte-xu70ka"),
          Q(N, "class", "collapse-content"),
          Q(C, "class", "collapse-arrow collapse bg-base-200/70 shadow-sm"),
          Q(
            e,
            "class",
            (ye = Qp(`main-container ${t[0] || ""}`) + " svelte-xu70ka")
          );
      },
      m(Ee, Le) {
        Mt(Ee, e, Le),
          $(e, i),
          $(i, n),
          $(i, r),
          $(i, s),
          $(i, o),
          $(i, l),
          $(l, c),
          $(c, d),
          $(c, u),
          $(c, f),
          $(f, p),
          $(f, g),
          $(f, m),
          $(f, y),
          $(f, _),
          $(_, M),
          Pt(b, _, null),
          $(l, E),
          $(l, T),
          $(e, w),
          $(e, C),
          $(C, L),
          $(C, P),
          $(C, R),
          $(C, W),
          $(C, N),
          $(N, U),
          $(U, G),
          $(U, B),
          $(U, V),
          $(V, X),
          $(V, j),
          $(V, Y),
          $(V, Z),
          $(V, K),
          Pt(me, K, null),
          $(K, re),
          $(N, F),
          $(N, Te),
          $(N, oe),
          $(N, Me),
          (_e = !0);
      },
      p(Ee, [Le]) {
        (!_e ||
          (Le & 1 &&
            ye !==
              (ye = Qp(`main-container ${Ee[0] || ""}`) + " svelte-xu70ka"))) &&
          Q(e, "class", ye);
      },
      i(Ee) {
        _e || (Be(b.$$.fragment, Ee), Be(me.$$.fragment, Ee), (_e = !0));
      },
      o(Ee) {
        Xe(b.$$.fragment, Ee), Xe(me.$$.fragment, Ee), (_e = !1);
      },
      d(Ee) {
        Ee && fe(e), Lt(b), Lt(me);
      },
    }
  );
}
function Ak(t, e, i) {
  const n = [];
  let r = new Date(t);
  for (; r <= e; ) n.push(r.getDate()), r.setDate(r.getDate() + i);
  return n;
}
function Ck(t, e, i) {
  let { class: n = "" } = e,
    { calenderData: r } = e;
  return (
    tl(() => {
      Ak(new Date(r[0]["start-date"]), new Date(r[1]["end-date"]), 1).length *
        64;
    }),
    (t.$$set = (s) => {
      "class" in s && i(0, (n = s.class)),
        "calenderData" in s && i(1, (r = s.calenderData));
    }),
    [n, r]
  );
}
class Pk extends vs {
  constructor(e) {
    super(), ys(this, e, Ck, Tk, gs, { class: 0, calenderData: 1 });
  }
}
function Lk(t) {
  let e,
    i,
    n,
    r,
    s,
    a,
    o,
    l = "เขาพนมรุ้ง",
    c,
    d,
    h = `อุทยานประวัติศาสตร์พนมรุ้ง หรือ ปราสาทหินพนมรุ้ง เป็นหนึ่งในปราสาทหินในกลุ่มราชมรรคา
				ตั้งอยู่ที่หมู่ที่ 2 (บ้านดอนหนองแหน) ตำบลตาเป๊ก อำเภอเฉลิมพระเกียรติ
				ห่างจากตัวเมืองบุรีรัมย์ลงมาทางทิศใต้ประมาณ 77 กิโลเมตร ประกอบไปด้วยโบราณสถานสำคัญ
				ซึ่งตั้งอยู่บนยอดภูเขาไฟที่ดับสนิทแล้ว สูงประมาณ 200 เมตรจากพื้นราบ (ประมาณ 350
				เมตรจากระดับน้ำทะเลปานกลาง) คำว่า พนมรุ้ง นั้น มาจากภาษาเขมร คำว่า วนํรุง แปลว่า ภูเขาใหญ่`,
    u,
    f,
    p,
    v,
    g,
    m,
    x,
    y,
    _,
    M,
    b,
    E = "ช้างอารีนา",
    T,
    S,
    w = `ช้างอารีนา (อังกฤษ: Chang Arena, ชื่อเดิม: ไอ-โมบาย สเตเดียม) มีชื่ออย่างไม่เป็นทางการว่า
				ธันเดอร์คาสเซิลสเตเดียม (อังกฤษ: Thunder Castle Stadium)
				เป็นสนามกีฬาที่สร้างขึ้นเพื่อใช้เป็นสนามเหย้าของสโมสรฟุตบอลบุรีรัมย์ ยูไนเต็ด
				ตั้งอยู่ที่ตำบลในเมือง อำเภอเมืองบุรีรัมย์ จังหวัดบุรีรัมย์ สนามแห่งนี้มีความจุ 24,000
				ที่นั่ง (ในปี พ.ศ. 2557 ได้ต่อเติมเป็น 32,600 ที่นั่ง) โครงสร้างประกอบด้วยเหล็กและไฟเบอร์
				ซึ่งสร้างด้วยงบประมาณกว่า 500 ล้านบาท
				โดยเป็นเงินสนับสนุนภายใต้สัญญาการกำหนดชื่อจากไอ-โมบายและบางส่วนของนายเนวิน ชิดชอบ
				จัดเป็นสนามฟุตบอลที่ได้มาตรฐานแห่งแรกและแห่งเดียวในประเทศไทยที่ไม่มีลู่วิ่งคั่นสนามและผ่านมาตรฐานระดับโลกจากสหพันธ์ฟุตบอลระหว่างประเทศ,มาตรฐานสนามกีฬาระดับเอจากสมาพันธ์ฟุตบอลเอเชีย
				และสหพันธ์ฟุตบอลอาเซียน
				และยังได้บันทึกลงกินเนสบุ๊คว่าเป็นสนามฟุตบอลในระดับฟีฟ่าที่ใช้เวลาก่อสร้างน้อยที่สุดในโลกคือ
				256 วัน`,
    C,
    L,
    P,
    R,
    I,
    W,
    N,
    U,
    G;
  return (
    (r = new il({
      props: {
        options: { ar: "4:3", fit: "fill" },
        class: "aspect-[4/3] h-full w-full rounded-xl object-cover",
        title:
          "สิทธิพงษ์ อินทะนิน, CC BY-SA 4.0 <https://creativecommons.org/licenses/by-sa/4.0>, via Wikimedia Commons",
        file: "sym2023/panomrung.jpg",
        alt: "ภาพด้านหน้าปราสาทเขาพนมรุ้ง มีพระอาทิตย์ส่องลอดตรงกลางภาพ ถ่ายโดยสิทธิพงษ์ อินทะนิน",
      },
    })),
    (v = new ni({ props: { icon: "mdi:open-in-new" } })),
    (y = new il({
      props: {
        options: { ar: "4:3", fit: "fill" },
        class: "aspect-[4/3] h-full w-full rounded-xl object-cover",
        title:
          "::::=UT=::::, CC BY-SA 3.0 <https://creativecommons.org/licenses/by-sa/3.0>, via Wikimedia Commons",
        file: "sym2023/ChangArean.jpg",
        alt: "ภาพถ่ายภายในสนามช้างอารีนา แสดงสนามหญ้าแท้และแสตน",
      },
    })),
    (R = new ni({ props: { icon: "mdi:open-in-new" } })),
    (U = new ni({ props: { icon: "mdi:open-in-new" } })),
    {
      c() {
        (e = he("div")),
          (i = he("div")),
          (n = he("div")),
          At(r.$$.fragment),
          (s = Ie()),
          (a = he("div")),
          (o = he("h1")),
          (o.textContent = l),
          (c = Ie()),
          (d = he("p")),
          (d.textContent = h),
          (u = Ie()),
          (f = he("a")),
          (p = Ii("อ่านต่อ")),
          At(v.$$.fragment),
          (g = Ie()),
          (m = he("div")),
          (x = he("div")),
          At(y.$$.fragment),
          (_ = Ie()),
          (M = he("div")),
          (b = he("h1")),
          (b.textContent = E),
          (T = Ie()),
          (S = he("p")),
          (S.textContent = w),
          (C = Ie()),
          (L = he("a")),
          (P = Ii("อ่านต่อ")),
          At(R.$$.fragment),
          (I = Ie()),
          (W = he("a")),
          (N = Ii("สถานที่ท่องเที่ยวอื่น ๆ ในจังหวัดบุรีรัมย์ ")),
          At(U.$$.fragment),
          this.h();
      },
      l(k) {
        e = ue(k, "DIV", { class: !0 });
        var B = Oe(e);
        i = ue(B, "DIV", { class: !0 });
        var V = Oe(i);
        n = ue(V, "DIV", { class: !0 });
        var X = Oe(n);
        Ct(r.$$.fragment, X),
          X.forEach(fe),
          (s = Ue(V)),
          (a = ue(V, "DIV", { class: !0 }));
        var H = Oe(a);
        (o = ue(H, "H1", { class: !0, ["data-svelte-h"]: !0 })),
          ht(o) !== "svelte-l1o3r3" && (o.textContent = l),
          (c = Ue(H)),
          (d = ue(H, "P", { class: !0, ["data-svelte-h"]: !0 })),
          ht(d) !== "svelte-1q4eanr" && (d.textContent = h),
          (u = Ue(H)),
          (f = ue(H, "A", { href: !0, class: !0 }));
        var j = Oe(f);
        (p = Ui(j, "อ่านต่อ")),
          Ct(v.$$.fragment, j),
          j.forEach(fe),
          H.forEach(fe),
          V.forEach(fe),
          (g = Ue(B)),
          (m = ue(B, "DIV", { class: !0 }));
        var Y = Oe(m);
        x = ue(Y, "DIV", { class: !0 });
        var ee = Oe(x);
        Ct(y.$$.fragment, ee),
          ee.forEach(fe),
          (_ = Ue(Y)),
          (M = ue(Y, "DIV", { class: !0 }));
        var Z = Oe(M);
        (b = ue(Z, "H1", { class: !0, ["data-svelte-h"]: !0 })),
          ht(b) !== "svelte-thw7gu" && (b.textContent = E),
          (T = Ue(Z)),
          (S = ue(Z, "P", { class: !0, ["data-svelte-h"]: !0 })),
          ht(S) !== "svelte-tal0up" && (S.textContent = w),
          (C = Ue(Z)),
          (L = ue(Z, "A", { href: !0, class: !0 }));
        var K = Oe(L);
        (P = Ui(K, "อ่านต่อ")),
          Ct(R.$$.fragment, K),
          K.forEach(fe),
          Z.forEach(fe),
          Y.forEach(fe),
          (I = Ue(B)),
          (W = ue(B, "A", { href: !0, class: !0 }));
        var me = Oe(W);
        (N = Ui(me, "สถานที่ท่องเที่ยวอื่น ๆ ในจังหวัดบุรีรัมย์ ")),
          Ct(U.$$.fragment, me),
          me.forEach(fe),
          B.forEach(fe),
          this.h();
      },
      h() {
        Q(n, "class", "d-image svelte-1g2ppnu"),
          Q(o, "class", "svelte-1g2ppnu"),
          Q(d, "class", "line-clamp-3 text-ellipsis svelte-1g2ppnu"),
          Q(
            f,
            "href",
            "https://th.wikipedia.org/wiki/%E0%B8%AD%E0%B8%B8%E0%B8%97%E0%B8%A2%E0%B8%B2%E0%B8%99%E0%B8%9B%E0%B8%A3%E0%B8%B0%E0%B8%A7%E0%B8%B1%E0%B8%95%E0%B8%B4%E0%B8%A8%E0%B8%B2%E0%B8%AA%E0%B8%95%E0%B8%A3%E0%B9%8C%E0%B8%9E%E0%B8%99%E0%B8%A1%E0%B8%A3%E0%B8%B8%E0%B9%89%E0%B8%87"
          ),
          Q(f, "class", "btn-primary btn mt-4"),
          Q(a, "class", "d-info svelte-1g2ppnu"),
          Q(i, "class", "item svelte-1g2ppnu"),
          Q(x, "class", "d-image svelte-1g2ppnu"),
          Q(b, "class", "svelte-1g2ppnu"),
          Q(S, "class", "line-clamp-3 text-ellipsis svelte-1g2ppnu"),
          Q(
            L,
            "href",
            "https://th.wikipedia.org/wiki/%E0%B8%8A%E0%B9%89%E0%B8%B2%E0%B8%87%E0%B8%AD%E0%B8%B2%E0%B8%A3%E0%B8%B5%E0%B8%99%E0%B8%B2"
          ),
          Q(L, "class", "btn-primary btn mt-4"),
          Q(M, "class", "d-info svelte-1g2ppnu"),
          Q(m, "class", "item svelte-1g2ppnu"),
          Q(W, "href", "https://facebook.com/BuriramRoute"),
          Q(W, "class", "btn m-auto flex md:float-right"),
          Q(e, "class", "trip-container svelte-1g2ppnu");
      },
      m(k, B) {
        Mt(k, e, B),
          $(e, i),
          $(i, n),
          Pt(r, n, null),
          $(i, s),
          $(i, a),
          $(a, o),
          $(a, c),
          $(a, d),
          $(a, u),
          $(a, f),
          $(f, p),
          Pt(v, f, null),
          $(e, g),
          $(e, m),
          $(m, x),
          Pt(y, x, null),
          $(m, _),
          $(m, M),
          $(M, b),
          $(M, T),
          $(M, S),
          $(M, C),
          $(M, L),
          $(L, P),
          Pt(R, L, null),
          $(e, I),
          $(e, W),
          $(W, N),
          Pt(U, W, null),
          (G = !0);
      },
      p: Ei,
      i(k) {
        G ||
          (Be(r.$$.fragment, k),
          Be(v.$$.fragment, k),
          Be(y.$$.fragment, k),
          Be(R.$$.fragment, k),
          Be(U.$$.fragment, k),
          (G = !0));
      },
      o(k) {
        Xe(r.$$.fragment, k),
          Xe(v.$$.fragment, k),
          Xe(y.$$.fragment, k),
          Xe(R.$$.fragment, k),
          Xe(U.$$.fragment, k),
          (G = !1);
      },
      d(k) {
        k && fe(e), Lt(r), Lt(v), Lt(y), Lt(R), Lt(U);
      },
    }
  );
}
class Dk extends vs {
  constructor(e) {
    super(), ys(this, e, null, Lk, gs, {});
  }
}
const Rk =
  "" + new URL("../assets/SpeakerPatent.9a4e65af.jpg", import.meta.url).href;
function Ok(t) {
  let e, i;
  return (
    (e = new ni({ props: { icon: "mdi:open-in-new", class: "h-5 w-5" } })),
    {
      c() {
        At(e.$$.fragment);
      },
      l(n) {
        Ct(e.$$.fragment, n);
      },
      m(n, r) {
        Pt(e, n, r), (i = !0);
      },
      i(n) {
        i || (Be(e.$$.fragment, n), (i = !0));
      },
      o(n) {
        Xe(e.$$.fragment, n), (i = !1);
      },
      d(n) {
        Lt(e, n);
      },
    }
  );
}
function Ik(t) {
  let e, i;
  return (
    (e = new ni({ props: { icon: "mdi:download", class: "h-5 w-5" } })),
    {
      c() {
        At(e.$$.fragment);
      },
      l(n) {
        Ct(e.$$.fragment, n);
      },
      m(n, r) {
        Pt(e, n, r), (i = !0);
      },
      i(n) {
        i || (Be(e.$$.fragment, n), (i = !0));
      },
      o(n) {
        Xe(e.$$.fragment, n), (i = !1);
      },
      d(n) {
        Lt(e, n);
      },
    }
  );
}
function Uk(t) {
  let e, i, n, r, s, a, o, l, c, d;
  const h = [Ik, Ok],
    u = [];
  function f(p, v) {
    return p[3] ? 0 : 1;
  }
  return (
    (l = f(t)),
    (c = u[l] = h[l](t)),
    {
      c() {
        (e = he("tr")),
          (i = he("td")),
          (n = Ie()),
          (r = he("td")),
          (s = Ie()),
          (a = he("td")),
          (o = he("a")),
          c.c(),
          this.h();
      },
      l(p) {
        e = ue(p, "TR", {});
        var v = Oe(e);
        i = ue(v, "TD", {});
        var g = Oe(i);
        g.forEach(fe), (n = Ue(v)), (r = ue(v, "TD", {}));
        var m = Oe(r);
        m.forEach(fe), (s = Ue(v)), (a = ue(v, "TD", { class: !0 }));
        var x = Oe(a);
        o = ue(x, "A", { href: !0, target: !0, class: !0 });
        var y = Oe(o);
        c.l(y), y.forEach(fe), x.forEach(fe), v.forEach(fe), this.h();
      },
      h() {
        Q(o, "href", t[2]),
          Q(o, "target", "_blank"),
          Q(o, "class", "btn-info btn"),
          Q(a, "class", "text-center");
      },
      m(p, v) {
        Mt(p, e, v),
          $(e, i),
          (i.innerHTML = t[0]),
          $(e, n),
          $(e, r),
          (r.innerHTML = t[1]),
          $(e, s),
          $(e, a),
          $(a, o),
          u[l].m(o, null),
          (d = !0);
      },
      p(p, [v]) {
        (!d || v & 1) && (i.innerHTML = p[0]),
          (!d || v & 2) && (r.innerHTML = p[1]);
        let g = l;
        (l = f(p)),
          l !== g &&
            (ki(),
            Xe(u[g], 1, 1, () => {
              u[g] = null;
            }),
            Vi(),
            (c = u[l]),
            c || ((c = u[l] = h[l](p)), c.c()),
            Be(c, 1),
            c.m(o, null)),
          (!d || v & 4) && Q(o, "href", p[2]);
      },
      i(p) {
        d || (Be(c), (d = !0));
      },
      o(p) {
        Xe(c), (d = !1);
      },
      d(p) {
        p && fe(e), u[l].d();
      },
    }
  );
}
function Nk(t, e, i) {
  let { name: n = "<name>" } = e,
    { description: r = "<description>" } = e,
    { link: s = "<link>" } = e,
    { isDownload: a = !1 } = e;
  return (
    (t.$$set = (o) => {
      "name" in o && i(0, (n = o.name)),
        "description" in o && i(1, (r = o.description)),
        "link" in o && i(2, (s = o.link)),
        "isDownload" in o && i(3, (a = o.isDownload));
    }),
    [n, r, s, a]
  );
}
class zk extends vs {
  constructor(e) {
    super(),
      ys(this, e, Nk, Uk, gs, {
        name: 0,
        description: 1,
        link: 2,
        isDownload: 3,
      });
  }
}
function ly(t, e, i) {
  const n = t.slice();
  return (
    (n[1] = e[i].name),
    (n[2] = e[i].description),
    (n[3] = e[i].link),
    (n[4] = e[i].isDownload),
    n
  );
}
function Bk(t) {
  return { c: Ei, l: Ei, m: Ei, p: Ei, i: Ei, o: Ei, d: Ei };
}
function Fk(t) {
  let e,
    i,
    n = tm(t[0]),
    r = [];
  for (let o = 0; o < n.length; o += 1) r[o] = hy(ly(t, n, o));
  const s = (o) =>
    Xe(r[o], 1, 1, () => {
      r[o] = null;
    });
  let a = null;
  return (
    n.length || (a = cy()),
    {
      c() {
        for (let o = 0; o < r.length; o += 1) r[o].c();
        (e = em()), a && a.c();
      },
      l(o) {
        for (let l = 0; l < r.length; l += 1) r[l].l(o);
        (e = em()), a && a.l(o);
      },
      m(o, l) {
        for (let c = 0; c < r.length; c += 1) r[c] && r[c].m(o, l);
        Mt(o, e, l), a && a.m(o, l), (i = !0);
      },
      p(o, l) {
        if (l & 0) {
          n = tm(o[0]);
          let c;
          for (c = 0; c < n.length; c += 1) {
            const d = ly(o, n, c);
            r[c]
              ? (r[c].p(d, l), Be(r[c], 1))
              : ((r[c] = hy(d)),
                r[c].c(),
                Be(r[c], 1),
                r[c].m(e.parentNode, e));
          }
          for (ki(), c = n.length; c < r.length; c += 1) s(c);
          Vi(),
            !n.length && a
              ? a.p(o, l)
              : n.length
              ? a && (a.d(1), (a = null))
              : ((a = cy()), a.c(), a.m(e.parentNode, e));
        }
      },
      i(o) {
        if (!i) {
          for (let l = 0; l < n.length; l += 1) Be(r[l]);
          i = !0;
        }
      },
      o(o) {
        r = r.filter(Boolean);
        for (let l = 0; l < r.length; l += 1) Xe(r[l]);
        i = !1;
      },
      d(o) {
        o && fe(e), ib(r, o), a && a.d(o);
      },
    }
  );
}
function cy(t) {
  let e,
    i = '<td colspan="3" class="text-center">ไม่พบเอกสาร</td> ';
  return {
    c() {
      (e = he("tr")), (e.innerHTML = i);
    },
    l(n) {
      (e = ue(n, "TR", { ["data-svelte-h"]: !0 })),
        ht(e) !== "svelte-gwb0eo" && (e.innerHTML = i);
    },
    m(n, r) {
      Mt(n, e, r);
    },
    p: Ei,
    d(n) {
      n && fe(e);
    },
  };
}
function hy(t) {
  let e, i;
  return (
    (e = new zk({
      props: { description: t[2], name: t[1], link: t[3], isDownload: t[4] },
    })),
    {
      c() {
        At(e.$$.fragment);
      },
      l(n) {
        Ct(e.$$.fragment, n);
      },
      m(n, r) {
        Pt(e, n, r), (i = !0);
      },
      p: Ei,
      i(n) {
        i || (Be(e.$$.fragment, n), (i = !0));
      },
      o(n) {
        Xe(e.$$.fragment, n), (i = !1);
      },
      d(n) {
        Lt(e, n);
      },
    }
  );
}
function kk(t) {
  let e,
    i =
      '<td colspan="3" class="text-center"><div class="loading loading-spinner text-primary" role="status"><span class="sr-only">กำลังโหลด...</span></div></td>';
  return {
    c() {
      (e = he("tr")), (e.innerHTML = i);
    },
    l(n) {
      (e = ue(n, "TR", { ["data-svelte-h"]: !0 })),
        ht(e) !== "svelte-1wqlkwk" && (e.innerHTML = i);
    },
    m(n, r) {
      Mt(n, e, r);
    },
    p: Ei,
    i: Ei,
    o: Ei,
    d(n) {
      n && fe(e);
    },
  };
}
function Vk(t) {
  let e,
    i,
    n =
      '<tr class=""><th>ชื่อเอกสาร</th> <th>รายละเอียด</th> <th>ดาวน์โหลด</th></tr>',
    r,
    s,
    a,
    o = {
      ctx: t,
      current: null,
      token: null,
      hasCatch: !1,
      pending: kk,
      then: Fk,
      catch: Bk,
      value: 0,
      blocks: [, , ,],
    };
  return (
    db(hb(), o),
    {
      c() {
        (e = he("table")),
          (i = he("thead")),
          (i.innerHTML = n),
          (r = Ie()),
          (s = he("tbody")),
          o.block.c(),
          this.h();
      },
      l(l) {
        e = ue(l, "TABLE", { class: !0 });
        var c = Oe(e);
        (i = ue(c, "THEAD", { ["data-svelte-h"]: !0 })),
          ht(i) !== "svelte-omxb48" && (i.innerHTML = n),
          (r = Ue(c)),
          (s = ue(c, "TBODY", {}));
        var d = Oe(s);
        o.block.l(d), d.forEach(fe), c.forEach(fe), this.h();
      },
      h() {
        Q(
          e,
          "class",
          "table-pin-rows mt-8 table dark:[&_tr]:border-gray-500/50"
        );
      },
      m(l, c) {
        Mt(l, e, c),
          $(e, i),
          $(e, r),
          $(e, s),
          o.block.m(s, (o.anchor = null)),
          (o.mount = () => s),
          (o.anchor = null),
          (a = !0);
      },
      p(l, [c]) {
        (t = l), fb(o, t, c);
      },
      i(l) {
        a || (Be(o.block), (a = !0));
      },
      o(l) {
        for (let c = 0; c < 3; c += 1) {
          const d = o.blocks[c];
          Xe(d);
        }
        a = !1;
      },
      d(l) {
        l && fe(e), o.block.d(), (o.token = null), (o = null);
      },
    }
  );
}
class Hk extends vs {
  constructor(e) {
    super(), ys(this, e, null, Vk, gs, {});
  }
}
const { document: Oi } = ub;
function Gk(t) {
  let e, i, n, r, s, a, o, l, c, d, h, u, f, p, v, g;
  return (
    (i = new ni({ props: { icon: "mdi:schedule" } })),
    (a = new ni({ props: { icon: "mdi:calendar" } })),
    (d = new ni({ props: { icon: "mdi:map" } })),
    (p = new ni({ props: { icon: "mdi:arrow-down" } })),
    {
      c() {
        (e = he("a")),
          At(i.$$.fragment),
          (n = Ii(" ดูตารางการนำเสนอ")),
          (r = Ie()),
          (s = he("a")),
          At(a.$$.fragment),
          (o = Ii(" กำหนดการและลำดับนำเสนอ")),
          (l = Ie()),
          (c = he("a")),
          At(d.$$.fragment),
          (h = Ii(" แผนที่โรงเรียน")),
          (u = Ie()),
          (f = he("a")),
          At(p.$$.fragment),
          (v = Ii(" เลื่อนลงเพื่อดูข้อมูลเพิ่มเติม")),
          this.h();
      },
      l(m) {
        e = ue(m, "A", { class: !0, href: !0 });
        var x = Oe(e);
        Ct(i.$$.fragment, x),
          (n = Ui(x, " ดูตารางการนำเสนอ")),
          x.forEach(fe),
          (r = Ue(m)),
          (s = ue(m, "A", { class: !0, href: !0 }));
        var y = Oe(s);
        Ct(a.$$.fragment, y),
          (o = Ui(y, " กำหนดการและลำดับนำเสนอ")),
          y.forEach(fe),
          (l = Ue(m)),
          (c = ue(m, "A", { class: !0, href: !0 }));
        var _ = Oe(c);
        Ct(d.$$.fragment, _),
          (h = Ui(_, " แผนที่โรงเรียน")),
          _.forEach(fe),
          (u = Ue(m)),
          (f = ue(m, "A", { class: !0, href: !0 }));
        var M = Oe(f);
        Ct(p.$$.fragment, M),
          (v = Ui(M, " เลื่อนลงเพื่อดูข้อมูลเพิ่มเติม")),
          M.forEach(fe),
          this.h();
      },
      h() {
        Q(e, "class", "btn btn-lg h-20 w-full justify-start"),
          Q(e, "href", "/schedule"),
          Q(s, "class", "btn btn-lg h-20 w-full justify-start"),
          Q(s, "href", "/#event-schedule"),
          Q(c, "class", "btn btn-lg h-20 w-full justify-start"),
          Q(c, "href", "/map"),
          Q(f, "class", "btn btn-ghost btn-lg h-20 w-full justify-start"),
          Q(f, "href", "/#event-calendar");
      },
      m(m, x) {
        Mt(m, e, x),
          Pt(i, e, null),
          $(e, n),
          Mt(m, r, x),
          Mt(m, s, x),
          Pt(a, s, null),
          $(s, o),
          Mt(m, l, x),
          Mt(m, c, x),
          Pt(d, c, null),
          $(c, h),
          Mt(m, u, x),
          Mt(m, f, x),
          Pt(p, f, null),
          $(f, v),
          (g = !0);
      },
      i(m) {
        g ||
          (Be(i.$$.fragment, m),
          Be(a.$$.fragment, m),
          Be(d.$$.fragment, m),
          Be(p.$$.fragment, m),
          (g = !0));
      },
      o(m) {
        Xe(i.$$.fragment, m),
          Xe(a.$$.fragment, m),
          Xe(d.$$.fragment, m),
          Xe(p.$$.fragment, m),
          (g = !1);
      },
      d(m) {
        m && (fe(e), fe(r), fe(s), fe(l), fe(c), fe(u), fe(f)),
          Lt(i),
          Lt(a),
          Lt(d),
          Lt(p);
      },
    }
  );
}
function jk(t) {
  let e, i, n, r, s, a, o, l, c, d, h, u, f;
  return (
    (n = new ni({ props: { icon: "mdi:bullhorn", class: "h-5 w-5" } })),
    (o = new ni({ props: { icon: "mdi:file-certificate", class: "h-5 w-5" } })),
    (h = new ni({ props: { icon: "mdi:file-pdf", class: "xs:h-5 xs:w-5" } })),
    {
      c() {
        (e = he("div")),
          (i = he("a")),
          At(n.$$.fragment),
          (r = Ii(" ผลการแข่งขัน")),
          (s = Ie()),
          (a = he("a")),
          At(o.$$.fragment),
          (l = Ii(" เกียรติบัตร")),
          (c = Ie()),
          (d = he("a")),
          At(h.$$.fragment),
          (u = Ii(" เอกสารเผยแพร่")),
          this.h();
      },
      l(p) {
        e = ue(p, "DIV", { class: !0 });
        var v = Oe(e);
        i = ue(v, "A", { class: !0, href: !0 });
        var g = Oe(i);
        Ct(n.$$.fragment, g),
          (r = Ui(g, " ผลการแข่งขัน")),
          g.forEach(fe),
          (s = Ue(v)),
          (a = ue(v, "A", { class: !0, href: !0 }));
        var m = Oe(a);
        Ct(o.$$.fragment, m),
          (l = Ui(m, " เกียรติบัตร")),
          m.forEach(fe),
          v.forEach(fe),
          (c = Ue(p)),
          (d = ue(p, "A", { class: !0, href: !0 }));
        var x = Oe(d);
        Ct(h.$$.fragment, x),
          (u = Ui(x, " เอกสารเผยแพร่")),
          x.forEach(fe),
          this.h();
      },
      h() {
        Q(i, "class", "btn justify-start max-xs:btn-block"),
          Q(
            i,
            "href",
            "https://drive.google.com/file/d/13fM_To8-eoHN07U4Nho6wAFIBkyxYaED/view"
          ),
          Q(a, "class", "btn justify-start max-xs:btn-block"),
          Q(a, "href", "/certs"),
          Q(e, "class", "flex flex-col gap-1 max-xs:w-full xs:flex-row"),
          Q(d, "class", "btn justify-start max-xs:btn-block xs:btn-sm"),
          Q(d, "href", "/#event-document");
      },
      m(p, v) {
        Mt(p, e, v),
          $(e, i),
          Pt(n, i, null),
          $(i, r),
          $(e, s),
          $(e, a),
          Pt(o, a, null),
          $(a, l),
          Mt(p, c, v),
          Mt(p, d, v),
          Pt(h, d, null),
          $(d, u),
          (f = !0);
      },
      i(p) {
        f ||
          (Be(n.$$.fragment, p),
          Be(o.$$.fragment, p),
          Be(h.$$.fragment, p),
          (f = !0));
      },
      o(p) {
        Xe(n.$$.fragment, p),
          Xe(o.$$.fragment, p),
          Xe(h.$$.fragment, p),
          (f = !1);
      },
      d(p) {
        p && (fe(e), fe(c), fe(d)), Lt(n), Lt(o), Lt(h);
      },
    }
  );
}
function uy(t) {
  let e,
    i,
    n,
    r = "WE",
    s,
    a,
    o = "BUILD",
    l,
    c,
    d = "FUTURE",
    h,
    u,
    f = "TOGETER",
    p,
    v,
    g,
    m,
    x,
    y,
    _,
    M,
    b,
    E =
      '<img srcset="https://pcshsbr-assets.imgix.net/sym2023/HeroPic1.jpg?auto=format,compress&amp;w=100 100w, https://pcshsbr-assets.imgix.net/sym2023/HeroPic1.jpg?auto=format,compress&amp;w=116 116w, https://pcshsbr-assets.imgix.net/sym2023/HeroPic1.jpg?auto=format,compress&amp;w=134 134w, https://pcshsbr-assets.imgix.net/sym2023/HeroPic1.jpg?auto=format,compress&amp;w=156 156w, https://pcshsbr-assets.imgix.net/sym2023/HeroPic1.jpg?auto=format,compress&amp;w=182 182w, https://pcshsbr-assets.imgix.net/sym2023/HeroPic1.jpg?auto=format,compress&amp;w=210 210w, https://pcshsbr-assets.imgix.net/sym2023/HeroPic1.jpg?auto=format,compress&amp;w=244 244w, https://pcshsbr-assets.imgix.net/sym2023/HeroPic1.jpg?auto=format,compress&amp;w=282 282w, https://pcshsbr-assets.imgix.net/sym2023/HeroPic1.jpg?auto=format,compress&amp;w=328 328w, https://pcshsbr-assets.imgix.net/sym2023/HeroPic1.jpg?auto=format,compress&amp;w=380 380w, https://pcshsbr-assets.imgix.net/sym2023/HeroPic1.jpg?auto=format,compress&amp;w=442 442w, https://pcshsbr-assets.imgix.net/sym2023/HeroPic1.jpg?auto=format,compress&amp;w=512 512w, https://pcshsbr-assets.imgix.net/sym2023/HeroPic1.jpg?auto=format,compress&amp;w=594 594w, https://pcshsbr-assets.imgix.net/sym2023/HeroPic1.jpg?auto=format,compress&amp;w=688 688w, https://pcshsbr-assets.imgix.net/sym2023/HeroPic1.jpg?auto=format,compress&amp;w=798 798w, https://pcshsbr-assets.imgix.net/sym2023/HeroPic1.jpg?auto=format,compress&amp;w=926 926w, https://pcshsbr-assets.imgix.net/sym2023/HeroPic1.jpg?auto=format,compress&amp;w=1074 1074w, https://pcshsbr-assets.imgix.net/sym2023/HeroPic1.jpg?auto=format,compress&amp;w=1246 1246w, https://pcshsbr-assets.imgix.net/sym2023/HeroPic1.jpg?auto=format,compress&amp;w=1446 1446w, https://pcshsbr-assets.imgix.net/sym2023/HeroPic1.jpg?auto=format,compress&amp;w=1678 1678w, https://pcshsbr-assets.imgix.net/sym2023/HeroPic1.jpg?auto=format,compress&amp;w=1946 1946w, https://pcshsbr-assets.imgix.net/sym2023/HeroPic1.jpg?auto=format,compress&amp;w=2258 2258w, https://pcshsbr-assets.imgix.net/sym2023/HeroPic1.jpg?auto=format,compress&amp;w=2618 2618w, https://pcshsbr-assets.imgix.net/sym2023/HeroPic1.jpg?auto=format,compress&amp;w=3038 3038w, https://pcshsbr-assets.imgix.net/sym2023/HeroPic1.jpg?auto=format,compress&amp;w=3524 3524w, https://pcshsbr-assets.imgix.net/sym2023/HeroPic1.jpg?auto=format,compress&amp;w=4088 4088w, https://pcshsbr-assets.imgix.net/sym2023/HeroPic1.jpg?auto=format,compress&amp;w=4742 4742w, https://pcshsbr-assets.imgix.net/sym2023/HeroPic1.jpg?auto=format,compress&amp;w=5500 5500w, https://pcshsbr-assets.imgix.net/sym2023/HeroPic1.jpg?auto=format,compress&amp;w=6380 6380w, https://pcshsbr-assets.imgix.net/sym2023/HeroPic1.jpg?auto=format,compress&amp;w=7400 7400w" src="https://pcshsbr-assets.imgix.net/sym2023/HeroPic1.jpg?ixembed=1689152679867&amp;auto=format,compress" class="info-img h-full w-full object-cover" alt="ภาพถ่ายบรรยายกาศการนำเสนอโครงงาน"/>',
    T,
    S,
    w = `<h1 class="bg-gradient-to-r from-primary to-secondary bg-clip-text text-6xl font-bold text-transparent">PCSHS SCIENCE SYMPOSIUM</h1> <p class=""><span class="bg-gradient-to-r from-primary to-secondary bg-clip-text font-bold text-transparent">PCSHS Science Symposium</span> มีเป้าหมายเพื่อส่งเสริมการพัฒนาและเผยแพร่โครงงานวิทยาศาสตร์และเทคโนโลยีของนักเรียนภายในกลุ่มโรงเรียนวิทยาศาสตร์จุฬาภรณราชวิทยาลัย
					(PCSHS) ทั้ง 12 แห่ง โดยจัดเป็นการนำเสนอผลงานโครงงานของนักเรียนระดับชั้นมัธยมศึกษาปีที่ 6 ณ
					โรงเรียนวิทยาศาสตร์จุฬาภรณราชวิทยาลัยเจ้าภาพ โดยนอกจากเป็นการแสดงผลงานของนักเรียนแล้ว ยังเป็นการเผยแพร่วัฒนธรรมและวิถีชีวิตของคนในท้องถิ่น
					เพื่อการพัฒนานักเรียนให้มีศักยภาพสอดรับกับความต้องการของประเทศ และนำองค์ความรู้มาพัฒนาประเทศในด้านต่าง
					ๆ ต่อไปในอนาคต</p>`,
    C,
    L,
    P,
    R,
    I,
    W,
    N,
    U,
    G,
    k,
    B = "Improving a Sustainable World through Innovation and Projects",
    V;
  return (
    (g = new ni({ props: { icon: "material-symbols:circle" } })),
    (x = new ni({ props: { icon: "mdi:triangle" } })),
    (_ = new ni({ props: { icon: "mdi:square" } })),
    (R = new ni({ props: { icon: "material-symbols:circle" } })),
    (W = new ni({ props: { icon: "mdi:triangle" } })),
    (U = new ni({ props: { icon: "mdi:square" } })),
    {
      c() {
        (e = he("section")),
          (i = he("div")),
          (n = he("span")),
          (n.textContent = r),
          (s = Ie()),
          (a = he("span")),
          (a.textContent = o),
          (l = Ie()),
          (c = he("span")),
          (c.textContent = d),
          (h = Ie()),
          (u = he("span")),
          (u.textContent = f),
          (p = Ie()),
          (v = he("div")),
          At(g.$$.fragment),
          (m = Ie()),
          At(x.$$.fragment),
          (y = Ie()),
          At(_.$$.fragment),
          (M = Ie()),
          (b = he("div")),
          (b.innerHTML = E),
          (T = Ie()),
          (S = he("div")),
          (S.innerHTML = w),
          (C = Ie()),
          (L = he("div")),
          (P = he("div")),
          At(R.$$.fragment),
          (I = Ie()),
          At(W.$$.fragment),
          (N = Ie()),
          At(U.$$.fragment),
          (G = Ie()),
          (k = he("span")),
          (k.textContent = B),
          this.h();
      },
      l(X) {
        e = ue(X, "SECTION", { class: !0 });
        var H = Oe(e);
        i = ue(H, "DIV", { class: !0 });
        var j = Oe(i);
        (n = ue(j, "SPAN", { class: !0, ["data-svelte-h"]: !0 })),
          ht(n) !== "svelte-waxgu9" && (n.textContent = r),
          (s = Ue(j)),
          (a = ue(j, "SPAN", { class: !0, ["data-svelte-h"]: !0 })),
          ht(a) !== "svelte-1todp4h" && (a.textContent = o),
          (l = Ue(j)),
          (c = ue(j, "SPAN", { class: !0, ["data-svelte-h"]: !0 })),
          ht(c) !== "svelte-1hvfmdo" && (c.textContent = d),
          (h = Ue(j)),
          (u = ue(j, "SPAN", { class: !0, ["data-svelte-h"]: !0 })),
          ht(u) !== "svelte-xsd90x" && (u.textContent = f),
          (p = Ue(j)),
          (v = ue(j, "DIV", { class: !0 }));
        var Y = Oe(v);
        Ct(g.$$.fragment, Y),
          (m = Ue(Y)),
          Ct(x.$$.fragment, Y),
          (y = Ue(Y)),
          Ct(_.$$.fragment, Y),
          Y.forEach(fe),
          j.forEach(fe),
          (M = Ue(H)),
          (b = ue(H, "DIV", { class: !0, ["data-svelte-h"]: !0 })),
          ht(b) !== "svelte-6zr626" && (b.innerHTML = E),
          (T = Ue(H)),
          (S = ue(H, "DIV", { class: !0, ["data-svelte-h"]: !0 })),
          ht(S) !== "svelte-1q0es38" && (S.innerHTML = w),
          (C = Ue(H)),
          (L = ue(H, "DIV", { class: !0 }));
        var ee = Oe(L);
        P = ue(ee, "DIV", { class: !0 });
        var Z = Oe(P);
        Ct(R.$$.fragment, Z),
          (I = Ue(Z)),
          Ct(W.$$.fragment, Z),
          (N = Ue(Z)),
          Ct(U.$$.fragment, Z),
          Z.forEach(fe),
          (G = Ue(ee)),
          (k = ue(ee, "SPAN", { class: !0, ["data-svelte-h"]: !0 })),
          ht(k) !== "svelte-1rb56hb" && (k.textContent = B),
          ee.forEach(fe),
          H.forEach(fe),
          this.h();
      },
      h() {
        Q(n, "class", ""),
          Q(a, "class", ""),
          Q(c, "class", ""),
          Q(u, "class", ""),
          Q(v, "class", "my-2 mr-2 flex"),
          Q(
            i,
            "class",
            "background absolute -left-10 top-5 flex rotate-90 flex-col text-8xl text-base-content/50 blur-md"
          ),
          Q(b, "class", "relative h-40 overflow-hidden rounded-3xl"),
          Q(S, "class", "info-paragrpah relative"),
          Q(P, "class", "my-2 mr-2 flex"),
          Q(k, "class", "text-sm"),
          Q(
            L,
            "class",
            "event-poem flex flex-row flex-wrap items-center pt-10"
          ),
          Q(e, "class", "event-info relative mx-auto max-w-4xl px-10 py-40");
      },
      m(X, H) {
        Mt(X, e, H),
          $(e, i),
          $(i, n),
          $(i, s),
          $(i, a),
          $(i, l),
          $(i, c),
          $(i, h),
          $(i, u),
          $(i, p),
          $(i, v),
          Pt(g, v, null),
          $(v, m),
          Pt(x, v, null),
          $(v, y),
          Pt(_, v, null),
          $(e, M),
          $(e, b),
          $(e, T),
          $(e, S),
          $(e, C),
          $(e, L),
          $(L, P),
          Pt(R, P, null),
          $(P, I),
          Pt(W, P, null),
          $(P, N),
          Pt(U, P, null),
          $(L, G),
          $(L, k),
          (V = !0);
      },
      i(X) {
        V ||
          (Be(g.$$.fragment, X),
          Be(x.$$.fragment, X),
          Be(_.$$.fragment, X),
          Be(R.$$.fragment, X),
          Be(W.$$.fragment, X),
          Be(U.$$.fragment, X),
          (V = !0));
      },
      o(X) {
        Xe(g.$$.fragment, X),
          Xe(x.$$.fragment, X),
          Xe(_.$$.fragment, X),
          Xe(R.$$.fragment, X),
          Xe(W.$$.fragment, X),
          Xe(U.$$.fragment, X),
          (V = !1);
      },
      d(X) {
        X && fe(e), Lt(g), Lt(x), Lt(_), Lt(R), Lt(W), Lt(U);
      },
    }
  );
}
function dy(t) {
  let e,
    i,
    n,
    r,
    s =
      '<span class="circle interactive bg-primary/50 svelte-2k4y2e"></span> <span class="circle left-10 top-0 scale-[5] bg-primary/50 svelte-2k4y2e"></span> <span class="circle right-0 top-20 scale-[3] bg-primary/50 svelte-2k4y2e"></span>',
    a,
    o,
    l,
    c =
      '<h2 class="m-0 flex items-center text-6xl font-bold"><span>ปฏิทิน</span></h2>',
    d,
    h,
    u;
  return (
    (h = new Pk({ props: { class: "", calenderData: Wb } })),
    {
      c() {
        (e = he("section")),
          (i = he("span")),
          (n = Ie()),
          (r = he("div")),
          (r.innerHTML = s),
          (a = Ie()),
          (o = he("div")),
          (l = he("div")),
          (l.innerHTML = c),
          (d = Ie()),
          At(h.$$.fragment),
          this.h();
      },
      l(f) {
        e = ue(f, "SECTION", { id: !0, class: !0 });
        var p = Oe(e);
        (i = ue(p, "SPAN", { class: !0, id: !0 })),
          Oe(i).forEach(fe),
          (n = Ue(p)),
          (r = ue(p, "DIV", { class: !0, ["data-svelte-h"]: !0 })),
          ht(r) !== "svelte-1439v9u" && (r.innerHTML = s),
          (a = Ue(p)),
          (o = ue(p, "DIV", { class: !0 }));
        var v = Oe(o);
        (l = ue(v, "DIV", { class: !0, ["data-svelte-h"]: !0 })),
          ht(l) !== "svelte-tevflf" && (l.innerHTML = c),
          (d = Ue(v)),
          Ct(h.$$.fragment, v),
          v.forEach(fe),
          p.forEach(fe),
          this.h();
      },
      h() {
        Q(i, "class", "target-anchor"),
          Q(i, "id", "event-schedule"),
          Q(r, "class", "background"),
          Q(l, "class", "pb-4"),
          Q(o, "class", "calendar-info relative mx-auto max-w-6xl p-10"),
          Q(e, "id", "event-calendar"),
          Q(
            e,
            "class",
            "event-calendar hover-effect relative mx-auto overflow-hidden bg-base-300"
          );
      },
      m(f, p) {
        Mt(f, e, p),
          $(e, i),
          $(e, n),
          $(e, r),
          $(e, a),
          $(e, o),
          $(o, l),
          $(o, d),
          Pt(h, o, null),
          (u = !0);
      },
      p: Ei,
      i(f) {
        u || (Be(h.$$.fragment, f), (u = !0));
      },
      o(f) {
        Xe(h.$$.fragment, f), (u = !1);
      },
      d(f) {
        f && fe(e), Lt(h);
      },
    }
  );
}
function fy(t) {
  let e, i, n;
  return (
    (i = new ni({ props: { icon: "mdi:home" } })),
    {
      c() {
        (e = he("a")), At(i.$$.fragment), this.h();
      },
      l(r) {
        e = ue(r, "A", { href: !0, class: !0 });
        var s = Oe(e);
        Ct(i.$$.fragment, s), s.forEach(fe), this.h();
      },
      h() {
        Q(e, "href", "/#hero-sticky"), Q(e, "class", "btn btn-accent mr-4");
      },
      m(r, s) {
        Mt(r, e, s), Pt(i, e, null), (n = !0);
      },
      i(r) {
        n || (Be(i.$$.fragment, r), (n = !0));
      },
      o(r) {
        Xe(i.$$.fragment, r), (n = !1);
      },
      d(r) {
        r && fe(e), Lt(i);
      },
    }
  );
}
function py(t) {
  let e,
    i,
    n,
    r,
    s =
      '<div class="text-c-1 absolute -bottom-[100%] left-0 z-[1000] transition-all duration-500 svelte-2k4y2e"><div class="text-c-2 p-8 transition-all duration-500"><h3 class="text-4xl font-bold">แผนที่โรงเรียน</h3> <p>คลิกที่นี่เพื่อดูแผนที่โรงเรียน</p></div></div>',
    a,
    o,
    l,
    c,
    d;
  return (
    (c = new il({
      props: {
        class: "z-[100] h-full w-full object-cover transition-all duration-500",
        alt: "ภาพแผนที่โรงเรียนแบบคร่าว ๆ",
        file: "sym2023/school-map.png",
      },
    })),
    {
      c() {
        (e = he("section")),
          (i = he("a")),
          (n = he("div")),
          (r = he("div")),
          (r.innerHTML = s),
          (a = Ie()),
          (o = he("span")),
          (l = Ie()),
          At(c.$$.fragment),
          this.h();
      },
      l(h) {
        e = ue(h, "SECTION", { id: !0, class: !0 });
        var u = Oe(e);
        i = ue(u, "A", { href: !0, target: !0 });
        var f = Oe(i);
        n = ue(f, "DIV", { class: !0 });
        var p = Oe(n);
        (r = ue(p, "DIV", { ["data-svelte-h"]: !0 })),
          ht(r) !== "svelte-1t379yn" && (r.innerHTML = s),
          (a = Ue(p)),
          (o = ue(p, "SPAN", { class: !0 })),
          Oe(o).forEach(fe),
          (l = Ue(p)),
          Ct(c.$$.fragment, p),
          p.forEach(fe),
          f.forEach(fe),
          u.forEach(fe),
          this.h();
      },
      h() {
        Q(o, "class", "transition-all duration-500 svelte-2k4y2e"),
          Q(
            n,
            "class",
            "main-c-1 relative mx-auto h-[30rem] max-w-[60rem] overflow-hidden rounded-3xl transition-all duration-500 svelte-2k4y2e"
          ),
          Q(i, "href", "/map"),
          Q(i, "target", "_blank"),
          Q(e, "id", "school-map"),
          Q(e, "class", "school-map p-10 svelte-2k4y2e");
      },
      m(h, u) {
        Mt(h, e, u),
          $(e, i),
          $(i, n),
          $(n, r),
          $(n, a),
          $(n, o),
          $(n, l),
          Pt(c, n, null),
          (d = !0);
      },
      i(h) {
        d || (Be(c.$$.fragment, h), (d = !0));
      },
      o(h) {
        Xe(c.$$.fragment, h), (d = !1);
      },
      d(h) {
        h && fe(e), Lt(c);
      },
    }
  );
}
function my(t) {
  let e,
    i,
    n,
    r =
      '<h2 class="m-0 flex items-center text-6xl font-bold"><span>ทัศนศึกษา</span></h2>',
    s,
    a,
    o;
  return (
    (a = new Dk({})),
    {
      c() {
        (e = he("section")),
          (i = he("div")),
          (n = he("div")),
          (n.innerHTML = r),
          (s = Ie()),
          At(a.$$.fragment),
          this.h();
      },
      l(l) {
        e = ue(l, "SECTION", { id: !0, class: !0 });
        var c = Oe(e);
        i = ue(c, "DIV", { class: !0 });
        var d = Oe(i);
        (n = ue(d, "DIV", { class: !0, ["data-svelte-h"]: !0 })),
          ht(n) !== "svelte-1q6e4ff" && (n.innerHTML = r),
          (s = Ue(d)),
          Ct(a.$$.fragment, d),
          d.forEach(fe),
          c.forEach(fe),
          this.h();
      },
      h() {
        Q(n, "class", "relative z-10"),
          Q(i, "class", "mx-auto max-w-6xl p-10"),
          Q(e, "id", "event-trip"),
          Q(e, "class", "event-trip relative mx-auto overflow-hidden");
      },
      m(l, c) {
        Mt(l, e, c), $(e, i), $(i, n), $(i, s), Pt(a, i, null), (o = !0);
      },
      i(l) {
        o || (Be(a.$$.fragment, l), (o = !0));
      },
      o(l) {
        Xe(a.$$.fragment, l), (o = !1);
      },
      d(l) {
        l && fe(e), Lt(a);
      },
    }
  );
}
function gy(t) {
  let e,
    i,
    n,
    r =
      '<h2 class="m-0 flex items-center text-6xl font-bold"><span>วิทยากร</span></h2>',
    s,
    a,
    o,
    l,
    c,
    d,
    h,
    u,
    f,
    p = `<h3 class="mb-6 text-2xl font-bold">ดร.สุพรรณ ยอดยิ่งยง</h3> <p>คว้ารางวัล Special Prize (On stage) จากผลงาน
							&quot;กระบวนการสังเคราะห์ซิลิกาแอโรเจลต้นทุนต่ำด้วยการทำแห้งที่ความดันบรรยากาศ&quot; จาก
							INDONESIAN INVENTION AND INNOVATION PROMOTION ASSOCIATION (INNOPA) ประเทศอินโดนีเซีย
							ในงาน Bitgaram International Exposition of Electric Power Technology (BIXPO 2015)
							ซึ่งจัดขึ้นระหว่างวันที่ 12 - 14</p>`,
    v;
  return (
    (c = new il({
      props: {
        class:
          "absolute bottom-2 right-2 mx-auto h-auto max-w-[25%] rounded-md shadow-lg",
        file: "sym2023/speaker-patent.jpg",
        alt: "",
      },
    })),
    (h = new il({
      props: {
        file: "sym2023/speaker-updated.png",
        class: "h-full w-full object-cover",
        alt: "วิทยากร",
      },
    })),
    {
      c() {
        (e = he("section")),
          (i = he("div")),
          (n = he("div")),
          (n.innerHTML = r),
          (s = Ie()),
          (a = he("div")),
          (o = he("div")),
          (l = he("a")),
          At(c.$$.fragment),
          (d = Ie()),
          At(h.$$.fragment),
          (u = Ie()),
          (f = he("div")),
          (f.innerHTML = p),
          this.h();
      },
      l(g) {
        e = ue(g, "SECTION", { id: !0, class: !0 });
        var m = Oe(e);
        i = ue(m, "DIV", { class: !0 });
        var x = Oe(i);
        (n = ue(x, "DIV", { class: !0, ["data-svelte-h"]: !0 })),
          ht(n) !== "svelte-1i3ezv0" && (n.innerHTML = r),
          (s = Ue(x)),
          (a = ue(x, "DIV", { class: !0 }));
        var y = Oe(a);
        o = ue(y, "DIV", { class: !0 });
        var _ = Oe(o);
        l = ue(_, "A", { href: !0, title: !0 });
        var M = Oe(l);
        Ct(c.$$.fragment, M),
          M.forEach(fe),
          (d = Ue(_)),
          Ct(h.$$.fragment, _),
          _.forEach(fe),
          (u = Ue(y)),
          (f = ue(y, "DIV", { class: !0, ["data-svelte-h"]: !0 })),
          ht(f) !== "svelte-dw8ow6" && (f.innerHTML = p),
          y.forEach(fe),
          x.forEach(fe),
          m.forEach(fe),
          this.h();
      },
      h() {
        Q(n, "class", "relative z-10"),
          Q(l, "href", Rk),
          Q(l, "title", "สิทธิบัตร"),
          Q(
            o,
            "class",
            "relative mx-auto max-w-sm overflow-hidden rounded-lg md:mx-0"
          ),
          Q(f, "class", "p-6"),
          Q(
            a,
            "class",
            "my-4 grid grid-cols-1 text-center md:grid-cols-2 md:text-left"
          ),
          Q(i, "class", "mx-auto max-w-6xl p-10"),
          Q(e, "id", "event-speaker"),
          Q(e, "class", "event-speaker relative mx-auto overflow-hidden");
      },
      m(g, m) {
        Mt(g, e, m),
          $(e, i),
          $(i, n),
          $(i, s),
          $(i, a),
          $(a, o),
          $(o, l),
          Pt(c, l, null),
          $(o, d),
          Pt(h, o, null),
          $(a, u),
          $(a, f),
          (v = !0);
      },
      p: Ei,
      i(g) {
        v || (Be(c.$$.fragment, g), Be(h.$$.fragment, g), (v = !0));
      },
      o(g) {
        Xe(c.$$.fragment, g), Xe(h.$$.fragment, g), (v = !1);
      },
      d(g) {
        g && fe(e), Lt(c), Lt(h);
      },
    }
  );
}
function vy(t) {
  let e,
    i,
    n,
    r,
    s = "<span>ดาวน์โหลดเอกสาร</span>",
    a,
    o,
    l;
  return (
    (o = new Hk({})),
    {
      c() {
        (e = he("section")),
          (i = he("div")),
          (n = he("div")),
          (r = he("h2")),
          (r.innerHTML = s),
          (a = Ie()),
          At(o.$$.fragment),
          this.h();
      },
      l(c) {
        e = ue(c, "SECTION", { id: !0, class: !0 });
        var d = Oe(e);
        i = ue(d, "DIV", { class: !0 });
        var h = Oe(i);
        n = ue(h, "DIV", { class: !0 });
        var u = Oe(n);
        (r = ue(u, "H2", { class: !0, ["data-svelte-h"]: !0 })),
          ht(r) !== "svelte-1su65am" && (r.innerHTML = s),
          (a = Ue(u)),
          Ct(o.$$.fragment, u),
          u.forEach(fe),
          h.forEach(fe),
          d.forEach(fe),
          this.h();
      },
      h() {
        Q(r, "class", "m-0 flex items-center text-6xl font-bold"),
          Q(n, "class", "relative z-10"),
          Q(i, "class", "mx-auto max-w-6xl p-10"),
          Q(e, "id", "event-document"),
          Q(e, "class", "event-document relative mx-auto overflow-hidden");
      },
      m(c, d) {
        Mt(c, e, d),
          $(e, i),
          $(i, n),
          $(n, r),
          $(n, a),
          Pt(o, n, null),
          (l = !0);
      },
      i(c) {
        l || (Be(o.$$.fragment, c), (l = !0));
      },
      o(c) {
        Xe(o.$$.fragment, c), (l = !1);
      },
      d(c) {
        c && fe(e), Lt(o);
      },
    }
  );
}
function Wk(t) {
  let e,
    i,
    n,
    r,
    s,
    a,
    o,
    l,
    c,
    d,
    h,
    u,
    f,
    p = "",
    v,
    g,
    m = `{
			'@context': 'https://schema.org',
			'@type': 'Event',
			name: 'The 3rd PCSHS Sciensce Symposium 2023',
			startDate: '2023-09-04T08:00:00+07:00',
			endDate: '2023-09-06T17:00:00+07:00',
			eventAttendanceMode: 'https://schema.org/MixedEventAttendanceMode',
			eventStatus: 'https://schema.org/EventScheduled',
			location: {
				'@type': 'Place',
				name: 'Princess Chulabhorn Science High School Buriram',
				geo: {
					'@type': 'GeoCoordinates',
					latitude: 15.3077745,
					longitude: 103.3009612
				},
				url: 'https://pcshsbr.ac.th'
			},
			image: [
				'https://pcshsbr-assets.imgix.net/sym2023/og-image.png?w=1200&h=630&fit=crop&auto=compress'
			],
			organizer: {
				'@type': 'Organization',
				name: 'Princess Chulabhorn Science High School Buriram',
				url: 'https://pcshsbr.ac.th'
			},
			description:
				'การนำเสนอผลงานนักเรียนกลุ่มโรงเรียนวิทยาศาสตร์จุฬาภรณราชวิทยาลัย ครั้งที่ 3'
		}`,
    x,
    y,
    _,
    M,
    b,
    E,
    T,
    S,
    w,
    C,
    L,
    P,
    R,
    I,
    W =
      '<span>PCSHSBR</span> <span class="divider mx-8 h-1 w-16 rounded-sm bg-base-content"></span> <span>4 กันยายน – 6 กันยายน 2566</span>',
    N,
    U,
    G =
      '<span class="sr-only">The</span> <span class="text-[120px]">3</span><sup class="translate-y-[-0.5em] text-[72px]">rd</sup> PCSHS Science Symposium',
    k,
    B,
    V = "Improving a Sustainable World through Innovation and Projects",
    X,
    H,
    j,
    Y,
    ee,
    Z,
    K,
    me,
    re,
    F,
    Te = "ข้อมูลงาน",
    be,
    oe,
    Me,
    Ae,
    ye,
    _e,
    Ee,
    Le,
    it =
      '<span class="circle interactive bg-accent/50 svelte-2k4y2e"></span> <span class="circle left-10 top-11 scale-[4] bg-accent/70 svelte-2k4y2e"></span> <span class="circle right-5 top-[70%] scale-[3] bg-accent/70 svelte-2k4y2e"></span>',
    O,
    D,
    ne,
    pe,
    xe,
    we,
    Fe = "กำหนดการและลำดับนำเสนอ",
    Se,
    le,
    je,
    $e,
    Ye,
    He,
    Ge,
    nt,
    wt,
    q;
  y = new jb({});
  function De(Ze) {
    t[6](Ze);
  }
  function se(Ze) {
    t[7](Ze);
  }
  function Ce(Ze) {
    t[8](Ze);
  }
  let Ne = {};
  t[0] !== void 0 && (Ne.isLoading = t[0]),
    t[1] !== void 0 && (Ne.isHover = t[1]),
    t[3] !== void 0 && (Ne.scrollProgress = t[3]),
    (T = new wk({ props: Ne })),
    Ia.push(() => Xh(T, "isLoading", De)),
    Ia.push(() => Xh(T, "isHover", se)),
    Ia.push(() => Xh(T, "scrollProgress", Ce));
  const xt = [jk, Gk],
    It = [];
  function oi(Ze, vt) {
    return Ze[4] ? 1 : 0;
  }
  (j = oi(t)),
    (Y = It[j] = xt[j](t)),
    (me = new ni({ props: { icon: "mdi:menu-down" } }));
  let Ut = !t[4] && uy(),
    dt = !t[4] && dy(),
    Nt = t[4] && fy();
  le = new Ek({});
  let Et = !t[4] && py(),
    Qt = !t[4] && my(),
    Zt = !t[4] && gy(),
    li = !t[4] && vy();
  return {
    c() {
      (e = he("meta")),
        (i = he("meta")),
        (n = he("meta")),
        (r = he("meta")),
        (s = he("meta")),
        (a = he("meta")),
        (o = he("meta")),
        (l = he("meta")),
        (c = he("meta")),
        (d = he("meta")),
        (h = he("meta")),
        (u = he("meta")),
        (f = he("script")),
        (f.innerHTML = p),
        (g = he("script")),
        (g.textContent = m),
        (x = Ie()),
        At(y.$$.fragment),
        (_ = Ie()),
        (M = he("div")),
        (b = he("section")),
        (E = he("div")),
        At(T.$$.fragment),
        (L = Ie()),
        (P = he("div")),
        (R = he("div")),
        (I = he("div")),
        (I.innerHTML = W),
        (N = Ie()),
        (U = he("h1")),
        (U.innerHTML = G),
        (k = Ie()),
        (B = he("p")),
        (B.textContent = V),
        (X = Ie()),
        (H = he("div")),
        Y.c(),
        (Z = Ie()),
        (K = he("div")),
        At(me.$$.fragment),
        (re = Ie()),
        (F = he("span")),
        (F.textContent = Te),
        (be = Ie()),
        (oe = he("div")),
        Ut && Ut.c(),
        (Me = Ie()),
        dt && dt.c(),
        (Ae = Ie()),
        (ye = he("section")),
        (_e = he("span")),
        (Ee = Ie()),
        (Le = he("div")),
        (Le.innerHTML = it),
        (O = Ie()),
        (D = he("div")),
        (ne = he("div")),
        (pe = he("h2")),
        Nt && Nt.c(),
        (xe = Ie()),
        (we = he("span")),
        (we.textContent = Fe),
        (Se = Ie()),
        At(le.$$.fragment),
        ($e = Ie()),
        Et && Et.c(),
        (Ye = Ie()),
        Qt && Qt.c(),
        (He = Ie()),
        Zt && Zt.c(),
        (Ge = Ie()),
        li && li.c(),
        this.h();
    },
    l(Ze) {
      const vt = nb("svelte-1q8kev0", Oi.head);
      (e = ue(vt, "META", { name: !0, content: !0 })),
        (i = ue(vt, "META", { property: !0, content: !0 })),
        (n = ue(vt, "META", { property: !0, content: !0 })),
        (r = ue(vt, "META", { property: !0, content: !0 })),
        (s = ue(vt, "META", { property: !0, content: !0 })),
        (a = ue(vt, "META", { property: !0, content: !0 })),
        (o = ue(vt, "META", { name: !0, content: !0 })),
        (l = ue(vt, "META", { property: !0, content: !0 })),
        (c = ue(vt, "META", { property: !0, content: !0 })),
        (d = ue(vt, "META", { name: !0, content: !0 })),
        (h = ue(vt, "META", { name: !0, content: !0 })),
        (u = ue(vt, "META", { name: !0, content: !0 })),
        (f = ue(vt, "SCRIPT", { src: !0, ["data-svelte-h"]: !0 })),
        ht(f) !== "svelte-1hweos8" && (f.innerHTML = p),
        (g = ue(vt, "SCRIPT", { type: !0, ["data-svelte-h"]: !0 })),
        ht(g) !== "svelte-ppj9af" && (g.textContent = m),
        vt.forEach(fe),
        (x = Ue(Ze)),
        Ct(y.$$.fragment, Ze),
        (_ = Ue(Ze)),
        (M = ue(Ze, "DIV", { class: !0, id: !0 }));
      var pn = Oe(M);
      b = ue(pn, "SECTION", { class: !0 });
      var Cn = Oe(b);
      E = ue(Cn, "DIV", { class: !0 });
      var Cl = Oe(E);
      Ct(T.$$.fragment, Cl),
        Cl.forEach(fe),
        (L = Ue(Cn)),
        (P = ue(Cn, "DIV", {}));
      var na = Oe(P);
      R = ue(na, "DIV", { class: !0 });
      var Kn = Oe(R);
      (I = ue(Kn, "DIV", { class: !0, ["data-svelte-h"]: !0 })),
        ht(I) !== "svelte-ncucgt" && (I.innerHTML = W),
        (N = Ue(Kn)),
        (U = ue(Kn, "H1", { class: !0, ["data-svelte-h"]: !0 })),
        ht(U) !== "svelte-1l94d78" && (U.innerHTML = G),
        (k = Ue(Kn)),
        (B = ue(Kn, "P", { class: !0, ["data-svelte-h"]: !0 })),
        ht(B) !== "svelte-1u0qp8y" && (B.textContent = V),
        (X = Ue(Kn)),
        (H = ue(Kn, "DIV", { class: !0 }));
      var z = Oe(H);
      Y.l(z),
        z.forEach(fe),
        Kn.forEach(fe),
        (Z = Ue(na)),
        (K = ue(na, "DIV", { class: !0 }));
      var ae = Oe(K);
      Ct(me.$$.fragment, ae),
        (re = Ue(ae)),
        (F = ue(ae, "SPAN", { ["data-svelte-h"]: !0 })),
        ht(F) !== "svelte-1v4okzz" && (F.textContent = Te),
        ae.forEach(fe),
        na.forEach(fe),
        Cn.forEach(fe),
        pn.forEach(fe),
        (be = Ue(Ze)),
        (oe = ue(Ze, "DIV", { class: !0, id: !0 }));
      var de = Oe(oe);
      Ut && Ut.l(de),
        (Me = Ue(de)),
        dt && dt.l(de),
        (Ae = Ue(de)),
        (ye = ue(de, "SECTION", { id: !0, class: !0 }));
      var te = Oe(ye);
      (_e = ue(te, "SPAN", { class: !0, id: !0 })),
        Oe(_e).forEach(fe),
        (Ee = Ue(te)),
        (Le = ue(te, "DIV", { class: !0, ["data-svelte-h"]: !0 })),
        ht(Le) !== "svelte-4vq8bk" && (Le.innerHTML = it),
        (O = Ue(te)),
        (D = ue(te, "DIV", { class: !0 }));
      var ge = Oe(D);
      ne = ue(ge, "DIV", { class: !0 });
      var qe = Oe(ne);
      pe = ue(qe, "H2", { class: !0 });
      var Je = Oe(pe);
      Nt && Nt.l(Je),
        (xe = Ue(Je)),
        (we = ue(Je, "SPAN", { ["data-svelte-h"]: !0 })),
        ht(we) !== "svelte-1ayc947" && (we.textContent = Fe),
        Je.forEach(fe),
        qe.forEach(fe),
        (Se = Ue(ge)),
        Ct(le.$$.fragment, ge),
        ge.forEach(fe),
        te.forEach(fe),
        ($e = Ue(de)),
        Et && Et.l(de),
        (Ye = Ue(de)),
        Qt && Qt.l(de),
        (He = Ue(de)),
        Zt && Zt.l(de),
        (Ge = Ue(de)),
        li && li.l(de),
        de.forEach(fe),
        this.h();
    },
    h() {
      (Oi.title = "The 3rd PCSHS Science Symposium 2023 @PCSHSBR"),
        Q(e, "name", "description"),
        Q(
          e,
          "content",
          "การนำเสนอผลงานนักเรียนกลุ่มโรงเรียนวิทยาศาสตร์จุฬาภรณราชวิทยาลัย ครั้งที่ 3"
        ),
        Q(i, "property", "og:url"),
        Q(i, "content", "https://3rdpss2023.pcshsbr.ac.th/"),
        Q(n, "property", "og:type"),
        Q(n, "content", "website"),
        Q(r, "property", "og:title"),
        Q(r, "content", "The 3rd PCSHS Science Symposium 2023"),
        Q(s, "property", "og:description"),
        Q(
          s,
          "content",
          "การนำเสนอผลงานนักเรียนกลุ่มโรงเรียนวิทยาศาสตร์จุฬาภรณราชวิทยาลัย ครั้งที่ 3"
        ),
        Q(a, "property", "og:image"),
        Q(
          a,
          "content",
          "https://pcshsbr-assets.imgix.net/sym2023/og-image.png?w=1200&h=630&fit=crop&auto=compress"
        ),
        Q(o, "name", "twitter:card"),
        Q(o, "content", "summary_large_image"),
        Q(l, "property", "twitter:domain"),
        Q(l, "content", "3rdpss2023.pcshsbr.ac.th"),
        Q(c, "property", "twitter:url"),
        Q(c, "content", "https://3rdpss2023.pcshsbr.ac.th/"),
        Q(d, "name", "twitter:title"),
        Q(d, "content", "The 3rd PCSHS Science Symposium 2023"),
        Q(h, "name", "twitter:description"),
        Q(
          h,
          "content",
          "การนำเสนอผลงานนักเรียนกลุ่มโรงเรียนวิทยาศาสตร์จุฬาภรณราชวิทยาลัย ครั้งที่ 3"
        ),
        Q(u, "name", "twitter:image"),
        Q(
          u,
          "content",
          "https://pcshsbr-assets.imgix.net/sym2023/og-image.png?w=1200&h=630&fit=crop&auto=compress"
        ),
        rb(f.src, (v = "https://accounts.google.com/gsi/client")) ||
          Q(f, "src", v),
        (f.async = !0),
        Q(g, "type", "application/ld+json"),
        Q(E, "class", "min-h-[-webkit-fill-available] overflow-hidden"),
        Q(
          I,
          "class",
          "date-range flex flex-row flex-wrap items-center font-display"
        ),
        Q(
          U,
          "class",
          "main-title text-4xl font-black leading-none md:text-6xl"
        ),
        Q(B, "class", "sub-title hidden font-display text-xl sm:block"),
        Q(
          H,
          "class",
          "documents mt-4 flex flex-col flex-wrap items-start gap-1 !mix-blend-normal !invert-0"
        ),
        Q(
          R,
          "class",
          (ee =
            "title absolute top-[15%] px-16 font-display " +
            (t[4] ? "" : "mix-blend-difference invert") +
            " dark:invert-0 md:px-32")
        ),
        Q(
          K,
          "class",
          "absolute bottom-0 hidden h-16 w-full flex-col items-center xs:flex"
        ),
        Q(b, "class", "banner sticky top-0"),
        Q(M, "class", "hero-sticky h-[200vh]"),
        Q(M, "id", "hero-sticky"),
        Q(_e, "class", "target-anchor"),
        Q(_e, "id", "event-schedule"),
        Q(Le, "class", "background"),
        Q(pe, "class", "m-0 flex items-center text-6xl font-bold"),
        Q(ne, "class", "pb-4"),
        Q(
          D,
          "class",
          (je =
            "calendar-info " +
            (t[4] ? "min-h-[100vh]" : "") +
            " relative mx-auto max-w-6xl p-10")
        ),
        Q(ye, "id", "event-schedule"),
        Q(
          ye,
          "class",
          "hover-effect relative mx-auto overflow-hidden bg-base-300"
        ),
        Q(oe, "class", "info-container relative w-full overflow-hidden"),
        Q(oe, "id", "info");
    },
    m(Ze, vt) {
      $(Oi.head, e),
        $(Oi.head, i),
        $(Oi.head, n),
        $(Oi.head, r),
        $(Oi.head, s),
        $(Oi.head, a),
        $(Oi.head, o),
        $(Oi.head, l),
        $(Oi.head, c),
        $(Oi.head, d),
        $(Oi.head, h),
        $(Oi.head, u),
        $(Oi.head, f),
        $(Oi.head, g),
        Mt(Ze, x, vt),
        Pt(y, Ze, vt),
        Mt(Ze, _, vt),
        Mt(Ze, M, vt),
        $(M, b),
        $(b, E),
        Pt(T, E, null),
        $(b, L),
        $(b, P),
        $(P, R),
        $(R, I),
        $(R, N),
        $(R, U),
        $(R, k),
        $(R, B),
        $(R, X),
        $(R, H),
        It[j].m(H, null),
        $(P, Z),
        $(P, K),
        Pt(me, K, null),
        $(K, re),
        $(K, F),
        t[11](M),
        Mt(Ze, be, vt),
        Mt(Ze, oe, vt),
        Ut && Ut.m(oe, null),
        $(oe, Me),
        dt && dt.m(oe, null),
        $(oe, Ae),
        $(oe, ye),
        $(ye, _e),
        $(ye, Ee),
        $(ye, Le),
        $(ye, O),
        $(ye, D),
        $(D, ne),
        $(ne, pe),
        Nt && Nt.m(pe, null),
        $(pe, xe),
        $(pe, we),
        $(D, Se),
        Pt(le, D, null),
        $(oe, $e),
        Et && Et.m(oe, null),
        $(oe, Ye),
        Qt && Qt.m(oe, null),
        $(oe, He),
        Zt && Zt.m(oe, null),
        $(oe, Ge),
        li && li.m(oe, null),
        (nt = !0),
        wt ||
          ((q = [Pa(b, "mouseenter", t[9]), Pa(b, "mouseleave", t[10])]),
          (wt = !0));
    },
    p(Ze, [vt]) {
      const pn = {};
      !S && vt & 1 && ((S = !0), (pn.isLoading = Ze[0]), qh(() => (S = !1))),
        !w && vt & 2 && ((w = !0), (pn.isHover = Ze[1]), qh(() => (w = !1))),
        !C &&
          vt & 8 &&
          ((C = !0), (pn.scrollProgress = Ze[3]), qh(() => (C = !1))),
        T.$set(pn);
      let Cn = j;
      (j = oi(Ze)),
        j !== Cn &&
          (ki(),
          Xe(It[Cn], 1, 1, () => {
            It[Cn] = null;
          }),
          Vi(),
          (Y = It[j]),
          Y || ((Y = It[j] = xt[j](Ze)), Y.c()),
          Be(Y, 1),
          Y.m(H, null)),
        (!nt ||
          (vt & 16 &&
            ee !==
              (ee =
                "title absolute top-[15%] px-16 font-display " +
                (Ze[4] ? "" : "mix-blend-difference invert") +
                " dark:invert-0 md:px-32"))) &&
          Q(R, "class", ee),
        Ze[4]
          ? Ut &&
            (ki(),
            Xe(Ut, 1, 1, () => {
              Ut = null;
            }),
            Vi())
          : Ut
          ? vt & 16 && Be(Ut, 1)
          : ((Ut = uy()), Ut.c(), Be(Ut, 1), Ut.m(oe, Me)),
        Ze[4]
          ? dt &&
            (ki(),
            Xe(dt, 1, 1, () => {
              dt = null;
            }),
            Vi())
          : dt
          ? (dt.p(Ze, vt), vt & 16 && Be(dt, 1))
          : ((dt = dy()), dt.c(), Be(dt, 1), dt.m(oe, Ae)),
        Ze[4]
          ? Nt
            ? vt & 16 && Be(Nt, 1)
            : ((Nt = fy()), Nt.c(), Be(Nt, 1), Nt.m(pe, xe))
          : Nt &&
            (ki(),
            Xe(Nt, 1, 1, () => {
              Nt = null;
            }),
            Vi()),
        (!nt ||
          (vt & 16 &&
            je !==
              (je =
                "calendar-info " +
                (Ze[4] ? "min-h-[100vh]" : "") +
                " relative mx-auto max-w-6xl p-10"))) &&
          Q(D, "class", je),
        Ze[4]
          ? Et &&
            (ki(),
            Xe(Et, 1, 1, () => {
              Et = null;
            }),
            Vi())
          : Et
          ? vt & 16 && Be(Et, 1)
          : ((Et = py()), Et.c(), Be(Et, 1), Et.m(oe, Ye)),
        Ze[4]
          ? Qt &&
            (ki(),
            Xe(Qt, 1, 1, () => {
              Qt = null;
            }),
            Vi())
          : Qt
          ? vt & 16 && Be(Qt, 1)
          : ((Qt = my()), Qt.c(), Be(Qt, 1), Qt.m(oe, He)),
        Ze[4]
          ? Zt &&
            (ki(),
            Xe(Zt, 1, 1, () => {
              Zt = null;
            }),
            Vi())
          : Zt
          ? (Zt.p(Ze, vt), vt & 16 && Be(Zt, 1))
          : ((Zt = gy()), Zt.c(), Be(Zt, 1), Zt.m(oe, Ge)),
        Ze[4]
          ? li &&
            (ki(),
            Xe(li, 1, 1, () => {
              li = null;
            }),
            Vi())
          : li
          ? vt & 16 && Be(li, 1)
          : ((li = vy()), li.c(), Be(li, 1), li.m(oe, null));
    },
    i(Ze) {
      nt ||
        (Be(y.$$.fragment, Ze),
        Be(T.$$.fragment, Ze),
        Be(Y),
        Be(me.$$.fragment, Ze),
        Be(Ut),
        Be(dt),
        Be(Nt),
        Be(le.$$.fragment, Ze),
        Be(Et),
        Be(Qt),
        Be(Zt),
        Be(li),
        (nt = !0));
    },
    o(Ze) {
      Xe(y.$$.fragment, Ze),
        Xe(T.$$.fragment, Ze),
        Xe(Y),
        Xe(me.$$.fragment, Ze),
        Xe(Ut),
        Xe(dt),
        Xe(Nt),
        Xe(le.$$.fragment, Ze),
        Xe(Et),
        Xe(Qt),
        Xe(Zt),
        Xe(li),
        (nt = !1);
    },
    d(Ze) {
      Ze && (fe(x), fe(_), fe(M), fe(be), fe(oe)),
        fe(e),
        fe(i),
        fe(n),
        fe(r),
        fe(s),
        fe(a),
        fe(o),
        fe(l),
        fe(c),
        fe(d),
        fe(h),
        fe(u),
        fe(f),
        fe(g),
        Lt(y, Ze),
        Lt(T),
        It[j].d(),
        Lt(me),
        t[11](null),
        Ut && Ut.d(),
        dt && dt.d(),
        Nt && Nt.d(),
        Lt(le),
        Et && Et.d(),
        Qt && Qt.d(),
        Zt && Zt.d(),
        li && li.d(),
        (wt = !1),
        yy(q);
    },
  };
}
function qk() {
  document.querySelectorAll(".hover-effect").forEach((e, i) => {
    let n = e.querySelector(".background"),
      r = n == null ? void 0 : n.querySelector(".interactive");
    window.addEventListener("mousemove", (s) => {
      let a = e == null ? void 0 : e.getBoundingClientRect();
      r &&
        (s.clientY - a.top < (e == null ? void 0 : e.clientHeight) &&
        s.clientY - (a == null ? void 0 : a.top) > 0
          ? ((r.style.opacity = "1"),
            (r.style.left = `${s.clientX - a.left}px`),
            (r.style.top = `${s.clientY - a.top}px`),
            (r.style.transform = "translate(-50%,-50%)"))
          : (r.style.opacity = "0"));
    });
  });
}
function Xk(t, e, i) {
  let n;
  Af(t, lb, (m) => i(12, (n = m)));
  let { data: r } = e,
    s = !0,
    a = !1,
    o,
    l,
    c = !1;
  tl(async () => {
    const m = (
      await Tf(
        () => import("../chunks/ScrollMagic.1c96735c.js").then((_) => _.S),
        [
          "../chunks/ScrollMagic.1c96735c.js",
          "../chunks/_commonjsHelpers.3bb56e27.js",
          "../chunks/index.08749574.js",
          "../chunks/scheduler.b44937bc.js",
        ],
        import.meta.url
      )
    ).default;
    let x = !1;
    function y() {
      var T, S, w;
      let _ = new m.Controller();
      new m.Scene({
        triggerElement: ".hero-sticky",
        triggerHook: 0,
        duration:
          (T = document.querySelector(".hero-sticky")) == null
            ? void 0
            : T.clientHeight,
      })
        .on("progress", (C) => {
          i(3, (l = C.progress));
        })
        .addTo(_);
      let M = Yt.timeline({
        autoplay: !0,
        duration: 1e3,
        easing: "easeOutExpo",
      });
      M.add({ targets: ".main-title ", opacity: [0, 1], delay: 1e3 }),
        M.add({
          targets: ".sub-title , .send-project , .enter-event",
          opacity: [0, 1],
          delay: 100,
        }),
        M.add({ targets: ".documents", opacity: [0, 1], delay: 50 }),
        M.add({ targets: ".date-range", opacity: [0, 1], delay: 0 }),
        new m.Scene({
          triggerElement: ".hero-sticky",
          triggerHook: 0,
          duration:
            (((S = document.querySelector(".hero-sticky")) == null
              ? void 0
              : S.clientHeight) ?? 0) - window.innerHeight,
        })
          .on("enter", (C) => {
            M.play();
          })
          .on("leave", (C) => {
            M.play();
          })
          .addTo(_);
      let b = Yt.timeline({
        autoplay: !1,
        duration: 1e3,
        easing: "easeOutExpo",
      });
      b.add({
        targets: ".info-img",
        opacity: [0, 1],
        scale: [1.5, 1],
        delay: 200,
      }),
        b.add({ targets: ".event-info .info-paragrpah", opacity: [0, 1] });
      let E = Yt({
        targets: ".event-info .background span,.event-info .background svg",
        translateY: [100, 0],
        opacity: [0, 1],
        delay: (C, L) => 200 * L,
        duration: 1e3,
        easing: "easeOutExpo",
      });
      b.add({ targets: " .event-info .event-poem", opacity: [0, 1] }),
        new m.Scene({
          triggerElement: ".event-info",
          triggerHook: 0,
          offset: -(window.innerHeight - 200),
          duration:
            (w = document.querySelector(".event-info")) == null
              ? void 0
              : w.clientHeight,
        })
          .on("enter", (C) => {
            x || (b.play(), E.play(), (x = !0));
          })
          .addTo(_);
    }
    qk(), y();
  });
  async function d(m) {
    const x = Cc({ message: "กำลังเข้าสู่ระบบ...", type: "default" }),
      { data: y, error: _ } = await r.supabase.auth.signInWithIdToken({
        token: m.credential,
        provider: "google",
      });
    if ((cb.pop(x), _ && _.message !== "Internal Server Error"))
      return Cc({
        message: xy(_.message) || "ข้อผิดพลาดที่ไม่ทราบสาเหตุ",
        type: "error",
      });
    if (_ && _.message === "Internal Server Error" && !y.user)
      return Cc({
        message:
          "ไม่พบคุณในระบบ คุณต้องได้รับคำเชิญก่อนจึงสามารถเข้าใช้งานระบบได้",
        initial: 0,
      });
    ob("/dashboard");
  }
  tl(() => {
    (window.handleSignInWithGoogle = d),
      n.url.searchParams.get("standtv") &&
        localStorage.setItem(
          "standtv",
          n.url.searchParams.get("standtv") ?? "0"
        ),
      i(4, (c = localStorage.getItem("standtv") === "1"));
  });
  function h(m) {
    (s = m), i(0, s);
  }
  function u(m) {
    (a = m), i(1, a);
  }
  function f(m) {
    (l = m), i(3, l);
  }
  const p = () => {
      i(1, (a = !0));
    },
    v = () => {
      i(1, (a = !1));
    };
  function g(m) {
    Ia[m ? "unshift" : "push"](() => {
      (o = m), i(2, o);
    });
  }
  return (
    (t.$$set = (m) => {
      "data" in m && i(5, (r = m.data));
    }),
    [s, a, o, l, c, r, h, u, f, p, v, g]
  );
}
class c4 extends vs {
  constructor(e) {
    super(), ys(this, e, Xk, Wk, gs, { data: 5 });
  }
}
export { c4 as component };
//# sourceMappingURL=19.73cfa827.js.map
